cscope 15 $HOME/workspace/csteal/test/sqlite312-cpp -c               0002145593
	@shell.cpp.c

33 typedef long unsigned int 
	tsize_t
;

35 typedef int 
	twchar_t
;

62 typedef unsigned char 
	t__u_char
;

63 typedef unsigned short int 
	t__u_short
;

64 typedef unsigned int 
	t__u_int
;

65 typedef unsigned long int 
	t__u_long
;

68 typedef signed char 
	t__int8_t
;

69 typedef unsigned char 
	t__uint8_t
;

70 typedef signed short int 
	t__int16_t
;

71 typedef unsigned short int 
	t__uint16_t
;

72 typedef signed int 
	t__int32_t
;

73 typedef unsigned int 
	t__uint32_t
;

75 typedef signed long int 
	t__int64_t
;

76 typedef unsigned long int 
	t__uint64_t
;

84 typedef long int 
	t__quad_t
;

85 typedef unsigned long int 
	t__u_quad_t
;

91 typedef unsigned long int 
	t__dev_t
;

92 typedef unsigned int 
	t__uid_t
;

93 typedef unsigned int 
	t__gid_t
;

94 typedef unsigned long int 
	t__ino_t
;

95 typedef unsigned long int 
	t__ino64_t
;

96 typedef unsigned int 
	t__mode_t
;

97 typedef unsigned long int 
	t__nlink_t
;

98 typedef long int 
	t__off_t
;

99 typedef long int 
	t__off64_t
;

100 typedef int 
	t__pid_t
;

101 typedef struct { int 
	m__val
[2]; } 
	t__fsid_t
;

102 typedef long int 
	t__clock_t
;

103 typedef unsigned long int 
	t__rlim_t
;

104 typedef unsigned long int 
	t__rlim64_t
;

105 typedef unsigned int 
	t__id_t
;

106 typedef long int 
	t__time_t
;

107 typedef unsigned int 
	t__useconds_t
;

108 typedef long int 
	t__suseconds_t
;

110 typedef int 
	t__daddr_t
;

111 typedef int 
	t__key_t
;

114 typedef int 
	t__clockid_t
;

117 typedef void * 
	t__timer_t
;

120 typedef long int 
	t__blksize_t
;

125 typedef long int 
	t__blkcnt_t
;

126 typedef long int 
	t__blkcnt64_t
;

129 typedef unsigned long int 
	t__fsblkcnt_t
;

130 typedef unsigned long int 
	t__fsblkcnt64_t
;

133 typedef unsigned long int 
	t__fsfilcnt_t
;

134 typedef unsigned long int 
	t__fsfilcnt64_t
;

137 typedef long int 
	t__fsword_t
;

139 typedef long int 
	t__ssize_t
;

142 typedef long int 
	t__syscall_slong_t
;

144 typedef unsigned long int 
	t__syscall_ulong_t
;

148 typedef 
__off64_t
 
	t__loff_t
;

149 typedef 
__quad_t
 *
	t__qaddr_t
;

150 typedef char *
	t__caddr_t
;

153 typedef long int 
	t__intptr_t
;

156 typedef unsigned int 
	t__socklen_t
;

169 static 
__inline
 unsigned int

170 
	$__bswap_32
 (unsigned int 
__bsx
)

172 return 
	`__builtin_bswap32
 (
__bsx
);

173 
	}
}

175 static 
__inline
 
__uint64_t


176 
	$__bswap_64
 (
__uint64_t
 
__bsx
)

178 return 
	`__builtin_bswap64
 (
__bsx
);

179 
	}
}

183 union 
	uwait


185 int 
	mw_status
;

189 unsigned int 
	m__w_termsig
:7;

190 unsigned int 
	m__w_coredump
:1;

191 unsigned int 
	m__w_retcode
:8;

200 } 
	m__wait_terminated
;

204 unsigned int 
	m__w_stopval
:8;

205 unsigned int 
	m__w_stopsig
:8;

213 } 
	m__wait_stopped
;

219 union 
wait
 *
	m__uptr
;

220 int *
	m__iptr
;

221 } 
	t__WAIT_STATUS
 
	t__attribute__
 ((
	t__transparent_union__
));

227 int 
	mquot
;

228 int 
	mrem
;

229 } 
	tdiv_t
;

235 long int 
	mquot
;

236 long int 
	mrem
;

237 } 
	tldiv_t
;

245 
__extension__
 typedef struct

247 long long int 
	mquot
;

248 long long int 
	mrem
;

249 } 
	tlldiv_t
;

253 extern 
size_t
 
	$__ctype_get_mb_cur_max
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

258 extern double 
	$atof
 (const char *
__nptr
)

259 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

261 extern int 
	$atoi
 (const char *
__nptr
)

262 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

264 extern long int 
	$atol
 (const char *
__nptr
)

265 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

271 
__extension__
 extern long long int 
	$atoll
 (const char *
__nptr
)

272 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

278 extern double 
	$strtod
 (const char *
__restrict
 
__nptr
,

279 char **
__restrict
 
__endptr
)

280 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

286 extern float 
	$strtof
 (const char *
__restrict
 
__nptr
,

287 char **
__restrict
 
__endptr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

289 extern long double 
	$strtold
 (const char *
__restrict
 
__nptr
,

290 char **
__restrict
 
__endptr
)

291 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

297 extern long int 
	$strtol
 (const char *
__restrict
 
__nptr
,

298 char **
__restrict
 
__endptr
, int 
__base
)

299 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

301 extern unsigned long int 
	$strtoul
 (const char *
__restrict
 
__nptr
,

302 char **
__restrict
 
__endptr
, int 
__base
)

303 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

308 
__extension__


309 extern long long int 
	$strtoq
 (const char *
__restrict
 
__nptr
,

310 char **
__restrict
 
__endptr
, int 
__base
)

311 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

313 
__extension__


314 extern unsigned long long int 
	$strtouq
 (const char *
__restrict
 
__nptr
,

315 char **
__restrict
 
__endptr
, int 
__base
)

316 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

322 
__extension__


323 extern long long int 
	$strtoll
 (const char *
__restrict
 
__nptr
,

324 char **
__restrict
 
__endptr
, int 
__base
)

325 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

327 
__extension__


328 extern unsigned long long int 
	$strtoull
 (const char *
__restrict
 
__nptr
,

329 char **
__restrict
 
__endptr
, int 
__base
)

330 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

333 extern char *
	$l64a
 (long int 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

336 extern long int 
	$a64l
 (const char *
__s
)

337 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

350 typedef 
__u_char
 
	tu_char
;

351 typedef 
__u_short
 
	tu_short
;

352 typedef 
__u_int
 
	tu_int
;

353 typedef 
__u_long
 
	tu_long
;

354 typedef 
__quad_t
 
	tquad_t
;

355 typedef 
__u_quad_t
 
	tu_quad_t
;

356 typedef 
__fsid_t
 
	tfsid_t
;

361 typedef 
__loff_t
 
	tloff_t
;

367 typedef 
__ino64_t
 
	tino_t
;

369 typedef 
__dev_t
 
	tdev_t
;

374 typedef 
__gid_t
 
	tgid_t
;

379 typedef 
__mode_t
 
	tmode_t
;

384 typedef 
__nlink_t
 
	tnlink_t
;

389 typedef 
__uid_t
 
	tuid_t
;

397 typedef 
__off64_t
 
	toff_t
;

399 typedef 
__pid_t
 
	tpid_t
;

405 typedef 
__id_t
 
	tid_t
;

410 typedef 
__ssize_t
 
	tssize_t
;

416 typedef 
__daddr_t
 
	tdaddr_t
;

417 typedef 
__caddr_t
 
	tcaddr_t
;

423 typedef 
__key_t
 
	tkey_t
;

429 typedef 
__clock_t
 
	tclock_t
;

436 typedef 
__time_t
 
	ttime_t
;

441 typedef 
__clockid_t
 
	tclockid_t
;

443 typedef 
__timer_t
 
	ttimer_t
;

451 typedef unsigned long int 
	tulong
;

452 typedef unsigned short int 
	tushort
;

453 typedef unsigned int 
	tuint
;

455 typedef int 
	tint8_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__QI__
)));

456 typedef int 
	tint16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

457 typedef int 
	tint32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

458 typedef int 
	tint64_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__DI__
)));

461 typedef unsigned int 
	tu_int8_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__QI__
)));

462 typedef unsigned int 
	tu_int16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

463 typedef unsigned int 
	tu_int32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

464 typedef unsigned int 
	tu_int64_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__DI__
)));

466 typedef int 
	tregister_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__word__
)));

479 typedef int 
	t__sig_atomic_t
;

486 unsigned long int 
__val
[(1024 / (8 * sizeof (unsigned long int)))];

487 } 
	t__sigset_t
;

492 typedef 
__sigset_t
 
	tsigset_t
;

500 struct 
	stimespec


502 
__time_t
 
tv_sec
;

503 
__syscall_slong_t
 
tv_nsec
;

509 struct 
	stimeval


511 
__time_t
 
tv_sec
;

512 
__suseconds_t
 
tv_usec
;

517 typedef 
__suseconds_t
 
	tsuseconds_t
;

523 typedef long int 
	t__fd_mask
;

533 
__fd_mask
 
__fds_bits
[1024 / (8 * (int) sizeof (__fd_mask))];

536 } 
	tfd_set
;

543 typedef 
__fd_mask
 
	tfd_mask
;

547 extern int 
	`select
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

548 
fd_set
 *
__restrict
 
__writefds
,

549 
fd_set
 *
__restrict
 
__exceptfds
,

550 struct 
timeval
 *
__restrict
 
__timeout
);

552 extern int 
	`pselect
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

553 
fd_set
 *
__restrict
 
__writefds
,

554 
fd_set
 *
__restrict
 
__exceptfds
,

555 const struct 
timespec
 *
__restrict
 
__timeout
,

556 const 
__sigset_t
 *
__restrict
 
__sigmask
);

566 
__extension__


567 extern unsigned int 
	$gnu_dev_major
 (unsigned long long int 
__dev
)

568 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

569 
__extension__


570 extern unsigned int 
	$gnu_dev_minor
 (unsigned long long int 
__dev
)

571 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

572 
__extension__


573 extern unsigned long long int 
	$gnu_dev_makedev
 (unsigned int 
__major
,

574 unsigned int 
__minor
)

575 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

584 typedef 
__blksize_t
 
	tblksize_t
;

586 typedef 
__blkcnt64_t
 
	tblkcnt_t
;

590 typedef 
__fsblkcnt64_t
 
	tfsblkcnt_t
;

594 typedef 
__fsfilcnt64_t
 
	tfsfilcnt_t
;

601 typedef unsigned long int 
	tpthread_t
;

604 union 
	upthread_attr_t


606 char 
__size
[56];

607 long int 
__align
;

610 typedef union 
pthread_attr_t
 
	tpthread_attr_t
;

616 typedef struct 
	s__pthread_internal_list


618 struct 
__pthread_internal_list
 *
__prev
;

619 struct 
__pthread_internal_list
 *
__next
;

620 } 
	t__pthread_list_t
;

624 struct 
	s__pthread_mutex_s


626 int 
__lock
;

627 unsigned int 
__count
;

628 int 
__owner
;

630 unsigned int 
__nusers
;

634 int 
__kind
;

636 short 
__spins
;

637 short 
__elision
;

638 
__pthread_list_t
 
__list
;

640 } 
__data
;

641 char 
__size
[40];

642 long int 
__align
;

643 } 
	tpthread_mutex_t
;

647 char 
__size
[4];

648 int 
__align
;

649 } 
	tpthread_mutexattr_t
;

658 int 
__lock
;

659 unsigned int 
__futex
;

660 
__extension__
 unsigned long long int 
__total_seq
;

661 
__extension__
 unsigned long long int 
__wakeup_seq
;

662 
__extension__
 unsigned long long int 
__woken_seq
;

663 void *
__mutex
;

664 unsigned int 
__nwaiters
;

665 unsigned int 
__broadcast_seq
;

666 } 
__data
;

667 char 
__size
[48];

668 
__extension__
 long long int 
__align
;

669 } 
	tpthread_cond_t
;

673 char 
__size
[4];

674 int 
__align
;

675 } 
	tpthread_condattr_t
;

679 typedef unsigned int 
	tpthread_key_t
;

683 typedef int 
	tpthread_once_t
;

694 int 
__lock
;

695 unsigned int 
__nr_readers
;

696 unsigned int 
__readers_wakeup
;

697 unsigned int 
__writer_wakeup
;

698 unsigned int 
__nr_readers_queued
;

699 unsigned int 
__nr_writers_queued
;

700 int 
__writer
;

701 int 
__shared
;

702 signed char 
__rwelision
;

707 unsigned char 
__pad1
[7];

710 unsigned long int 
__pad2
;

713 unsigned int 
__flags
;

715 } 
__data
;

717 char 
__size
[56];

718 long int 
__align
;

719 } 
	tpthread_rwlock_t
;

723 char 
__size
[8];

724 long int 
__align
;

725 } 
	tpthread_rwlockattr_t
;

731 typedef volatile int 
	tpthread_spinlock_t
;

738 char 
__size
[32];

739 long int 
__align
;

740 } 
	tpthread_barrier_t
;

744 char 
__size
[4];

745 int 
__align
;

746 } 
	tpthread_barrierattr_t
;

758 extern long int 
	$random
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

761 extern void 
	$srandom
 (unsigned int 
__seed
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

767 extern char *
	$initstate
 (unsigned int 
__seed
, char *
__statebuf
,

768 
size_t
 
__statelen
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

772 extern char *
	$setstate
 (char *
__statebuf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

780 struct 
	srandom_data


782 
int32_t
 *
fptr
;

783 
int32_t
 *
rptr
;

784 
int32_t
 *
state
;

785 int 
rand_type
;

786 int 
rand_deg
;

787 int 
rand_sep
;

788 
int32_t
 *
end_ptr
;

791 extern int 
	$random_r
 (struct 
random_data
 *
__restrict
 
__buf
,

792 
int32_t
 *
__restrict
 
__result
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

794 extern int 
	$srandom_r
 (unsigned int 
__seed
, struct 
random_data
 *
__buf
)

795 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

797 extern int 
	$initstate_r
 (unsigned int 
__seed
, char *
__restrict
 
__statebuf
,

798 
size_t
 
__statelen
,

799 struct 
random_data
 *
__restrict
 
__buf
)

800 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 4)));

802 extern int 
	$setstate_r
 (char *
__restrict
 
__statebuf
,

803 struct 
random_data
 *
__restrict
 
__buf
)

804 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

811 extern int 
	$rand
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

813 extern void 
	$srand
 (unsigned int 
__seed
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

818 extern int 
	$rand_r
 (unsigned int *
__seed
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

826 extern double 
	$drand48
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

827 extern double 
	$erand48
 (unsigned short int 
__xsubi
[3]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

830 extern long int 
	$lrand48
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

831 extern long int 
	$nrand48
 (unsigned short int 
__xsubi
[3])

832 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

835 extern long int 
	$mrand48
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

836 extern long int 
	$jrand48
 (unsigned short int 
__xsubi
[3])

837 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

840 extern void 
	$srand48
 (long int 
__seedval
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

841 extern unsigned short int *
	$seed48
 (unsigned short int 
__seed16v
[3])

842 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

843 extern void 
	$lcong48
 (unsigned short int 
__param
[7]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

849 struct 
	sdrand48_data


851 unsigned short int 
__x
[3];

852 unsigned short int 
__old_x
[3];

853 unsigned short int 
__c
;

854 unsigned short int 
__init
;

855 
__extension__
 unsigned long long int 
__a
;

860 extern int 
	$drand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

861 double *
__restrict
 
__result
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

862 extern int 
	$erand48_r
 (unsigned short int 
__xsubi
[3],

863 struct 
drand48_data
 *
__restrict
 
__buffer
,

864 double *
__restrict
 
__result
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

867 extern int 
	$lrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

868 long int *
__restrict
 
__result
)

869 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

870 extern int 
	$nrand48_r
 (unsigned short int 
__xsubi
[3],

871 struct 
drand48_data
 *
__restrict
 
__buffer
,

872 long int *
__restrict
 
__result
)

873 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

876 extern int 
	$mrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

877 long int *
__restrict
 
__result
)

878 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

879 extern int 
	$jrand48_r
 (unsigned short int 
__xsubi
[3],

880 struct 
drand48_data
 *
__restrict
 
__buffer
,

881 long int *
__restrict
 
__result
)

882 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

885 extern int 
	$srand48_r
 (long int 
__seedval
, struct 
drand48_data
 *
__buffer
)

886 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

888 extern int 
	$seed48_r
 (unsigned short int 
__seed16v
[3],

889 struct 
drand48_data
 *
__buffer
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

891 extern int 
	$lcong48_r
 (unsigned short int 
__param
[7],

892 struct 
drand48_data
 *
__buffer
)

893 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

903 extern void *
	$malloc
 (
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

905 extern void *
	$calloc
 (
size_t
 
__nmemb
, size_t 
__size
)

906 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

917 extern void *
	$realloc
 (void *
__ptr
, 
size_t
 
__size
)

918 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__warn_unused_result__
));

920 extern void 
	$free
 (void *
__ptr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

925 extern void 
	$cfree
 (void *
__ptr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

940 extern void *
	$alloca
 (
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

953 extern void *
	$valloc
 (
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

958 extern int 
	$posix_memalign
 (void **
__memptr
, 
size_t
 
__alignment
, size_t 
__size
)

959 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

963 extern void 
	$abort
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

967 extern int 
	`atexit
 (void (*
__func
) (void)) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

974 extern int 
	`on_exit
 (void (*
__func
) (int 
__status
, void *
__arg
), void *__arg)

975 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

982 extern void 
	$exit
 (int 
__status
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

996 extern void 
	$_Exit
 (int 
__status
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

1003 extern char *
	$getenv
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

1006 extern int 
	$putenv
 (char *
__string
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

1012 extern int 
	$setenv
 (const char *
__name
, const char *
__value
, int 
__replace
)

1013 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

1016 extern int 
	$unsetenv
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

1023 extern int 
	$clearenv
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1025 extern char *
	$mktemp
 (char *
__template
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

1027 extern int 
	$mkstemp
 (char *
__template
) 
	`__asm__
 ("" "mkstemp64")

1028 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

1030 extern int 
	$mkstemps
 (char *
__template
, int 
__suffixlen
) 
	`__asm__
 ("" "mkstemps64")

1031 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

1033 extern char *
	$mkdtemp
 (char *
__template
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

1040 extern int 
	`system
 (const char *
__command
) ;

1043 extern char *
	$realpath
 (const char *
__restrict
 
__name
,

1044 char *
__restrict
 
__resolved
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1051 typedef int (*
	t__compar_fn_t
) (const void *, const void *);

1056 extern void *
	$bsearch
 (const void *
__key
, const void *
__base
,

1057 
size_t
 
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
)

1058 
	`__attribute__
 ((
	`__nonnull__
 (1, 2, 5))) ;

1066 extern void 
	$qsort
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

1067 
__compar_fn_t
 
__compar
) 
	`__attribute__
 ((
	`__nonnull__
 (1, 4)));

1069 extern int 
	$abs
 (int 
__x
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

1070 extern long int 
	$labs
 (long int 
__x
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

1074 
__extension__
 extern long long int 
	$llabs
 (long long int 
__x
)

1075 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

1083 extern 
div_t
 
	$div
 (int 
__numer
, int 
__denom
)

1084 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

1085 extern 
ldiv_t
 
	$ldiv
 (long int 
__numer
, long int 
__denom
)

1086 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

1091 
__extension__
 extern 
lldiv_t
 
	$lldiv
 (long long int 
__numer
,

1092 long long int 
__denom
)

1093 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

1096 extern char *
	$ecvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

1097 int *
__restrict
 
__sign
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

1102 extern char *
	$fcvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

1103 int *
__restrict
 
__sign
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

1108 extern char *
	$gcvt
 (double 
__value
, int 
__ndigit
, char *
__buf
)

1109 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3))) ;

1114 extern char *
	$qecvt
 (long double 
__value
, int 
__ndigit
,

1115 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

1116 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

1117 extern char *
	$qfcvt
 (long double 
__value
, int 
__ndigit
,

1118 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

1119 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

1120 extern char *
	$qgcvt
 (long double 
__value
, int 
__ndigit
, char *
__buf
)

1121 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3))) ;

1126 extern int 
	$ecvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

1127 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

1128 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

1129 extern int 
	$fcvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

1130 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

1131 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

1133 extern int 
	$qecvt_r
 (long double 
__value
, int 
__ndigit
,

1134 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

1135 char *
__restrict
 
__buf
, 
size_t
 
__len
)

1136 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

1137 extern int 
	$qfcvt_r
 (long double 
__value
, int 
__ndigit
,

1138 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

1139 char *
__restrict
 
__buf
, 
size_t
 
__len
)

1140 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

1147 extern int 
	$mblen
 (const char *
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1150 extern int 
	$mbtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

1151 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1154 extern int 
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1158 extern 
size_t
 
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__pwcs
,

1159 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1161 extern 
size_t
 
	$wcstombs
 (char *
__restrict
 
__s
,

1162 const 
wchar_t
 *
__restrict
 
__pwcs
, 
size_t
 
__n
)

1163 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1172 extern int 
	$rpmatch
 (const char *
__response
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

1174 extern int 
	$getsubopt
 (char **
__restrict
 
__optionp
,

1175 char *const *
__restrict
 
__tokens
,

1176 char **
__restrict
 
__valuep
)

1177 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2, 3))) ;

1179 extern int 
	$getloadavg
 (double 
__loadavg
[], int 
__nelem
)

1180 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

1206 extern void *
	$memcpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

1207 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1210 extern void *
	$memmove
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

1211 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1218 extern void *
	$memccpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

1219 int 
__c
, 
size_t
 
__n
)

1220 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1226 extern void *
	$memset
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

1229 extern int 
	$memcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

1230 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1232 extern void *
	$memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

1233 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

1239 extern char *
	$strcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

1240 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1242 extern char *
	$strncpy
 (char *
__restrict
 
__dest
,

1243 const char *
__restrict
 
__src
, 
size_t
 
__n
)

1244 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1247 extern char *
	$strcat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

1248 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1250 extern char *
	$strncat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
,

1251 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1254 extern int 
	$strcmp
 (const char *
__s1
, const char *
__s2
)

1255 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1257 extern int 
	$strncmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

1258 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1261 extern int 
	$strcoll
 (const char *
__s1
, const char *
__s2
)

1262 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1264 extern 
size_t
 
	$strxfrm
 (char *
__restrict
 
__dest
,

1265 const char *
__restrict
 
__src
, 
size_t
 
__n
)

1266 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

1275 typedef struct 
	s__locale_struct


1278 struct 
__locale_data
 *
__locales
[13];

1281 const unsigned short int *
__ctype_b
;

1282 const int *
__ctype_tolower
;

1283 const int *
__ctype_toupper
;

1286 const char *
__names
[13];

1287 } *
	t__locale_t
;

1290 typedef 
__locale_t
 
	tlocale_t
;

1294 extern int 
	$strcoll_l
 (const char *
__s1
, const char *
__s2
, 
__locale_t
 
__l
)

1295 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2, 3)));

1297 extern 
size_t
 
	$strxfrm_l
 (char *
__dest
, const char *
__src
, 
size_t
 
__n
,

1298 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 4)));

1303 extern char *
	$strdup
 (const char *
__s
)

1304 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) __attribute__ ((
	`__nonnull__
 (1)));

1311 extern char *
	$strndup
 (const char *
__string
, 
size_t
 
__n
)

1312 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) __attribute__ ((
	`__nonnull__
 (1)));

1316 extern char *
	$strchr
 (const char *
__s
, int 
__c
)

1317 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

1319 extern char *
	$strrchr
 (const char *
__s
, int 
__c
)

1320 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

1327 extern 
size_t
 
	$strcspn
 (const char *
__s
, const char *
__reject
)

1328 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1331 extern 
size_t
 
	$strspn
 (const char *
__s
, const char *
__accept
)

1332 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1334 extern char *
	$strpbrk
 (const char *
__s
, const char *
__accept
)

1335 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1337 extern char *
	$strstr
 (const char *
__haystack
, const char *
__needle
)

1338 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1343 extern char *
	$strtok
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
)

1344 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

1349 extern char *
	$__strtok_r
 (char *
__restrict
 
__s
,

1350 const char *
__restrict
 
__delim
,

1351 char **
__restrict
 
__save_ptr
)

1352 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

1354 extern char *
	$strtok_r
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
,

1355 char **
__restrict
 
__save_ptr
)

1356 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

1360 extern 
size_t
 
	$strlen
 (const char *
__s
)

1361 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

1367 extern 
size_t
 
	$strnlen
 (const char *
__string
, 
size_t
 
__maxlen
)

1368 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

1374 extern char *
	$strerror
 (int 
__errnum
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1377 extern int 
	$strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
) 
	`__asm__
 ("" "__xpg_strerror_r") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

1379 
	`__attribute__
 ((
	`__nonnull__
 (2)));

1381 extern char *
	$strerror_l
 (int 
__errnum
, 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1387 extern void 
	$__bzero
 (void *
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

1391 extern void 
	$bcopy
 (const void *
__src
, void *
__dest
, 
size_t
 
__n
)

1392 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1395 extern void 
	$bzero
 (void *
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

1398 extern int 
	$bcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

1399 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1401 extern char *
	$index
 (const char *
__s
, int 
__c
)

1402 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

1404 extern char *
	$rindex
 (const char *
__s
, int 
__c
)

1405 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

1410 extern int 
	$ffs
 (int 
__i
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

1412 extern int 
	$strcasecmp
 (const char *
__s1
, const char *
__s2
)

1413 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1416 extern int 
	$strncasecmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

1417 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1419 extern char *
	$strsep
 (char **
__restrict
 
__stringp
,

1420 const char *
__restrict
 
__delim
)

1421 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1426 extern char *
	$strsignal
 (int 
__sig
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1429 extern char *
	$__stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

1430 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1431 extern char *
	$stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

1432 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1436 extern char *
	$__stpncpy
 (char *
__restrict
 
__dest
,

1437 const char *
__restrict
 
__src
, 
size_t
 
__n
)

1438 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1439 extern char *
	$stpncpy
 (char *
__restrict
 
__dest
,

1440 const char *
__restrict
 
__src
, 
size_t
 
__n
)

1441 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

1454 struct 
_IO_FILE
;

1458 typedef struct 
_IO_FILE
 
	tFILE
;

1465 typedef struct 
_IO_FILE
 
	t__FILE
;

1481 int 
__count
;

1485 unsigned int 
__wch
;

1489 char 
__wchb
[4];

1490 } 
__value
;

1491 } 
	t__mbstate_t
;

1495 
__off_t
 
__pos
;

1496 
__mbstate_t
 
__state
;

1497 } 
	t_G_fpos_t
;

1500 
__off64_t
 
__pos
;

1501 
__mbstate_t
 
__state
;

1502 } 
	t_G_fpos64_t
;

1507 typedef 
__builtin_va_list
 
	t__gnuc_va_list
;

1510 struct 
_IO_jump_t
; struct 
_IO_FILE
;

1512 typedef void 
	t_IO_lock_t
;

1518 struct 
	s_IO_marker
 {

1519 struct 
_IO_marker
 *
_next
;

1520 struct 
_IO_FILE
 *
_sbuf
;

1524 int 
_pos
;

1529 enum 
	e__codecvt_result


1531 
__codecvt_ok
,

1532 
__codecvt_partial
,

1533 
__codecvt_error
,

1534 
__codecvt_noconv


1537 struct 
	s_IO_FILE
 {

1538 int 
_flags
;

1543 char* 
_IO_read_ptr
;

1544 char* 
_IO_read_end
;

1545 char* 
_IO_read_base
;

1546 char* 
_IO_write_base
;

1547 char* 
_IO_write_ptr
;

1548 char* 
_IO_write_end
;

1549 char* 
_IO_buf_base
;

1550 char* 
_IO_buf_end
;

1552 char *
_IO_save_base
;

1553 char *
_IO_backup_base
;

1554 char *
_IO_save_end
;

1556 struct 
_IO_marker
 *
_markers
;

1558 struct 
_IO_FILE
 *
_chain
;

1560 int 
_fileno
;

1564 int 
_flags2
;

1566 
__off_t
 
_old_offset
;

1570 unsigned short 
_cur_column
;

1571 signed char 
_vtable_offset
;

1572 char 
_shortbuf
[1];

1576 
_IO_lock_t
 *
_lock
;

1578 
__off64_t
 
_offset
;

1580 void *
__pad1
;

1581 void *
__pad2
;

1582 void *
__pad3
;

1583 void *
__pad4
;

1584 
size_t
 
__pad5
;

1586 int 
_mode
;

1588 char 
_unused2
[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (
size_t
)];

1593 typedef struct 
_IO_FILE
 
	t_IO_FILE
;

1596 struct 
_IO_FILE_plus
;

1598 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdin_
;

1599 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdout_
;

1600 extern struct 
_IO_FILE_plus
 
_IO_2_1_stderr_
;

1602 typedef 
__ssize_t
 
	t__io_read_fn
 (void *
	t__cookie
, char *
	t__buf
, 
	tsize_t
 
	t__nbytes
);

1610 typedef 
__ssize_t
 
	t__io_write_fn
 (void *
	t__cookie
, const char *
	t__buf
,

1611 
	tsize_t
 
	t__n
);

1619 typedef int 
	t__io_seek_fn
 (void *
	t__cookie
, 
	t__off64_t
 *
	t__pos
, int 
	t__w
);

1622 typedef int 
	t__io_close_fn
 (void *
	t__cookie
);

1624 extern int 
	`__underflow
 (
_IO_FILE
 *);

1625 extern int 
	`__uflow
 (
_IO_FILE
 *);

1626 extern int 
	`__overflow
 (
_IO_FILE
 *, int);

1628 extern int 
	`_IO_getc
 (
_IO_FILE
 *
__fp
);

1629 extern int 
	`_IO_putc
 (int 
__c
, 
_IO_FILE
 *
__fp
);

1630 extern int 
	$_IO_feof
 (
_IO_FILE
 *
__fp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1631 extern int 
	$_IO_ferror
 (
_IO_FILE
 *
__fp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1633 extern int 
	`_IO_peekc_locked
 (
_IO_FILE
 *
__fp
);

1639 extern void 
	$_IO_flockfile
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1640 extern void 
	$_IO_funlockfile
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1641 extern int 
	$_IO_ftrylockfile
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1643 extern int 
	`_IO_vfscanf
 (
_IO_FILE
 * 
__restrict
, const char * __restrict,

1644 
__gnuc_va_list
, int *
__restrict
);

1645 extern int 
	`_IO_vfprintf
 (
_IO_FILE
 *
__restrict
, const char *__restrict,

1646 
__gnuc_va_list
);

1647 extern 
__ssize_t
 
	`_IO_padn
 (
_IO_FILE
 *, int, __ssize_t);

1648 extern 
size_t
 
	`_IO_sgetn
 (
_IO_FILE
 *, void *, size_t);

1650 extern 
__off64_t
 
	`_IO_seekoff
 (
_IO_FILE
 *, __off64_t, int, int);

1651 extern 
__off64_t
 
	`_IO_seekpos
 (
_IO_FILE
 *, __off64_t, int);

1653 extern void 
	$_IO_free_backup_area
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1659 typedef 
__gnuc_va_list
 
	tva_list
;

1665 typedef 
_G_fpos64_t
 
	tfpos_t
;

1674 extern struct 
_IO_FILE
 *
stdin
;

1675 extern struct 
_IO_FILE
 *
stdout
;

1676 extern struct 
_IO_FILE
 *
stderr
;

1684 extern int 
	$remove
 (const char *
__filename
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1686 extern int 
	$rename
 (const char *
__old
, const char *
__new
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1691 extern int 
	$renameat
 (int 
__oldfd
, const char *
__old
, int 
__newfd
,

1692 const char *
__new
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1697 extern 
FILE
 *
	$tmpfile
 (void) 
	`__asm__
 ("" "tmpfile64") ;

1699 extern char *
	$tmpnam
 (char *
__s
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1705 extern char *
	$tmpnam_r
 (char *
__s
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1707 extern char *
	$tempnam
 (const char *
__dir
, const char *
__pfx
)

1708 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

1717 extern int 
	`fclose
 (
FILE
 *
__stream
);

1722 extern int 
	`fflush
 (
FILE
 *
__stream
);

1725 extern int 
	`fflush_unlocked
 (
FILE
 *
__stream
);

1729 extern 
FILE
 *
	$fopen
 (const char *
__restrict
 
__filename
, const char *__restrict 
__modes
) 
	`__asm__
 ("" "fopen64")

1732 extern 
FILE
 *
	$freopen
 (const char *
__restrict
 
__filename
, const char *__restrict 
__modes
, 
FILE
 *__restrict 
__stream
) 
	`__asm__
 ("" "freopen64")

1743 extern 
FILE
 *
	$fdopen
 (int 
__fd
, const char *
__modes
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1745 extern 
FILE
 *
	$fmemopen
 (void *
__s
, 
size_t
 
__len
, const char *
__modes
)

1746 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1751 extern 
FILE
 *
	$open_memstream
 (char **
__bufloc
, 
size_t
 *
__sizeloc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1758 extern void 
	$setbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1762 extern int 
	$setvbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

1763 int 
__modes
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1769 extern void 
	$setbuffer
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

1770 
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1773 extern void 
	$setlinebuf
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1782 extern int 
	`fprintf
 (
FILE
 *
__restrict
 
__stream
,

1783 const char *
__restrict
 
__format
, ...);

1788 extern int 
	`printf
 (const char *
__restrict
 
__format
, ...);

1790 extern int 
	$sprintf
 (char *
__restrict
 
__s
,

1791 const char *
__restrict
 
__format
, ...) 
	`__attribute__
 ((
__nothrow__
));

1797 extern int 
	`vfprintf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

1798 
__gnuc_va_list
 
__arg
);

1803 extern int 
	`vprintf
 (const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
);

1805 extern int 
	$vsprintf
 (char *
__restrict
 
__s
, const char *__restrict 
__format
,

1806 
__gnuc_va_list
 
__arg
) 
	`__attribute__
 ((
__nothrow__
));

1812 extern int 
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

1813 const char *
__restrict
 
__format
, ...)

1814 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 3, 4)));

1816 extern int 
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

1817 const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
)

1818 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 3, 0)));

1821 extern int 
	$vdprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
,

1822 
__gnuc_va_list
 
__arg
)

1823 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

1824 extern int 
	$dprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
, ...)

1825 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

1834 extern int 
	`fscanf
 (
FILE
 *
__restrict
 
__stream
,

1835 const char *
__restrict
 
__format
, ...) ;

1840 extern int 
	`scanf
 (const char *
__restrict
 
__format
, ...) ;

1842 extern int 
	$sscanf
 (const char *
__restrict
 
__s
,

1843 const char *
__restrict
 
__format
, ...) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1845 extern int 
	$fscanf
 (
FILE
 *
__restrict
 
__stream
, const char *__restrict 
__format
, ...) 
	`__asm__
 ("" "__isoc99_fscanf")

1848 extern int 
	$scanf
 (const char *
__restrict
 
__format
, ...) 
	`__asm__
 ("" "__isoc99_scanf")

1850 extern int 
	$sscanf
 (const char *
__restrict
 
__s
, const char *__restrict 
__format
, ...) 
	`__asm__
 ("" "__isoc99_sscanf") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

1862 extern int 
	$vfscanf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

1863 
__gnuc_va_list
 
__arg
)

1864 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0))) ;

1870 extern int 
	$vscanf
 (const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
)

1871 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 1, 0))) ;

1874 extern int 
	$vsscanf
 (const char *
__restrict
 
__s
,

1875 const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
)

1876 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__format__
 (
__scanf__
, 2, 0)));

1878 extern int 
	$vfscanf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
, 
__gnuc_va_list
 
__arg
) 
	`__asm__
 ("" "__isoc99_vfscanf")

1882 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0))) ;

1883 extern int 
	$vscanf
 (const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
) 
	`__asm__
 ("" "__isoc99_vscanf")

1885 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 1, 0))) ;

1886 extern int 
	$vsscanf
 (const char *
__restrict
 
__s
, const char *__restrict 
__format
, 
__gnuc_va_list
 
__arg
) 
	`__asm__
 ("" "__isoc99_vsscanf") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

1890 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

1901 extern int 
	`fgetc
 (
FILE
 *
__stream
);

1902 extern int 
	`getc
 (
FILE
 *
__stream
);

1908 extern int 
	`getchar
 (void);

1911 extern int 
	`getc_unlocked
 (
FILE
 *
__stream
);

1912 extern int 
	`getchar_unlocked
 (void);

1914 extern int 
	`fgetc_unlocked
 (
FILE
 *
__stream
);

1926 extern int 
	`fputc
 (int 
__c
, 
FILE
 *
__stream
);

1927 extern int 
	`putc
 (int 
__c
, 
FILE
 *
__stream
);

1933 extern int 
	`putchar
 (int 
__c
);

1936 extern int 
	`fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

1944 extern int 
	`putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

1945 extern int 
	`putchar_unlocked
 (int 
__c
);

1952 extern int 
	`getw
 (
FILE
 *
__stream
);

1955 extern int 
	`putw
 (int 
__w
, 
FILE
 *
__stream
);

1964 extern char *
	`fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

1967 extern char *
	$gets
 (char *
__s
) 
	`__attribute__
 ((
__deprecated__
));

1971 extern 
__ssize_t
 
	`__getdelim
 (char **
__restrict
 
__lineptr
,

1972 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

1973 
FILE
 *
__restrict
 
__stream
) ;

1974 extern 
__ssize_t
 
	`getdelim
 (char **
__restrict
 
__lineptr
,

1975 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

1976 
FILE
 *
__restrict
 
__stream
) ;

1984 extern 
__ssize_t
 
	`getline
 (char **
__restrict
 
__lineptr
,

1985 
size_t
 *
__restrict
 
__n
,

1986 
FILE
 *
__restrict
 
__stream
) ;

1995 extern int 
	`fputs
 (const char *
__restrict
 
__s
, 
FILE
 *__restrict 
__stream
);

2001 extern int 
	`puts
 (const char *
__s
);

2008 extern int 
	`ungetc
 (int 
__c
, 
FILE
 *
__stream
);

2015 extern 
size_t
 
	`fread
 (void *
__restrict
 
__ptr
, size_t 
__size
,

2016 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) ;

2021 extern 
size_t
 
	`fwrite
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

2022 
size_t
 
__n
, 
FILE
 *
__restrict
 
__s
);

2025 extern 
size_t
 
	`fread_unlocked
 (void *
__restrict
 
__ptr
, size_t 
__size
,

2026 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) ;

2027 extern 
size_t
 
	`fwrite_unlocked
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

2028 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
);

2037 extern int 
	`fseek
 (
FILE
 *
__stream
, long int 
__off
, int 
__whence
);

2042 extern long int 
	`ftell
 (
FILE
 *
__stream
) ;

2047 extern void 
	`rewind
 (
FILE
 *
__stream
);

2050 extern int 
	$fseeko
 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
) 
	`__asm__
 ("" "fseeko64")

2053 extern 
__off64_t
 
	$ftello
 (
FILE
 *
__stream
) 
	`__asm__
 ("" "ftello64");

2063 extern int 
	$fgetpos
 (
FILE
 *
__restrict
 
__stream
, 
fpos_t
 *__restrict 
__pos
) 
	`__asm__
 ("" "fgetpos64")

2065 extern int 
	$fsetpos
 (
FILE
 *
__stream
, const 
fpos_t
 *
__pos
) 
	`__asm__
 ("" "fsetpos64")

2076 extern void 
	$clearerr
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2078 extern int 
	$feof
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2080 extern int 
	$ferror
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2085 extern void 
	$clearerr_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2086 extern int 
	$feof_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2087 extern int 
	$ferror_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2096 extern void 
	`perror
 (const char *
__s
);

2105 extern int 
sys_nerr
;

2106 extern const char *const 
sys_errlist
[];

2112 extern int 
	$fileno
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2117 extern int 
	$fileno_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2119 extern 
FILE
 *
	`popen
 (const char *
__command
, const char *
__modes
) ;

2125 extern int 
	`pclose
 (
FILE
 *
__stream
);

2131 extern char *
	$ctermid
 (char *
__s
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2133 extern void 
	$flockfile
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2137 extern int 
	$ftrylockfile
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2140 extern void 
	$funlockfile
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2149 extern void 
	$__assert_fail
 (const char *
__assertion
, const char *
__file
,

2150 unsigned int 
__line
, const char *
__function
)

2151 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

2154 extern void 
	$__assert_perror_fail
 (int 
__errnum
, const char *
__file
,

2155 unsigned int 
__line
, const char *
__function
)

2156 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

2161 extern void 
	$__assert
 (const char *
__assertion
, const char *
__file
, int 
__line
)

2162 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

2172 extern const char 
sqlite3_version
[];

2173 const char * 
	`sqlite3_libversion
(void);

2174 const char * 
	`sqlite3_sourceid
(void);

2175 int 
	`sqlite3_libversion_number
(void);

2177 int 
	`sqlite3_compileoption_used
(const char *
zOptName
);

2178 const char * 
	`sqlite3_compileoption_get
(int 
N
);

2180 int 
	`sqlite3_threadsafe
(void);

2182 typedef struct 
sqlite3
 
	tsqlite3
;

2184 typedef long long int 
	tsqlite_int64
;

2185 typedef unsigned long long int 
	tsqlite_uint64
;

2187 typedef 
sqlite_int64
 
	tsqlite3_int64
;

2188 typedef 
sqlite_uint64
 
	tsqlite3_uint64
;

2190 int 
	`sqlite3_close
(
sqlite3
*);

2191 int 
	`sqlite3_close_v2
(
sqlite3
*);

2198 typedef int (*
	tsqlite3_callback
)(void*,int,char**, char**);

2200 int 
	`sqlite3_exec
(

2201 
sqlite3
*,

2202 const char *
sql
,

2203 int (*
callback
)(void*,int,char**,char**),

2205 char **
errmsg


2208 typedef struct 
sqlite3_file
 
	tsqlite3_file
;

2209 struct 
	ssqlite3_file
 {

2210 const struct 
sqlite3_io_methods
 *
pMethods
;

2213 typedef struct 
sqlite3_io_methods
 
	tsqlite3_io_methods
;

2214 struct 
	ssqlite3_io_methods
 {

2215 int 
iVersion
;

2216 int (*
xClose
)(
sqlite3_file
*);

2217 int (*
xRead
)(
sqlite3_file
*, void*, int 
iAmt
, 
sqlite3_int64
 
iOfst
);

2218 int (*
xWrite
)(
sqlite3_file
*, const void*, int 
iAmt
, 
sqlite3_int64
 
iOfst
);

2219 int (*
xTruncate
)(
sqlite3_file
*, 
sqlite3_int64
 
size
);

2220 int (*
xSync
)(
sqlite3_file
*, int 
flags
);

2221 int (*
xFileSize
)(
sqlite3_file
*, 
sqlite3_int64
 *
pSize
);

2222 int (*
xLock
)(
sqlite3_file
*, int);

2223 int (*
xUnlock
)(
sqlite3_file
*, int);

2224 int (*
xCheckReservedLock
)(
sqlite3_file
*, int *
pResOut
);

2225 int (*
xFileControl
)(
sqlite3_file
*, int 
op
, void *
pArg
);

2226 int (*
xSectorSize
)(
sqlite3_file
*);

2227 int (*
xDeviceCharacteristics
)(
sqlite3_file
*);

2229 int (*
xShmMap
)(
sqlite3_file
*, int 
iPg
, int 
pgsz
, int, void volatile**);

2230 int (*
xShmLock
)(
sqlite3_file
*, int 
offset
, int 
n
, int 
flags
);

2231 void (*
xShmBarrier
)(
sqlite3_file
*);

2232 int (*
xShmUnmap
)(
sqlite3_file
*, int 
deleteFlag
);

2234 int (*
xFetch
)(
sqlite3_file
*, 
sqlite3_int64
 
iOfst
, int 
iAmt
, void **
pp
);

2235 int (*
xUnfetch
)(
sqlite3_file
*, 
sqlite3_int64
 
iOfst
, void *
p
);

2240 typedef struct 
sqlite3_mutex
 
	tsqlite3_mutex
;

2242 typedef struct 
sqlite3_vfs
 
	tsqlite3_vfs
;

2243 typedef void (*
	tsqlite3_syscall_ptr
)(void);

2244 struct 
	ssqlite3_vfs
 {

2245 int 
iVersion
;

2246 int 
szOsFile
;

2247 int 
mxPathname
;

2248 
sqlite3_vfs
 *
pNext
;

2249 const char *
zName
;

2250 void *
pAppData
;

2251 int (*
xOpen
)(
sqlite3_vfs
*, const char *
zName
, 
sqlite3_file
*,

2252 int 
flags
, int *
pOutFlags
);

2253 int (*
xDelete
)(
sqlite3_vfs
*, const char *
zName
, int 
syncDir
);

2254 int (*
xAccess
)(
sqlite3_vfs
*, const char *
zName
, int 
flags
, int *
pResOut
);

2255 int (*
xFullPathname
)(
sqlite3_vfs
*, const char *
zName
, int 
nOut
, char *
zOut
);

2256 void *(*
xDlOpen
)(
sqlite3_vfs
*, const char *
zFilename
);

2257 void (*
xDlError
)(
sqlite3_vfs
*, int 
nByte
, char *
zErrMsg
);

2258 void (*(*
xDlSym
)(
sqlite3_vfs
*,void*, const char *
zSymbol
))(void);

2259 void (*
xDlClose
)(
sqlite3_vfs
*, void*);

2260 int (*
xRandomness
)(
sqlite3_vfs
*, int 
nByte
, char *
zOut
);

2261 int (*
xSleep
)(
sqlite3_vfs
*, int 
microseconds
);

2262 int (*
xCurrentTime
)(
sqlite3_vfs
*, double*);

2263 int (*
xGetLastError
)(
sqlite3_vfs
*, int, char *);

2268 int (*
xCurrentTimeInt64
)(
sqlite3_vfs
*, 
sqlite3_int64
*);

2273 int (*
xSetSystemCall
)(
sqlite3_vfs
*, const char *
zName
, 
sqlite3_syscall_ptr
);

2274 
	`sqlite3_syscall_ptr
 (*
xGetSystemCall
)(
sqlite3_vfs
*, const char *
zName
);

2275 const char *(*
xNextSystemCall
)(
sqlite3_vfs
*, const char *
zName
);

2283 int 
	`sqlite3_initialize
(void);

2284 int 
	`sqlite3_shutdown
(void);

2285 int 
	`sqlite3_os_init
(void);

2286 int 
	`sqlite3_os_end
(void);

2288 int 
	`sqlite3_config
(int, ...);

2290 int 
	`sqlite3_db_config
(
sqlite3
*, int 
op
, ...);

2292 typedef struct 
sqlite3_mem_methods
 
	tsqlite3_mem_methods
;

2293 struct 
	ssqlite3_mem_methods
 {

2294 void *(*
xMalloc
)(int);

2295 void (*
xFree
)(void*);

2296 void *(*
xRealloc
)(void*,int);

2297 int (*
xSize
)(void*);

2298 int (*
xRoundup
)(int);

2299 int (*
xInit
)(void*);

2300 void (*
xShutdown
)(void*);

2301 void *
pAppData
;

2304 int 
	`sqlite3_extended_result_codes
(
sqlite3
*, int 
onoff
);

2306 
sqlite3_int64
 
	`sqlite3_last_insert_rowid
(
sqlite3
*);

2308 int 
	`sqlite3_changes
(
sqlite3
*);

2310 int 
	`sqlite3_total_changes
(
sqlite3
*);

2312 void 
	`sqlite3_interrupt
(
sqlite3
*);

2314 int 
	`sqlite3_complete
(const char *
sql
);

2315 int 
	`sqlite3_complete16
(const void *
sql
);

2317 int 
	`sqlite3_busy_handler
(
sqlite3
*, int(*)(void*,int), void*);

2319 int 
	`sqlite3_busy_timeout
(
sqlite3
*, int 
ms
);

2321 int 
	`sqlite3_get_table
(

2322 
sqlite3
 *
db
,

2323 const char *
zSql
,

2324 char ***
pazResult
,

2325 int *
pnRow
,

2326 int *
pnColumn
,

2327 char **
pzErrmsg


2329 void 
	`sqlite3_free_table
(char **
result
);

2331 char * 
	`sqlite3_mprintf
(const char*,...);

2332 char * 
	`sqlite3_vmprintf
(const char*, 
va_list
);

2333 char * 
	`sqlite3_snprintf
(int,char*,const char*, ...);

2334 char * 
	`sqlite3_vsnprintf
(int,char*,const char*, 
va_list
);

2336 void * 
	`sqlite3_malloc
(int);

2337 void * 
	`sqlite3_malloc64
(
sqlite3_uint64
);

2338 void * 
	`sqlite3_realloc
(void*, int);

2339 void * 
	`sqlite3_realloc64
(void*, 
sqlite3_uint64
);

2340 void 
	`sqlite3_free
(void*);

2341 
sqlite3_uint64
 
	`sqlite3_msize
(void*);

2343 
sqlite3_int64
 
	`sqlite3_memory_used
(void);

2344 
sqlite3_int64
 
	`sqlite3_memory_highwater
(int 
resetFlag
);

2346 void 
	`sqlite3_randomness
(int 
N
, void *
P
);

2348 int 
	`sqlite3_set_authorizer
(

2349 
sqlite3
*,

2350 int (*
xAuth
)(void*,int,const char*,const char*,const char*,const char*),

2351 void *
pUserData


2354 void * 
	`sqlite3_trace
(
sqlite3
*, void(*
xTrace
)(void*,const char*), void*);

2355 void * 
	`sqlite3_profile
(
sqlite3
*,

2356 void(*
xProfile
)(void*,const char*,
sqlite3_uint64
), void*);

2358 void 
	`sqlite3_progress_handler
(
sqlite3
*, int, int(*)(void*), void*);

2360 int 
	`sqlite3_open
(

2361 const char *
filename
,

2362 
sqlite3
 **
ppDb


2364 int 
	`sqlite3_open16
(

2365 const void *
filename
,

2366 
sqlite3
 **
ppDb


2368 int 
	`sqlite3_open_v2
(

2369 const char *
filename
,

2370 
sqlite3
 **
ppDb
,

2371 int 
flags
,

2372 const char *
zVfs


2375 const char * 
	`sqlite3_uri_parameter
(const char *
zFilename
, const char *
zParam
);

2376 int 
	`sqlite3_uri_boolean
(const char *
zFile
, const char *
zParam
, int 
bDefault
);

2377 
sqlite3_int64
 
	`sqlite3_uri_int64
(const char*, const char*, sqlite3_int64);

2379 int 
	`sqlite3_errcode
(
sqlite3
 *
db
);

2380 int 
	`sqlite3_extended_errcode
(
sqlite3
 *
db
);

2381 const char * 
	`sqlite3_errmsg
(
sqlite3
*);

2382 const void * 
	`sqlite3_errmsg16
(
sqlite3
*);

2383 const char * 
	`sqlite3_errstr
(int);

2385 typedef struct 
sqlite3_stmt
 
	tsqlite3_stmt
;

2387 int 
	`sqlite3_limit
(
sqlite3
*, int 
id
, int 
newVal
);

2389 int 
	`sqlite3_prepare
(

2390 
sqlite3
 *
db
,

2391 const char *
zSql
,

2392 int 
nByte
,

2393 
sqlite3_stmt
 **
ppStmt
,

2394 const char **
pzTail


2396 int 
	`sqlite3_prepare_v2
(

2397 
sqlite3
 *
db
,

2398 const char *
zSql
,

2399 int 
nByte
,

2400 
sqlite3_stmt
 **
ppStmt
,

2401 const char **
pzTail


2403 int 
	`sqlite3_prepare16
(

2404 
sqlite3
 *
db
,

2405 const void *
zSql
,

2406 int 
nByte
,

2407 
sqlite3_stmt
 **
ppStmt
,

2408 const void **
pzTail


2410 int 
	`sqlite3_prepare16_v2
(

2411 
sqlite3
 *
db
,

2412 const void *
zSql
,

2413 int 
nByte
,

2414 
sqlite3_stmt
 **
ppStmt
,

2415 const void **
pzTail


2418 const char * 
	`sqlite3_sql
(
sqlite3_stmt
 *
pStmt
);

2420 int 
	`sqlite3_stmt_readonly
(
sqlite3_stmt
 *
pStmt
);

2422 int 
	`sqlite3_stmt_busy
(
sqlite3_stmt
*);

2424 typedef struct 
Mem
 
	tsqlite3_value
;

2426 typedef struct 
sqlite3_context
 
	tsqlite3_context
;

2428 int 
	`sqlite3_bind_blob
(
sqlite3_stmt
*, int, const void*, int 
n
, void(*)(void*));

2429 int 
	`sqlite3_bind_blob64
(
sqlite3_stmt
*, int, const void*, 
sqlite3_uint64
,

2431 int 
	`sqlite3_bind_double
(
sqlite3_stmt
*, int, double);

2432 int 
	`sqlite3_bind_int
(
sqlite3_stmt
*, int, int);

2433 int 
	`sqlite3_bind_int64
(
sqlite3_stmt
*, int, 
sqlite3_int64
);

2434 int 
	`sqlite3_bind_null
(
sqlite3_stmt
*, int);

2435 int 
	`sqlite3_bind_text
(
sqlite3_stmt
*,int,const char*,int,void(*)(void*));

2436 int 
	`sqlite3_bind_text16
(
sqlite3_stmt
*, int, const void*, int, void(*)(void*));

2437 int 
	`sqlite3_bind_text64
(
sqlite3_stmt
*, int, const char*, 
sqlite3_uint64
,

2438 void(*)(void*), unsigned char 
encoding
);

2439 int 
	`sqlite3_bind_value
(
sqlite3_stmt
*, int, const 
sqlite3_value
*);

2440 int 
	`sqlite3_bind_zeroblob
(
sqlite3_stmt
*, int, int 
n
);

2441 int 
	`sqlite3_bind_zeroblob64
(
sqlite3_stmt
*, int, 
sqlite3_uint64
);

2443 int 
	`sqlite3_bind_parameter_count
(
sqlite3_stmt
*);

2445 const char * 
	`sqlite3_bind_parameter_name
(
sqlite3_stmt
*, int);

2447 int 
	`sqlite3_bind_parameter_index
(
sqlite3_stmt
*, const char *
zName
);

2449 int 
	`sqlite3_clear_bindings
(
sqlite3_stmt
*);

2451 int 
	`sqlite3_column_count
(
sqlite3_stmt
 *
pStmt
);

2453 const char * 
	`sqlite3_column_name
(
sqlite3_stmt
*, int 
N
);

2454 const void * 
	`sqlite3_column_name16
(
sqlite3_stmt
*, int 
N
);

2456 const char * 
	`sqlite3_column_database_name
(
sqlite3_stmt
*,int);

2457 const void * 
	`sqlite3_column_database_name16
(
sqlite3_stmt
*,int);

2458 const char * 
	`sqlite3_column_table_name
(
sqlite3_stmt
*,int);

2459 const void * 
	`sqlite3_column_table_name16
(
sqlite3_stmt
*,int);

2460 const char * 
	`sqlite3_column_origin_name
(
sqlite3_stmt
*,int);

2461 const void * 
	`sqlite3_column_origin_name16
(
sqlite3_stmt
*,int);

2463 const char * 
	`sqlite3_column_decltype
(
sqlite3_stmt
*,int);

2464 const void * 
	`sqlite3_column_decltype16
(
sqlite3_stmt
*,int);

2466 int 
	`sqlite3_step
(
sqlite3_stmt
*);

2468 int 
	`sqlite3_data_count
(
sqlite3_stmt
 *
pStmt
);

2470 const void * 
	`sqlite3_column_blob
(
sqlite3_stmt
*, int 
iCol
);

2471 int 
	`sqlite3_column_bytes
(
sqlite3_stmt
*, int 
iCol
);

2472 int 
	`sqlite3_column_bytes16
(
sqlite3_stmt
*, int 
iCol
);

2473 double 
	`sqlite3_column_double
(
sqlite3_stmt
*, int 
iCol
);

2474 int 
	`sqlite3_column_int
(
sqlite3_stmt
*, int 
iCol
);

2475 
sqlite3_int64
 
	`sqlite3_column_int64
(
sqlite3_stmt
*, int 
iCol
);

2476 const unsigned char * 
	`sqlite3_column_text
(
sqlite3_stmt
*, int 
iCol
);

2477 const void * 
	`sqlite3_column_text16
(
sqlite3_stmt
*, int 
iCol
);

2478 int 
	`sqlite3_column_type
(
sqlite3_stmt
*, int 
iCol
);

2479 
sqlite3_value
 * 
	`sqlite3_column_value
(
sqlite3_stmt
*, int 
iCol
);

2481 int 
	`sqlite3_finalize
(
sqlite3_stmt
 *
pStmt
);

2483 int 
	`sqlite3_reset
(
sqlite3_stmt
 *
pStmt
);

2485 int 
	`sqlite3_create_function
(

2486 
sqlite3
 *
db
,

2487 const char *
zFunctionName
,

2488 int 
nArg
,

2489 int 
eTextRep
,

2490 void *
pApp
,

2491 void (*
xFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

2492 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
**),

2493 void (*
xFinal
)(
sqlite3_context
*)

2495 int 
	`sqlite3_create_function16
(

2496 
sqlite3
 *
db
,

2497 const void *
zFunctionName
,

2498 int 
nArg
,

2499 int 
eTextRep
,

2500 void *
pApp
,

2501 void (*
xFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

2502 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
**),

2503 void (*
xFinal
)(
sqlite3_context
*)

2505 int 
	`sqlite3_create_function_v2
(

2506 
sqlite3
 *
db
,

2507 const char *
zFunctionName
,

2508 int 
nArg
,

2509 int 
eTextRep
,

2510 void *
pApp
,

2511 void (*
xFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

2512 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
**),

2513 void (*
xFinal
)(
sqlite3_context
*),

2514 void(*
xDestroy
)(void*)

2517 int 
	`sqlite3_aggregate_count
(
sqlite3_context
*);

2518 int 
	`sqlite3_expired
(
sqlite3_stmt
*);

2519 int 
	`sqlite3_transfer_bindings
(
sqlite3_stmt
*, sqlite3_stmt*);

2520 int 
	`sqlite3_global_recover
(void);

2521 void 
	`sqlite3_thread_cleanup
(void);

2522 int 
	`sqlite3_memory_alarm
(void(*)(void*,
sqlite3_int64
,int),

2523 void*,
sqlite3_int64
);

2525 const void * 
	`sqlite3_value_blob
(
sqlite3_value
*);

2526 int 
	`sqlite3_value_bytes
(
sqlite3_value
*);

2527 int 
	`sqlite3_value_bytes16
(
sqlite3_value
*);

2528 double 
	`sqlite3_value_double
(
sqlite3_value
*);

2529 int 
	`sqlite3_value_int
(
sqlite3_value
*);

2530 
sqlite3_int64
 
	`sqlite3_value_int64
(
sqlite3_value
*);

2531 const unsigned char * 
	`sqlite3_value_text
(
sqlite3_value
*);

2532 const void * 
	`sqlite3_value_text16
(
sqlite3_value
*);

2533 const void * 
	`sqlite3_value_text16le
(
sqlite3_value
*);

2534 const void * 
	`sqlite3_value_text16be
(
sqlite3_value
*);

2535 int 
	`sqlite3_value_type
(
sqlite3_value
*);

2536 int 
	`sqlite3_value_numeric_type
(
sqlite3_value
*);

2538 unsigned int 
	`sqlite3_value_subtype
(
sqlite3_value
*);

2540 
sqlite3_value
 * 
	`sqlite3_value_dup
(const sqlite3_value*);

2541 void 
	`sqlite3_value_free
(
sqlite3_value
*);

2543 void * 
	`sqlite3_aggregate_context
(
sqlite3_context
*, int 
nBytes
);

2545 void * 
	`sqlite3_user_data
(
sqlite3_context
*);

2547 
sqlite3
 * 
	`sqlite3_context_db_handle
(
sqlite3_context
*);

2549 void * 
	`sqlite3_get_auxdata
(
sqlite3_context
*, int 
N
);

2550 void 
	`sqlite3_set_auxdata
(
sqlite3_context
*, int 
N
, void*, void (*)(void*));

2552 typedef void (*
	tsqlite3_destructor_type
)(void*);

2554 void 
	`sqlite3_result_blob
(
sqlite3_context
*, const void*, int, void(*)(void*));

2555 void 
	`sqlite3_result_blob64
(
sqlite3_context
*,const void*,

2556 
sqlite3_uint64
,void(*)(void*));

2557 void 
	`sqlite3_result_double
(
sqlite3_context
*, double);

2558 void 
	`sqlite3_result_error
(
sqlite3_context
*, const char*, int);

2559 void 
	`sqlite3_result_error16
(
sqlite3_context
*, const void*, int);

2560 void 
	`sqlite3_result_error_toobig
(
sqlite3_context
*);

2561 void 
	`sqlite3_result_error_nomem
(
sqlite3_context
*);

2562 void 
	`sqlite3_result_error_code
(
sqlite3_context
*, int);

2563 void 
	`sqlite3_result_int
(
sqlite3_context
*, int);

2564 void 
	`sqlite3_result_int64
(
sqlite3_context
*, 
sqlite3_int64
);

2565 void 
	`sqlite3_result_null
(
sqlite3_context
*);

2566 void 
	`sqlite3_result_text
(
sqlite3_context
*, const char*, int, void(*)(void*));

2567 void 
	`sqlite3_result_text64
(
sqlite3_context
*, const char*,
sqlite3_uint64
,

2568 void(*)(void*), unsigned char 
encoding
);

2569 void 
	`sqlite3_result_text16
(
sqlite3_context
*, const void*, int, void(*)(void*));

2570 void 
	`sqlite3_result_text16le
(
sqlite3_context
*, const void*, int,void(*)(void*));

2571 void 
	`sqlite3_result_text16be
(
sqlite3_context
*, const void*, int,void(*)(void*));

2572 void 
	`sqlite3_result_value
(
sqlite3_context
*, 
sqlite3_value
*);

2573 void 
	`sqlite3_result_zeroblob
(
sqlite3_context
*, int 
n
);

2574 int 
	`sqlite3_result_zeroblob64
(
sqlite3_context
*, 
sqlite3_uint64
 
n
);

2576 void 
	`sqlite3_result_subtype
(
sqlite3_context
*,unsigned int);

2578 int 
	`sqlite3_create_collation
(

2579 
sqlite3
*,

2580 const char *
zName
,

2581 int 
eTextRep
,

2582 void *
pArg
,

2583 int(*
xCompare
)(void*,int,const void*,int,const void*)

2585 int 
	`sqlite3_create_collation_v2
(

2586 
sqlite3
*,

2587 const char *
zName
,

2588 int 
eTextRep
,

2589 void *
pArg
,

2590 int(*
xCompare
)(void*,int,const void*,int,const void*),

2591 void(*
xDestroy
)(void*)

2593 int 
	`sqlite3_create_collation16
(

2594 
sqlite3
*,

2595 const void *
zName
,

2596 int 
eTextRep
,

2597 void *
pArg
,

2598 int(*
xCompare
)(void*,int,const void*,int,const void*)

2601 int 
	`sqlite3_collation_needed
(

2602 
sqlite3
*,

2604 void(*)(void*,
sqlite3
*,int 
eTextRep
,const char*)

2606 int 
	`sqlite3_collation_needed16
(

2607 
sqlite3
*,

2609 void(*)(void*,
sqlite3
*,int 
eTextRep
,const void*)

2612 int 
	`sqlite3_sleep
(int);

2614 extern char *
sqlite3_temp_directory
;

2616 extern char *
sqlite3_data_directory
;

2618 int 
	`sqlite3_get_autocommit
(
sqlite3
*);

2620 
sqlite3
 * 
	`sqlite3_db_handle
(
sqlite3_stmt
*);

2622 const char * 
	`sqlite3_db_filename
(
sqlite3
 *
db
, const char *
zDbName
);

2624 int 
	`sqlite3_db_readonly
(
sqlite3
 *
db
, const char *
zDbName
);

2626 
sqlite3_stmt
 * 
	`sqlite3_next_stmt
(
sqlite3
 *
pDb
, sqlite3_stmt *
pStmt
);

2628 void * 
	`sqlite3_commit_hook
(
sqlite3
*, int(*)(void*), void*);

2629 void * 
	`sqlite3_rollback_hook
(
sqlite3
*, void(*)(void *), void*);

2631 void * 
	`sqlite3_update_hook
(

2632 
sqlite3
*,

2633 void(*)(void *,int ,char const *,char const *,
sqlite3_int64
),

2637 int 
	`sqlite3_enable_shared_cache
(int);

2639 int 
	`sqlite3_release_memory
(int);

2641 int 
	`sqlite3_db_release_memory
(
sqlite3
*);

2643 
sqlite3_int64
 
	`sqlite3_soft_heap_limit64
(sqlite3_int64 
N
);

2645 void 
	`sqlite3_soft_heap_limit
(int 
N
);

2647 int 
	`sqlite3_table_column_metadata
(

2648 
sqlite3
 *
db
,

2649 const char *
zDbName
,

2650 const char *
zTableName
,

2651 const char *
zColumnName
,

2652 char const **
pzDataType
,

2653 char const **
pzCollSeq
,

2654 int *
pNotNull
,

2655 int *
pPrimaryKey
,

2656 int *
pAutoinc


2659 int 
	`sqlite3_load_extension
(

2660 
sqlite3
 *
db
,

2661 const char *
zFile
,

2662 const char *
zProc
,

2663 char **
pzErrMsg


2666 int 
	`sqlite3_enable_load_extension
(
sqlite3
 *
db
, int 
onoff
);

2668 int 
	`sqlite3_auto_extension
(void (*
xEntryPoint
)(void));

2670 int 
	`sqlite3_cancel_auto_extension
(void (*
xEntryPoint
)(void));

2678 void 
	`sqlite3_reset_auto_extension
(void);

2680 typedef struct 
sqlite3_vtab
 
	tsqlite3_vtab
;

2681 typedef struct 
sqlite3_index_info
 
	tsqlite3_index_info
;

2682 typedef struct 
sqlite3_vtab_cursor
 
	tsqlite3_vtab_cursor
;

2683 typedef struct 
sqlite3_module
 
	tsqlite3_module
;

2685 struct 
	ssqlite3_module
 {

2686 int 
iVersion
;

2687 int (*
xCreate
)(
sqlite3
*, void *
pAux
,

2688 int 
argc
, const char *const*
argv
,

2689 
sqlite3_vtab
 **
ppVTab
, char**);

2690 int (*
xConnect
)(
sqlite3
*, void *
pAux
,

2691 int 
argc
, const char *const*
argv
,

2692 
sqlite3_vtab
 **
ppVTab
, char**);

2693 int (*
xBestIndex
)(
sqlite3_vtab
 *
pVTab
, 
sqlite3_index_info
*);

2694 int (*
xDisconnect
)(
sqlite3_vtab
 *
pVTab
);

2695 int (*
xDestroy
)(
sqlite3_vtab
 *
pVTab
);

2696 int (*
xOpen
)(
sqlite3_vtab
 *
pVTab
, 
sqlite3_vtab_cursor
 **
ppCursor
);

2697 int (*
xClose
)(
sqlite3_vtab_cursor
*);

2698 int (*
xFilter
)(
sqlite3_vtab_cursor
*, int 
idxNum
, const char *
idxStr
,

2699 int 
argc
, 
sqlite3_value
 **
argv
);

2700 int (*
xNext
)(
sqlite3_vtab_cursor
*);

2701 int (*
xEof
)(
sqlite3_vtab_cursor
*);

2702 int (*
xColumn
)(
sqlite3_vtab_cursor
*, 
sqlite3_context
*, int);

2703 int (*
xRowid
)(
sqlite3_vtab_cursor
*, 
sqlite3_int64
 *
pRowid
);

2704 int (*
xUpdate
)(
sqlite3_vtab
 *, int, 
sqlite3_value
 **, 
sqlite3_int64
 *);

2705 int (*
xBegin
)(
sqlite3_vtab
 *
pVTab
);

2706 int (*
xSync
)(
sqlite3_vtab
 *
pVTab
);

2707 int (*
xCommit
)(
sqlite3_vtab
 *
pVTab
);

2708 int (*
xRollback
)(
sqlite3_vtab
 *
pVTab
);

2709 int (*
xFindFunction
)(
sqlite3_vtab
 *
pVtab
, int 
nArg
, const char *
zName
,

2710 void (**
pxFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

2711 void **
ppArg
);

2712 int (*
xRename
)(
sqlite3_vtab
 *
pVtab
, const char *
zNew
);

2715 int (*
xSavepoint
)(
sqlite3_vtab
 *
pVTab
, int);

2716 int (*
xRelease
)(
sqlite3_vtab
 *
pVTab
, int);

2717 int (*
xRollbackTo
)(
sqlite3_vtab
 *
pVTab
, int);

2720 struct 
	ssqlite3_index_info
 {

2722 int 
nConstraint
;

2723 struct 
	ssqlite3_index_constraint
 {

2724 int 
iColumn
;

2725 unsigned char 
op
;

2726 unsigned char 
usable
;

2727 int 
iTermOffset
;

2728 } *
aConstraint
;

2729 int 
nOrderBy
;

2730 struct 
	ssqlite3_index_orderby
 {

2731 int 
iColumn
;

2732 unsigned char 
desc
;

2733 } *
aOrderBy
;

2735 struct 
	ssqlite3_index_constraint_usage
 {

2736 int 
argvIndex
;

2737 unsigned char 
omit
;

2738 } *
aConstraintUsage
;

2739 int 
idxNum
;

2740 char *
idxStr
;

2741 int 
needToFreeIdxStr
;

2742 int 
orderByConsumed
;

2743 double 
estimatedCost
;

2745 
sqlite3_int64
 
estimatedRows
;

2747 int 
idxFlags
;

2749 
sqlite3_uint64
 
colUsed
;

2752 int 
	`sqlite3_create_module
(

2753 
sqlite3
 *
db
,

2754 const char *
zName
,

2755 const 
sqlite3_module
 *
p
,

2756 void *
pClientData


2758 int 
	`sqlite3_create_module_v2
(

2759 
sqlite3
 *
db
,

2760 const char *
zName
,

2761 const 
sqlite3_module
 *
p
,

2762 void *
pClientData
,

2763 void(*
xDestroy
)(void*)

2766 struct 
	ssqlite3_vtab
 {

2767 const 
sqlite3_module
 *
pModule
;

2768 int 
nRef
;

2769 char *
zErrMsg
;

2773 struct 
	ssqlite3_vtab_cursor
 {

2774 
sqlite3_vtab
 *
pVtab
;

2778 int 
	`sqlite3_declare_vtab
(
sqlite3
*, const char *
zSQL
);

2780 int 
	`sqlite3_overload_function
(
sqlite3
*, const char *
zFuncName
, int 
nArg
);

2782 typedef struct 
sqlite3_blob
 
	tsqlite3_blob
;

2784 int 
	`sqlite3_blob_open
(

2785 
sqlite3
*,

2786 const char *
zDb
,

2787 const char *
zTable
,

2788 const char *
zColumn
,

2789 
sqlite3_int64
 
iRow
,

2790 int 
flags
,

2791 
sqlite3_blob
 **
ppBlob


2794 int 
	`sqlite3_blob_reopen
(
sqlite3_blob
 *, 
sqlite3_int64
);

2796 int 
	`sqlite3_blob_close
(
sqlite3_blob
 *);

2798 int 
	`sqlite3_blob_bytes
(
sqlite3_blob
 *);

2800 int 
	`sqlite3_blob_read
(
sqlite3_blob
 *, void *
Z
, int 
N
, int 
iOffset
);

2802 int 
	`sqlite3_blob_write
(
sqlite3_blob
 *, const void *
z
, int 
n
, int 
iOffset
);

2804 
sqlite3_vfs
 * 
	`sqlite3_vfs_find
(const char *
zVfsName
);

2805 int 
	`sqlite3_vfs_register
(
sqlite3_vfs
*, int 
makeDflt
);

2806 int 
	`sqlite3_vfs_unregister
(
sqlite3_vfs
*);

2808 
sqlite3_mutex
 * 
	`sqlite3_mutex_alloc
(int);

2809 void 
	`sqlite3_mutex_free
(
sqlite3_mutex
*);

2810 void 
	`sqlite3_mutex_enter
(
sqlite3_mutex
*);

2811 int 
	`sqlite3_mutex_try
(
sqlite3_mutex
*);

2812 void 
	`sqlite3_mutex_leave
(
sqlite3_mutex
*);

2814 typedef struct 
sqlite3_mutex_methods
 
	tsqlite3_mutex_methods
;

2815 struct 
	ssqlite3_mutex_methods
 {

2816 int (*
xMutexInit
)(void);

2817 int (*
xMutexEnd
)(void);

2818 
sqlite3_mutex
 *(*
xMutexAlloc
)(int);

2819 void (*
xMutexFree
)(
sqlite3_mutex
 *);

2820 void (*
xMutexEnter
)(
sqlite3_mutex
 *);

2821 int (*
xMutexTry
)(
sqlite3_mutex
 *);

2822 void (*
xMutexLeave
)(
sqlite3_mutex
 *);

2823 int (*
xMutexHeld
)(
sqlite3_mutex
 *);

2824 int (*
xMutexNotheld
)(
sqlite3_mutex
 *);

2827 int 
	`sqlite3_mutex_held
(
sqlite3_mutex
*);

2828 int 
	`sqlite3_mutex_notheld
(
sqlite3_mutex
*);

2830 
sqlite3_mutex
 * 
	`sqlite3_db_mutex
(
sqlite3
*);

2832 int 
	`sqlite3_file_control
(
sqlite3
*, const char *
zDbName
, int 
op
, void*);

2834 int 
	`sqlite3_test_control
(int 
op
, ...);

2836 int 
	`sqlite3_status
(int 
op
, int *
pCurrent
, int *
pHighwater
, int 
resetFlag
);

2837 int 
	`sqlite3_status64
(

2838 int 
op
,

2839 
sqlite3_int64
 *
pCurrent
,

2840 
sqlite3_int64
 *
pHighwater
,

2841 int 
resetFlag


2844 int 
	`sqlite3_db_status
(
sqlite3
*, int 
op
, int *
pCur
, int *
pHiwtr
, int 
resetFlg
);

2846 int 
	`sqlite3_stmt_status
(
sqlite3_stmt
*, int 
op
,int 
resetFlg
);

2848 typedef struct 
sqlite3_pcache
 
	tsqlite3_pcache
;

2850 typedef struct 
sqlite3_pcache_page
 
	tsqlite3_pcache_page
;

2851 struct 
	ssqlite3_pcache_page
 {

2852 void *
pBuf
;

2853 void *
pExtra
;

2856 typedef struct 
sqlite3_pcache_methods2
 
	tsqlite3_pcache_methods2
;

2857 struct 
	ssqlite3_pcache_methods2
 {

2858 int 
iVersion
;

2859 void *
pArg
;

2860 int (*
xInit
)(void*);

2861 void (*
xShutdown
)(void*);

2862 
sqlite3_pcache
 *(*
xCreate
)(int 
szPage
, int 
szExtra
, int 
bPurgeable
);

2863 void (*
xCachesize
)(
sqlite3_pcache
*, int 
nCachesize
);

2864 int (*
xPagecount
)(
sqlite3_pcache
*);

2865 
sqlite3_pcache_page
 *(*
xFetch
)(
sqlite3_pcache
*, unsigned 
key
, int 
createFlag
);

2866 void (*
xUnpin
)(
sqlite3_pcache
*, 
sqlite3_pcache_page
*, int 
discard
);

2867 void (*
xRekey
)(
sqlite3_pcache
*, 
sqlite3_pcache_page
*,

2868 unsigned 
oldKey
, unsigned 
newKey
);

2869 void (*
xTruncate
)(
sqlite3_pcache
*, unsigned 
iLimit
);

2870 void (*
xDestroy
)(
sqlite3_pcache
*);

2871 void (*
xShrink
)(
sqlite3_pcache
*);

2879 typedef struct 
sqlite3_pcache_methods
 
	tsqlite3_pcache_methods
;

2880 struct 
	ssqlite3_pcache_methods
 {

2881 void *
pArg
;

2882 int (*
xInit
)(void*);

2883 void (*
xShutdown
)(void*);

2884 
sqlite3_pcache
 *(*
xCreate
)(int 
szPage
, int 
bPurgeable
);

2885 void (*
xCachesize
)(
sqlite3_pcache
*, int 
nCachesize
);

2886 int (*
xPagecount
)(
sqlite3_pcache
*);

2887 void *(*
xFetch
)(
sqlite3_pcache
*, unsigned 
key
, int 
createFlag
);

2888 void (*
xUnpin
)(
sqlite3_pcache
*, void*, int 
discard
);

2889 void (*
xRekey
)(
sqlite3_pcache
*, void*, unsigned 
oldKey
, unsigned 
newKey
);

2890 void (*
xTruncate
)(
sqlite3_pcache
*, unsigned 
iLimit
);

2891 void (*
xDestroy
)(
sqlite3_pcache
*);

2894 typedef struct 
sqlite3_backup
 
	tsqlite3_backup
;

2896 
sqlite3_backup
 * 
	`sqlite3_backup_init
(

2897 
sqlite3
 *
pDest
,

2898 const char *
zDestName
,

2899 
sqlite3
 *
pSource
,

2900 const char *
zSourceName


2902 int 
	`sqlite3_backup_step
(
sqlite3_backup
 *
p
, int 
nPage
);

2903 int 
	`sqlite3_backup_finish
(
sqlite3_backup
 *
p
);

2904 int 
	`sqlite3_backup_remaining
(
sqlite3_backup
 *
p
);

2905 int 
	`sqlite3_backup_pagecount
(
sqlite3_backup
 *
p
);

2907 int 
	`sqlite3_unlock_notify
(

2908 
sqlite3
 *
pBlocked
,

2909 void (*
xNotify
)(void **
apArg
, int 
nArg
),

2910 void *
pNotifyArg


2913 int 
	`sqlite3_stricmp
(const char *, const char *);

2914 int 
	`sqlite3_strnicmp
(const char *, const char *, int);

2916 int 
	`sqlite3_strglob
(const char *
zGlob
, const char *
zStr
);

2918 int 
	`sqlite3_strlike
(const char *
zGlob
, const char *
zStr
, unsigned int 
cEsc
);

2920 void 
	`sqlite3_log
(int 
iErrCode
, const char *
zFormat
, ...);

2922 void * 
	`sqlite3_wal_hook
(

2923 
sqlite3
*,

2924 int(*)(void *,
sqlite3
*,const char*,int),

2928 int 
	`sqlite3_wal_autocheckpoint
(
sqlite3
 *
db
, int 
N
);

2930 int 
	`sqlite3_wal_checkpoint
(
sqlite3
 *
db
, const char *
zDb
);

2932 int 
	`sqlite3_wal_checkpoint_v2
(

2933 
sqlite3
 *
db
,

2934 const char *
zDb
,

2935 int 
eMode
,

2936 int *
pnLog
,

2937 int *
pnCkpt


2940 int 
	`sqlite3_vtab_config
(
sqlite3
*, int 
op
, ...);

2942 int 
	`sqlite3_vtab_on_conflict
(
sqlite3
 *);

2944 int 
	`sqlite3_stmt_scanstatus
(

2945 
sqlite3_stmt
 *
pStmt
,

2946 int 
idx
,

2947 int 
iScanStatusOp
,

2948 void *
pOut


2951 void 
	`sqlite3_stmt_scanstatus_reset
(
sqlite3_stmt
*);

2953 int 
	`sqlite3_db_cacheflush
(
sqlite3
*);

2955 int 
	`sqlite3_system_errno
(
sqlite3
*);

2957 typedef struct 
sqlite3_snapshot
 
	tsqlite3_snapshot
;

2959 int 
	`sqlite3_snapshot_get
(

2960 
sqlite3
 *
db
,

2961 const char *
zSchema
,

2962 
sqlite3_snapshot
 **
ppSnapshot


2965 int 
	`sqlite3_snapshot_open
(

2966 
sqlite3
 *
db
,

2967 const char *
zSchema
,

2968 
sqlite3_snapshot
 *
pSnapshot


2971 void 
	`sqlite3_snapshot_free
(
sqlite3_snapshot
*);

2973 typedef struct 
sqlite3_rtree_geometry
 
	tsqlite3_rtree_geometry
;

2974 typedef struct 
sqlite3_rtree_query_info
 
	tsqlite3_rtree_query_info
;

2982 typedef double 
	tsqlite3_rtree_dbl
;

2984 int 
	`sqlite3_rtree_geometry_callback
(

2985 
sqlite3
 *
db
,

2986 const char *
zGeom
,

2987 int (*
xGeom
)(
sqlite3_rtree_geometry
*, int, 
sqlite3_rtree_dbl
*,int*),

2988 void *
pContext


2996 struct 
	ssqlite3_rtree_geometry
 {

2997 void *
pContext
;

2998 int 
nParam
;

2999 
sqlite3_rtree_dbl
 *
aParam
;

3000 void *
pUser
;

3001 void (*
xDelUser
)(void *);

3010 int 
	`sqlite3_rtree_query_callback
(

3011 
sqlite3
 *
db
,

3012 const char *
zQueryFunc
,

3013 int (*
xQueryFunc
)(
sqlite3_rtree_query_info
*),

3014 void *
pContext
,

3015 void (*
xDestructor
)(void*)

3018 struct 
	ssqlite3_rtree_query_info
 {

3019 void *
pContext
;

3020 int 
nParam
;

3021 
sqlite3_rtree_dbl
 *
aParam
;

3022 void *
pUser
;

3023 void (*
xDelUser
)(void*);

3024 
sqlite3_rtree_dbl
 *
aCoord
;

3025 unsigned int *
anQueue
;

3026 int 
nCoord
;

3027 int 
iLevel
;

3028 int 
mxLevel
;

3029 
sqlite3_int64
 
iRowid
;

3030 
sqlite3_rtree_dbl
 
rParentScore
;

3031 int 
eParentWithin
;

3032 int 
eWithin
;

3033 
sqlite3_rtree_dbl
 
rScore
;

3035 
sqlite3_value
 **
apSqlParam
;

3038 typedef struct 
Fts5ExtensionApi
 
	tFts5ExtensionApi
;

3039 typedef struct 
Fts5Context
 
	tFts5Context
;

3040 typedef struct 
Fts5PhraseIter
 
	tFts5PhraseIter
;

3042 typedef void (*
	tfts5_extension_function
)(

3043 const 
	tFts5ExtensionApi
 *
	tpApi
,

3044 
	tFts5Context
 *
	tpFts
,

3045 
	tsqlite3_context
 *
	tpCtx
,

3046 int 
	tnVal
,

3047 
	tsqlite3_value
 **
	tapVal


3050 struct 
	sFts5PhraseIter
 {

3051 const unsigned char *
a
;

3052 const unsigned char *
b
;

3055 struct 
	sFts5ExtensionApi
 {

3056 int 
iVersion
;

3058 void *(*
xUserData
)(
Fts5Context
*);

3060 int (*
xColumnCount
)(
Fts5Context
*);

3061 int (*
xRowCount
)(
Fts5Context
*, 
sqlite3_int64
 *
pnRow
);

3062 int (*
xColumnTotalSize
)(
Fts5Context
*, int 
iCol
, 
sqlite3_int64
 *
pnToken
);

3064 int (*
xTokenize
)(
Fts5Context
*,

3065 const char *
pText
, int 
nText
,

3066 void *
pCtx
,

3067 int (*
xToken
)(void*, int, const char*, int, int, int)

3070 int (*
xPhraseCount
)(
Fts5Context
*);

3071 int (*
xPhraseSize
)(
Fts5Context
*, int 
iPhrase
);

3073 int (*
xInstCount
)(
Fts5Context
*, int *
pnInst
);

3074 int (*
xInst
)(
Fts5Context
*, int 
iIdx
, int *
piPhrase
, int *
piCol
, int *
piOff
);

3076 
	`sqlite3_int64
 (*
xRowid
)(
Fts5Context
*);

3077 int (*
xColumnText
)(
Fts5Context
*, int 
iCol
, const char **
pz
, int *
pn
);

3078 int (*
xColumnSize
)(
Fts5Context
*, int 
iCol
, int *
pnToken
);

3080 int (*
xQueryPhrase
)(
Fts5Context
*, int 
iPhrase
, void *
pUserData
,

3081 int(*)(const 
Fts5ExtensionApi
*,
Fts5Context
*,void*)

3083 int (*
xSetAuxdata
)(
Fts5Context
*, void *
pAux
, void(*
xDelete
)(void*));

3084 void *(*
xGetAuxdata
)(
Fts5Context
*, int 
bClear
);

3086 int (*
xPhraseFirst
)(
Fts5Context
*, int 
iPhrase
, 
Fts5PhraseIter
*, int*, int*);

3087 void (*
xPhraseNext
)(
Fts5Context
*, 
Fts5PhraseIter
*, int *
piCol
, int *
piOff
);

3089 int (*
xPhraseFirstColumn
)(
Fts5Context
*, int 
iPhrase
, 
Fts5PhraseIter
*, int*);

3090 void (*
xPhraseNextColumn
)(
Fts5Context
*, 
Fts5PhraseIter
*, int *
piCol
);

3093 typedef struct 
Fts5Tokenizer
 
	tFts5Tokenizer
;

3094 typedef struct 
fts5_tokenizer
 
	tfts5_tokenizer
;

3095 struct 
	sfts5_tokenizer
 {

3096 int (*
xCreate
)(void*, const char **
azArg
, int 
nArg
, 
Fts5Tokenizer
 **
ppOut
);

3097 void (*
xDelete
)(
Fts5Tokenizer
*);

3098 int (*
xTokenize
)(
Fts5Tokenizer
*,

3099 void *
pCtx
,

3100 int 
flags
,

3101 const char *
pText
, int 
nText
,

3102 int (*
xToken
)(

3103 void *
pCtx
,

3104 int 
tflags
,

3105 const char *
pToken
,

3106 int 
nToken
,

3107 int 
iStart
,

3108 int 
iEnd


3113 typedef struct 
fts5_api
 
	tfts5_api
;

3114 struct 
	sfts5_api
 {

3115 int 
iVersion
;

3118 int (*
xCreateTokenizer
)(

3119 
fts5_api
 *
pApi
,

3120 const char *
zName
,

3121 void *
pContext
,

3122 
fts5_tokenizer
 *
pTokenizer
,

3123 void (*
xDestroy
)(void*)

3127 int (*
xFindTokenizer
)(

3128 
fts5_api
 *
pApi
,

3129 const char *
zName
,

3130 void **
ppContext
,

3131 
fts5_tokenizer
 *
pTokenizer


3135 int (*
xCreateFunction
)(

3136 
fts5_api
 *
pApi
,

3137 const char *
zName
,

3138 void *
pContext
,

3139 
fts5_extension_function
 
xFunction
,

3140 void (*
xDestroy
)(void*)

3153 
_ISupper
 = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),

3154 
_ISlower
 = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),

3155 
_ISalpha
 = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),

3156 
_ISdigit
 = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),

3157 
_ISxdigit
 = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),

3158 
_ISspace
 = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),

3159 
_ISprint
 = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),

3160 
_ISgraph
 = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),

3161 
_ISblank
 = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),

3162 
_IScntrl
 = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),

3163 
_ISpunct
 = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),

3164 
_ISalnum
 = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))

3167 extern const unsigned short int **
	$__ctype_b_loc
 (void)

3168 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

3169 extern const 
__int32_t
 **
	$__ctype_tolower_loc
 (void)

3170 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

3171 extern const 
__int32_t
 **
	$__ctype_toupper_loc
 (void)

3172 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

3180 extern int 
	$isalnum
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3181 extern int 
	$isalpha
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3182 extern int 
	$iscntrl
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3183 extern int 
	$isdigit
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3184 extern int 
	$islower
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3185 extern int 
	$isgraph
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3186 extern int 
	$isprint
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3187 extern int 
	$ispunct
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3188 extern int 
	$isspace
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3189 extern int 
	$isupper
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3190 extern int 
	$isxdigit
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3194 extern int 
	$tolower
 (int 
__c
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3197 extern int 
	$toupper
 (int 
__c
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3206 extern int 
	$isblank
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3210 extern int 
	$isascii
 (int 
__c
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3214 extern int 
	$toascii
 (int 
__c
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3218 extern int 
	$_toupper
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3219 extern int 
	$_tolower
 (int) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3221 extern int 
	$isalnum_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3222 extern int 
	$isalpha_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3223 extern int 
	$iscntrl_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3224 extern int 
	$isdigit_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3225 extern int 
	$islower_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3226 extern int 
	$isgraph_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3227 extern int 
	$isprint_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3228 extern int 
	$ispunct_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3229 extern int 
	$isspace_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3230 extern int 
	$isupper_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3231 extern int 
	$isxdigit_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3233 extern int 
	$isblank_l
 (int, 
__locale_t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3237 extern int 
	$__tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3238 extern int 
	$tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3241 extern int 
	$__toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3242 extern int 
	$toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3255 extern int 
	`__sigismember
 (const 
__sigset_t
 *, int);

3256 extern int 
	`__sigaddset
 (
__sigset_t
 *, int);

3257 extern int 
	`__sigdelset
 (
__sigset_t
 *, int);

3266 typedef 
__sig_atomic_t
 
	tsig_atomic_t
;

3289 typedef union 
	usigval


3291 int 
sival_int
;

3292 void *
sival_ptr
;

3293 } 
	tsigval_t
;

3295 typedef 
__clock_t
 
	t__sigchld_clock_t
;

3301 int 
si_signo
;

3302 int 
si_errno
;

3304 int 
si_code
;

3308 int 
_pad
[((128 / sizeof (int)) - 4)];

3313 
__pid_t
 
si_pid
;

3314 
__uid_t
 
si_uid
;

3315 } 
_kill
;

3320 int 
si_tid
;

3321 int 
si_overrun
;

3322 
sigval_t
 
si_sigval
;

3323 } 
_timer
;

3328 
__pid_t
 
si_pid
;

3329 
__uid_t
 
si_uid
;

3330 
sigval_t
 
si_sigval
;

3331 } 
_rt
;

3336 
__pid_t
 
si_pid
;

3337 
__uid_t
 
si_uid
;

3338 int 
si_status
;

3339 
__sigchld_clock_t
 
si_utime
;

3340 
__sigchld_clock_t
 
si_stime
;

3341 } 
_sigchld
;

3346 void *
si_addr
;

3347 short int 
si_addr_lsb
;

3350 void *
_lower
;

3351 void *
_upper
;

3352 } 
si_addr_bnd
;

3353 } 
_sigfault
;

3358 long int 
si_band
;

3359 int 
si_fd
;

3360 } 
_sigpoll
;

3365 void *
_call_addr
;

3366 int 
_syscall
;

3367 unsigned int 
_arch
;

3368 } 
_sigsys
;

3369 } 
_sifields
;

3370 } 
	tsiginfo_t
 ;

3374 
SI_ASYNCNL
 = -60,

3376 
SI_TKILL
 = -6,

3378 
SI_SIGIO
,

3380 
SI_ASYNCIO
,

3382 
SI_MESGQ
,

3384 
SI_TIMER
,

3386 
SI_QUEUE
,

3388 
SI_USER
,

3390 
SI_KERNEL
 = 0x80

3399 
ILL_ILLOPC
 = 1,

3401 
ILL_ILLOPN
,

3403 
ILL_ILLADR
,

3405 
ILL_ILLTRP
,

3407 
ILL_PRVOPC
,

3409 
ILL_PRVREG
,

3411 
ILL_COPROC
,

3413 
ILL_BADSTK


3420 
FPE_INTDIV
 = 1,

3422 
FPE_INTOVF
,

3424 
FPE_FLTDIV
,

3426 
FPE_FLTOVF
,

3428 
FPE_FLTUND
,

3430 
FPE_FLTRES
,

3432 
FPE_FLTINV
,

3434 
FPE_FLTSUB


3441 
SEGV_MAPERR
 = 1,

3443 
SEGV_ACCERR


3450 
BUS_ADRALN
 = 1,

3452 
BUS_ADRERR
,

3454 
BUS_OBJERR
,

3456 
BUS_MCEERR_AR
,

3458 
BUS_MCEERR_AO


3464 
CLD_EXITED
 = 1,

3466 
CLD_KILLED
,

3468 
CLD_DUMPED
,

3470 
CLD_TRAPPED
,

3472 
CLD_STOPPED
,

3474 
CLD_CONTINUED


3481 
POLL_IN
 = 1,

3483 
POLL_OUT
,

3485 
POLL_MSG
,

3487 
POLL_ERR
,

3489 
POLL_PRI
,

3491 
POLL_HUP


3495 typedef struct 
	ssigevent


3497 
sigval_t
 
sigev_value
;

3498 int 
sigev_signo
;

3499 int 
sigev_notify
;

3503 int 
_pad
[((64 / sizeof (int)) - 4)];

3507 
__pid_t
 
_tid
;

3511 void (*
_function
) (
sigval_t
);

3512 
pthread_attr_t
 *
_attribute
;

3513 } 
_sigev_thread
;

3514 } 
_sigev_un
;

3515 } 
	tsigevent_t
;

3524 
SIGEV_SIGNAL
 = 0,

3526 
SIGEV_NONE
,

3528 
SIGEV_THREAD
,

3531 
SIGEV_THREAD_ID
 = 4

3539 typedef void (*
	t__sighandler_t
) (int);

3544 extern 
__sighandler_t
 
	$__sysv_signal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

3545 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3549 extern 
__sighandler_t
 
	$signal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

3550 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3554 extern int 
	$kill
 (
__pid_t
 
__pid
, int 
__sig
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3561 extern int 
	$killpg
 (
__pid_t
 
__pgrp
, int 
__sig
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3566 extern int 
	$raise
 (int 
__sig
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3571 extern 
__sighandler_t
 
	$ssignal
 (int 
__sig
, 
__sighandler_t
 
__handler
)

3572 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3573 extern int 
	$gsignal
 (int 
__sig
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3578 extern void 
	`psignal
 (int 
__sig
, const char *
__s
);

3581 extern void 
	`psiginfo
 (const 
siginfo_t
 *
__pinfo
, const char *
__s
);

3583 extern int 
	$sigblock
 (int 
__mask
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__deprecated__
));

3586 extern int 
	$sigsetmask
 (int 
__mask
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__deprecated__
));

3589 extern int 
	$siggetmask
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__deprecated__
));

3591 typedef 
__sighandler_t
 
	tsig_t
;

3597 extern int 
	$sigemptyset
 (
sigset_t
 *
__set
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3600 extern int 
	$sigfillset
 (
sigset_t
 *
__set
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3603 extern int 
	$sigaddset
 (
sigset_t
 *
__set
, int 
__signo
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3606 extern int 
	$sigdelset
 (
sigset_t
 *
__set
, int 
__signo
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3609 extern int 
	$sigismember
 (const 
sigset_t
 *
__set
, int 
__signo
)

3610 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3614 struct 
	ssigaction


3621 
__sighandler_t
 
sa_handler
;

3623 void (*
sa_sigaction
) (int, 
siginfo_t
 *, void *);

3625 
__sigaction_handler
;

3633 
__sigset_t
 
sa_mask
;

3636 int 
sa_flags
;

3639 void (*
sa_restorer
) (void);

3644 extern int 
	$sigprocmask
 (int 
__how
, const 
sigset_t
 *
__restrict
 
__set
,

3645 
sigset_t
 *
__restrict
 
__oset
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3652 extern int 
	$sigsuspend
 (const 
sigset_t
 *
__set
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

3655 extern int 
	$sigaction
 (int 
__sig
, const struct 
sigaction
 *
__restrict
 
__act
,

3656 struct 
sigaction
 *
__restrict
 
__oact
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3659 extern int 
	$sigpending
 (
sigset_t
 *
__set
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3666 extern int 
	$sigwait
 (const 
sigset_t
 *
__restrict
 
__set
, int *__restrict 
__sig
)

3667 
	`__attribute__
 ((
	`__nonnull__
 (1, 2)));

3674 extern int 
	$sigwaitinfo
 (const 
sigset_t
 *
__restrict
 
__set
,

3675 
siginfo_t
 *
__restrict
 
__info
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

3682 extern int 
	$sigtimedwait
 (const 
sigset_t
 *
__restrict
 
__set
,

3683 
siginfo_t
 *
__restrict
 
__info
,

3684 const struct 
timespec
 *
__restrict
 
__timeout
)

3685 
	`__attribute__
 ((
	`__nonnull__
 (1)));

3689 extern int 
	$sigqueue
 (
__pid_t
 
__pid
, int 
__sig
, const union 
sigval
 
__val
)

3690 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3692 extern const char *const 
_sys_siglist
[65];

3693 extern const char *const 
sys_siglist
[65];

3699 struct 
	s_fpx_sw_bytes


3701 
__uint32_t
 
magic1
;

3702 
__uint32_t
 
extended_size
;

3703 
__uint64_t
 
xstate_bv
;

3704 
__uint32_t
 
xstate_size
;

3705 
__uint32_t
 
padding
[7];

3708 struct 
	s_fpreg


3710 unsigned short 
significand
[4];

3711 unsigned short 
exponent
;

3714 struct 
	s_fpxreg


3716 unsigned short 
significand
[4];

3717 unsigned short 
exponent
;

3718 unsigned short 
padding
[3];

3721 struct 
	s_xmmreg


3723 
__uint32_t
 
element
[4];

3726 struct 
	s_fpstate


3729 
__uint16_t
 
cwd
;

3730 
__uint16_t
 
swd
;

3731 
__uint16_t
 
ftw
;

3732 
__uint16_t
 
fop
;

3733 
__uint64_t
 
rip
;

3734 
__uint64_t
 
rdp
;

3735 
__uint32_t
 
mxcsr
;

3736 
__uint32_t
 
mxcr_mask
;

3737 struct 
_fpxreg
 
_st
[8];

3738 struct 
_xmmreg
 
_xmm
[16];

3739 
__uint32_t
 
padding
[24];

3742 struct 
	ssigcontext


3744 
__uint64_t
 
r8
;

3745 
__uint64_t
 
r9
;

3746 
__uint64_t
 
r10
;

3747 
__uint64_t
 
r11
;

3748 
__uint64_t
 
r12
;

3749 
__uint64_t
 
r13
;

3750 
__uint64_t
 
r14
;

3751 
__uint64_t
 
r15
;

3752 
__uint64_t
 
rdi
;

3753 
__uint64_t
 
rsi
;

3754 
__uint64_t
 
rbp
;

3755 
__uint64_t
 
rbx
;

3756 
__uint64_t
 
rdx
;

3757 
__uint64_t
 
rax
;

3758 
__uint64_t
 
rcx
;

3759 
__uint64_t
 
rsp
;

3760 
__uint64_t
 
rip
;

3761 
__uint64_t
 
eflags
;

3762 unsigned short 
cs
;

3763 unsigned short 
gs
;

3764 unsigned short 
fs
;

3765 unsigned short 
__pad0
;

3766 
__uint64_t
 
err
;

3767 
__uint64_t
 
trapno
;

3768 
__uint64_t
 
oldmask
;

3769 
__uint64_t
 
cr2
;

3770 
__extension__
 union

3772 struct 
_fpstate
 * 
fpstate
;

3773 
__uint64_t
 
__fpstate_word
;

3775 
__uint64_t
 
__reserved1
 [8];

3780 struct 
	s_xsave_hdr


3782 
__uint64_t
 
xstate_bv
;

3783 
__uint64_t
 
reserved1
[2];

3784 
__uint64_t
 
reserved2
[5];

3787 struct 
	s_ymmh_state


3789 
__uint32_t
 
ymmh_space
[64];

3792 struct 
	s_xstate


3794 struct 
_fpstate
 
fpstate
;

3795 struct 
_xsave_hdr
 
xstate_hdr
;

3796 struct 
_ymmh_state
 
ymmh
;

3801 extern int 
	$sigreturn
 (struct 
sigcontext
 *
__scp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3814 extern int 
	$siginterrupt
 (int 
__sig
, int 
__interrupt
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3818 struct 
	ssigstack


3820 void *
ss_sp
;

3821 int 
ss_onstack
;

3828 
SS_ONSTACK
 = 1,

3830 
SS_DISABLE


3834 typedef struct 
	ssigaltstack


3836 void *
ss_sp
;

3837 int 
ss_flags
;

3838 
size_t
 
ss_size
;

3839 } 
	tstack_t
;

3848 
__extension__
 typedef long long int 
	tgreg_t
;

3854 typedef 
greg_t
 
	tgregset_t
[23];

3856 struct 
	s_libc_fpxreg


3858 unsigned short int 
significand
[4];

3859 unsigned short int 
exponent
;

3860 unsigned short int 
padding
[3];

3863 struct 
	s_libc_xmmreg


3865 
__uint32_t
 
element
[4];

3868 struct 
	s_libc_fpstate


3871 
__uint16_t
 
cwd
;

3872 
__uint16_t
 
swd
;

3873 
__uint16_t
 
ftw
;

3874 
__uint16_t
 
fop
;

3875 
__uint64_t
 
rip
;

3876 
__uint64_t
 
rdp
;

3877 
__uint32_t
 
mxcsr
;

3878 
__uint32_t
 
mxcr_mask
;

3879 struct 
_libc_fpxreg
 
_st
[8];

3880 struct 
_libc_xmmreg
 
_xmm
[16];

3881 
__uint32_t
 
padding
[24];

3885 typedef struct 
_libc_fpstate
 *
	tfpregset_t
;

3890 
gregset_t
 
gregs
;

3892 
fpregset_t
 
fpregs
;

3893 
__extension__
 unsigned long long 
__reserved1
 [8];

3894 } 
	tmcontext_t
;

3897 typedef struct 
	sucontext


3899 unsigned long int 
uc_flags
;

3900 struct 
ucontext
 *
uc_link
;

3901 
stack_t
 
uc_stack
;

3902 
mcontext_t
 
uc_mcontext
;

3903 
__sigset_t
 
uc_sigmask
;

3904 struct 
_libc_fpstate
 
__fpregs_mem
;

3905 } 
	tucontext_t
;

3912 extern int 
	$sigstack
 (struct 
sigstack
 *
__ss
, struct sigstack *
__oss
)

3913 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__deprecated__
));

3917 extern int 
	$sigaltstack
 (const struct 
sigaltstack
 *
__restrict
 
__ss
,

3918 struct 
sigaltstack
 *
__restrict
 
__oss
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3922 extern int 
	$pthread_sigmask
 (int 
__how
,

3923 const 
__sigset_t
 *
__restrict
 
__newmask
,

3924 
__sigset_t
 *
__restrict
 
__oldmask
)
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3927 extern int 
	$pthread_kill
 (
pthread_t
 
__threadid
, int 
__signo
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3935 extern int 
	$__libc_current_sigrtmin
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3937 extern int 
	$__libc_current_sigrtmax
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3954 struct 
	spasswd


3956 char *
pw_name
;

3957 char *
pw_passwd
;

3958 
__uid_t
 
pw_uid
;

3959 
__gid_t
 
pw_gid
;

3960 char *
pw_gecos
;

3961 char *
pw_dir
;

3962 char *
pw_shell
;

3965 extern void 
	`setpwent
 (void);

3971 extern void 
	`endpwent
 (void);

3977 extern struct 
passwd
 *
	`getpwent
 (void);

3979 extern struct 
passwd
 *
	$fgetpwent
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

3987 extern int 
	`putpwent
 (const struct 
passwd
 *
__restrict
 
__p
,

3988 
FILE
 *
__restrict
 
__f
);

3995 extern struct 
passwd
 *
	`getpwuid
 (
__uid_t
 
__uid
);

4001 extern struct 
passwd
 *
	$getpwnam
 (const char *
__name
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

4003 extern int 
	$getpwent_r
 (struct 
passwd
 *
__restrict
 
__resultbuf
,

4004 char *
__restrict
 
__buffer
, 
size_t
 
__buflen
,

4005 struct 
passwd
 **
__restrict
 
__result
)

4006 
	`__attribute__
 ((
	`__nonnull__
 (1, 2, 4)));

4009 extern int 
	$getpwuid_r
 (
__uid_t
 
__uid
,

4010 struct 
passwd
 *
__restrict
 
__resultbuf
,

4011 char *
__restrict
 
__buffer
, 
size_t
 
__buflen
,

4012 struct 
passwd
 **
__restrict
 
__result
)

4013 
	`__attribute__
 ((
	`__nonnull__
 (2, 3, 5)));

4015 extern int 
	$getpwnam_r
 (const char *
__restrict
 
__name
,

4016 struct 
passwd
 *
__restrict
 
__resultbuf
,

4017 char *
__restrict
 
__buffer
, 
size_t
 
__buflen
,

4018 struct 
passwd
 **
__restrict
 
__result
)

4019 
	`__attribute__
 ((
	`__nonnull__
 (1, 2, 3, 5)));

4021 extern int 
	$fgetpwent_r
 (
FILE
 *
__restrict
 
__stream
,

4022 struct 
passwd
 *
__restrict
 
__resultbuf
,

4023 char *
__restrict
 
__buffer
, 
size_t
 
__buflen
,

4024 struct 
passwd
 **
__restrict
 
__result
)

4025 
	`__attribute__
 ((
	`__nonnull__
 (1, 2, 3, 5)));

4048 typedef 
__useconds_t
 
	tuseconds_t
;

4050 typedef 
__intptr_t
 
	tintptr_t
;

4057 typedef 
__socklen_t
 
	tsocklen_t
;

4059 extern int 
	$access
 (const char *
__name
, int 
__type
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

4061 extern int 
	$faccessat
 (int 
__fd
, const char *
__file
, int 
__type
, int 
__flag
)

4062 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

4064 extern 
__off64_t
 
	$lseek
 (int 
__fd
, 
__off64_t
 
__offset
, int 
__whence
) 
	`__asm__
 ("" "lseek64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

4068 extern int 
	`close
 (int 
__fd
);

4075 extern 
ssize_t
 
	`read
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
) ;

4081 extern 
ssize_t
 
	`write
 (int 
__fd
, const void *
__buf
, 
size_t
 
__n
) ;

4083 extern 
ssize_t
 
	$pread
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
, 
__off64_t
 
__offset
) 
	`__asm__
 ("" "pread64")

4086 extern 
ssize_t
 
	$pwrite
 (int 
__fd
, const void *
__buf
, 
size_t
 
__nbytes
, 
__off64_t
 
__offset
) 
	`__asm__
 ("" "pwrite64")

4090 extern int 
	$pipe
 (int 
__pipedes
[2]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4092 extern unsigned int 
	$alarm
 (unsigned int 
__seconds
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4094 extern unsigned int 
	`sleep
 (unsigned int 
__seconds
);

4102 extern 
__useconds_t
 
	$ualarm
 (
__useconds_t
 
__value
, __useconds_t 
__interval
)

4103 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4110 extern int 
	`usleep
 (
__useconds_t
 
__useconds
);

4112 extern int 
	`pause
 (void);

4116 extern int 
	$chown
 (const char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

4117 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

4121 extern int 
	$fchown
 (int 
__fd
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4126 extern int 
	$lchown
 (const char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

4127 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

4134 extern int 
	$fchownat
 (int 
__fd
, const char *
__file
, 
__uid_t
 
__owner
,

4135 
__gid_t
 
__group
, int 
__flag
)

4136 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

4140 extern int 
	$chdir
 (const char *
__path
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

4144 extern int 
	$fchdir
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4146 extern char *
	$getcwd
 (char *
__buf
, 
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4148 extern char *
	$getwd
 (char *
__buf
)

4149 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	$__nonnull__
 (1))) 
	`__attribute__
 ((
__deprecated__
)) ;

4154 extern int 
	$dup
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4157 extern int 
	$dup2
 (int 
__fd
, int 
__fd2
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4159 extern char **
__environ
;

4167 extern int 
	$execve
 (const char *
__path
, char *const 
__argv
[],

4168 char *const 
__envp
[]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

4173 extern int 
	$fexecve
 (int 
__fd
, char *const 
__argv
[], char *const 
__envp
[])

4174 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

4179 extern int 
	$execv
 (const char *
__path
, char *const 
__argv
[])

4180 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

4184 extern int 
	$execle
 (const char *
__path
, const char *
__arg
, ...)

4185 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

4189 extern int 
	$execl
 (const char *
__path
, const char *
__arg
, ...)

4190 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

4194 extern int 
	$execvp
 (const char *
__file
, char *const 
__argv
[])

4195 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

4200 extern int 
	$execlp
 (const char *
__file
, const char *
__arg
, ...)

4201 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

4203 extern int 
	$nice
 (int 
__inc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4208 extern void 
	$_exit
 (int 
__status
) 
	`__attribute__
 ((
__noreturn__
));

4218 
_PC_LINK_MAX
,

4220 
_PC_MAX_CANON
,

4222 
_PC_MAX_INPUT
,

4224 
_PC_NAME_MAX
,

4226 
_PC_PATH_MAX
,

4228 
_PC_PIPE_BUF
,

4230 
_PC_CHOWN_RESTRICTED
,

4232 
_PC_NO_TRUNC
,

4234 
_PC_VDISABLE
,

4236 
_PC_SYNC_IO
,

4238 
_PC_ASYNC_IO
,

4240 
_PC_PRIO_IO
,

4242 
_PC_SOCK_MAXBUF
,

4244 
_PC_FILESIZEBITS
,

4246 
_PC_REC_INCR_XFER_SIZE
,

4248 
_PC_REC_MAX_XFER_SIZE
,

4250 
_PC_REC_MIN_XFER_SIZE
,

4252 
_PC_REC_XFER_ALIGN
,

4254 
_PC_ALLOC_SIZE_MIN
,

4256 
_PC_SYMLINK_MAX
,

4258 
_PC_2_SYMLINKS


4265 
_SC_ARG_MAX
,

4267 
_SC_CHILD_MAX
,

4269 
_SC_CLK_TCK
,

4271 
_SC_NGROUPS_MAX
,

4273 
_SC_OPEN_MAX
,

4275 
_SC_STREAM_MAX
,

4277 
_SC_TZNAME_MAX
,

4279 
_SC_JOB_CONTROL
,

4281 
_SC_SAVED_IDS
,

4283 
_SC_REALTIME_SIGNALS
,

4285 
_SC_PRIORITY_SCHEDULING
,

4287 
_SC_TIMERS
,

4289 
_SC_ASYNCHRONOUS_IO
,

4291 
_SC_PRIORITIZED_IO
,

4293 
_SC_SYNCHRONIZED_IO
,

4295 
_SC_FSYNC
,

4297 
_SC_MAPPED_FILES
,

4299 
_SC_MEMLOCK
,

4301 
_SC_MEMLOCK_RANGE
,

4303 
_SC_MEMORY_PROTECTION
,

4305 
_SC_MESSAGE_PASSING
,

4307 
_SC_SEMAPHORES
,

4309 
_SC_SHARED_MEMORY_OBJECTS
,

4311 
_SC_AIO_LISTIO_MAX
,

4313 
_SC_AIO_MAX
,

4315 
_SC_AIO_PRIO_DELTA_MAX
,

4317 
_SC_DELAYTIMER_MAX
,

4319 
_SC_MQ_OPEN_MAX
,

4321 
_SC_MQ_PRIO_MAX
,

4323 
_SC_VERSION
,

4325 
_SC_PAGESIZE
,

4328 
_SC_RTSIG_MAX
,

4330 
_SC_SEM_NSEMS_MAX
,

4332 
_SC_SEM_VALUE_MAX
,

4334 
_SC_SIGQUEUE_MAX
,

4336 
_SC_TIMER_MAX
,

4341 
_SC_BC_BASE_MAX
,

4343 
_SC_BC_DIM_MAX
,

4345 
_SC_BC_SCALE_MAX
,

4347 
_SC_BC_STRING_MAX
,

4349 
_SC_COLL_WEIGHTS_MAX
,

4351 
_SC_EQUIV_CLASS_MAX
,

4353 
_SC_EXPR_NEST_MAX
,

4355 
_SC_LINE_MAX
,

4357 
_SC_RE_DUP_MAX
,

4359 
_SC_CHARCLASS_NAME_MAX
,

4362 
_SC_2_VERSION
,

4364 
_SC_2_C_BIND
,

4366 
_SC_2_C_DEV
,

4368 
_SC_2_FORT_DEV
,

4370 
_SC_2_FORT_RUN
,

4372 
_SC_2_SW_DEV
,

4374 
_SC_2_LOCALEDEF
,

4377 
_SC_PII
,

4379 
_SC_PII_XTI
,

4381 
_SC_PII_SOCKET
,

4383 
_SC_PII_INTERNET
,

4385 
_SC_PII_OSI
,

4387 
_SC_POLL
,

4389 
_SC_SELECT
,

4391 
_SC_UIO_MAXIOV
,

4393 
_SC_IOV_MAX
 = 
_SC_UIO_MAXIOV
,

4395 
_SC_PII_INTERNET_STREAM
,

4397 
_SC_PII_INTERNET_DGRAM
,

4399 
_SC_PII_OSI_COTS
,

4401 
_SC_PII_OSI_CLTS
,

4403 
_SC_PII_OSI_M
,

4405 
_SC_T_IOV_MAX
,

4409 
_SC_THREADS
,

4411 
_SC_THREAD_SAFE_FUNCTIONS
,

4413 
_SC_GETGR_R_SIZE_MAX
,

4415 
_SC_GETPW_R_SIZE_MAX
,

4417 
_SC_LOGIN_NAME_MAX
,

4419 
_SC_TTY_NAME_MAX
,

4421 
_SC_THREAD_DESTRUCTOR_ITERATIONS
,

4423 
_SC_THREAD_KEYS_MAX
,

4425 
_SC_THREAD_STACK_MIN
,

4427 
_SC_THREAD_THREADS_MAX
,

4429 
_SC_THREAD_ATTR_STACKADDR
,

4431 
_SC_THREAD_ATTR_STACKSIZE
,

4433 
_SC_THREAD_PRIORITY_SCHEDULING
,

4435 
_SC_THREAD_PRIO_INHERIT
,

4437 
_SC_THREAD_PRIO_PROTECT
,

4439 
_SC_THREAD_PROCESS_SHARED
,

4442 
_SC_NPROCESSORS_CONF
,

4444 
_SC_NPROCESSORS_ONLN
,

4446 
_SC_PHYS_PAGES
,

4448 
_SC_AVPHYS_PAGES
,

4450 
_SC_ATEXIT_MAX
,

4452 
_SC_PASS_MAX
,

4455 
_SC_XOPEN_VERSION
,

4457 
_SC_XOPEN_XCU_VERSION
,

4459 
_SC_XOPEN_UNIX
,

4461 
_SC_XOPEN_CRYPT
,

4463 
_SC_XOPEN_ENH_I18N
,

4465 
_SC_XOPEN_SHM
,

4468 
_SC_2_CHAR_TERM
,

4470 
_SC_2_C_VERSION
,

4472 
_SC_2_UPE
,

4475 
_SC_XOPEN_XPG2
,

4477 
_SC_XOPEN_XPG3
,

4479 
_SC_XOPEN_XPG4
,

4482 
_SC_CHAR_BIT
,

4484 
_SC_CHAR_MAX
,

4486 
_SC_CHAR_MIN
,

4488 
_SC_INT_MAX
,

4490 
_SC_INT_MIN
,

4492 
_SC_LONG_BIT
,

4494 
_SC_WORD_BIT
,

4496 
_SC_MB_LEN_MAX
,

4498 
_SC_NZERO
,

4500 
_SC_SSIZE_MAX
,

4502 
_SC_SCHAR_MAX
,

4504 
_SC_SCHAR_MIN
,

4506 
_SC_SHRT_MAX
,

4508 
_SC_SHRT_MIN
,

4510 
_SC_UCHAR_MAX
,

4512 
_SC_UINT_MAX
,

4514 
_SC_ULONG_MAX
,

4516 
_SC_USHRT_MAX
,

4519 
_SC_NL_ARGMAX
,

4521 
_SC_NL_LANGMAX
,

4523 
_SC_NL_MSGMAX
,

4525 
_SC_NL_NMAX
,

4527 
_SC_NL_SETMAX
,

4529 
_SC_NL_TEXTMAX
,

4532 
_SC_XBS5_ILP32_OFF32
,

4534 
_SC_XBS5_ILP32_OFFBIG
,

4536 
_SC_XBS5_LP64_OFF64
,

4538 
_SC_XBS5_LPBIG_OFFBIG
,

4541 
_SC_XOPEN_LEGACY
,

4543 
_SC_XOPEN_REALTIME
,

4545 
_SC_XOPEN_REALTIME_THREADS
,

4548 
_SC_ADVISORY_INFO
,

4550 
_SC_BARRIERS
,

4552 
_SC_BASE
,

4554 
_SC_C_LANG_SUPPORT
,

4556 
_SC_C_LANG_SUPPORT_R
,

4558 
_SC_CLOCK_SELECTION
,

4560 
_SC_CPUTIME
,

4562 
_SC_THREAD_CPUTIME
,

4564 
_SC_DEVICE_IO
,

4566 
_SC_DEVICE_SPECIFIC
,

4568 
_SC_DEVICE_SPECIFIC_R
,

4570 
_SC_FD_MGMT
,

4572 
_SC_FIFO
,

4574 
_SC_PIPE
,

4576 
_SC_FILE_ATTRIBUTES
,

4578 
_SC_FILE_LOCKING
,

4580 
_SC_FILE_SYSTEM
,

4582 
_SC_MONOTONIC_CLOCK
,

4584 
_SC_MULTI_PROCESS
,

4586 
_SC_SINGLE_PROCESS
,

4588 
_SC_NETWORKING
,

4590 
_SC_READER_WRITER_LOCKS
,

4592 
_SC_SPIN_LOCKS
,

4594 
_SC_REGEXP
,

4596 
_SC_REGEX_VERSION
,

4598 
_SC_SHELL
,

4600 
_SC_SIGNALS
,

4602 
_SC_SPAWN
,

4604 
_SC_SPORADIC_SERVER
,

4606 
_SC_THREAD_SPORADIC_SERVER
,

4608 
_SC_SYSTEM_DATABASE
,

4610 
_SC_SYSTEM_DATABASE_R
,

4612 
_SC_TIMEOUTS
,

4614 
_SC_TYPED_MEMORY_OBJECTS
,

4616 
_SC_USER_GROUPS
,

4618 
_SC_USER_GROUPS_R
,

4620 
_SC_2_PBS
,

4622 
_SC_2_PBS_ACCOUNTING
,

4624 
_SC_2_PBS_LOCATE
,

4626 
_SC_2_PBS_MESSAGE
,

4628 
_SC_2_PBS_TRACK
,

4630 
_SC_SYMLOOP_MAX
,

4632 
_SC_STREAMS
,

4634 
_SC_2_PBS_CHECKPOINT
,

4637 
_SC_V6_ILP32_OFF32
,

4639 
_SC_V6_ILP32_OFFBIG
,

4641 
_SC_V6_LP64_OFF64
,

4643 
_SC_V6_LPBIG_OFFBIG
,

4646 
_SC_HOST_NAME_MAX
,

4648 
_SC_TRACE
,

4650 
_SC_TRACE_EVENT_FILTER
,

4652 
_SC_TRACE_INHERIT
,

4654 
_SC_TRACE_LOG
,

4657 
_SC_LEVEL1_ICACHE_SIZE
,

4659 
_SC_LEVEL1_ICACHE_ASSOC
,

4661 
_SC_LEVEL1_ICACHE_LINESIZE
,

4663 
_SC_LEVEL1_DCACHE_SIZE
,

4665 
_SC_LEVEL1_DCACHE_ASSOC
,

4667 
_SC_LEVEL1_DCACHE_LINESIZE
,

4669 
_SC_LEVEL2_CACHE_SIZE
,

4671 
_SC_LEVEL2_CACHE_ASSOC
,

4673 
_SC_LEVEL2_CACHE_LINESIZE
,

4675 
_SC_LEVEL3_CACHE_SIZE
,

4677 
_SC_LEVEL3_CACHE_ASSOC
,

4679 
_SC_LEVEL3_CACHE_LINESIZE
,

4681 
_SC_LEVEL4_CACHE_SIZE
,

4683 
_SC_LEVEL4_CACHE_ASSOC
,

4685 
_SC_LEVEL4_CACHE_LINESIZE
,

4689 
_SC_IPV6
 = 
_SC_LEVEL1_ICACHE_SIZE
 + 50,

4691 
_SC_RAW_SOCKETS
,

4694 
_SC_V7_ILP32_OFF32
,

4696 
_SC_V7_ILP32_OFFBIG
,

4698 
_SC_V7_LP64_OFF64
,

4700 
_SC_V7_LPBIG_OFFBIG
,

4703 
_SC_SS_REPL_MAX
,

4706 
_SC_TRACE_EVENT_NAME_MAX
,

4708 
_SC_TRACE_NAME_MAX
,

4710 
_SC_TRACE_SYS_MAX
,

4712 
_SC_TRACE_USER_EVENT_MAX
,

4715 
_SC_XOPEN_STREAMS
,

4718 
_SC_THREAD_ROBUST_PRIO_INHERIT
,

4720 
_SC_THREAD_ROBUST_PRIO_PROTECT


4727 
_CS_PATH
,

4730 
_CS_V6_WIDTH_RESTRICTED_ENVS
,

4734 
_CS_GNU_LIBC_VERSION
,

4736 
_CS_GNU_LIBPTHREAD_VERSION
,

4739 
_CS_V5_WIDTH_RESTRICTED_ENVS
,

4743 
_CS_V7_WIDTH_RESTRICTED_ENVS
,

4747 
_CS_LFS_CFLAGS
 = 1000,

4749 
_CS_LFS_LDFLAGS
,

4751 
_CS_LFS_LIBS
,

4753 
_CS_LFS_LINTFLAGS
,

4755 
_CS_LFS64_CFLAGS
,

4757 
_CS_LFS64_LDFLAGS
,

4759 
_CS_LFS64_LIBS
,

4761 
_CS_LFS64_LINTFLAGS
,

4764 
_CS_XBS5_ILP32_OFF32_CFLAGS
 = 1100,

4766 
_CS_XBS5_ILP32_OFF32_LDFLAGS
,

4768 
_CS_XBS5_ILP32_OFF32_LIBS
,

4770 
_CS_XBS5_ILP32_OFF32_LINTFLAGS
,

4772 
_CS_XBS5_ILP32_OFFBIG_CFLAGS
,

4774 
_CS_XBS5_ILP32_OFFBIG_LDFLAGS
,

4776 
_CS_XBS5_ILP32_OFFBIG_LIBS
,

4778 
_CS_XBS5_ILP32_OFFBIG_LINTFLAGS
,

4780 
_CS_XBS5_LP64_OFF64_CFLAGS
,

4782 
_CS_XBS5_LP64_OFF64_LDFLAGS
,

4784 
_CS_XBS5_LP64_OFF64_LIBS
,

4786 
_CS_XBS5_LP64_OFF64_LINTFLAGS
,

4788 
_CS_XBS5_LPBIG_OFFBIG_CFLAGS
,

4790 
_CS_XBS5_LPBIG_OFFBIG_LDFLAGS
,

4792 
_CS_XBS5_LPBIG_OFFBIG_LIBS
,

4794 
_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
,

4797 
_CS_POSIX_V6_ILP32_OFF32_CFLAGS
,

4799 
_CS_POSIX_V6_ILP32_OFF32_LDFLAGS
,

4801 
_CS_POSIX_V6_ILP32_OFF32_LIBS
,

4803 
_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
,

4805 
_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
,

4807 
_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
,

4809 
_CS_POSIX_V6_ILP32_OFFBIG_LIBS
,

4811 
_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
,

4813 
_CS_POSIX_V6_LP64_OFF64_CFLAGS
,

4815 
_CS_POSIX_V6_LP64_OFF64_LDFLAGS
,

4817 
_CS_POSIX_V6_LP64_OFF64_LIBS
,

4819 
_CS_POSIX_V6_LP64_OFF64_LINTFLAGS
,

4821 
_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
,

4823 
_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
,

4825 
_CS_POSIX_V6_LPBIG_OFFBIG_LIBS
,

4827 
_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
,

4830 
_CS_POSIX_V7_ILP32_OFF32_CFLAGS
,

4832 
_CS_POSIX_V7_ILP32_OFF32_LDFLAGS
,

4834 
_CS_POSIX_V7_ILP32_OFF32_LIBS
,

4836 
_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
,

4838 
_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
,

4840 
_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
,

4842 
_CS_POSIX_V7_ILP32_OFFBIG_LIBS
,

4844 
_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
,

4846 
_CS_POSIX_V7_LP64_OFF64_CFLAGS
,

4848 
_CS_POSIX_V7_LP64_OFF64_LDFLAGS
,

4850 
_CS_POSIX_V7_LP64_OFF64_LIBS
,

4852 
_CS_POSIX_V7_LP64_OFF64_LINTFLAGS
,

4854 
_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
,

4856 
_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
,

4858 
_CS_POSIX_V7_LPBIG_OFFBIG_LIBS
,

4860 
_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS
,

4863 
_CS_V6_ENV
,

4865 
_CS_V7_ENV


4871 extern long int 
	$pathconf
 (const char *
__path
, int 
__name
)

4872 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

4875 extern long int 
	$fpathconf
 (int 
__fd
, int 
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4878 extern long int 
	$sysconf
 (int 
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4882 extern 
size_t
 
	$confstr
 (int 
__name
, char *
__buf
, 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4887 extern 
__pid_t
 
	$getpid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4890 extern 
__pid_t
 
	$getppid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4893 extern 
__pid_t
 
	$getpgrp
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4896 extern 
__pid_t
 
	$__getpgid
 (
__pid_t
 
__pid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4898 extern 
__pid_t
 
	$getpgid
 (
__pid_t
 
__pid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4905 extern int 
	$setpgid
 (
__pid_t
 
__pid
, __pid_t 
__pgid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4907 extern int 
	$setpgrp
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4914 extern 
__pid_t
 
	$setsid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4918 extern 
__pid_t
 
	$getsid
 (
__pid_t
 
__pid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4922 extern 
__uid_t
 
	$getuid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4925 extern 
__uid_t
 
	$geteuid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4928 extern 
__gid_t
 
	$getgid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4931 extern 
__gid_t
 
	$getegid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4936 extern int 
	$getgroups
 (int 
__size
, 
__gid_t
 
__list
[]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4938 extern int 
	$setuid
 (
__uid_t
 
__uid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4943 extern int 
	$setreuid
 (
__uid_t
 
__ruid
, __uid_t 
__euid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4948 extern int 
	$seteuid
 (
__uid_t
 
__uid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4955 extern int 
	$setgid
 (
__gid_t
 
__gid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4960 extern int 
	$setregid
 (
__gid_t
 
__rgid
, __gid_t 
__egid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4965 extern int 
	$setegid
 (
__gid_t
 
__gid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

4967 extern 
__pid_t
 
	$fork
 (void) 
	`__attribute__
 ((
__nothrow__
));

4975 extern 
__pid_t
 
	$vfork
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4981 extern char *
	$ttyname
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4985 extern int 
	$ttyname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

4986 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

4990 extern int 
	$isatty
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

4996 extern int 
	$ttyslot
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5001 extern int 
	$link
 (const char *
__from
, const char *
__to
)

5002 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2))) ;

5007 extern int 
	$linkat
 (int 
__fromfd
, const char *
__from
, int 
__tofd
,

5008 const char *
__to
, int 
__flags
)

5009 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 4))) ;

5014 extern int 
	$symlink
 (const char *
__from
, const char *
__to
)

5015 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2))) ;

5020 extern 
ssize_t
 
	$readlink
 (const char *
__restrict
 
__path
,

5021 char *
__restrict
 
__buf
, 
size_t
 
__len
)

5022 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2))) ;

5027 extern int 
	$symlinkat
 (const char *
__from
, int 
__tofd
,

5028 const char *
__to
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3))) ;

5031 extern 
ssize_t
 
	$readlinkat
 (int 
__fd
, const char *
__restrict
 
__path
,

5032 char *
__restrict
 
__buf
, 
size_t
 
__len
)

5033 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3))) ;

5037 extern int 
	$unlink
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5041 extern int 
	$unlinkat
 (int 
__fd
, const char *
__name
, int 
__flag
)

5042 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

5046 extern int 
	$rmdir
 (const char *
__path
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5050 extern 
__pid_t
 
	$tcgetpgrp
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5053 extern int 
	$tcsetpgrp
 (int 
__fd
, 
__pid_t
 
__pgrp_id
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5060 extern char *
	`getlogin
 (void);

5068 extern int 
	$getlogin_r
 (char *
__name
, 
size_t
 
__name_len
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

5073 extern int 
	$setlogin
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5077 extern char *
optarg
;

5079 extern int 
optind
;

5084 extern int 
opterr
;

5088 extern int 
optopt
;

5090 extern int 
	$getopt
 (int 
___argc
, char *const *
___argv
, const char *
__shortopts
)

5091 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5100 extern int 
	$gethostname
 (char *
__name
, 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5107 extern int 
	$sethostname
 (const char *
__name
, 
size_t
 
__len
)

5108 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

5112 extern int 
	$sethostid
 (long int 
__id
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

5118 extern int 
	$getdomainname
 (char *
__name
, 
size_t
 
__len
)

5119 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

5120 extern int 
	$setdomainname
 (const char *
__name
, 
size_t
 
__len
)

5121 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

5127 extern int 
	$vhangup
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5130 extern int 
	$revoke
 (const char *
__file
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

5138 extern int 
	$profil
 (unsigned short int *
__sample_buffer
, 
size_t
 
__size
,

5139 
size_t
 
__offset
, unsigned int 
__scale
)

5140 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5146 extern int 
	$acct
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5150 extern char *
	$getusershell
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5151 extern void 
	$endusershell
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5152 extern void 
	$setusershell
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5158 extern int 
	$daemon
 (int 
__nochdir
, int 
__noclose
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

5165 extern int 
	$chroot
 (const char *
__path
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

5169 extern char *
	$getpass
 (const char *
__prompt
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

5177 extern int 
	`fsync
 (int 
__fd
);

5179 extern long int 
	`gethostid
 (void);

5182 extern void 
	$sync
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5188 extern int 
	$getpagesize
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

5193 extern int 
	$getdtablesize
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5195 extern int 
	$truncate
 (const char *
__file
, 
__off64_t
 
__length
) 
	`__asm__
 ("" "truncate64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

5197 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

5199 extern int 
	$ftruncate
 (int 
__fd
, 
__off64_t
 
__length
) 
	`__asm__
 ("" "ftruncate64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

5202 extern int 
	$brk
 (void *
__addr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

5208 extern void *
	$sbrk
 (
intptr_t
 
__delta
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5210 extern long int 
	$syscall
 (long int 
__sysno
, ...) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5212 extern int 
	$lockf
 (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
) 
	`__asm__
 ("" "lockf64")

5215 extern int 
	`fdatasync
 (int 
__fildes
);

5220 extern int 
	`isatty
(int);

5225 extern 
FILE
 *
	`popen
(const char*,const char*);

5226 extern int 
	`pclose
(
FILE
*);

5228 static int 
enableTimer
 = 0;

5231 static 
sqlite3_int64
 
	$timeOfDay
(void){

5232 static 
sqlite3_vfs
 *
clockVfs
 = 0;

5233 
sqlite3_int64
 
t
;

5234 if( 
clockVfs
==0 ) clockVfs = 
	`sqlite3_vfs_find
(0);

5235 if( 
clockVfs
->
iVersion
>=2 && clockVfs->
xCurrentTimeInt64
!=0 ){

5236 
clockVfs
->
	`xCurrentTimeInt64
(clockVfs, &
t
);

5238 double 
r
;

5239 
clockVfs
->
	`xCurrentTime
(clockVfs, &
r
);

5240 
t
 = (
sqlite3_int64
)(
r
*86400000.0);

5242 return 
t
;

5243 
	}
}

5256 struct 
	stimezone


5258 int 
	mtz_minuteswest
;

5259 int 
	mtz_dsttime
;

5262 typedef struct 
timezone
 *
	t__restrict
 
	t__timezone_ptr_t
;

5264 extern int 
	$gettimeofday
 (struct 
timeval
 *
__restrict
 
__tv
,

5265 
__timezone_ptr_t
 
__tz
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5270 extern int 
	$settimeofday
 (const struct 
timeval
 *
__tv
,

5271 const struct 
timezone
 *
__tz
)

5272 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5278 extern int 
	$adjtime
 (const struct 
timeval
 *
__delta
,

5279 struct 
timeval
 *
__olddelta
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5284 enum 
	e__itimer_which


5287 
ITIMER_REAL
 = 0,

5290 
ITIMER_VIRTUAL
 = 1,

5294 
ITIMER_PROF
 = 2

5300 struct 
	sitimerval


5303 struct 
timeval
 
it_interval
;

5305 struct 
timeval
 
it_value
;

5313 typedef int 
	t__itimer_which_t
;

5318 extern int 
	$getitimer
 (
__itimer_which_t
 
__which
,

5319 struct 
itimerval
 *
__value
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5324 extern int 
	$setitimer
 (
__itimer_which_t
 
__which
,

5325 const struct 
itimerval
 *
__restrict
 
__new
,

5326 struct 
itimerval
 *
__restrict
 
__old
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5331 extern int 
	$utimes
 (const char *
__file
, const struct 
timeval
 
__tvp
[2])

5332 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5336 extern int 
	$lutimes
 (const char *
__file
, const struct 
timeval
 
__tvp
[2])

5337 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

5340 extern int 
	$futimes
 (int 
__fd
, const struct 
timeval
 
__tvp
[2]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5348 enum 
	e__rlimit_resource


5351 
RLIMIT_CPU
 = 0,

5355 
RLIMIT_FSIZE
 = 1,

5359 
RLIMIT_DATA
 = 2,

5363 
RLIMIT_STACK
 = 3,

5367 
RLIMIT_CORE
 = 4,

5374 
__RLIMIT_RSS
 = 5,

5378 
RLIMIT_NOFILE
 = 7,

5379 
__RLIMIT_OFILE
 = 
RLIMIT_NOFILE
,

5384 
RLIMIT_AS
 = 9,

5388 
__RLIMIT_NPROC
 = 6,

5392 
__RLIMIT_MEMLOCK
 = 8,

5396 
__RLIMIT_LOCKS
 = 10,

5400 
__RLIMIT_SIGPENDING
 = 11,

5404 
__RLIMIT_MSGQUEUE
 = 12,

5410 
__RLIMIT_NICE
 = 13,

5415 
__RLIMIT_RTPRIO
 = 14,

5421 
__RLIMIT_RTTIME
 = 15,

5424 
__RLIMIT_NLIMITS
 = 16,

5425 
__RLIM_NLIMITS
 = 
__RLIMIT_NLIMITS


5430 typedef 
__rlim64_t
 
	trlim_t
;

5436 struct 
	srlimit


5439 
rlim_t
 
rlim_cur
;

5441 
rlim_t
 
rlim_max
;

5444 enum 
	e__rusage_who


5447 
RUSAGE_SELF
 = 0,

5451 
RUSAGE_CHILDREN
 = -1

5465 struct 
	srusage


5468 struct 
timeval
 
ru_utime
;

5470 struct 
timeval
 
ru_stime
;

5472 
__extension__
 union

5474 long int 
ru_maxrss
;

5475 
__syscall_slong_t
 
__ru_maxrss_word
;

5480 
__extension__
 union

5482 long int 
ru_ixrss
;

5483 
__syscall_slong_t
 
__ru_ixrss_word
;

5486 
__extension__
 union

5488 long int 
ru_idrss
;

5489 
__syscall_slong_t
 
__ru_idrss_word
;

5492 
__extension__
 union

5494 long int 
ru_isrss
;

5495 
__syscall_slong_t
 
__ru_isrss_word
;

5499 
__extension__
 union

5501 long int 
ru_minflt
;

5502 
__syscall_slong_t
 
__ru_minflt_word
;

5505 
__extension__
 union

5507 long int 
ru_majflt
;

5508 
__syscall_slong_t
 
__ru_majflt_word
;

5511 
__extension__
 union

5513 long int 
ru_nswap
;

5514 
__syscall_slong_t
 
__ru_nswap_word
;

5518 
__extension__
 union

5520 long int 
ru_inblock
;

5521 
__syscall_slong_t
 
__ru_inblock_word
;

5524 
__extension__
 union

5526 long int 
ru_oublock
;

5527 
__syscall_slong_t
 
__ru_oublock_word
;

5530 
__extension__
 union

5532 long int 
ru_msgsnd
;

5533 
__syscall_slong_t
 
__ru_msgsnd_word
;

5536 
__extension__
 union

5538 long int 
ru_msgrcv
;

5539 
__syscall_slong_t
 
__ru_msgrcv_word
;

5542 
__extension__
 union

5544 long int 
ru_nsignals
;

5545 
__syscall_slong_t
 
__ru_nsignals_word
;

5550 
__extension__
 union

5552 long int 
ru_nvcsw
;

5553 
__syscall_slong_t
 
__ru_nvcsw_word
;

5557 
__extension__
 union

5559 long int 
ru_nivcsw
;

5560 
__syscall_slong_t
 
__ru_nivcsw_word
;

5570 enum 
	e__priority_which


5572 
PRIO_PROCESS
 = 0,

5574 
PRIO_PGRP
 = 1,

5576 
PRIO_USER
 = 2

5593 typedef int 
	t__rlimit_resource_t
;

5594 typedef int 
	t__rusage_who_t
;

5595 typedef int 
	t__priority_which_t
;

5597 extern int 
	$getrlimit
 (
__rlimit_resource_t
 
__resource
, struct 
rlimit
 *
__rlimits
) 
	`__asm__
 ("" "getrlimit64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

5600 extern int 
	$setrlimit
 (
__rlimit_resource_t
 
__resource
, const struct 
rlimit
 *
__rlimits
) 
	`__asm__
 ("" "setrlimit64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

5604 extern int 
	$getrusage
 (
__rusage_who_t
 
__who
, struct 
rusage
 *
__usage
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5610 extern int 
	$getpriority
 (
__priority_which_t
 
__which
, 
id_t
 
__who
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5614 extern int 
	$setpriority
 (
__priority_which_t
 
__which
, 
id_t
 
__who
, int 
__prio
)

5615 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

5620 static struct 
rusage
 
sBegin
;

5621 static 
sqlite3_int64
 
iBegin
;

5626 static void 
	$beginTimer
(void){

5627 if( 
enableTimer
 ){

5628 
	`getrusage
(
RUSAGE_SELF
, &
sBegin
);

5629 
iBegin
 = 
	`timeOfDay
();

5631 
	}
}

5634 static double 
	$timeDiff
(struct 
timeval
 *
pStart
, struct timeval *
pEnd
){

5635 return (
pEnd
->
tv_usec
 - 
pStart
->tv_usec)*0.000001 +

5636 (double)(
pEnd
->
tv_sec
 - 
pStart
->tv_sec);

5637 
	}
}

5642 static void 
	$endTimer
(void){

5643 if( 
enableTimer
 ){

5644 
sqlite3_int64
 
iEnd
 = 
	`timeOfDay
();

5645 struct 
rusage
 
sEnd
;

5646 
	`getrusage
(
RUSAGE_SELF
, &
sEnd
);

5647 
	`printf
("Run Time: real %.3f user %f sys %f\n",

5648 (
iEnd
 - 
iBegin
)*0.001,

5649 
	`timeDiff
(&
sBegin
.
ru_utime
, &
sEnd
.ru_utime),

5650 
	`timeDiff
(&
sBegin
.
ru_stime
, &
sEnd
.ru_stime));

5652 
	}
}

5654 static int 
	gbail_on_error
 = 0;

5660 static int 
	gstdin_is_interactive
 = 1;

5667 static int 
	gstdout_is_console
 = 1;

5674 static 
sqlite3
 *
	gglobalDb
 = 0;

5679 static volatile int 
	gseenInterrupt
 = 0;

5685 static char *
	gArgv0
;

5691 static char 
	gmainPrompt
[20];

5692 static char 
	gcontinuePrompt
[20];

5694 static int 
	$isNumber
(const char *
z
, int *
realnum
){

5695 if( *
z
=='-' || *z=='+' ) z++;

5696 if( !((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)*
z
))] & (unsigned short int) 
_ISdigit
) ){

5699 
z
++;

5700 if( 
realnum
 ) *realnum = 0;

5701 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)*
z
))] & (unsigned short int) 
_ISdigit
) ){ z++; }

5702 if( *
z
=='.' ){

5703 
z
++;

5704 if( !((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)*
z
))] & (unsigned short int) 
_ISdigit
) ) return 0;

5705 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)*
z
))] & (unsigned short int) 
_ISdigit
) ){ z++; }

5706 if( 
realnum
 ) *realnum = 1;

5708 if( *
z
=='e' || *z=='E' ){

5709 
z
++;

5710 if( *
z
=='+' || *z=='-' ) z++;

5711 if( !((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)*
z
))] & (unsigned short int) 
_ISdigit
) ) return 0;

5712 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)*
z
))] & (unsigned short int) 
_ISdigit
) ){ z++; }

5713 if( 
realnum
 ) *realnum = 1;

5715 return *
z
==0;

5716 
	}
}

5718 static const char *
	gzShellStatic
 = 0;

5719 static void 
	$shellstaticFunc
(

5720 
sqlite3_context
 *
context
,

5721 int 
argc
,

5722 
sqlite3_value
 **
argv


5724 ((0==
argc
) ? (void) (0) : 
	`__assert_fail
 ("0==argc", "shell.c", 432, 
__PRETTY_FUNCTION__
));

5725 ((
zShellStatic
) ? (void) (0) : 
	`__assert_fail
 ("zShellStatic", "shell.c", 433, 
__PRETTY_FUNCTION__
));

5726 (void)(
argc
);

5727 (void)(
argv
);

5728 
	`sqlite3_result_text
(
context
, 
zShellStatic
, -1, ((
sqlite3_destructor_type
)0));

5729 
	}
}

5736 static int 
	$strlen30
(const char *
z
){

5737 const char *
z2
 = 
z
;

5738 while( *
z2
 ){ z2++; }

5739 return 0x3fffffff & (int)(
z2
 - 
z
);

5740 
	}
}

5742 static char *
	$local_getline
(char *
zLine
, 
FILE
 *
in
){

5743 int 
nLine
 = 
zLine
==0 ? 0 : 100;

5744 int 
n
 = 0;

5747 if( 
n
+100>
nLine
 ){

5748 
nLine
 = nLine*2 + 100;

5749 
zLine
 = 
	`realloc
(zLine, 
nLine
);

5750 if( 
zLine
==0 ) return 0;

5752 if( 
	`fgets
(&
zLine
[
n
], 
nLine
 - n, 
in
)==0 ){

5753 if( 
n
==0 ){

5754 
	`free
(
zLine
);

5757 
zLine
[
n
] = 0;

5760 while( 
zLine
[
n
] ) n++;

5761 if( 
n
>0 && 
zLine
[n-1]=='\n' ){

5762 
n
--;

5763 if( 
n
>0 && 
zLine
[n-1]=='\r' ) n--;

5764 
zLine
[
n
] = 0;

5769 return 
zLine
;

5770 
	}
}

5772 static char *
	$one_input_line
(
FILE
 *
in
, char *
zPrior
, int 
isContinuation
){

5773 char *
zPrompt
;

5774 char *
zResult
;

5775 if( 
in
!=0 ){

5776 
zResult
 = 
	`local_getline
(
zPrior
, 
in
);

5778 
zPrompt
 = 
isContinuation
 ? 
continuePrompt
 : 
mainPrompt
;

5780 
	`printf
("%s", 
zPrompt
);

5781 
	`fflush
(
stdout
);

5782 
zResult
 = 
	`local_getline
(
zPrior
, 
stdin
);

5789 return 
zResult
;

5790 
	}
}

5792 typedef struct 
SavedModeInfo
 
	tSavedModeInfo
;

5793 struct 
	sSavedModeInfo
 {

5794 int 
	mvalid
;

5795 int 
	mmode
;

5796 int 
	mshowHeader
;

5797 int 
	mcolWidth
[100];

5804 typedef struct 
ShellState
 
	tShellState
;

5805 struct 
	sShellState
 {

5806 
sqlite3
 *
	mdb
;

5807 int 
	mechoOn
;

5808 int 
	mautoExplain
;

5809 int 
	mautoEQP
;

5810 int 
	mstatsOn
;

5811 int 
	mscanstatsOn
;

5812 int 
	mcountChanges
;

5813 int 
	mbackslashOn
;

5814 int 
	moutCount
;

5815 int 
	mcnt
;

5816 
FILE
 *
	mout
;

5817 
FILE
 *
	mtraceOut
;

5818 int 
	mnErr
;

5819 int 
	mmode
;

5820 int 
	mcMode
;

5821 int 
	mnormalMode
;

5822 int 
	mwritableSchema
;

5823 int 
	mshowHeader
;

5824 unsigned 
	mshellFlgs
;

5825 char *
	mzDestTable
;

5826 char 
	mcolSeparator
[20];

5827 char 
	mrowSeparator
[20];

5828 int 
	mcolWidth
[100];

5829 int 
	mactualWidth
[100];

5830 char 
	mnullValue
[20];

5832 char 
	moutfile
[4096];

5833 const char *
	mzDbFilename
;

5834 char *
	mzFreeOnClose
;

5835 const char *
	mzVfs
;

5836 
sqlite3_stmt
 *
	mpStmt
;

5837 
FILE
 *
	mpLog
;

5838 int *
	maiIndent
;

5839 int 
	mnIndent
;

5840 int 
	miIndent
;

5843 static const char *
	gmodeDescr
[] = {

5856 static void 
	$shellLog
(void *
pArg
, int 
iErrCode
, const char *
zMsg
){

5857 
ShellState
 *
p
 = (ShellState*)
pArg
;

5858 if( 
p
->
pLog
==0 ) return;

5859 
	`fprintf
(
p
->
pLog
, "(%d) %s\n", 
iErrCode
, 
zMsg
);

5860 
	`fflush
(
p
->
pLog
);

5861 
	}
}

5866 static void 
	$output_hex_blob
(
FILE
 *
out
, const void *
pBlob
, int 
nBlob
){

5867 int 
i
;

5868 char *
zBlob
 = (char *)
pBlob
;

5869 
	`fprintf
(
out
,"X'");

5870 for(
i
=0; i<
nBlob
; i++){ 
	`fprintf
(
out
,"%02x",
zBlob
[i]&0xff); }

5871 
	`fprintf
(
out
,"'");

5872 
	}
}

5877 static void 
	$output_quoted_string
(
FILE
 *
out
, const char *
z
){

5878 int 
i
;

5879 int 
nSingle
 = 0;

5881 for(
i
=0; 
z
[i]; i++){

5882 if( 
z
[
i
]=='\'' ) 
nSingle
++;

5884 if( 
nSingle
==0 ){

5885 
	`fprintf
(
out
,"'%s'",
z
);

5887 
	`fprintf
(
out
,"'");

5888 while( *
z
 ){

5889 for(
i
=0; 
z
[i] && z[i]!='\''; i++){}

5890 if( 
i
==0 ){

5891 
	`fprintf
(
out
,"''");

5892 
z
++;

5893 }else if( 
z
[
i
]=='\'' ){

5894 
	`fprintf
(
out
,"%.*s''",
i
,
z
);

5895 
z
 += 
i
+1;

5897 
	`fprintf
(
out
,"%s",
z
);

5901 
	`fprintf
(
out
,"'");

5904 
	}
}

5909 static void 
	$output_c_string
(
FILE
 *
out
, const char *
z
){

5910 unsigned int 
c
;

5911 
	`fputc
('"', 
out
);

5912 while( (
c
 = *(
z
++))!=0 ){

5913 if( 
c
=='\\' ){

5914 
	`fputc
(
c
, 
out
);

5915 
	`fputc
(
c
, 
out
);

5916 }else if( 
c
=='"' ){

5917 
	`fputc
('\\', 
out
);

5918 
	`fputc
('"', 
out
);

5919 }else if( 
c
=='\t' ){

5920 
	`fputc
('\\', 
out
);

5921 
	`fputc
('t', 
out
);

5922 }else if( 
c
=='\n' ){

5923 
	`fputc
('\\', 
out
);

5924 
	`fputc
('n', 
out
);

5925 }else if( 
c
=='\r' ){

5926 
	`fputc
('\\', 
out
);

5927 
	`fputc
('r', 
out
);

5928 }else if( !((*
	`__ctype_b_loc
 ())[(int) ((
c
&0xff))] & (unsigned short int) 
_ISprint
) ){

5929 
	`fprintf
(
out
, "\\%03o", 
c
&0xff);

5931 
	`fputc
(
c
, 
out
);

5934 
	`fputc
('"', 
out
);

5935 
	}
}

5941 static void 
	$output_html_string
(
FILE
 *
out
, const char *
z
){

5942 int 
i
;

5943 if( 
z
==0 ) z = "";

5944 while( *
z
 ){

5945 for(
i
=0; 
z
[i]

5946 && 
z
[
i
]!='<'

5947 && 
z
[
i
]!='&'

5948 && 
z
[
i
]!='>'

5949 && 
z
[
i
]!='\"'

5950 && 
z
[
i
]!='\'';

5951 
i
++){}

5952 if( 
i
>0 ){

5953 
	`fprintf
(
out
,"%.*s",
i
,
z
);

5955 if( 
z
[
i
]=='<' ){

5956 
	`fprintf
(
out
,"&lt;");

5957 }else if( 
z
[
i
]=='&' ){

5958 
	`fprintf
(
out
,"&amp;");

5959 }else if( 
z
[
i
]=='>' ){

5960 
	`fprintf
(
out
,"&gt;");

5961 }else if( 
z
[
i
]=='\"' ){

5962 
	`fprintf
(
out
,"&quot;");

5963 }else if( 
z
[
i
]=='\'' ){

5964 
	`fprintf
(
out
,"&#39;");

5968 
z
 += 
i
 + 1;

5970 
	}
}

5976 static const char 
	gneedCsvQuote
[] = {

6001 static void 
	$output_csv
(
ShellState
 *
p
, const char *
z
, int 
bSep
){

6002 
FILE
 *
out
 = 
p
->out;

6003 if( 
z
==0 ){

6004 
	`fprintf
(
out
,"%s",
p
->
nullValue
);

6006 int 
i
;

6007 int 
nSep
 = 
	`strlen30
(
p
->
colSeparator
);

6008 for(
i
=0; 
z
[i]; i++){

6009 if( 
needCsvQuote
[((unsigned char*)
z
)[
i
]]

6010 || (
z
[
i
]==
p
->
colSeparator
[0] &&

6011 (
nSep
==1 || 
	`memcmp
(
z
, 
p
->
colSeparator
, nSep)==0)) ){

6012 
i
 = 0;

6016 if( 
i
==0 ){

6017 
	`_IO_putc
 ('"', 
out
);

6018 for(
i
=0; 
z
[i]; i++){

6019 if( 
z
[
i
]=='"' ) 
	`_IO_putc
 ('"', 
out
);

6020 
	`_IO_putc
 (
z
[
i
], 
out
);

6022 
	`_IO_putc
 ('"', 
out
);

6024 
	`fprintf
(
out
, "%s", 
z
);

6027 if( 
bSep
 ){

6028 
	`fprintf
(
p
->
out
, "%s", p->
colSeparator
);

6030 
	}
}

6036 static void 
	$interrupt_handler
(int 
NotUsed
){

6037 (void)(
NotUsed
);

6038 
seenInterrupt
++;

6039 if( 
seenInterrupt
>2 ) 
	`exit
(1);

6040 if( 
globalDb
 ) 
	`sqlite3_interrupt
(globalDb);

6041 
	}
}

6048 static int 
	$shell_callback
(

6049 void *
pArg
,

6050 int 
nArg
,

6051 char **
azArg
,

6052 char **
azCol
,

6053 int *
aiType


6055 int 
i
;

6056 
ShellState
 *
p
 = (ShellState*)
pArg
;

6058 switch( 
p
->
cMode
 ){

6060 int 
w
 = 5;

6061 if( 
azArg
==0 ) break;

6062 for(
i
=0; i<
nArg
; i++){

6063 int 
len
 = 
	`strlen30
(
azCol
[
i
] ? azCol[i] : "");

6064 if( 
len
>
w
 ) w = len;

6066 if( 
p
->
cnt
++>0 ) 
	`fprintf
(p->
out
, "%s", p->
rowSeparator
);

6067 for(
i
=0; i<
nArg
; i++){

6068 
	`fprintf
(
p
->
out
,"%*s = %s%s", 
w
, 
azCol
[
i
],

6069 
azArg
[
i
] ? azArg[i] : 
p
->
nullValue
, p->
rowSeparator
);

6075 static const int 
aExplainWidths
[] = {4, 13, 4, 4, 4, 13, 2, 13};

6076 const int *
colWidth
;

6077 int 
showHdr
;

6078 char *
rowSep
;

6079 if( 
p
->
cMode
==1 ){

6080 
colWidth
 = 
p
->colWidth;

6081 
showHdr
 = 
p
->
showHeader
;

6082 
rowSep
 = 
p
->
rowSeparator
;

6084 
colWidth
 = 
aExplainWidths
;

6085 
showHdr
 = 1;

6086 
rowSep
 = "\n";

6088 if( 
p
->
cnt
++==0 ){

6089 for(
i
=0; i<
nArg
; i++){

6090 int 
w
, 
n
;

6091 if( 
i
<(int)(sizeof(
p
->
colWidth
)/sizeof(p->colWidth[0])) ){

6092 
w
 = 
colWidth
[
i
];

6094 
w
 = 0;

6096 if( 
w
==0 ){

6097 
w
 = 
	`strlen30
(
azCol
[
i
] ? azCol[i] : "");

6098 if( 
w
<10 ) w = 10;

6099 
n
 = 
	`strlen30
(
azArg
 && azArg[
i
] ? azArg[i] : 
p
->
nullValue
);

6100 if( 
w
<
n
 ) w = n;

6102 if( 
i
<(int)(sizeof(
p
->
actualWidth
)/sizeof(p->actualWidth[0])) ){

6103 
p
->
actualWidth
[
i
] = 
w
;

6105 if( 
showHdr
 ){

6106 if( 
w
<0 ){

6107 
	`fprintf
(
p
->
out
,"%*.*s%s",-
w
,-w,
azCol
[
i
],

6108 
i
==
nArg
-1 ? 
rowSep
 : " ");

6110 
	`fprintf
(
p
->
out
,"%-*.*s%s",
w
,w,
azCol
[
i
],

6111 
i
==
nArg
-1 ? 
rowSep
 : " ");

6115 if( 
showHdr
 ){

6116 for(
i
=0; i<
nArg
; i++){

6117 int 
w
;

6118 if( 
i
<(int)(sizeof(
p
->
actualWidth
)/sizeof(p->actualWidth[0])) ){

6119 
w
 = 
p
->
actualWidth
[
i
];

6120 if( 
w
<0 ) w = -w;

6122 
w
 = 10;

6124 
	`fprintf
(
p
->
out
,"%-*.*s%s",
w
,w,

6127 
i
==
nArg
-1 ? 
rowSep
 : " ");

6131 if( 
azArg
==0 ) break;

6132 for(
i
=0; i<
nArg
; i++){

6133 int 
w
;

6134 if( 
i
<(int)(sizeof(
p
->
actualWidth
)/sizeof(p->actualWidth[0])) ){

6135 
w
 = 
p
->
actualWidth
[
i
];

6137 
w
 = 10;

6139 if( 
p
->
cMode
==8 && 
azArg
[
i
] && 
	`strlen30
(azArg[i])>
w
 ){

6140 
w
 = 
	`strlen30
(
azArg
[
i
]);

6142 if( 
i
==1 && 
p
->
aiIndent
 && p->
pStmt
 ){

6143 if( 
p
->
iIndent
<p->
nIndent
 ){

6144 
	`fprintf
(
p
->
out
, "%*.s", p->
aiIndent
[p->
iIndent
], "");

6146 
p
->
iIndent
++;

6148 if( 
w
<0 ){

6149 
	`fprintf
(
p
->
out
,"%*.*s%s",-
w
,-w,

6150 
azArg
[
i
] ? azArg[i] : 
p
->
nullValue
,

6151 
i
==
nArg
-1 ? 
rowSep
 : " ");

6153 
	`fprintf
(
p
->
out
,"%-*.*s%s",
w
,w,

6154 
azArg
[
i
] ? azArg[i] : 
p
->
nullValue
,

6155 
i
==
nArg
-1 ? 
rowSep
 : " ");

6162 if( 
p
->
cnt
++==0 && p->
showHeader
 ){

6163 for(
i
=0; i<
nArg
; i++){

6164 
	`fprintf
(
p
->
out
,"%s%s",
azCol
[
i
],

6165 
i
==
nArg
-1 ? 
p
->
rowSeparator
 : p->
colSeparator
);

6168 if( 
azArg
==0 ) break;

6169 for(
i
=0; i<
nArg
; i++){

6170 char *
z
 = 
azArg
[
i
];

6171 if( 
z
==0 ) z = 
p
->
nullValue
;

6172 
	`fprintf
(
p
->
out
, "%s", 
z
);

6173 if( 
i
<
nArg
-1 ){

6174 
	`fprintf
(
p
->
out
, "%s", p->
colSeparator
);

6175 }else if( 
p
->
cMode
==3 ){

6176 
	`fprintf
(
p
->
out
, ";%s", p->
rowSeparator
);

6178 
	`fprintf
(
p
->
out
, "%s", p->
rowSeparator
);

6184 if( 
p
->
cnt
++==0 && p->
showHeader
 ){

6185 
	`fprintf
(
p
->
out
,"<TR>");

6186 for(
i
=0; i<
nArg
; i++){

6187 
	`fprintf
(
p
->
out
,"<TH>");

6188 
	`output_html_string
(
p
->
out
, 
azCol
[
i
]);

6189 
	`fprintf
(
p
->
out
,"</TH>\n");

6191 
	`fprintf
(
p
->
out
,"</TR>\n");

6193 if( 
azArg
==0 ) break;

6194 
	`fprintf
(
p
->
out
,"<TR>");

6195 for(
i
=0; i<
nArg
; i++){

6196 
	`fprintf
(
p
->
out
,"<TD>");

6197 
	`output_html_string
(
p
->
out
, 
azArg
[
i
] ? azArg[i] : p->
nullValue
);

6198 
	`fprintf
(
p
->
out
,"</TD>\n");

6200 
	`fprintf
(
p
->
out
,"</TR>\n");

6204 if( 
p
->
cnt
++==0 && p->
showHeader
 ){

6205 for(
i
=0; i<
nArg
; i++){

6206 
	`output_c_string
(
p
->
out
,
azCol
[
i
] ? azCol[i] : "");

6207 if(
i
<
nArg
-1) 
	`fprintf
(
p
->
out
, "%s", p->
colSeparator
);

6209 
	`fprintf
(
p
->
out
, "%s", p->
rowSeparator
);

6211 if( 
azArg
==0 ) break;

6212 for(
i
=0; i<
nArg
; i++){

6213 
	`output_c_string
(
p
->
out
, 
azArg
[
i
] ? azArg[i] : p->
nullValue
);

6214 if(
i
<
nArg
-1) 
	`fprintf
(
p
->
out
, "%s", p->
colSeparator
);

6216 
	`fprintf
(
p
->
out
, "%s", p->
rowSeparator
);

6221 if( 
p
->
cnt
++==0 && p->
showHeader
 ){

6222 for(
i
=0; i<
nArg
; i++){

6223 
	`output_csv
(
p
, 
azCol
[
i
] ? azCol[i] : "", i<
nArg
-1);

6225 
	`fprintf
(
p
->
out
, "%s", p->
rowSeparator
);

6227 if( 
nArg
>0 ){

6228 for(
i
=0; i<
nArg
; i++){

6229 
	`output_csv
(
p
, 
azArg
[
i
], i<
nArg
-1);

6231 
	`fprintf
(
p
->
out
, "%s", p->
rowSeparator
);

6237 
p
->
cnt
++;

6238 if( 
azArg
==0 ) break;

6239 
	`fprintf
(
p
->
out
,"INSERT INTO %s",p->
zDestTable
);

6240 if( 
p
->
showHeader
 ){

6241 
	`fprintf
(
p
->
out
,"(");

6242 for(
i
=0; i<
nArg
; i++){

6243 char *
zSep
 = 
i
>0 ? ",": "";

6244 
	`fprintf
(
p
->
out
, "%s%s", 
zSep
, 
azCol
[
i
]);

6246 
	`fprintf
(
p
->
out
,")");

6248 
	`fprintf
(
p
->
out
," VALUES(");

6249 for(
i
=0; i<
nArg
; i++){

6250 char *
zSep
 = 
i
>0 ? ",": "";

6251 if( (
azArg
[
i
]==0) || (
aiType
 && aiType[i]==5) ){

6252 
	`fprintf
(
p
->
out
,"%sNULL",
zSep
);

6253 }else if( 
aiType
 && aiType[
i
]==3 ){

6254 if( 
zSep
[0] ) 
	`fprintf
(
p
->
out
,"%s",zSep);

6255 
	`output_quoted_string
(
p
->
out
, 
azArg
[
i
]);

6256 }else if( 
aiType
 && (aiType[
i
]==1

6257 || 
aiType
[
i
]==2) ){

6258 
	`fprintf
(
p
->
out
,"%s%s",
zSep
, 
azArg
[
i
]);

6259 }else if( 
aiType
 && aiType[
i
]==4 && 
p
->
pStmt
 ){

6260 const void *
pBlob
 = 
	`sqlite3_column_blob
(
p
->
pStmt
, 
i
);

6261 int 
nBlob
 = 
	`sqlite3_column_bytes
(
p
->
pStmt
, 
i
);

6262 if( 
zSep
[0] ) 
	`fprintf
(
p
->
out
,"%s",zSep);

6263 
	`output_hex_blob
(
p
->
out
, 
pBlob
, 
nBlob
);

6264 }else if( 
	`isNumber
(
azArg
[
i
], 0) ){

6265 
	`fprintf
(
p
->
out
,"%s%s",
zSep
, 
azArg
[
i
]);

6267 if( 
zSep
[0] ) 
	`fprintf
(
p
->
out
,"%s",zSep);

6268 
	`output_quoted_string
(
p
->
out
, 
azArg
[
i
]);

6271 
	`fprintf
(
p
->
out
,");\n");

6275 if( 
p
->
cnt
++==0 && p->
showHeader
 ){

6276 for(
i
=0; i<
nArg
; i++){

6277 if( 
i
>0 ) 
	`fprintf
(
p
->
out
, "%s", p->
colSeparator
);

6278 
	`fprintf
(
p
->
out
,"%s",
azCol
[
i
] ? azCol[i] : "");

6280 
	`fprintf
(
p
->
out
, "%s", p->
rowSeparator
);

6282 if( 
azArg
==0 ) break;

6283 for(
i
=0; i<
nArg
; i++){

6284 if( 
i
>0 ) 
	`fprintf
(
p
->
out
, "%s", p->
colSeparator
);

6285 
	`fprintf
(
p
->
out
,"%s",
azArg
[
i
] ? azArg[i] : p->
nullValue
);

6287 
	`fprintf
(
p
->
out
, "%s", p->
rowSeparator
);

6292 
	}
}

6298 static int 
	$callback
(void *
pArg
, int 
nArg
, char **
azArg
, char **
azCol
){

6300 return 
	`shell_callback
(
pArg
, 
nArg
, 
azArg
, 
azCol
, ((void *)0));

6301 
	}
}

6308 static void 
	$set_table_name
(
ShellState
 *
p
, const char *
zName
){

6309 int 
i
, 
n
;

6310 int 
needQuote
;

6311 char *
z
;

6313 if( 
p
->
zDestTable
 ){

6314 
	`free
(
p
->
zDestTable
);

6315 
p
->
zDestTable
 = 0;

6317 if( 
zName
==0 ) return;

6318 
needQuote
 = !((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)*
zName
))] & (unsigned short int) 
_ISalpha
) && *zName!='_';

6319 for(
i
=
n
=0; 
zName
[i]; i++, n++){

6320 if( !((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)
zName
[
i
]))] & (unsigned short int) 
_ISalnum
) && zName[i]!='_' ){

6321 
needQuote
 = 1;

6322 if( 
zName
[
i
]=='\'' ) 
n
++;

6325 if( 
needQuote
 ) 
n
 += 2;

6326 
z
 = 
p
->
zDestTable
 = 
	`malloc
( 
n
+1 );

6327 if( 
z
==0 ){

6328 
	`fprintf
(
stderr
,"Error: out of memory\n");

6329 
	`exit
(1);

6331 
n
 = 0;

6332 if( 
needQuote
 ) 
z
[
n
++] = '\'';

6333 for(
i
=0; 
zName
[i]; i++){

6334 
z
[
n
++] = 
zName
[
i
];

6335 if( 
zName
[
i
]=='\'' ) 
z
[
n
++] = '\'';

6337 if( 
needQuote
 ) 
z
[
n
++] = '\'';

6338 
z
[
n
] = 0;

6339 
	}
}

6341 static char *
	$appendText
(char *
zIn
, char const *
zAppend
, char 
quote
){

6342 int 
len
;

6343 int 
i
;

6344 int 
nAppend
 = 
	`strlen30
(
zAppend
);

6345 int 
nIn
 = (
zIn
?
	`strlen30
(zIn):0);

6347 
len
 = 
nAppend
+
nIn
+1;

6348 if( 
quote
 ){

6349 
len
 += 2;

6350 for(
i
=0; i<
nAppend
; i++){

6351 if( 
zAppend
[
i
]==
quote
 ) 
len
++;

6355 
zIn
 = (char *)
	`realloc
(zIn, 
len
);

6356 if( !
zIn
 ){

6360 if( 
quote
 ){

6361 char *
zCsr
 = &
zIn
[
nIn
];

6362 *
zCsr
++ = 
quote
;

6363 for(
i
=0; i<
nAppend
; i++){

6364 *
zCsr
++ = 
zAppend
[
i
];

6365 if( 
zAppend
[
i
]==
quote
 ) *
zCsr
++ = quote;

6367 *
zCsr
++ = 
quote
;

6368 *
zCsr
++ = '\0';

6369 (((
zCsr
-
zIn
)==
len
) ? (void) (0) : 
	`__assert_fail
 ("(zCsr-zIn)==len", "shell.c", 1206, 
__PRETTY_FUNCTION__
));

6371 
	`memcpy
(&
zIn
[
nIn
], 
zAppend
, 
nAppend
);

6372 
zIn
[
len
-1] = '\0';

6375 return 
zIn
;

6376 
	}
}

6378 static int 
	$run_table_dump_query
(

6379 
ShellState
 *
p
,

6380 const char *
zSelect
,

6381 const char *
zFirstRow


6383 
sqlite3_stmt
 *
pSelect
;

6384 int 
rc
;

6385 int 
nResult
;

6386 int 
i
;

6387 const char *
z
;

6388 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zSelect
, -1, &
pSelect
, 0);

6389 if( 
rc
!=0 || !
pSelect
 ){

6390 
	`fprintf
(
p
->
out
, "/**** ERROR: (%d) %s *****/\n", 
rc
,

6391 
	`sqlite3_errmsg
(
p
->
db
));

6392 if( (
rc
&0xff)!=11 ) 
p
->
nErr
++;

6393 return 
rc
;

6395 
rc
 = 
	`sqlite3_step
(
pSelect
);

6396 
nResult
 = 
	`sqlite3_column_count
(
pSelect
);

6397 while( 
rc
==100 ){

6398 if( 
zFirstRow
 ){

6399 
	`fprintf
(
p
->
out
, "%s", 
zFirstRow
);

6400 
zFirstRow
 = 0;

6402 
z
 = (const char*)
	`sqlite3_column_text
(
pSelect
, 0);

6403 
	`fprintf
(
p
->
out
, "%s", 
z
);

6404 for(
i
=1; i<
nResult
; i++){

6405 
	`fprintf
(
p
->
out
, ",%s", 
	`sqlite3_column_text
(
pSelect
, 
i
));

6407 if( 
z
==0 ) z = "";

6408 while( 
z
[0] && (z[0]!='-' || z[1]!='-') ) z++;

6409 if( 
z
[0] ){

6410 
	`fprintf
(
p
->
out
, "\n;\n");

6412 
	`fprintf
(
p
->
out
, ";\n");

6414 
rc
 = 
	`sqlite3_step
(
pSelect
);

6416 
rc
 = 
	`sqlite3_finalize
(
pSelect
);

6417 if( 
rc
!=0 ){

6418 
	`fprintf
(
p
->
out
, "/**** ERROR: (%d) %s *****/\n", 
rc
,

6419 
	`sqlite3_errmsg
(
p
->
db
));

6420 if( (
rc
&0xff)!=11 ) 
p
->
nErr
++;

6422 return 
rc
;

6423 
	}
}

6428 static char *
	$save_err_msg
(

6429 
sqlite3
 *
db


6431 int 
nErrMsg
 = 1+
	`strlen30
(
	`sqlite3_errmsg
(
db
));

6432 char *
zErrMsg
 = 
	`sqlite3_malloc64
(
nErrMsg
);

6433 if( 
zErrMsg
 ){

6434 
	`memcpy
(
zErrMsg
, 
	`sqlite3_errmsg
(
db
), 
nErrMsg
);

6436 return 
zErrMsg
;

6437 
	}
}

6443 static void 
	$displayLinuxIoStats
(
FILE
 *
out
){

6444 
FILE
 *
in
;

6445 char 
z
[200];

6446 
	`sqlite3_snprintf
(sizeof(
z
), z, "/proc/%d/io", 
	`getpid
());

6447 
in
 = 
	`fopen
(
z
, "rb");

6448 if( 
in
==0 ) return;

6449 while( 
	`fgets
(
z
, sizeof(z), 
in
)!=0 ){

6451 const char *
zPattern
;

6452 const char *
zDesc
;

6453 } 
aTrans
[] = {

6462 int 
i
;

6463 for(
i
=0; i<(int)(sizeof(
aTrans
)/sizeof(aTrans[0])); i++){

6464 int 
n
 = (int)
	`strlen
(
aTrans
[
i
].
zPattern
);

6465 if( 
	`strncmp
(
aTrans
[
i
].
zPattern
, 
z
, 
n
)==0 ){

6466 
	`fprintf
(
out
, "%-36s %s", 
aTrans
[
i
].
zDesc
, &
z
[
n
]);

6471 
	`fclose
(
in
);

6472 
	}
}

6479 static int 
	$display_stats
(

6480 
sqlite3
 *
db
,

6481 
ShellState
 *
pArg
,

6482 int 
bReset


6484 int 
iCur
;

6485 int 
iHiwtr
;

6487 if( 
pArg
 && pArg->
out
 ){

6489 
iHiwtr
 = 
iCur
 = -1;

6490 
	`sqlite3_status
(0, &
iCur
, &
iHiwtr
, 
bReset
);

6491 
	`fprintf
(
pArg
->
out
,

6493 
iCur
, 
iHiwtr
);

6494 
iHiwtr
 = 
iCur
 = -1;

6495 
	`sqlite3_status
(9, &
iCur
, &
iHiwtr
, 
bReset
);

6496 
	`fprintf
(
pArg
->
out
, "Number of Outstanding Allocations: %d (max %d)\n",

6497 
iCur
, 
iHiwtr
);

6498 if( 
pArg
->
shellFlgs
 & 0x00002 ){

6499 
iHiwtr
 = 
iCur
 = -1;

6500 
	`sqlite3_status
(1, &
iCur
, &
iHiwtr
, 
bReset
);

6501 
	`fprintf
(
pArg
->
out
,

6503 
iCur
, 
iHiwtr
);

6505 
iHiwtr
 = 
iCur
 = -1;

6506 
	`sqlite3_status
(2, &
iCur
, &
iHiwtr
, 
bReset
);

6507 
	`fprintf
(
pArg
->
out
,

6509 
iCur
, 
iHiwtr
);

6510 if( 
pArg
->
shellFlgs
 & 0x00001 ){

6511 
iHiwtr
 = 
iCur
 = -1;

6512 
	`sqlite3_status
(3, &
iCur
, &
iHiwtr
, 
bReset
);

6513 
	`fprintf
(
pArg
->
out
,

6515 
iCur
, 
iHiwtr
);

6517 
iHiwtr
 = 
iCur
 = -1;

6518 
	`sqlite3_status
(4, &
iCur
, &
iHiwtr
, 
bReset
);

6519 
	`fprintf
(
pArg
->
out
,

6521 
iCur
, 
iHiwtr
);

6522 
iHiwtr
 = 
iCur
 = -1;

6523 
	`sqlite3_status
(5, &
iCur
, &
iHiwtr
, 
bReset
);

6524 
	`fprintf
(
pArg
->
out
, "Largest Allocation: %d bytes\n",

6525 
iHiwtr
);

6526 
iHiwtr
 = 
iCur
 = -1;

6527 
	`sqlite3_status
(7, &
iCur
, &
iHiwtr
, 
bReset
);

6528 
	`fprintf
(
pArg
->
out
, "Largest Pcache Allocation: %d bytes\n",

6529 
iHiwtr
);

6530 
iHiwtr
 = 
iCur
 = -1;

6531 
	`sqlite3_status
(8, &
iCur
, &
iHiwtr
, 
bReset
);

6532 
	`fprintf
(
pArg
->
out
, "Largest Scratch Allocation: %d bytes\n",

6533 
iHiwtr
);

6542 if( 
pArg
 && pArg->
out
 && 
db
 ){

6543 if( 
pArg
->
shellFlgs
 & 0x00004 ){

6544 
iHiwtr
 = 
iCur
 = -1;

6545 
	`sqlite3_db_status
(
db
, 0,

6546 &
iCur
, &
iHiwtr
, 
bReset
);

6547 
	`fprintf
(
pArg
->
out
,

6549 
iCur
, 
iHiwtr
);

6550 
	`sqlite3_db_status
(
db
, 4,

6551 &
iCur
, &
iHiwtr
, 
bReset
);

6552 
	`fprintf
(
pArg
->
out
, "Successful lookaside attempts: %d\n",

6553 
iHiwtr
);

6554 
	`sqlite3_db_status
(
db
, 5,

6555 &
iCur
, &
iHiwtr
, 
bReset
);

6556 
	`fprintf
(
pArg
->
out
, "Lookaside failures due to size: %d\n",

6557 
iHiwtr
);

6558 
	`sqlite3_db_status
(
db
, 6,

6559 &
iCur
, &
iHiwtr
, 
bReset
);

6560 
	`fprintf
(
pArg
->
out
, "Lookaside failures due to OOM: %d\n",

6561 
iHiwtr
);

6563 
iHiwtr
 = 
iCur
 = -1;

6564 
	`sqlite3_db_status
(
db
, 1, &
iCur
, &
iHiwtr
, 
bReset
);

6565 
	`fprintf
(
pArg
->
out
, "Pager Heap Usage: %d bytes\n",

6566 
iCur
);

6567 
iHiwtr
 = 
iCur
 = -1;

6568 
	`sqlite3_db_status
(
db
, 7, &
iCur
, &
iHiwtr
, 1);

6569 
	`fprintf
(
pArg
->
out
, "Page cache hits: %d\n", 
iCur
);

6570 
iHiwtr
 = 
iCur
 = -1;

6571 
	`sqlite3_db_status
(
db
, 8, &
iCur
, &
iHiwtr
, 1);

6572 
	`fprintf
(
pArg
->
out
, "Page cache misses: %d\n", 
iCur
);

6573 
iHiwtr
 = 
iCur
 = -1;

6574 
	`sqlite3_db_status
(
db
, 9, &
iCur
, &
iHiwtr
, 1);

6575 
	`fprintf
(
pArg
->
out
, "Page cache writes: %d\n", 
iCur
);

6576 
iHiwtr
 = 
iCur
 = -1;

6577 
	`sqlite3_db_status
(
db
, 2, &
iCur
, &
iHiwtr
, 
bReset
);

6578 
	`fprintf
(
pArg
->
out
, "Schema Heap Usage: %d bytes\n",

6579 
iCur
);

6580 
iHiwtr
 = 
iCur
 = -1;

6581 
	`sqlite3_db_status
(
db
, 3, &
iCur
, &
iHiwtr
, 
bReset
);

6582 
	`fprintf
(
pArg
->
out
, "Statement Heap/Lookaside Usage: %d bytes\n",

6583 
iCur
);

6586 if( 
pArg
 && pArg->
out
 && 
db
 && pArg->
pStmt
 ){

6587 
iCur
 = 
	`sqlite3_stmt_status
(
pArg
->
pStmt
, 1,

6588 
bReset
);

6589 
	`fprintf
(
pArg
->
out
, "Fullscan Steps: %d\n", 
iCur
);

6590 
iCur
 = 
	`sqlite3_stmt_status
(
pArg
->
pStmt
, 2, 
bReset
);

6591 
	`fprintf
(
pArg
->
out
, "Sort Operations: %d\n", 
iCur
);

6592 
iCur
 = 
	`sqlite3_stmt_status
(
pArg
->
pStmt
, 3,
bReset
);

6593 
	`fprintf
(
pArg
->
out
, "Autoindex Inserts: %d\n", 
iCur
);

6594 
iCur
 = 
	`sqlite3_stmt_status
(
pArg
->
pStmt
, 4, 
bReset
);

6595 
	`fprintf
(
pArg
->
out
, "Virtual Machine Steps: %d\n", 
iCur
);

6599 
	`displayLinuxIoStats
(
pArg
->
out
);

6605 
	}
}

6610 static void 
	$display_scanstats
(

6611 
sqlite3
 *
db
,

6612 
ShellState
 *
pArg


6615 (void)(
db
);

6616 (void)(
pArg
);

6618 
	}
}

6626 static int 
	$str_in_array
(const char *
zStr
, const char **
azArray
){

6627 int 
i
;

6628 for(
i
=0; 
azArray
[i]; i++){

6629 if( 0==
	`strcmp
(
zStr
, 
azArray
[
i
]) ) return 1;

6632 
	}
}

6634 static void 
	$explain_data_prepare
(
ShellState
 *
p
, 
sqlite3_stmt
 *
pSql
){

6635 const char *
zSql
;

6636 const char *
z
;

6637 int *
abYield
 = 0;

6638 int 
nAlloc
 = 0;

6639 int 
iOp
;

6641 const char *
azNext
[] = { "Next", "Prev", "VPrev", "VNext", "SorterNext",

6643 const char *
azYield
[] = { "Yield", "SeekLT", "SeekGT", "RowSetRead",

6645 const char *
azGoto
[] = { "Goto", 0 };

6649 if( 
	`sqlite3_column_count
(
pSql
)!=8 ){

6650 
p
->
cMode
 = p->
mode
;

6653 
zSql
 = 
	`sqlite3_sql
(
pSql
);

6654 if( 
zSql
==0 ) return;

6655 for(
z
=
zSql
; *z==' ' || *z=='\t' || *z=='\n' || *z=='\f' || *z=='\r'; z++);

6656 if( 
	`sqlite3_strnicmp
(
z
, "explain", 7) ){

6657 
p
->
cMode
 = p->
mode
;

6661 for(
iOp
=0; 100==
	`sqlite3_step
(
pSql
); iOp++){

6662 int 
i
;

6663 int 
iAddr
 = 
	`sqlite3_column_int
(
pSql
, 0);

6664 const char *
zOp
 = (const char*)
	`sqlite3_column_text
(
pSql
, 1);

6671 int 
p2
 = 
	`sqlite3_column_int
(
pSql
, 3);

6672 int 
p2op
 = (
p2
 + (
iOp
-
iAddr
));

6675 if( 
iOp
>=
nAlloc
 ){

6676 if( 
iOp
==0 ){

6679 static const char *
explainCols
[] = {

6681 int 
jj
;

6682 for(
jj
=0; jj<(int)(sizeof(
explainCols
)/sizeof(explainCols[0])); jj++){

6683 if( 
	`strcmp
(
	`sqlite3_column_name
(
pSql
,
jj
),
explainCols
[jj])!=0 ){

6684 
p
->
cMode
 = p->
mode
;

6685 
	`sqlite3_reset
(
pSql
);

6690 
nAlloc
 += 100;

6691 
p
->
aiIndent
 = (int*)
	`sqlite3_realloc64
(p->aiIndent, 
nAlloc
*sizeof(int));

6692 
abYield
 = (int*)
	`sqlite3_realloc64
(abYield, 
nAlloc
*sizeof(int));

6694 
abYield
[
iOp
] = 
	`str_in_array
(
zOp
, 
azYield
);

6695 
p
->
aiIndent
[
iOp
] = 0;

6696 
p
->
nIndent
 = 
iOp
+1;

6698 if( 
	`str_in_array
(
zOp
, 
azNext
) ){

6699 for(
i
=
p2op
; i<
iOp
; i++) 
p
->
aiIndent
[i] += 2;

6701 if( 
	`str_in_array
(
zOp
, 
azGoto
) && 
p2op
<
p
->
nIndent


6702 && (
abYield
[
p2op
] || 
	`sqlite3_column_int
(
pSql
, 2))

6704 for(
i
=
p2op
+1; i<
iOp
; i++) 
p
->
aiIndent
[i] += 2;

6708 
p
->
iIndent
 = 0;

6709 
	`sqlite3_free
(
abYield
);

6710 
	`sqlite3_reset
(
pSql
);

6711 
	}
}

6716 static void 
	$explain_data_delete
(
ShellState
 *
p
){

6717 
	`sqlite3_free
(
p
->
aiIndent
);

6718 
p
->
aiIndent
 = 0;

6719 
p
->
nIndent
 = 0;

6720 
p
->
iIndent
 = 0;

6721 
	}
}

6723 static int 
shell_exec
(

6724 
sqlite3
 *
db
,

6725 const char *
zSql
,

6726 int (*
xCallback
)(void*,int,char**,char**,int*),

6728 
ShellState
 *
pArg
,

6729 char **
pzErrMsg


6731 
sqlite3_stmt
 *
pStmt
 = ((void *)0);

6732 int 
rc
 = 0;

6733 int 
rc2
;

6734 const char *
zLeftover
;

6736 if( 
pzErrMsg
 ){

6737 *
pzErrMsg
 = ((void *)0);

6740 while( 
zSql
[0] && (0 == 
rc
) ){

6741 
rc
 = 
	`sqlite3_prepare_v2
(
db
, 
zSql
, -1, &
pStmt
, &
zLeftover
);

6742 if( 0 != 
rc
 ){

6743 if( 
pzErrMsg
 ){

6744 *
pzErrMsg
 = 
	`save_err_msg
(
db
);

6747 if( !
pStmt
 ){

6749 
zSql
 = 
zLeftover
;

6750 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)
zSql
[0]))] & (unsigned short int) 
_ISspace
) ) zSql++;

6755 if( 
pArg
 ){

6756 
pArg
->
pStmt
 = pStmt;

6757 
pArg
->
cnt
 = 0;

6761 if( 
pArg
 && pArg->
echoOn
 ){

6762 const char *
zStmtSql
 = 
	`sqlite3_sql
(
pStmt
);

6763 
	`fprintf
(
pArg
->
out
, "%s\n", 
zStmtSql
 ? zStmtSql : 
zSql
);

6767 if( 
pArg
 && pArg->
autoEQP
 ){

6768 
sqlite3_stmt
 *
pExplain
;

6769 char *
zEQP
 = 
	`sqlite3_mprintf
("EXPLAIN QUERY PLAN %s",

6770 
	`sqlite3_sql
(
pStmt
));

6771 
rc
 = 
	`sqlite3_prepare_v2
(
db
, 
zEQP
, -1, &
pExplain
, 0);

6772 if( 
rc
==0 ){

6773 while( 
	`sqlite3_step
(
pExplain
)==100 ){

6774 
	`fprintf
(
pArg
->
out
,"--EQP-- %d,",
	`sqlite3_column_int
(
pExplain
, 0));

6775 
	`fprintf
(
pArg
->
out
,"%d,", 
	`sqlite3_column_int
(
pExplain
, 1));

6776 
	`fprintf
(
pArg
->
out
,"%d,", 
	`sqlite3_column_int
(
pExplain
, 2));

6777 
	`fprintf
(
pArg
->
out
,"%s\n", 
	`sqlite3_column_text
(
pExplain
, 3));

6780 
	`sqlite3_finalize
(
pExplain
);

6781 
	`sqlite3_free
(
zEQP
);

6784 if( 
pArg
 ){

6785 
pArg
->
cMode
 = pArg->
mode
;

6786 if( 
pArg
->
autoExplain


6787 && 
	`sqlite3_column_count
(
pStmt
)==8

6788 && 
	`sqlite3_strlike
("%EXPLAIN%", 
	`sqlite3_sql
(
pStmt
),0)==0

6790 
pArg
->
cMode
 = 8;

6795 if( 
pArg
->
cMode
==8 ){

6796 
	`explain_data_prepare
(
pArg
, 
pStmt
);

6803 
rc
 = 
	`sqlite3_step
(
pStmt
);

6805 if( 100 == 
rc
 ){

6807 if( 
xCallback
 ){

6809 int 
nCol
 = 
	`sqlite3_column_count
(
pStmt
);

6810 void *
pData
 = 
	`sqlite3_malloc64
(3*
nCol
*sizeof(const char*) + 1);

6811 if( !
pData
 ){

6812 
rc
 = 7;

6814 char **
azCols
 = (char **)
pData
;

6815 char **
azVals
 = &
azCols
[
nCol
];

6816 int *
aiTypes
 = (int *)&
azVals
[
nCol
];

6817 int 
i
, 
x
;

6818 ((sizeof(int) <= sizeof(char *)) ? (void) (0) : 
	`__assert_fail
 ("sizeof(int) <= sizeof(char *)", "shell.c", 1728, 
__PRETTY_FUNCTION__
));

6820 for(
i
=0; i<
nCol
; i++){

6821 
azCols
[
i
] = (char *)
	`sqlite3_column_name
(
pStmt
, i);

6825 for(
i
=0; i<
nCol
; i++){

6826 
aiTypes
[
i
] = 
x
 = 
	`sqlite3_column_type
(
pStmt
, i);

6827 if( 
x
==4 && 
pArg
 && pArg->
cMode
==5 ){

6828 
azVals
[
i
] = "";

6830 
azVals
[
i
] = (char*)
	`sqlite3_column_text
(
pStmt
, i);

6832 if( !
azVals
[
i
] && (
aiTypes
[i]!=5) ){

6833 
rc
 = 7;

6839 if( 100 == 
rc
 ){

6841 if( 
	`xCallback
(
pArg
, 
nCol
, 
azVals
, 
azCols
, 
aiTypes
) ){

6842 
rc
 = 4;

6844 
rc
 = 
	`sqlite3_step
(
pStmt
);

6847 } while( 100 == 
rc
 );

6848 
	`sqlite3_free
(
pData
);

6852 
rc
 = 
	`sqlite3_step
(
pStmt
);

6853 } while( 
rc
 == 100 );

6857 
	`explain_data_delete
(
pArg
);

6860 if( 
pArg
 && pArg->
statsOn
 ){

6861 
	`display_stats
(
db
, 
pArg
, 0);

6865 if( 
pArg
 && pArg->
scanstatsOn
 ){

6866 
	`display_scanstats
(
db
, 
pArg
);

6872 
rc2
 = 
	`sqlite3_finalize
(
pStmt
);

6873 if( 
rc
!=7 ) rc = 
rc2
;

6874 if( 
rc
==0 ){

6875 
zSql
 = 
zLeftover
;

6876 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)
zSql
[0]))] & (unsigned short int) 
_ISspace
) ) zSql++;

6877 }else if( 
pzErrMsg
 ){

6878 *
pzErrMsg
 = 
	`save_err_msg
(
db
);

6882 if( 
pArg
 ){

6883 
pArg
->
pStmt
 = ((void *)0);

6888 return 
rc
;

6889 
	}
}

6891 static int 
	$dump_callback
(void *
pArg
, int 
nArg
, char **
azArg
, char **
azCol
){

6892 int 
rc
;

6893 const char *
zTable
;

6894 const char *
zType
;

6895 const char *
zSql
;

6896 const char *
zPrepStmt
 = 0;

6897 
ShellState
 *
p
 = (ShellState *)
pArg
;

6899 (void)(
azCol
);

6900 if( 
nArg
!=3 ) return 1;

6901 
zTable
 = 
azArg
[0];

6902 
zType
 = 
azArg
[1];

6903 
zSql
 = 
azArg
[2];

6905 if( 
	`strcmp
(
zTable
, "sqlite_sequence")==0 ){

6906 
zPrepStmt
 = "DELETE FROM sqlite_sequence;\n";

6907 }else if( 
	`sqlite3_strglob
("sqlite_stat?", 
zTable
)==0 ){

6908 
	`fprintf
(
p
->
out
, "ANALYZE sqlite_master;\n");

6909 }else if( 
	`strncmp
(
zTable
, "sqlite_", 7)==0 ){

6911 }else if( 
	`strncmp
(
zSql
, "CREATE VIRTUAL TABLE", 20)==0 ){

6912 char *
zIns
;

6913 if( !
p
->
writableSchema
 ){

6914 
	`fprintf
(
p
->
out
, "PRAGMA writable_schema=ON;\n");

6915 
p
->
writableSchema
 = 1;

6917 
zIns
 = 
	`sqlite3_mprintf
(

6920 
zTable
, zTable, 
zSql
);

6921 
	`fprintf
(
p
->
out
, "%s\n", 
zIns
);

6922 
	`sqlite3_free
(
zIns
);

6925 
	`fprintf
(
p
->
out
, "%s;\n", 
zSql
);

6928 if( 
	`strcmp
(
zType
, "table")==0 ){

6929 
sqlite3_stmt
 *
pTableInfo
 = 0;

6930 char *
zSelect
 = 0;

6931 char *
zTableInfo
 = 0;

6932 char *
zTmp
 = 0;

6933 int 
nRow
 = 0;

6935 
zTableInfo
 = 
	`appendText
(zTableInfo, "PRAGMA table_info(", 0);

6936 
zTableInfo
 = 
	`appendText
(zTableInfo, 
zTable
, '"');

6937 
zTableInfo
 = 
	`appendText
(zTableInfo, ");", 0);

6939 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zTableInfo
, -1, &
pTableInfo
, 0);

6940 
	`free
(
zTableInfo
);

6941 if( 
rc
!=0 || !
pTableInfo
 ){

6945 
zSelect
 = 
	`appendText
(zSelect, "SELECT 'INSERT INTO ' || ", 0);

6948 
zTmp
 = 
	`appendText
(zTmp, 
zTable
, '"');

6949 if( 
zTmp
 ){

6950 
zSelect
 = 
	`appendText
(zSelect, 
zTmp
, '\'');

6951 
	`free
(
zTmp
);

6953 
zSelect
 = 
	`appendText
(zSelect, " || ' VALUES(' || ", 0);

6954 
rc
 = 
	`sqlite3_step
(
pTableInfo
);

6955 while( 
rc
==100 ){

6956 const char *
zText
 = (const char *)
	`sqlite3_column_text
(
pTableInfo
, 1);

6957 
zSelect
 = 
	`appendText
(zSelect, "quote(", 0);

6958 
zSelect
 = 
	`appendText
(zSelect, 
zText
, '"');

6959 
rc
 = 
	`sqlite3_step
(
pTableInfo
);

6960 if( 
rc
==100 ){

6961 
zSelect
 = 
	`appendText
(zSelect, "), ", 0);

6963 
zSelect
 = 
	`appendText
(zSelect, ") ", 0);

6965 
nRow
++;

6967 
rc
 = 
	`sqlite3_finalize
(
pTableInfo
);

6968 if( 
rc
!=0 || 
nRow
==0 ){

6969 
	`free
(
zSelect
);

6972 
zSelect
 = 
	`appendText
(zSelect, "|| ')' FROM ", 0);

6973 
zSelect
 = 
	`appendText
(zSelect, 
zTable
, '"');

6975 
rc
 = 
	`run_table_dump_query
(
p
, 
zSelect
, 
zPrepStmt
);

6976 if( 
rc
==11 ){

6977 
zSelect
 = 
	`appendText
(zSelect, " ORDER BY rowid DESC", 0);

6978 
	`run_table_dump_query
(
p
, 
zSelect
, 0);

6980 
	`free
(
zSelect
);

6983 
	}
}

6985 static int 
	$run_schema_dump_query
(

6986 
ShellState
 *
p
,

6987 const char *
zQuery


6989 int 
rc
;

6990 char *
zErr
 = 0;

6991 
rc
 = 
	`sqlite3_exec
(
p
->
db
, 
zQuery
, 
dump_callback
, p, &
zErr
);

6992 if( 
rc
==11 ){

6993 char *
zQ2
;

6994 int 
len
 = 
	`strlen30
(
zQuery
);

6995 
	`fprintf
(
p
->
out
, "/****** CORRUPTION ERROR *******/\n");

6996 if( 
zErr
 ){

6997 
	`fprintf
(
p
->
out
, "/****** %s ******/\n", 
zErr
);

6998 
	`sqlite3_free
(
zErr
);

6999 
zErr
 = 0;

7001 
zQ2
 = 
	`malloc
( 
len
+100 );

7002 if( 
zQ2
==0 ) return 
rc
;

7003 
	`sqlite3_snprintf
(
len
+100, 
zQ2
, "%s ORDER BY rowid DESC", 
zQuery
);

7004 
rc
 = 
	`sqlite3_exec
(
p
->
db
, 
zQ2
, 
dump_callback
, p, &
zErr
);

7005 if( 
rc
 ){

7006 
	`fprintf
(
p
->
out
, "/****** ERROR: %s ******/\n", 
zErr
);

7008 
rc
 = 11;

7010 
	`sqlite3_free
(
zErr
);

7011 
	`free
(
zQ2
);

7013 return 
rc
;

7014 
	}
}

7019 static char 
	gzHelp
[] =

7093 static int 
process_input
(
ShellState
 *
p
, 
FILE
 *
in
);

7099 static void 
	$readfileFunc
(

7100 
sqlite3_context
 *
context
,

7101 int 
argc
,

7102 
sqlite3_value
 **
argv


7104 const char *
zName
;

7105 
FILE
 *
in
;

7106 long 
nIn
;

7107 void *
pBuf
;

7109 (void)(
argc
);

7110 
zName
 = (const char*)
	`sqlite3_value_text
(
argv
[0]);

7111 if( 
zName
==0 ) return;

7112 
in
 = 
	`fopen
(
zName
, "rb");

7113 if( 
in
==0 ) return;

7114 
	`fseek
(
in
, 0, 2);

7115 
nIn
 = 
	`ftell
(
in
);

7116 
	`rewind
(
in
);

7117 
pBuf
 = 
	`sqlite3_malloc64
( 
nIn
 );

7118 if( 
pBuf
 && 1==
	`fread
(pBuf, 
nIn
, 1, 
in
) ){

7119 
	`sqlite3_result_blob
(
context
, 
pBuf
, 
nIn
, 
sqlite3_free
);

7121 
	`sqlite3_free
(
pBuf
);

7123 
	`fclose
(
in
);

7124 
	}
}

7132 static void 
	$writefileFunc
(

7133 
sqlite3_context
 *
context
,

7134 int 
argc
,

7135 
sqlite3_value
 **
argv


7137 
FILE
 *
out
;

7138 const char *
z
;

7139 
sqlite3_int64
 
rc
;

7140 const char *
zFile
;

7142 (void)(
argc
);

7143 
zFile
 = (const char*)
	`sqlite3_value_text
(
argv
[0]);

7144 if( 
zFile
==0 ) return;

7145 
out
 = 
	`fopen
(
zFile
, "wb");

7146 if( 
out
==0 ) return;

7147 
z
 = (const char*)
	`sqlite3_value_blob
(
argv
[1]);

7148 if( 
z
==0 ){

7149 
rc
 = 0;

7151 
rc
 = 
	`fwrite
(
z
, 1, 
	`sqlite3_value_bytes
(
argv
[1]), 
out
);

7153 
	`fclose
(
out
);

7154 
	`sqlite3_result_int64
(
context
, 
rc
);

7155 
	}
}

7161 static void 
	$open_db
(
ShellState
 *
p
, int 
keepAlive
){

7162 if( 
p
->
db
==0 ){

7163 
	`sqlite3_initialize
();

7164 
	`sqlite3_open
(
p
->
zDbFilename
, &p->
db
);

7165 
globalDb
 = 
p
->
db
;

7166 if( 
p
->
db
 && 
	`sqlite3_errcode
(p->db)==0 ){

7167 
	`sqlite3_create_function
(
p
->
db
, "shellstatic", 0, 1, 0,

7168 
shellstaticFunc
, 0, 0);

7170 if( 
p
->
db
==0 || 0!=
	`sqlite3_errcode
(p->db) ){

7171 
	`fprintf
(
stderr
,"Error: unable to open database \"%s\": %s\n",

7172 
p
->
zDbFilename
, 
	`sqlite3_errmsg
(p->
db
));

7173 if( 
keepAlive
 ) return;

7174 
	`exit
(1);

7177 
	`sqlite3_enable_load_extension
(
p
->
db
, 1);

7179 
	`sqlite3_create_function
(
p
->
db
, "readfile", 1, 1, 0,

7180 
readfileFunc
, 0, 0);

7181 
	`sqlite3_create_function
(
p
->
db
, "writefile", 2, 1, 0,

7182 
writefileFunc
, 0, 0);

7184 
	}
}

7186 static void 
	$resolve_backslashes
(char *
z
){

7187 int 
i
, 
j
;

7188 char 
c
;

7189 while( *
z
 && *z!='\\' ) z++;

7190 for(
i
=
j
=0; (
c
 = 
z
[i])!=0; i++, j++){

7191 if( 
c
=='\\' && 
z
[
i
+1]!=0 ){

7192 
c
 = 
z
[++
i
];

7193 if( 
c
=='a' ){

7194 
c
 = '\a';

7195 }else if( 
c
=='b' ){

7196 
c
 = '\b';

7197 }else if( 
c
=='t' ){

7198 
c
 = '\t';

7199 }else if( 
c
=='n' ){

7200 
c
 = '\n';

7201 }else if( 
c
=='v' ){

7202 
c
 = '\v';

7203 }else if( 
c
=='f' ){

7204 
c
 = '\f';

7205 }else if( 
c
=='r' ){

7206 
c
 = '\r';

7207 }else if( 
c
=='"' ){

7208 
c
 = '"';

7209 }else if( 
c
=='\'' ){

7210 
c
 = '\'';

7211 }else if( 
c
=='\\' ){

7212 
c
 = '\\';

7213 }else if( 
c
>='0' && c<='7' ){

7214 
c
 -= '0';

7215 if( 
z
[
i
+1]>='0' && z[i+1]<='7' ){

7216 
i
++;

7217 
c
 = (c<<3) + 
z
[
i
] - '0';

7218 if( 
z
[
i
+1]>='0' && z[i+1]<='7' ){

7219 
i
++;

7220 
c
 = (c<<3) + 
z
[
i
] - '0';

7225 
z
[
j
] = 
c
;

7227 if( 
j
<
i
 ) 
z
[j] = 0;

7228 
	}
}

7234 static int 
	$hexDigitValue
(char 
c
){

7235 if( 
c
>='0' && c<='9' ) return c - '0';

7236 if( 
c
>='a' && c<='f' ) return c - 'a' + 10;

7237 if( 
c
>='A' && c<='F' ) return c - 'A' + 10;

7239 
	}
}

7244 static 
sqlite3_int64
 
	$integerValue
(const char *
zArg
){

7245 
sqlite3_int64
 
v
 = 0;

7246 static const struct { char *
zSuffix
; int 
iMult
; } 
aMult
[] = {

7257 int 
i
;

7258 int 
isNeg
 = 0;

7259 if( 
zArg
[0]=='-' ){

7260 
isNeg
 = 1;

7261 
zArg
++;

7262 }else if( 
zArg
[0]=='+' ){

7263 
zArg
++;

7265 if( 
zArg
[0]=='0' && zArg[1]=='x' ){

7266 int 
x
;

7267 
zArg
 += 2;

7268 while( (
x
 = 
	`hexDigitValue
(
zArg
[0]))>=0 ){

7269 
v
 = (v<<4) + 
x
;

7270 
zArg
++;

7273 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)
zArg
[0]))] & (unsigned short int) 
_ISdigit
) ){

7274 
v
 = v*10 + 
zArg
[0] - '0';

7275 
zArg
++;

7278 for(
i
=0; i<(int)(sizeof(
aMult
)/sizeof(aMult[0])); i++){

7279 if( 
	`sqlite3_stricmp
(
aMult
[
i
].
zSuffix
, 
zArg
)==0 ){

7280 
v
 *= 
aMult
[
i
].
iMult
;

7284 return 
isNeg
? -
v
 : v;

7285 
	}
}

7291 static int 
	$booleanValue
(char *
zArg
){

7292 int 
i
;

7293 if( 
zArg
[0]=='0' && zArg[1]=='x' ){

7294 for(
i
=2; 
	`hexDigitValue
(
zArg
[i])>=0; i++){}

7296 for(
i
=0; 
zArg
[i]>='0' && zArg[i]<='9'; i++){}

7298 if( 
i
>0 && 
zArg
[i]==0 ) return (int)(
	`integerValue
(zArg) & 0xffffffff);

7299 if( 
	`sqlite3_stricmp
(
zArg
, "on")==0 || sqlite3_stricmp(zArg,"yes")==0 ){

7302 if( 
	`sqlite3_stricmp
(
zArg
, "off")==0 || sqlite3_stricmp(zArg,"no")==0 ){

7305 
	`fprintf
(
stderr
, "ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n",

7306 
zArg
);

7308 
	}
}

7313 static void 
	$output_file_close
(
FILE
 *
f
){

7314 if( 
f
 && f!=
stdout
 && f!=
stderr
 ) 
	`fclose
(f);

7315 
	}
}

7322 static 
FILE
 *
	$output_file_open
(const char *
zFile
){

7323 
FILE
 *
f
;

7324 if( 
	`strcmp
(
zFile
,"stdout")==0 ){

7325 
f
 = 
stdout
;

7326 }else if( 
	`strcmp
(
zFile
, "stderr")==0 ){

7327 
f
 = 
stderr
;

7328 }else if( 
	`strcmp
(
zFile
, "off")==0 ){

7329 
f
 = 0;

7331 
f
 = 
	`fopen
(
zFile
, "wb");

7332 if( 
f
==0 ){

7333 
	`fprintf
(
stderr
, "Error: cannot open \"%s\"\n", 
zFile
);

7336 return 
f
;

7337 
	}
}

7342 static void 
	$sql_trace_callback
(void *
pArg
, const char *
z
){

7343 
FILE
 *
f
 = (FILE*)
pArg
;

7344 if( 
f
 ){

7345 int 
i
 = (int)
	`strlen
(
z
);

7346 while( 
i
>0 && 
z
[i-1]==';' ){ i--; }

7347 
	`fprintf
(
f
, "%.*s;\n", 
i
, 
z
);

7349 
	}
}

7355 static void 
	$test_breakpoint
(void){

7356 static int 
nCall
 = 0;

7357 
nCall
++;

7358 
	}
}

7363 typedef struct 
ImportCtx
 
	tImportCtx
;

7364 struct 
	sImportCtx
 {

7365 const char *
	mzFile
;

7366 
FILE
 *
	min
;

7367 char *
	mz
;

7368 int 
	mn
;

7369 int 
	mnAlloc
;

7370 int 
	mnLine
;

7371 int 
	mcTerm
;

7372 int 
	mcColSep
;

7373 int 
	mcRowSep
;

7377 static void 
	$import_append_char
(
ImportCtx
 *
p
, int 
c
){

7378 if( 
p
->
n
+1>=p->
nAlloc
 ){

7379 
p
->
nAlloc
 += p->nAlloc + 100;

7380 
p
->
z
 = 
	`sqlite3_realloc64
(p->z, p->
nAlloc
);

7381 if( 
p
->
z
==0 ){

7382 
	`fprintf
(
stderr
, "out of memory\n");

7383 
	`exit
(1);

7386 
p
->
z
[p->
n
++] = (char)
c
;

7387 
	}
}

7389 static char * 
	$csv_read_one_field
(
ImportCtx
 *
p
){

7390 int 
c
;

7391 int 
cSep
 = 
p
->
cColSep
;

7392 int 
rSep
 = 
p
->
cRowSep
;

7393 
p
->
n
 = 0;

7394 
c
 = 
	`fgetc
(
p
->
in
);

7395 if( 
c
==(-1) || 
seenInterrupt
 ){

7396 
p
->
cTerm
 = (-1);

7399 if( 
c
=='"' ){

7400 int 
pc
, 
ppc
;

7401 int 
startLine
 = 
p
->
nLine
;

7402 int 
cQuote
 = 
c
;

7403 
pc
 = 
ppc
 = 0;

7405 
c
 = 
	`fgetc
(
p
->
in
);

7406 if( 
c
==
rSep
 ) 
p
->
nLine
++;

7407 if( 
c
==
cQuote
 ){

7408 if( 
pc
==
cQuote
 ){

7409 
pc
 = 0;

7413 if( (
c
==
cSep
 && 
pc
==
cQuote
)

7414 || (
c
==
rSep
 && 
pc
==
cQuote
)

7415 || (
c
==
rSep
 && 
pc
=='\r' && 
ppc
==
cQuote
)

7416 || (
c
==(-1) && 
pc
==
cQuote
)

7418 do{ 
p
->
n
--; }while( p->
z
[p->n]!=
cQuote
 );

7419 
p
->
cTerm
 = 
c
;

7422 if( 
pc
==
cQuote
 && 
c
!='\r' ){

7423 
	`fprintf
(
stderr
, "%s:%d: unescaped %c character\n",

7424 
p
->
zFile
, p->
nLine
, 
cQuote
);

7426 if( 
c
==(-1) ){

7427 
	`fprintf
(
stderr
, "%s:%d: unterminated %c-quoted field\n",

7428 
p
->
zFile
, 
startLine
, 
cQuote
);

7429 
p
->
cTerm
 = 
c
;

7432 
	`import_append_char
(
p
, 
c
);

7433 
ppc
 = 
pc
;

7434 
pc
 = 
c
;

7437 while( 
c
!=(-1) && c!=
cSep
 && c!=
rSep
 ){

7438 
	`import_append_char
(
p
, 
c
);

7439 
c
 = 
	`fgetc
(
p
->
in
);

7441 if( 
c
==
rSep
 ){

7442 
p
->
nLine
++;

7443 if( 
p
->
n
>0 && p->
z
[p->n-1]=='\r' ) p->n--;

7445 
p
->
cTerm
 = 
c
;

7447 if( 
p
->
z
 ) p->z[p->
n
] = 0;

7448 return 
p
->
z
;

7449 
	}
}

7451 static char * 
	$ascii_read_one_field
(
ImportCtx
 *
p
){

7452 int 
c
;

7453 int 
cSep
 = 
p
->
cColSep
;

7454 int 
rSep
 = 
p
->
cRowSep
;

7455 
p
->
n
 = 0;

7456 
c
 = 
	`fgetc
(
p
->
in
);

7457 if( 
c
==(-1) || 
seenInterrupt
 ){

7458 
p
->
cTerm
 = (-1);

7461 while( 
c
!=(-1) && c!=
cSep
 && c!=
rSep
 ){

7462 
	`import_append_char
(
p
, 
c
);

7463 
c
 = 
	`fgetc
(
p
->
in
);

7465 if( 
c
==
rSep
 ){

7466 
p
->
nLine
++;

7468 
p
->
cTerm
 = 
c
;

7469 if( 
p
->
z
 ) p->z[p->
n
] = 0;

7470 return 
p
->
z
;

7471 
	}
}

7478 static void 
	$tryToCloneData
(

7479 
ShellState
 *
p
,

7480 
sqlite3
 *
newDb
,

7481 const char *
zTable


7483 
sqlite3_stmt
 *
pQuery
 = 0;

7484 
sqlite3_stmt
 *
pInsert
 = 0;

7485 char *
zQuery
 = 0;

7486 char *
zInsert
 = 0;

7487 int 
rc
;

7488 int 
i
, 
j
, 
n
;

7489 int 
nTable
 = (int)
	`strlen
(
zTable
);

7490 int 
k
 = 0;

7491 int 
cnt
 = 0;

7492 const int 
spinRate
 = 10000;

7494 
zQuery
 = 
	`sqlite3_mprintf
("SELECT * FROM \"%w\"", 
zTable
);

7495 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zQuery
, -1, &
pQuery
, 0);

7496 if( 
rc
 ){

7497 
	`fprintf
(
stderr
, "Error %d: %s on [%s]\n",

7498 
	`sqlite3_extended_errcode
(
p
->
db
), 
	`sqlite3_errmsg
(p->db),

7499 
zQuery
);

7500 goto 
end_data_xfer
;

7502 
n
 = 
	`sqlite3_column_count
(
pQuery
);

7503 
zInsert
 = 
	`sqlite3_malloc64
(200 + 
nTable
 + 
n
*3);

7504 if( 
zInsert
==0 ){

7505 
	`fprintf
(
stderr
, "out of memory\n");

7506 goto 
end_data_xfer
;

7508 
	`sqlite3_snprintf
(200+
nTable
,
zInsert
,

7509 "INSERT OR IGNORE INTO \"%s\" VALUES(?", 
zTable
);

7510 
i
 = (int)
	`strlen
(
zInsert
);

7511 for(
j
=1; j<
n
; j++){

7512 
	`memcpy
(
zInsert
+
i
, ",?", 2);

7513 
i
 += 2;

7515 
	`memcpy
(
zInsert
+
i
, ");", 3);

7516 
rc
 = 
	`sqlite3_prepare_v2
(
newDb
, 
zInsert
, -1, &
pInsert
, 0);

7517 if( 
rc
 ){

7518 
	`fprintf
(
stderr
, "Error %d: %s on [%s]\n",

7519 
	`sqlite3_extended_errcode
(
newDb
), 
	`sqlite3_errmsg
(newDb),

7520 
zQuery
);

7521 goto 
end_data_xfer
;

7523 for(
k
=0; k<2; k++){

7524 while( (
rc
 = 
	`sqlite3_step
(
pQuery
))==100 ){

7525 for(
i
=0; i<
n
; i++){

7526 switch( 
	`sqlite3_column_type
(
pQuery
, 
i
) ){

7528 
	`sqlite3_bind_null
(
pInsert
, 
i
+1);

7532 
	`sqlite3_bind_int64
(
pInsert
, 
i
+1, 
	`sqlite3_column_int64
(
pQuery
,i));

7536 
	`sqlite3_bind_double
(
pInsert
, 
i
+1, 
	`sqlite3_column_double
(
pQuery
,i));

7540 
	`sqlite3_bind_text
(
pInsert
, 
i
+1,

7541 (const char*)
	`sqlite3_column_text
(
pQuery
,
i
),

7542 -1, ((
sqlite3_destructor_type
)0));

7546 
	`sqlite3_bind_blob
(
pInsert
, 
i
+1, 
	`sqlite3_column_blob
(
pQuery
,i),

7547 
	`sqlite3_column_bytes
(
pQuery
,
i
),

7548 ((
sqlite3_destructor_type
)0));

7553 
rc
 = 
	`sqlite3_step
(
pInsert
);

7554 if( 
rc
!=0 && rc!=100 && rc!=101 ){

7555 
	`fprintf
(
stderr
, "Error %d: %s\n", 
	`sqlite3_extended_errcode
(
newDb
),

7556 
	`sqlite3_errmsg
(
newDb
));

7558 
	`sqlite3_reset
(
pInsert
);

7559 
cnt
++;

7560 if( (
cnt
%
spinRate
)==0 ){

7561 
	`printf
("%c\b", "|/-\\"[(
cnt
/
spinRate
)%4]);

7562 
	`fflush
(
stdout
);

7565 if( 
rc
==101 ) break;

7566 
	`sqlite3_finalize
(
pQuery
);

7567 
	`sqlite3_free
(
zQuery
);

7568 
zQuery
 = 
	`sqlite3_mprintf
("SELECT * FROM \"%w\" ORDER BY rowid DESC;",

7569 
zTable
);

7570 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zQuery
, -1, &
pQuery
, 0);

7571 if( 
rc
 ){

7572 
	`fprintf
(
stderr
, "Warning: cannot step \"%s\" backwards", 
zTable
);

7577 
end_data_xfer
:

7578 
	`sqlite3_finalize
(
pQuery
);

7579 
	`sqlite3_finalize
(
pInsert
);

7580 
	`sqlite3_free
(
zQuery
);

7581 
	`sqlite3_free
(
zInsert
);

7582 
	}
}

7584 static void 
tryToCloneSchema
(

7585 
ShellState
 *
p
,

7586 
sqlite3
 *
newDb
,

7587 const char *
zWhere
,

7588 void (*
xForEach
)(
ShellState
*,
sqlite3
*,const char*)

7590 
sqlite3_stmt
 *
pQuery
 = 0;

7591 char *
zQuery
 = 0;

7592 int 
rc
;

7593 const unsigned char *
zName
;

7594 const unsigned char *
zSql
;

7595 char *
zErrMsg
 = 0;

7597 
zQuery
 = 
	`sqlite3_mprintf
("SELECT name, sql FROM sqlite_master"

7598 " WHERE %s", 
zWhere
);

7599 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zQuery
, -1, &
pQuery
, 0);

7600 if( 
rc
 ){

7601 
	`fprintf
(
stderr
, "Error: (%d) %s on [%s]\n",

7602 
	`sqlite3_extended_errcode
(
p
->
db
), 
	`sqlite3_errmsg
(p->db),

7603 
zQuery
);

7604 goto 
end_schema_xfer
;

7606 while( (
rc
 = 
	`sqlite3_step
(
pQuery
))==100 ){

7607 
zName
 = 
	`sqlite3_column_text
(
pQuery
, 0);

7608 
zSql
 = 
	`sqlite3_column_text
(
pQuery
, 1);

7609 
	`printf
("%s... ", 
zName
); 
	`fflush
(
stdout
);

7610 
	`sqlite3_exec
(
newDb
, (const char*)
zSql
, 0, 0, &
zErrMsg
);

7611 if( 
zErrMsg
 ){

7612 
	`fprintf
(
stderr
, "Error: %s\nSQL: [%s]\n", 
zErrMsg
, 
zSql
);

7613 
	`sqlite3_free
(
zErrMsg
);

7614 
zErrMsg
 = 0;

7616 if( 
xForEach
 ){

7617 
	`xForEach
(
p
, 
newDb
, (const char*)
zName
);

7619 
	`printf
("done\n");

7621 if( 
rc
!=101 ){

7622 
	`sqlite3_finalize
(
pQuery
);

7623 
	`sqlite3_free
(
zQuery
);

7624 
zQuery
 = 
	`sqlite3_mprintf
("SELECT name, sql FROM sqlite_master"

7625 " WHERE %s ORDER BY rowid DESC", 
zWhere
);

7626 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zQuery
, -1, &
pQuery
, 0);

7627 if( 
rc
 ){

7628 
	`fprintf
(
stderr
, "Error: (%d) %s on [%s]\n",

7629 
	`sqlite3_extended_errcode
(
p
->
db
), 
	`sqlite3_errmsg
(p->db),

7630 
zQuery
);

7631 goto 
end_schema_xfer
;

7633 while( (
rc
 = 
	`sqlite3_step
(
pQuery
))==100 ){

7634 
zName
 = 
	`sqlite3_column_text
(
pQuery
, 0);

7635 
zSql
 = 
	`sqlite3_column_text
(
pQuery
, 1);

7636 
	`printf
("%s... ", 
zName
); 
	`fflush
(
stdout
);

7637 
	`sqlite3_exec
(
newDb
, (const char*)
zSql
, 0, 0, &
zErrMsg
);

7638 if( 
zErrMsg
 ){

7639 
	`fprintf
(
stderr
, "Error: %s\nSQL: [%s]\n", 
zErrMsg
, 
zSql
);

7640 
	`sqlite3_free
(
zErrMsg
);

7641 
zErrMsg
 = 0;

7643 if( 
xForEach
 ){

7644 
	`xForEach
(
p
, 
newDb
, (const char*)
zName
);

7646 
	`printf
("done\n");

7649 
end_schema_xfer
:

7650 
	`sqlite3_finalize
(
pQuery
);

7651 
	`sqlite3_free
(
zQuery
);

7652 
	}
}

7659 static void 
	$tryToClone
(
ShellState
 *
p
, const char *
zNewDb
){

7660 int 
rc
;

7661 
sqlite3
 *
newDb
 = 0;

7662 if( 
	`access
(
zNewDb
,0)==0 ){

7663 
	`fprintf
(
stderr
, "File \"%s\" already exists.\n", 
zNewDb
);

7666 
rc
 = 
	`sqlite3_open
(
zNewDb
, &
newDb
);

7667 if( 
rc
 ){

7668 
	`fprintf
(
stderr
, "Cannot create output database: %s\n",

7669 
	`sqlite3_errmsg
(
newDb
));

7671 
	`sqlite3_exec
(
p
->
db
, "PRAGMA writable_schema=ON;", 0, 0, 0);

7672 
	`sqlite3_exec
(
newDb
, "BEGIN EXCLUSIVE;", 0, 0, 0);

7673 
	`tryToCloneSchema
(
p
, 
newDb
, "type='table'", 
tryToCloneData
);

7674 
	`tryToCloneSchema
(
p
, 
newDb
, "type!='table'", 0);

7675 
	`sqlite3_exec
(
newDb
, "COMMIT;", 0, 0, 0);

7676 
	`sqlite3_exec
(
p
->
db
, "PRAGMA writable_schema=OFF;", 0, 0, 0);

7678 
	`sqlite3_close
(
newDb
);

7679 
	}
}

7684 static void 
	$output_reset
(
ShellState
 *
p
){

7685 if( 
p
->
outfile
[0]=='|' ){

7687 
	`pclose
(
p
->
out
);

7690 
	`output_file_close
(
p
->
out
);

7692 
p
->
outfile
[0] = 0;

7693 
p
->
out
 = 
stdout
;

7694 
	}
}

7699 static int 
	$db_int
(
ShellState
 *
p
, const char *
zSql
){

7700 
sqlite3_stmt
 *
pStmt
;

7701 int 
res
 = 0;

7702 
	`sqlite3_prepare_v2
(
p
->
db
, 
zSql
, -1, &
pStmt
, 0);

7703 if( 
pStmt
 && 
	`sqlite3_step
(pStmt)==100 ){

7704 
res
 = 
	`sqlite3_column_int
(
pStmt
,0);

7706 
	`sqlite3_finalize
(
pStmt
);

7707 return 
res
;

7708 
	}
}

7713 unsigned int 
	$get2byteInt
(unsigned char *
a
){

7714 return (
a
[0]<<8) + a[1];

7715 
	}
}

7716 unsigned int 
	$get4byteInt
(unsigned char *
a
){

7717 return (
a
[0]<<24) + (a[1]<<16) + (a[2]<<8) + a[3];

7718 
	}
}

7725 static int 
	$shell_dbinfo_command
(
ShellState
 *
p
, int 
nArg
, char **
azArg
){

7726 static const struct { const char *
zName
; int 
ofst
; } 
aField
[] = {

7740 static const struct { const char *
zName
; const char *
zSql
; } 
aQuery
[] = {

7752 
sqlite3_file
 *
pFile
 = 0;

7753 int 
i
;

7754 char *
zSchemaTab
;

7755 char *
zDb
 = 
nArg
>=2 ? 
azArg
[1] : "main";

7756 unsigned char 
aHdr
[100];

7757 
	`open_db
(
p
, 0);

7758 if( 
p
->
db
==0 ) return 1;

7759 
	`sqlite3_file_control
(
p
->
db
, 
zDb
, 7, &
pFile
);

7760 if( 
pFile
==0 || pFile->
pMethods
==0 || pFile->pMethods->
xRead
==0 ){

7763 
i
 = 
pFile
->
pMethods
->
	`xRead
(pFile, 
aHdr
, 100, 0);

7764 if( 
i
!=0 ){

7765 
	`fprintf
(
stderr
, "unable to read database header\n");

7768 
i
 = 
	`get2byteInt
(
aHdr
+16);

7769 if( 
i
==1 ) i = 65536;

7770 
	`fprintf
(
p
->
out
, "%-20s %d\n", "database page size:", 
i
);

7771 
	`fprintf
(
p
->
out
, "%-20s %d\n", "write format:", 
aHdr
[18]);

7772 
	`fprintf
(
p
->
out
, "%-20s %d\n", "read format:", 
aHdr
[19]);

7773 
	`fprintf
(
p
->
out
, "%-20s %d\n", "reserved bytes:", 
aHdr
[20]);

7774 for(
i
=0; i<(int)(sizeof(
aField
)/sizeof(aField[0])); i++){

7775 int 
ofst
 = 
aField
[
i
].ofst;

7776 unsigned int 
val
 = 
	`get4byteInt
(
aHdr
 + 
ofst
);

7777 
	`fprintf
(
p
->
out
, "%-20s %u", 
aField
[
i
].
zName
, 
val
);

7778 switch( 
ofst
 ){

7780 if( 
val
==1 ) 
	`fprintf
(
p
->
out
, " (utf8)");

7781 if( 
val
==2 ) 
	`fprintf
(
p
->
out
, " (utf16le)");

7782 if( 
val
==3 ) 
	`fprintf
(
p
->
out
, " (utf16be)");

7785 
	`fprintf
(
p
->
out
, "\n");

7787 if( 
zDb
==0 ){

7788 
zSchemaTab
 = 
	`sqlite3_mprintf
("main.sqlite_master");

7789 }else if( 
	`strcmp
(
zDb
,"temp")==0 ){

7790 
zSchemaTab
 = 
	`sqlite3_mprintf
("%s", "sqlite_temp_master");

7792 
zSchemaTab
 = 
	`sqlite3_mprintf
("\"%w\".sqlite_master", 
zDb
);

7794 for(
i
=0; i<(int)(sizeof(
aQuery
)/sizeof(aQuery[0])); i++){

7795 char *
zSql
 = 
	`sqlite3_mprintf
(
aQuery
[
i
].zSql, 
zSchemaTab
);

7796 int 
val
 = 
	`db_int
(
p
, 
zSql
);

7797 
	`sqlite3_free
(
zSql
);

7798 
	`fprintf
(
p
->
out
, "%-20s %d\n", 
aQuery
[
i
].
zName
, 
val
);

7800 
	`sqlite3_free
(
zSchemaTab
);

7802 
	}
}

7807 static int 
	$shellDatabaseError
(
sqlite3
 *
db
){

7808 const char *
zErr
 = 
	`sqlite3_errmsg
(
db
);

7809 
	`fprintf
(
stderr
, "Error: %s\n", 
zErr
);

7811 
	}
}

7816 static int 
	$shellNomemError
(void){

7817 
	`fprintf
(
stderr
, "Error: out of memory\n");

7819 
	}
}

7827 static int 
	$do_meta_command
(char *
zLine
, 
ShellState
 *
p
){

7828 int 
h
 = 1;

7829 int 
nArg
 = 0;

7830 int 
n
, 
c
;

7831 int 
rc
 = 0;

7832 char *
azArg
[50];

7836 while( 
zLine
[
h
] && 
nArg
<(int)(sizeof(
azArg
)/sizeof(azArg[0])) ){

7837 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)
zLine
[
h
]))] & (unsigned short int) 
_ISspace
) ){ h++; }

7838 if( 
zLine
[
h
]==0 ) break;

7839 if( 
zLine
[
h
]=='\'' || zLine[h]=='"' ){

7840 int 
delim
 = 
zLine
[
h
++];

7841 
azArg
[
nArg
++] = &
zLine
[
h
];

7842 while( 
zLine
[
h
] && zLine[h]!=
delim
 ){

7843 if( 
zLine
[
h
]=='\\' && 
delim
=='"' && zLine[h+1]!=0 ) h++;

7844 
h
++;

7846 if( 
zLine
[
h
]==
delim
 ){

7847 
zLine
[
h
++] = 0;

7849 if( 
delim
=='"' ) 
	`resolve_backslashes
(
azArg
[
nArg
-1]);

7851 
azArg
[
nArg
++] = &
zLine
[
h
];

7852 while( 
zLine
[
h
] && !((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)zLine[h]))] & (unsigned short int) 
_ISspace
) ){ h++; }

7853 if( 
zLine
[
h
] ) zLine[h++] = 0;

7854 
	`resolve_backslashes
(
azArg
[
nArg
-1]);

7860 if( 
nArg
==0 ) return 0;

7861 
n
 = 
	`strlen30
(
azArg
[0]);

7862 
c
 = 
azArg
[0][0];

7863 if( (
c
=='b' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "backup", n)==0)

7864 || (
c
=='s' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "save", n)==0)

7866 const char *
zDestFile
 = 0;

7867 const char *
zDb
 = 0;

7868 
sqlite3
 *
pDest
;

7869 
sqlite3_backup
 *
pBackup
;

7870 int 
j
;

7871 for(
j
=1; j<
nArg
; j++){

7872 const char *
z
 = 
azArg
[
j
];

7873 if( 
z
[0]=='-' ){

7874 while( 
z
[0]=='-' ) z++;

7877 
	`fprintf
(
stderr
, "unknown option: %s\n", 
azArg
[
j
]);

7880 }else if( 
zDestFile
==0 ){

7881 
zDestFile
 = 
azArg
[
j
];

7882 }else if( 
zDb
==0 ){

7883 
zDb
 = 
zDestFile
;

7884 
zDestFile
 = 
azArg
[
j
];

7886 
	`fprintf
(
stderr
, "too many arguments to .backup\n");

7890 if( 
zDestFile
==0 ){

7891 
	`fprintf
(
stderr
, "missing FILENAME argument on .backup\n");

7894 if( 
zDb
==0 ) zDb = "main";

7895 
rc
 = 
	`sqlite3_open
(
zDestFile
, &
pDest
);

7896 if( 
rc
!=0 ){

7897 
	`fprintf
(
stderr
, "Error: cannot open \"%s\"\n", 
zDestFile
);

7898 
	`sqlite3_close
(
pDest
);

7901 
	`open_db
(
p
, 0);

7902 
pBackup
 = 
	`sqlite3_backup_init
(
pDest
, "main", 
p
->
db
, 
zDb
);

7903 if( 
pBackup
==0 ){

7904 
	`fprintf
(
stderr
, "Error: %s\n", 
	`sqlite3_errmsg
(
pDest
));

7905 
	`sqlite3_close
(
pDest
);

7908 while( (
rc
 = 
	`sqlite3_backup_step
(
pBackup
,100))==0 ){}

7909 
	`sqlite3_backup_finish
(
pBackup
);

7910 if( 
rc
==101 ){

7911 
rc
 = 0;

7913 
	`fprintf
(
stderr
, "Error: %s\n", 
	`sqlite3_errmsg
(
pDest
));

7914 
rc
 = 1;

7916 
	`sqlite3_close
(
pDest
);

7919 if( 
c
=='b' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "bail", n)==0 ){

7920 if( 
nArg
==2 ){

7921 
bail_on_error
 = 
	`booleanValue
(
azArg
[1]);

7923 
	`fprintf
(
stderr
, "Usage: .bail on|off\n");

7924 
rc
 = 1;

7928 if( 
c
=='b' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "binary", n)==0 ){

7929 if( 
nArg
==2 ){

7930 if( 
	`booleanValue
(
azArg
[1]) ){

7936 
	`fprintf
(
stderr
, "Usage: .binary on|off\n");

7937 
rc
 = 1;

7944 if( 
c
=='b' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "breakpoint", n)==0 ){

7945 
	`test_breakpoint
();

7948 if( 
c
=='c' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "changes", n)==0 ){

7949 if( 
nArg
==2 ){

7950 
p
->
countChanges
 = 
	`booleanValue
(
azArg
[1]);

7952 
	`fprintf
(
stderr
, "Usage: .changes on|off\n");

7953 
rc
 = 1;

7957 if( 
c
=='c' && 
	`strncmp
(
azArg
[0], "clone", 
n
)==0 ){

7958 if( 
nArg
==2 ){

7959 
	`tryToClone
(
p
, 
azArg
[1]);

7961 
	`fprintf
(
stderr
, "Usage: .clone FILENAME\n");

7962 
rc
 = 1;

7966 if( 
c
=='d' && 
n
>1 && 
	`strncmp
(
azArg
[0], "databases", n)==0 ){

7967 
ShellState
 
data
;

7968 char *
zErrMsg
 = 0;

7969 
	`open_db
(
p
, 0);

7970 
	`memcpy
(&
data
, 
p
, sizeof(data));

7971 
data
.
showHeader
 = 1;

7972 
data
.
cMode
 = data.
mode
 = 1;

7973 
data
.
colWidth
[0] = 3;

7974 
data
.
colWidth
[1] = 15;

7975 
data
.
colWidth
[2] = 58;

7976 
data
.
cnt
 = 0;

7977 
	`sqlite3_exec
(
p
->
db
, "PRAGMA database_list; ", 
callback
, &
data
, &
zErrMsg
);

7978 if( 
zErrMsg
 ){

7979 
	`fprintf
(
stderr
,"Error: %s\n", 
zErrMsg
);

7980 
	`sqlite3_free
(
zErrMsg
);

7981 
rc
 = 1;

7985 if( 
c
=='d' && 
	`strncmp
(
azArg
[0], "dbinfo", 
n
)==0 ){

7986 
rc
 = 
	`shell_dbinfo_command
(
p
, 
nArg
, 
azArg
);

7989 if( 
c
=='d' && 
	`strncmp
(
azArg
[0], "dump", 
n
)==0 ){

7990 
	`open_db
(
p
, 0);

7994 if( 
nArg
!=1 && nArg!=2 ){

7995 
	`fprintf
(
stderr
, "Usage: .dump ?LIKE-PATTERN?\n");

7996 
rc
 = 1;

7997 goto 
meta_command_exit
;

7999 
	`fprintf
(
p
->
out
, "PRAGMA foreign_keys=OFF;\n");

8000 
	`fprintf
(
p
->
out
, "BEGIN TRANSACTION;\n");

8001 
p
->
writableSchema
 = 0;

8002 
	`sqlite3_exec
(
p
->
db
, "SAVEPOINT dump; PRAGMA writable_schema=ON", 0, 0, 0);

8003 
p
->
nErr
 = 0;

8004 if( 
nArg
==1 ){

8005 
	`run_schema_dump_query
(
p
,

8009 
	`run_schema_dump_query
(
p
,

8013 
	`run_table_dump_query
(
p
,

8018 int 
i
;

8019 for(
i
=1; i<
nArg
; i++){

8020 
zShellStatic
 = 
azArg
[
i
];

8021 
	`run_schema_dump_query
(
p
,

8025 
	`run_table_dump_query
(
p
,

8031 
zShellStatic
 = 0;

8034 if( 
p
->
writableSchema
 ){

8035 
	`fprintf
(
p
->
out
, "PRAGMA writable_schema=OFF;\n");

8036 
p
->
writableSchema
 = 0;

8038 
	`sqlite3_exec
(
p
->
db
, "PRAGMA writable_schema=OFF;", 0, 0, 0);

8039 
	`sqlite3_exec
(
p
->
db
, "RELEASE dump;", 0, 0, 0);

8040 
	`fprintf
(
p
->
out
, p->
nErr
 ? "ROLLBACK; -- due to errors\n" : "COMMIT;\n");

8043 if( 
c
=='e' && 
	`strncmp
(
azArg
[0], "echo", 
n
)==0 ){

8044 if( 
nArg
==2 ){

8045 
p
->
echoOn
 = 
	`booleanValue
(
azArg
[1]);

8047 
	`fprintf
(
stderr
, "Usage: .echo on|off\n");

8048 
rc
 = 1;

8052 if( 
c
=='e' && 
	`strncmp
(
azArg
[0], "eqp", 
n
)==0 ){

8053 if( 
nArg
==2 ){

8054 
p
->
autoEQP
 = 
	`booleanValue
(
azArg
[1]);

8056 
	`fprintf
(
stderr
, "Usage: .eqp on|off\n");

8057 
rc
 = 1;

8061 if( 
c
=='e' && 
	`strncmp
(
azArg
[0], "exit", 
n
)==0 ){

8062 if( 
nArg
>1 && (
rc
 = (int)
	`integerValue
(
azArg
[1]))!=0 ) 
	`exit
(rc);

8063 
rc
 = 2;

8066 if( 
c
=='e' && 
	`strncmp
(
azArg
[0], "explain", 
n
)==0 ){

8067 int 
val
 = 1;

8068 if( 
nArg
>=2 ){

8069 if( 
	`strcmp
(
azArg
[1],"auto")==0 ){

8070 
val
 = 99;

8072 
val
 = 
	`booleanValue
(
azArg
[1]);

8075 if( 
val
==1 && 
p
->
mode
!=8 ){

8076 
p
->
normalMode
 = p->
mode
;

8077 
p
->
mode
 = 8;

8078 
p
->
autoExplain
 = 0;

8079 }else if( 
val
==0 ){

8080 if( 
p
->
mode
==8 ) p->mode = p->
normalMode
;

8081 
p
->
autoExplain
 = 0;

8082 }else if( 
val
==99 ){

8083 if( 
p
->
mode
==8 ) p->mode = p->
normalMode
;

8084 
p
->
autoExplain
 = 1;

8088 if( 
c
=='f' && 
	`strncmp
(
azArg
[0], "fullschema", 
n
)==0 ){

8089 
ShellState
 
data
;

8090 char *
zErrMsg
 = 0;

8091 int 
doStats
 = 0;

8092 if( 
nArg
!=1 ){

8093 
	`fprintf
(
stderr
, "Usage: .fullschema\n");

8094 
rc
 = 1;

8095 goto 
meta_command_exit
;

8097 
	`open_db
(
p
, 0);

8098 
	`memcpy
(&
data
, 
p
, sizeof(data));

8099 
data
.
showHeader
 = 0;

8100 
data
.
cMode
 = data.
mode
 = 3;

8101 
rc
 = 
	`sqlite3_exec
(
p
->
db
,

8108 
callback
, &
data
, &
zErrMsg


8110 if( 
rc
==0 ){

8111 
sqlite3_stmt
 *
pStmt
;

8112 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
,

8115 -1, &
pStmt
, 0);

8116 
doStats
 = 
	`sqlite3_step
(
pStmt
)==100;

8117 
	`sqlite3_finalize
(
pStmt
);

8119 if( 
doStats
==0 ){

8120 
	`fprintf
(
p
->
out
, "/* No STAT tables available */\n");

8122 
	`fprintf
(
p
->
out
, "ANALYZE sqlite_master;\n");

8123 
	`sqlite3_exec
(
p
->
db
, "SELECT 'ANALYZE sqlite_master'",

8124 
callback
, &
data
, &
zErrMsg
);

8125 
data
.
cMode
 = data.
mode
 = 5;

8126 
data
.
zDestTable
 = "sqlite_stat1";

8127 
	`shell_exec
(
p
->
db
, "SELECT * FROM sqlite_stat1",

8128 
shell_callback
, &
data
,&
zErrMsg
);

8129 
data
.
zDestTable
 = "sqlite_stat3";

8130 
	`shell_exec
(
p
->
db
, "SELECT * FROM sqlite_stat3",

8131 
shell_callback
, &
data
,&
zErrMsg
);

8132 
data
.
zDestTable
 = "sqlite_stat4";

8133 
	`shell_exec
(
p
->
db
, "SELECT * FROM sqlite_stat4",

8134 
shell_callback
, &
data
, &
zErrMsg
);

8135 
	`fprintf
(
p
->
out
, "ANALYZE sqlite_master;\n");

8139 if( 
c
=='h' && 
	`strncmp
(
azArg
[0], "headers", 
n
)==0 ){

8140 if( 
nArg
==2 ){

8141 
p
->
showHeader
 = 
	`booleanValue
(
azArg
[1]);

8143 
	`fprintf
(
stderr
, "Usage: .headers on|off\n");

8144 
rc
 = 1;

8148 if( 
c
=='h' && 
	`strncmp
(
azArg
[0], "help", 
n
)==0 ){

8149 
	`fprintf
(
p
->
out
, "%s", 
zHelp
);

8152 if( 
c
=='i' && 
	`strncmp
(
azArg
[0], "import", 
n
)==0 ){

8153 char *
zTable
;

8154 char *
zFile
;

8155 
sqlite3_stmt
 *
pStmt
 = ((void *)0);

8156 int 
nCol
;

8157 int 
nByte
;

8158 int 
i
, 
j
;

8159 int 
needCommit
;

8160 int 
nSep
;

8161 char *
zSql
;

8162 
ImportCtx
 
sCtx
;

8163 char *( *
xRead
)(
ImportCtx
*);

8164 int ( *
xCloser
)(
FILE
*);

8166 if( 
nArg
!=3 ){

8167 
	`fprintf
(
stderr
, "Usage: .import FILE TABLE\n");

8168 goto 
meta_command_exit
;

8170 
zFile
 = 
azArg
[1];

8171 
zTable
 = 
azArg
[2];

8172 
seenInterrupt
 = 0;

8173 
	`memset
(&
sCtx
, 0, sizeof(sCtx));

8174 
	`open_db
(
p
, 0);

8175 
nSep
 = 
	`strlen30
(
p
->
colSeparator
);

8176 if( 
nSep
==0 ){

8177 
	`fprintf
(
stderr
,

8181 if( 
nSep
>1 ){

8182 
	`fprintf
(
stderr
, "Error: multi-character column separators not allowed"

8186 
nSep
 = 
	`strlen30
(
p
->
rowSeparator
);

8187 if( 
nSep
==0 ){

8188 
	`fprintf
(
stderr
, "Error: non-null row separator required for import\n");

8191 if( 
nSep
==2 && 
p
->
mode
==7 && 
	`strcmp
(p->
rowSeparator
, "\r\n")==0 ){

8196 
	`sqlite3_snprintf
(sizeof(
p
->
rowSeparator
), p->rowSeparator, "\n");

8197 
nSep
 = 
	`strlen30
(
p
->
rowSeparator
);

8199 if( 
nSep
>1 ){

8200 
	`fprintf
(
stderr
, "Error: multi-character row separators not allowed"

8204 
sCtx
.
zFile
 = zFile;

8205 
sCtx
.
nLine
 = 1;

8206 if( 
sCtx
.
zFile
[0]=='|' ){

8211 
sCtx
.
in
 = 
	`popen
(sCtx.
zFile
+1, "r");

8212 
sCtx
.
zFile
 = "<pipe>";

8213 
xCloser
 = 
pclose
;

8216 
sCtx
.
in
 = 
	`fopen
(sCtx.
zFile
, "rb");

8217 
xCloser
 = 
fclose
;

8219 if( 
p
->
mode
==9 ){

8220 
xRead
 = 
ascii_read_one_field
;

8222 
xRead
 = 
csv_read_one_field
;

8224 if( 
sCtx
.
in
==0 ){

8225 
	`fprintf
(
stderr
, "Error: cannot open \"%s\"\n", 
zFile
);

8228 
sCtx
.
cColSep
 = 
p
->
colSeparator
[0];

8229 
sCtx
.
cRowSep
 = 
p
->
rowSeparator
[0];

8230 
zSql
 = 
	`sqlite3_mprintf
("SELECT * FROM %s", 
zTable
);

8231 if( 
zSql
==0 ){

8232 
	`fprintf
(
stderr
, "Error: out of memory\n");

8233 
	`xCloser
(
sCtx
.
in
);

8236 
nByte
 = 
	`strlen30
(
zSql
);

8237 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zSql
, -1, &
pStmt
, 0);

8238 
	`import_append_char
(&
sCtx
, 0);

8239 if( 
rc
 && 
	`sqlite3_strglob
("no such table: *", 
	`sqlite3_errmsg
(
p
->
db
))==0 ){

8240 char *
zCreate
 = 
	`sqlite3_mprintf
("CREATE TABLE %s", 
zTable
);

8241 char 
cSep
 = '(';

8242 while( 
	`xRead
(&
sCtx
) ){

8243 
zCreate
 = 
	`sqlite3_mprintf
("%z%c\n \"%w\" TEXT", zCreate, 
cSep
, 
sCtx
.
z
);

8244 
cSep
 = ',';

8245 if( 
sCtx
.
cTerm
!=sCtx.
cColSep
 ) break;

8247 if( 
cSep
=='(' ){

8248 
	`sqlite3_free
(
zCreate
);

8249 
	`sqlite3_free
(
sCtx
.
z
);

8250 
	`xCloser
(
sCtx
.
in
);

8251 
	`fprintf
(
stderr
,"%s: empty file\n", 
sCtx
.
zFile
);

8254 
zCreate
 = 
	`sqlite3_mprintf
("%z\n)", zCreate);

8255 
rc
 = 
	`sqlite3_exec
(
p
->
db
, 
zCreate
, 0, 0, 0);

8256 
	`sqlite3_free
(
zCreate
);

8257 if( 
rc
 ){

8258 
	`fprintf
(
stderr
, "CREATE TABLE %s(...) failed: %s\n", 
zTable
,

8259 
	`sqlite3_errmsg
(
p
->
db
));

8260 
	`sqlite3_free
(
sCtx
.
z
);

8261 
	`xCloser
(
sCtx
.
in
);

8264 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zSql
, -1, &
pStmt
, 0);

8266 
	`sqlite3_free
(
zSql
);

8267 if( 
rc
 ){

8268 if (
pStmt
) 
	`sqlite3_finalize
(pStmt);

8269 
	`fprintf
(
stderr
,"Error: %s\n", 
	`sqlite3_errmsg
(
p
->
db
));

8270 
	`xCloser
(
sCtx
.
in
);

8273 
nCol
 = 
	`sqlite3_column_count
(
pStmt
);

8274 
	`sqlite3_finalize
(
pStmt
);

8275 
pStmt
 = 0;

8276 if( 
nCol
==0 ) return 0;

8277 
zSql
 = 
	`sqlite3_malloc64
( 
nByte
*2 + 20 + 
nCol
*2 );

8278 if( 
zSql
==0 ){

8279 
	`fprintf
(
stderr
, "Error: out of memory\n");

8280 
	`xCloser
(
sCtx
.
in
);

8283 
	`sqlite3_snprintf
(
nByte
+20, 
zSql
, "INSERT INTO \"%w\" VALUES(?", 
zTable
);

8284 
j
 = 
	`strlen30
(
zSql
);

8285 for(
i
=1; i<
nCol
; i++){

8286 
zSql
[
j
++] = ',';

8287 
zSql
[
j
++] = '?';

8289 
zSql
[
j
++] = ')';

8290 
zSql
[
j
] = 0;

8291 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, 
zSql
, -1, &
pStmt
, 0);

8292 
	`sqlite3_free
(
zSql
);

8293 if( 
rc
 ){

8294 
	`fprintf
(
stderr
, "Error: %s\n", 
	`sqlite3_errmsg
(
p
->
db
));

8295 if (
pStmt
) 
	`sqlite3_finalize
(pStmt);

8296 
	`xCloser
(
sCtx
.
in
);

8299 
needCommit
 = 
	`sqlite3_get_autocommit
(
p
->
db
);

8300 if( 
needCommit
 ) 
	`sqlite3_exec
(
p
->
db
, "BEGIN", 0, 0, 0);

8302 int 
startLine
 = 
sCtx
.
nLine
;

8303 for(
i
=0; i<
nCol
; i++){

8304 char *
z
 = 
	`xRead
(&
sCtx
);

8309 if( 
z
==0 && 
i
==0 ) break;

8315 if( 
p
->
mode
==9 && (
z
==0 || z[0]==0) && 
i
==0 ) break;

8316 
	`sqlite3_bind_text
(
pStmt
, 
i
+1, 
z
, -1, ((
sqlite3_destructor_type
)-1));

8317 if( 
i
<
nCol
-1 && 
sCtx
.
cTerm
!=sCtx.
cColSep
 ){

8318 
	`fprintf
(
stderr
, "%s:%d: expected %d columns but found %d - "

8320 
sCtx
.
zFile
, 
startLine
, 
nCol
, 
i
+1);

8321 
i
 += 2;

8322 while( 
i
<=
nCol
 ){ 
	`sqlite3_bind_null
(
pStmt
, i); i++; }

8325 if( 
sCtx
.
cTerm
==sCtx.
cColSep
 ){

8327 
	`xRead
(&
sCtx
);

8328 
i
++;

8329 }while( 
sCtx
.
cTerm
==sCtx.
cColSep
 );

8330 
	`fprintf
(
stderr
, "%s:%d: expected %d columns but found %d - "

8332 
sCtx
.
zFile
, 
startLine
, 
nCol
, 
i
);

8334 if( 
i
>=
nCol
 ){

8335 
	`sqlite3_step
(
pStmt
);

8336 
rc
 = 
	`sqlite3_reset
(
pStmt
);

8337 if( 
rc
!=0 ){

8338 
	`fprintf
(
stderr
, "%s:%d: INSERT failed: %s\n", 
sCtx
.
zFile
,

8339 
startLine
, 
	`sqlite3_errmsg
(
p
->
db
));

8342 }while( 
sCtx
.
cTerm
!=(-1) );

8344 
	`xCloser
(
sCtx
.
in
);

8345 
	`sqlite3_free
(
sCtx
.
z
);

8346 
	`sqlite3_finalize
(
pStmt
);

8347 if( 
needCommit
 ) 
	`sqlite3_exec
(
p
->
db
, "COMMIT", 0, 0, 0);

8350 if( 
c
=='i' && (
	`strncmp
(
azArg
[0], "indices", 
n
)==0

8351 || 
	`strncmp
(
azArg
[0], "indexes", 
n
)==0) ){

8352 
ShellState
 
data
;

8353 char *
zErrMsg
 = 0;

8354 
	`open_db
(
p
, 0);

8355 
	`memcpy
(&
data
, 
p
, sizeof(data));

8356 
data
.
showHeader
 = 0;

8357 
data
.
cMode
 = data.
mode
 = 2;

8358 if( 
nArg
==1 ){

8359 
rc
 = 
	`sqlite3_exec
(
p
->
db
,

8366 
callback
, &
data
, &
zErrMsg


8368 }else if( 
nArg
==2 ){

8369 
zShellStatic
 = 
azArg
[1];

8370 
rc
 = 
	`sqlite3_exec
(
p
->
db
,

8377 
callback
, &
data
, &
zErrMsg


8379 
zShellStatic
 = 0;

8381 
	`fprintf
(
stderr
, "Usage: .indexes ?LIKE-PATTERN?\n");

8382 
rc
 = 1;

8383 goto 
meta_command_exit
;

8385 if( 
zErrMsg
 ){

8386 
	`fprintf
(
stderr
,"Error: %s\n", 
zErrMsg
);

8387 
	`sqlite3_free
(
zErrMsg
);

8388 
rc
 = 1;

8389 }else if( 
rc
 != 0 ){

8390 
	`fprintf
(
stderr
,

8392 
rc
 = 1;

8396 if( 
c
=='l' && 
n
>=5 && 
	`strncmp
(
azArg
[0], "limits", n)==0 ){

8398 const char *
zLimitName
;

8399 int 
limitCode
;

8400 } 
aLimit
[] = {

8414 int 
i
, 
n2
;

8415 
	`open_db
(
p
, 0);

8416 if( 
nArg
==1 ){

8417 for(
i
=0; i<(int)(sizeof(
aLimit
)/sizeof(aLimit[0])); i++){

8418 
	`printf
("%20s %d\n", 
aLimit
[
i
].
zLimitName
,

8419 
	`sqlite3_limit
(
p
->
db
, 
aLimit
[
i
].
limitCode
, -1));

8421 }else if( 
nArg
>3 ){

8422 
	`fprintf
(
stderr
, "Usage: .limit NAME ?NEW-VALUE?\n");

8423 
rc
 = 1;

8424 goto 
meta_command_exit
;

8426 int 
iLimit
 = -1;

8427 
n2
 = 
	`strlen30
(
azArg
[1]);

8428 for(
i
=0; i<(int)(sizeof(
aLimit
)/sizeof(aLimit[0])); i++){

8429 if( 
	`sqlite3_strnicmp
(
aLimit
[
i
].
zLimitName
, 
azArg
[1], 
n2
)==0 ){

8430 if( 
iLimit
<0 ){

8431 
iLimit
 = 
i
;

8433 
	`fprintf
(
stderr
, "ambiguous limit: \"%s\"\n", 
azArg
[1]);

8434 
rc
 = 1;

8435 goto 
meta_command_exit
;

8439 if( 
iLimit
<0 ){

8440 
	`fprintf
(
stderr
, "unknown limit: \"%s\"\n"

8442 
azArg
[1]);

8443 
rc
 = 1;

8444 goto 
meta_command_exit
;

8446 if( 
nArg
==3 ){

8447 
	`sqlite3_limit
(
p
->
db
, 
aLimit
[
iLimit
].
limitCode
,

8448 (int)
	`integerValue
(
azArg
[2]));

8450 
	`printf
("%20s %d\n", 
aLimit
[
iLimit
].
zLimitName
,

8451 
	`sqlite3_limit
(
p
->
db
, 
aLimit
[
iLimit
].
limitCode
, -1));

8456 if( 
c
=='l' && 
	`strncmp
(
azArg
[0], "load", 
n
)==0 ){

8457 const char *
zFile
, *
zProc
;

8458 char *
zErrMsg
 = 0;

8459 if( 
nArg
<2 ){

8460 
	`fprintf
(
stderr
, "Usage: .load FILE ?ENTRYPOINT?\n");

8461 
rc
 = 1;

8462 goto 
meta_command_exit
;

8464 
zFile
 = 
azArg
[1];

8465 
zProc
 = 
nArg
>=3 ? 
azArg
[2] : 0;

8466 
	`open_db
(
p
, 0);

8467 
rc
 = 
	`sqlite3_load_extension
(
p
->
db
, 
zFile
, 
zProc
, &
zErrMsg
);

8468 if( 
rc
!=0 ){

8469 
	`fprintf
(
stderr
, "Error: %s\n", 
zErrMsg
);

8470 
	`sqlite3_free
(
zErrMsg
);

8471 
rc
 = 1;

8476 if( 
c
=='l' && 
	`strncmp
(
azArg
[0], "log", 
n
)==0 ){

8477 if( 
nArg
!=2 ){

8478 
	`fprintf
(
stderr
, "Usage: .log FILENAME\n");

8479 
rc
 = 1;

8481 const char *
zFile
 = 
azArg
[1];

8482 
	`output_file_close
(
p
->
pLog
);

8483 
p
->
pLog
 = 
	`output_file_open
(
zFile
);

8487 if( 
c
=='m' && 
	`strncmp
(
azArg
[0], "mode", 
n
)==0 ){

8488 const char *
zMode
 = 
nArg
>=2 ? 
azArg
[1] : "";

8489 int 
n2
 = (int)
	`strlen
(
zMode
);

8490 int 
c2
 = 
zMode
[0];

8491 if( 
c2
=='l' && 
n2
>2 && 
	`strncmp
(
azArg
[1],"lines",n2)==0 ){

8492 
p
->
mode
 = 0;

8493 }else if( 
c2
=='c' && 
	`strncmp
(
azArg
[1],"columns",
n2
)==0 ){

8494 
p
->
mode
 = 1;

8495 }else if( 
c2
=='l' && 
n2
>2 && 
	`strncmp
(
azArg
[1],"list",n2)==0 ){

8496 
p
->
mode
 = 2;

8497 }else if( 
c2
=='h' && 
	`strncmp
(
azArg
[1],"html",
n2
)==0 ){

8498 
p
->
mode
 = 4;

8499 }else if( 
c2
=='t' && 
	`strncmp
(
azArg
[1],"tcl",
n2
)==0 ){

8500 
p
->
mode
 = 6;

8501 
	`sqlite3_snprintf
(sizeof(
p
->
colSeparator
), p->colSeparator, " ");

8502 }else if( 
c2
=='c' && 
	`strncmp
(
azArg
[1],"csv",
n2
)==0 ){

8503 
p
->
mode
 = 7;

8504 
	`sqlite3_snprintf
(sizeof(
p
->
colSeparator
), p->colSeparator, ",");

8505 
	`sqlite3_snprintf
(sizeof(
p
->
rowSeparator
), p->rowSeparator, "\r\n");

8506 }else if( 
c2
=='t' && 
	`strncmp
(
azArg
[1],"tabs",
n2
)==0 ){

8507 
p
->
mode
 = 2;

8508 
	`sqlite3_snprintf
(sizeof(
p
->
colSeparator
), p->colSeparator, "\t");

8509 }else if( 
c2
=='i' && 
	`strncmp
(
azArg
[1],"insert",
n2
)==0 ){

8510 
p
->
mode
 = 5;

8511 
	`set_table_name
(
p
, 
nArg
>=3 ? 
azArg
[2] : "table");

8512 }else if( 
c2
=='a' && 
	`strncmp
(
azArg
[1],"ascii",
n2
)==0 ){

8513 
p
->
mode
 = 9;

8514 
	`sqlite3_snprintf
(sizeof(
p
->
colSeparator
), p->colSeparator, "\x1F");

8515 
	`sqlite3_snprintf
(sizeof(
p
->
rowSeparator
), p->rowSeparator, "\x1E");

8517 
	`fprintf
(
stderr
, "Error: mode should be one of: "

8519 
rc
 = 1;

8521 
p
->
cMode
 = p->
mode
;

8524 if( 
c
=='n' && 
	`strncmp
(
azArg
[0], "nullvalue", 
n
)==0 ){

8525 if( 
nArg
==2 ){

8526 
	`sqlite3_snprintf
(sizeof(
p
->
nullValue
), p->nullValue,

8527 "%.*s", (int)(int)(sizeof(
p
->
nullValue
)/sizeof(p->nullValue[0]))-1, 
azArg
[1]);

8529 
	`fprintf
(
stderr
, "Usage: .nullvalue STRING\n");

8530 
rc
 = 1;

8534 if( 
c
=='o' && 
	`strncmp
(
azArg
[0], "open", 
n
)==0 && n>=2 ){

8535 
sqlite3
 *
savedDb
 = 
p
->
db
;

8536 const char *
zSavedFilename
 = 
p
->
zDbFilename
;

8537 char *
zNewFilename
 = 0;

8538 
p
->
db
 = 0;

8539 if( 
nArg
>=2 ) 
zNewFilename
 = 
	`sqlite3_mprintf
("%s", 
azArg
[1]);

8540 
p
->
zDbFilename
 = 
zNewFilename
;

8541 
	`open_db
(
p
, 1);

8542 if( 
p
->
db
!=0 ){

8543 
	`sqlite3_close
(
savedDb
);

8544 
	`sqlite3_free
(
p
->
zFreeOnClose
);

8545 
p
->
zFreeOnClose
 = 
zNewFilename
;

8547 
	`sqlite3_free
(
zNewFilename
);

8548 
p
->
db
 = 
savedDb
;

8549 
p
->
zDbFilename
 = 
zSavedFilename
;

8553 if( 
c
=='o'

8554 && (
	`strncmp
(
azArg
[0], "output", 
n
)==0 || strncmp(azArg[0], "once", n)==0)

8556 const char *
zFile
 = 
nArg
>=2 ? 
azArg
[1] : "stdout";

8557 if( 
nArg
>2 ){

8558 
	`fprintf
(
stderr
, "Usage: .%s FILE\n", 
azArg
[0]);

8559 
rc
 = 1;

8560 goto 
meta_command_exit
;

8562 if( 
n
>1 && 
	`strncmp
(
azArg
[0], "once", n)==0 ){

8563 if( 
nArg
<2 ){

8564 
	`fprintf
(
stderr
, "Usage: .once FILE\n");

8565 
rc
 = 1;

8566 goto 
meta_command_exit
;

8568 
p
->
outCount
 = 2;

8570 
p
->
outCount
 = 0;

8572 
	`output_reset
(
p
);

8573 if( 
zFile
[0]=='|' ){

8579 
p
->
out
 = 
	`popen
(
zFile
 + 1, "w");

8580 if( 
p
->
out
==0 ){

8581 
	`fprintf
(
stderr
,"Error: cannot open pipe \"%s\"\n", 
zFile
 + 1);

8582 
p
->
out
 = 
stdout
;

8583 
rc
 = 1;

8585 
	`sqlite3_snprintf
(sizeof(
p
->
outfile
), p->outfile, "%s", 
zFile
);

8589 
p
->
out
 = 
	`output_file_open
(
zFile
);

8590 if( 
p
->
out
==0 ){

8591 if( 
	`strcmp
(
zFile
,"off")!=0 ){

8592 
	`fprintf
(
stderr
,"Error: cannot write to \"%s\"\n", 
zFile
);

8594 
p
->
out
 = 
stdout
;

8595 
rc
 = 1;

8597 
	`sqlite3_snprintf
(sizeof(
p
->
outfile
), p->outfile, "%s", 
zFile
);

8602 if( 
c
=='p' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "print", n)==0 ){

8603 int 
i
;

8604 for(
i
=1; i<
nArg
; i++){

8605 if( 
i
>1 ) 
	`fprintf
(
p
->
out
, " ");

8606 
	`fprintf
(
p
->
out
, "%s", 
azArg
[
i
]);

8608 
	`fprintf
(
p
->
out
, "\n");

8611 if( 
c
=='p' && 
	`strncmp
(
azArg
[0], "prompt", 
n
)==0 ){

8612 if( 
nArg
 >= 2) {

8613 
	`strncpy
(
mainPrompt
,
azArg
[1],(int)(int)(sizeof(mainPrompt)/sizeof(mainPrompt[0]))-1);

8615 if( 
nArg
 >= 3) {

8616 
	`strncpy
(
continuePrompt
,
azArg
[2],(int)(int)(sizeof(continuePrompt)/sizeof(continuePrompt[0]))-1);

8620 if( 
c
=='q' && 
	`strncmp
(
azArg
[0], "quit", 
n
)==0 ){

8621 
rc
 = 2;

8624 if( 
c
=='r' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "read", n)==0 ){

8625 
FILE
 *
alt
;

8626 if( 
nArg
!=2 ){

8627 
	`fprintf
(
stderr
, "Usage: .read FILE\n");

8628 
rc
 = 1;

8629 goto 
meta_command_exit
;

8631 
alt
 = 
	`fopen
(
azArg
[1], "rb");

8632 if( 
alt
==0 ){

8633 
	`fprintf
(
stderr
,"Error: cannot open \"%s\"\n", 
azArg
[1]);

8634 
rc
 = 1;

8636 
rc
 = 
	`process_input
(
p
, 
alt
);

8637 
	`fclose
(
alt
);

8641 if( 
c
=='r' && 
n
>=3 && 
	`strncmp
(
azArg
[0], "restore", n)==0 ){

8642 const char *
zSrcFile
;

8643 const char *
zDb
;

8644 
sqlite3
 *
pSrc
;

8645 
sqlite3_backup
 *
pBackup
;

8646 int 
nTimeout
 = 0;

8648 if( 
nArg
==2 ){

8649 
zSrcFile
 = 
azArg
[1];

8650 
zDb
 = "main";

8651 }else if( 
nArg
==3 ){

8652 
zSrcFile
 = 
azArg
[2];

8653 
zDb
 = 
azArg
[1];

8655 
	`fprintf
(
stderr
, "Usage: .restore ?DB? FILE\n");

8656 
rc
 = 1;

8657 goto 
meta_command_exit
;

8659 
rc
 = 
	`sqlite3_open
(
zSrcFile
, &
pSrc
);

8660 if( 
rc
!=0 ){

8661 
	`fprintf
(
stderr
, "Error: cannot open \"%s\"\n", 
zSrcFile
);

8662 
	`sqlite3_close
(
pSrc
);

8665 
	`open_db
(
p
, 0);

8666 
pBackup
 = 
	`sqlite3_backup_init
(
p
->
db
, 
zDb
, 
pSrc
, "main");

8667 if( 
pBackup
==0 ){

8668 
	`fprintf
(
stderr
, "Error: %s\n", 
	`sqlite3_errmsg
(
p
->
db
));

8669 
	`sqlite3_close
(
pSrc
);

8672 while( (
rc
 = 
	`sqlite3_backup_step
(
pBackup
,100))==0

8673 || 
rc
==5 ){

8674 if( 
rc
==5 ){

8675 if( 
nTimeout
++ >= 3 ) break;

8676 
	`sqlite3_sleep
(100);

8679 
	`sqlite3_backup_finish
(
pBackup
);

8680 if( 
rc
==101 ){

8681 
rc
 = 0;

8682 }else if( 
rc
==5 || rc==6 ){

8683 
	`fprintf
(
stderr
, "Error: source database is busy\n");

8684 
rc
 = 1;

8686 
	`fprintf
(
stderr
, "Error: %s\n", 
	`sqlite3_errmsg
(
p
->
db
));

8687 
rc
 = 1;

8689 
	`sqlite3_close
(
pSrc
);

8693 if( 
c
=='s' && 
	`strncmp
(
azArg
[0], "scanstats", 
n
)==0 ){

8694 if( 
nArg
==2 ){

8695 
p
->
scanstatsOn
 = 
	`booleanValue
(
azArg
[1]);

8697 
	`fprintf
(
stderr
, "Warning: .scanstats not available in this build.\n");

8700 
	`fprintf
(
stderr
, "Usage: .scanstats on|off\n");

8701 
rc
 = 1;

8705 if( 
c
=='s' && 
	`strncmp
(
azArg
[0], "schema", 
n
)==0 ){

8706 
ShellState
 
data
;

8707 char *
zErrMsg
 = 0;

8708 
	`open_db
(
p
, 0);

8709 
	`memcpy
(&
data
, 
p
, sizeof(data));

8710 
data
.
showHeader
 = 0;

8711 
data
.
cMode
 = data.
mode
 = 3;

8712 if( 
nArg
==2 ){

8713 int 
i
;

8714 for(
i
=0; 
azArg
[1][i]; i++) azArg[1][i] = (char)
	`tolower
((unsigned char)azArg[1][i]);

8715 if( 
	`strcmp
(
azArg
[1],"sqlite_master")==0 ){

8716 char *
new_argv
[2], *
new_colv
[2];

8717 
new_argv
[0] = "CREATE TABLE sqlite_master (\n"

8724 
new_argv
[1] = 0;

8725 
new_colv
[0] = "sql";

8726 
new_colv
[1] = 0;

8727 
	`callback
(&
data
, 1, 
new_argv
, 
new_colv
);

8728 
rc
 = 0;

8729 }else if( 
	`strcmp
(
azArg
[1],"sqlite_temp_master")==0 ){

8730 char *
new_argv
[2], *
new_colv
[2];

8731 
new_argv
[0] = "CREATE TEMP TABLE sqlite_temp_master (\n"

8738 
new_argv
[1] = 0;

8739 
new_colv
[0] = "sql";

8740 
new_colv
[1] = 0;

8741 
	`callback
(&
data
, 1, 
new_argv
, 
new_colv
);

8742 
rc
 = 0;

8744 
zShellStatic
 = 
azArg
[1];

8745 
rc
 = 
	`sqlite3_exec
(
p
->
db
,

8753 
callback
, &
data
, &
zErrMsg
);

8754 
zShellStatic
 = 0;

8756 }else if( 
nArg
==1 ){

8757 
rc
 = 
	`sqlite3_exec
(
p
->
db
,

8764 
callback
, &
data
, &
zErrMsg


8767 
	`fprintf
(
stderr
, "Usage: .schema ?LIKE-PATTERN?\n");

8768 
rc
 = 1;

8769 goto 
meta_command_exit
;

8771 if( 
zErrMsg
 ){

8772 
	`fprintf
(
stderr
,"Error: %s\n", 
zErrMsg
);

8773 
	`sqlite3_free
(
zErrMsg
);

8774 
rc
 = 1;

8775 }else if( 
rc
 != 0 ){

8776 
	`fprintf
(
stderr
,"Error: querying schema information\n");

8777 
rc
 = 1;

8779 
rc
 = 0;

8783 if( 
c
=='s' && 
	`strncmp
(
azArg
[0], "separator", 
n
)==0 ){

8784 if( 
nArg
<2 || nArg>3 ){

8785 
	`fprintf
(
stderr
, "Usage: .separator COL ?ROW?\n");

8786 
rc
 = 1;

8788 if( 
nArg
>=2 ){

8789 
	`sqlite3_snprintf
(sizeof(
p
->
colSeparator
), p->colSeparator,

8790 "%.*s", (int)(int)(sizeof(
p
->
colSeparator
)/sizeof(p->colSeparator[0]))-1, 
azArg
[1]);

8792 if( 
nArg
>=3 ){

8793 
	`sqlite3_snprintf
(sizeof(
p
->
rowSeparator
), p->rowSeparator,

8794 "%.*s", (int)(int)(sizeof(
p
->
rowSeparator
)/sizeof(p->rowSeparator[0]))-1, 
azArg
[2]);

8798 if( 
c
=='s'

8799 && (
	`strncmp
(
azArg
[0], "shell", 
n
)==0 || strncmp(azArg[0],"system",n)==0)

8801 char *
zCmd
;

8802 int 
i
, 
x
;

8803 if( 
nArg
<2 ){

8804 
	`fprintf
(
stderr
, "Usage: .system COMMAND\n");

8805 
rc
 = 1;

8806 goto 
meta_command_exit
;

8808 
zCmd
 = 
	`sqlite3_mprintf
(
	`strchr
(
azArg
[1],' ')==0?"%s":"\"%s\"", azArg[1]);

8809 for(
i
=2; i<
nArg
; i++){

8810 
zCmd
 = 
	`sqlite3_mprintf
(
	`strchr
(
azArg
[
i
],' ')==0?"%z %s":"%z \"%s\"",

8811 
zCmd
, 
azArg
[
i
]);

8813 
x
 = 
	`system
(
zCmd
);

8814 
	`sqlite3_free
(
zCmd
);

8815 if( 
x
 ) 
	`fprintf
(
stderr
, "System command returns %d\n", x);

8818 if( 
c
=='s' && 
	`strncmp
(
azArg
[0], "show", 
n
)==0 ){

8819 int 
i
;

8820 if( 
nArg
!=1 ){

8821 
	`fprintf
(
stderr
, "Usage: .show\n");

8822 
rc
 = 1;

8823 goto 
meta_command_exit
;

8825 
	`fprintf
(
p
->
out
, "%12.12s: %s\n","echo", p->
echoOn
 ? "on" : "off");

8826 
	`fprintf
(
p
->
out
, "%12.12s: %s\n","eqp", p->
autoEQP
 ? "on" : "off");

8827 
	`fprintf
(
p
->
out
, "%12.12s: %s\n","explain",

8828 
p
->
mode
==8 ? "on" : p->
autoExplain
 ? "auto" : "off");

8829 
	`fprintf
(
p
->
out
,"%12.12s: %s\n","headers", p->
showHeader
 ? "on" : "off");

8830 
	`fprintf
(
p
->
out
, "%12.12s: %s\n","mode", 
modeDescr
[p->
mode
]);

8831 
	`fprintf
(
p
->
out
, "%12.12s: ", "nullvalue");

8832 
	`output_c_string
(
p
->
out
, p->
nullValue
);

8833 
	`fprintf
(
p
->
out
, "\n");

8834 
	`fprintf
(
p
->
out
,"%12.12s: %s\n","output",

8835 
	`strlen30
(
p
->
outfile
) ? p->outfile : "stdout");

8836 
	`fprintf
(
p
->
out
,"%12.12s: ", "colseparator");

8837 
	`output_c_string
(
p
->
out
, p->
colSeparator
);

8838 
	`fprintf
(
p
->
out
, "\n");

8839 
	`fprintf
(
p
->
out
,"%12.12s: ", "rowseparator");

8840 
	`output_c_string
(
p
->
out
, p->
rowSeparator
);

8841 
	`fprintf
(
p
->
out
, "\n");

8842 
	`fprintf
(
p
->
out
, "%12.12s: %s\n","stats", p->
statsOn
 ? "on" : "off");

8843 
	`fprintf
(
p
->
out
, "%12.12s: ", "width");

8844 for (
i
=0;i<(int)(int)(sizeof(
p
->
colWidth
)/sizeof(p->colWidth[0])) && p->colWidth[i] != 0;i++) {

8845 
	`fprintf
(
p
->
out
, "%d ", p->
colWidth
[
i
]);

8847 
	`fprintf
(
p
->
out
, "\n");

8850 if( 
c
=='s' && 
	`strncmp
(
azArg
[0], "stats", 
n
)==0 ){

8851 if( 
nArg
==2 ){

8852 
p
->
statsOn
 = 
	`booleanValue
(
azArg
[1]);

8853 }else if( 
nArg
==1 ){

8854 
	`display_stats
(
p
->
db
, p, 0);

8856 
	`fprintf
(
stderr
, "Usage: .stats ?on|off?\n");

8857 
rc
 = 1;

8861 if( 
c
=='t' && 
n
>1 && 
	`strncmp
(
azArg
[0], "tables", n)==0 ){

8862 
sqlite3_stmt
 *
pStmt
;

8863 char **
azResult
;

8864 int 
nRow
, 
nAlloc
;

8865 char *
zSql
 = 0;

8866 int 
ii
;

8867 
	`open_db
(
p
, 0);

8868 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, "PRAGMA database_list", -1, &
pStmt
, 0);

8869 if( 
rc
 ) return 
	`shellDatabaseError
(
p
->
db
);

8874 
zSql
 = 
	`sqlite3_mprintf
(

8879 while( 
zSql
 && 
	`sqlite3_step
(
pStmt
)==100 ){

8880 const char *
zDbName
 = (const char*)
	`sqlite3_column_text
(
pStmt
, 1);

8881 if( 
zDbName
==0 || 
	`strcmp
(zDbName,"main")==0 ) continue;

8882 if( 
	`strcmp
(
zDbName
,"temp")==0 ){

8883 
zSql
 = 
	`sqlite3_mprintf
(

8888 " AND name LIKE ?1", 
zSql
);

8890 
zSql
 = 
	`sqlite3_mprintf
(

8895 " AND name LIKE ?1", 
zSql
, 
zDbName
, zDbName);

8898 
rc
 = 
	`sqlite3_finalize
(
pStmt
);

8899 if( 
zSql
 && 
rc
==0 ){

8900 
zSql
 = 
	`sqlite3_mprintf
("%z ORDER BY 1", zSql);

8901 if( 
zSql
 ) 
rc
 = 
	`sqlite3_prepare_v2
(
p
->
db
, zSql, -1, &
pStmt
, 0);

8903 
	`sqlite3_free
(
zSql
);

8904 if( !
zSql
 ) return 
	`shellNomemError
();

8905 if( 
rc
 ) return 
	`shellDatabaseError
(
p
->
db
);

8909 
nRow
 = 
nAlloc
 = 0;

8910 
azResult
 = 0;

8911 if( 
nArg
>1 ){

8912 
	`sqlite3_bind_text
(
pStmt
, 1, 
azArg
[1], -1, ((
sqlite3_destructor_type
)-1));

8914 
	`sqlite3_bind_text
(
pStmt
, 1, "%", -1, ((
sqlite3_destructor_type
)0));

8916 while( 
	`sqlite3_step
(
pStmt
)==100 ){

8917 if( 
nRow
>=
nAlloc
 ){

8918 char **
azNew
;

8919 int 
n2
 = 
nAlloc
*2 + 10;

8920 
azNew
 = 
	`sqlite3_realloc64
(
azResult
, sizeof(azResult[0])*
n2
);

8921 if( 
azNew
==0 ){

8922 
rc
 = 
	`shellNomemError
();

8925 
nAlloc
 = 
n2
;

8926 
azResult
 = 
azNew
;

8928 
azResult
[
nRow
] = 
	`sqlite3_mprintf
("%s", 
	`sqlite3_column_text
(
pStmt
, 0));

8929 if( 0==
azResult
[
nRow
] ){

8930 
rc
 = 
	`shellNomemError
();

8933 
nRow
++;

8935 if( 
	`sqlite3_finalize
(
pStmt
)!=0 ){

8936 
rc
 = 
	`shellDatabaseError
(
p
->
db
);

8940 if( 
rc
==0 && 
nRow
>0 ){

8941 int 
len
, 
maxlen
 = 0;

8942 int 
i
, 
j
;

8943 int 
nPrintCol
, 
nPrintRow
;

8944 for(
i
=0; i<
nRow
; i++){

8945 
len
 = 
	`strlen30
(
azResult
[
i
]);

8946 if( 
len
>
maxlen
 ) maxlen = len;

8948 
nPrintCol
 = 80/(
maxlen
+2);

8949 if( 
nPrintCol
<1 ) nPrintCol = 1;

8950 
nPrintRow
 = (
nRow
 + 
nPrintCol
 - 1)/nPrintCol;

8951 for(
i
=0; i<
nPrintRow
; i++){

8952 for(
j
=
i
; j<
nRow
; j+=
nPrintRow
){

8953 char *
zSp
 = 
j
<
nPrintRow
 ? "" : " ";

8954 
	`fprintf
(
p
->
out
, "%s%-*s", 
zSp
, 
maxlen
,

8955 
azResult
[
j
] ? azResult[j]:"");

8957 
	`fprintf
(
p
->
out
, "\n");

8961 for(
ii
=0; ii<
nRow
; ii++) 
	`sqlite3_free
(
azResult
[ii]);

8962 
	`sqlite3_free
(
azResult
);

8965 if( 
c
=='t' && 
n
>=8 && 
	`strncmp
(
azArg
[0], "testctrl", n)==0 && 
nArg
>=2 ){

8967 const char *
zCtrlName
;

8968 int 
ctrlCode
;

8969 } 
aCtrl
[] = {

8987 int 
testctrl
 = -1;

8988 int 
rc2
 = 0;

8989 int 
i
, 
n2
;

8990 
	`open_db
(
p
, 0);

8994 
n2
 = 
	`strlen30
(
azArg
[1]);

8995 for(
i
=0; i<(int)(sizeof(
aCtrl
)/sizeof(aCtrl[0])); i++){

8996 if( 
	`strncmp
(
azArg
[1], 
aCtrl
[
i
].
zCtrlName
, 
n2
)==0 ){

8997 if( 
testctrl
<0 ){

8998 
testctrl
 = 
aCtrl
[
i
].
ctrlCode
;

9000 
	`fprintf
(
stderr
, "ambiguous option name: \"%s\"\n", 
azArg
[1]);

9001 
testctrl
 = -1;

9006 if( 
testctrl
<0 ) testctrl = (int)
	`integerValue
(
azArg
[1]);

9007 if( (
testctrl
<5) || (testctrl>25) ){

9008 
	`fprintf
(
stderr
,"Error: invalid testctrl option: %s\n", 
azArg
[1]);

9010 switch(
testctrl
){

9015 if( 
nArg
==3 ){

9016 int 
opt
 = (int)
	`strtol
(
azArg
[2], 0, 0);

9017 
rc2
 = 
	`sqlite3_test_control
(
testctrl
, 
p
->
db
, 
opt
);

9018 
	`fprintf
(
p
->
out
, "%d (0x%08x)\n", 
rc2
, rc2);

9020 
	`fprintf
(
stderr
,"Error: testctrl %s takes a single int option\n",

9021 
azArg
[1]);

9030 if( 
nArg
==2 ){

9031 
rc2
 = 
	`sqlite3_test_control
(
testctrl
);

9032 
	`fprintf
(
p
->
out
, "%d (0x%08x)\n", 
rc2
, rc2);

9034 
	`fprintf
(
stderr
,"Error: testctrl %s takes no options\n",

9035 
azArg
[1]);

9041 if( 
nArg
==3 ){

9042 unsigned int 
opt
 = (unsigned int)
	`integerValue
(
azArg
[2]);

9043 
rc2
 = 
	`sqlite3_test_control
(
testctrl
, 
opt
);

9044 
	`fprintf
(
p
->
out
, "%d (0x%08x)\n", 
rc2
, rc2);

9046 
	`fprintf
(
stderr
,"Error: testctrl %s takes a single unsigned"

9047 " int option\n", 
azArg
[1]);

9055 if( 
nArg
==3 ){

9056 int 
opt
 = 
	`booleanValue
(
azArg
[2]);

9057 
rc2
 = 
	`sqlite3_test_control
(
testctrl
, 
opt
);

9058 
	`fprintf
(
p
->
out
, "%d (0x%08x)\n", 
rc2
, rc2);

9060 
	`fprintf
(
stderr
,"Error: testctrl %s takes a single int option\n",

9061 
azArg
[1]);

9066 if( 
nArg
==5 ){

9067 
rc2
 = 
	`sqlite3_test_control
(
testctrl
, 
p
->
db
,

9068 
azArg
[2],

9069 
	`integerValue
(
azArg
[3]),

9070 
	`integerValue
(
azArg
[4]));

9071 
	`fprintf
(
p
->
out
, "%d (0x%08x)\n", 
rc2
, rc2);

9073 
	`fprintf
(
stderr
,"Usage: .testctrl imposter dbName onoff tnum\n");

9082 
	`fprintf
(
stderr
,

9084 
azArg
[1]);

9090 if( 
c
=='t' && 
n
>4 && 
	`strncmp
(
azArg
[0], "timeout", n)==0 ){

9091 
	`open_db
(
p
, 0);

9092 
	`sqlite3_busy_timeout
(
p
->
db
, 
nArg
>=2 ? (int)
	`integerValue
(
azArg
[1]) : 0);

9095 if( 
c
=='t' && 
n
>=5 && 
	`strncmp
(
azArg
[0], "timer", n)==0 ){

9096 if( 
nArg
==2 ){

9097 
enableTimer
 = 
	`booleanValue
(
azArg
[1]);

9098 if( 
enableTimer
 && !1 ){

9099 
	`fprintf
(
stderr
, "Error: timer not available on this system.\n");

9100 
enableTimer
 = 0;

9103 
	`fprintf
(
stderr
, "Usage: .timer on|off\n");

9104 
rc
 = 1;

9108 if( 
c
=='t' && 
	`strncmp
(
azArg
[0], "trace", 
n
)==0 ){

9109 
	`open_db
(
p
, 0);

9110 if( 
nArg
!=2 ){

9111 
	`fprintf
(
stderr
, "Usage: .trace FILE|off\n");

9112 
rc
 = 1;

9113 goto 
meta_command_exit
;

9115 
	`output_file_close
(
p
->
traceOut
);

9116 
p
->
traceOut
 = 
	`output_file_open
(
azArg
[1]);

9118 if( 
p
->
traceOut
==0 ){

9119 
	`sqlite3_trace
(
p
->
db
, 0, 0);

9121 
	`sqlite3_trace
(
p
->
db
, 
sql_trace_callback
, p->
traceOut
);

9126 if( 
c
=='v' && 
	`strncmp
(
azArg
[0], "version", 
n
)==0 ){

9127 
	`fprintf
(
p
->
out
, "SQLite %s %s\n" ,

9128 
	`sqlite3_libversion
(), 
	`sqlite3_sourceid
());

9131 if( 
c
=='v' && 
	`strncmp
(
azArg
[0], "vfsinfo", 
n
)==0 ){

9132 const char *
zDbName
 = 
nArg
==2 ? 
azArg
[1] : "main";

9133 
sqlite3_vfs
 *
pVfs
;

9134 if( 
p
->
db
 ){

9135 
	`sqlite3_file_control
(
p
->
db
, 
zDbName
, 27, &
pVfs
);

9136 if( 
pVfs
 ){

9137 
	`fprintf
(
p
->
out
, "vfs.zName = \"%s\"\n", 
pVfs
->
zName
);

9138 
	`fprintf
(
p
->
out
, "vfs.iVersion = %d\n", 
pVfs
->
iVersion
);

9139 
	`fprintf
(
p
->
out
, "vfs.szOsFile = %d\n", 
pVfs
->
szOsFile
);

9140 
	`fprintf
(
p
->
out
, "vfs.mxPathname = %d\n", 
pVfs
->
mxPathname
);

9145 if( 
c
=='v' && 
	`strncmp
(
azArg
[0], "vfslist", 
n
)==0 ){

9146 
sqlite3_vfs
 *
pVfs
;

9147 
sqlite3_vfs
 *
pCurrent
 = 0;

9148 if( 
p
->
db
 ){

9149 
	`sqlite3_file_control
(
p
->
db
, "main", 27, &
pCurrent
);

9151 for(
pVfs
=
	`sqlite3_vfs_find
(0); pVfs; pVfs=pVfs->
pNext
){

9152 
	`fprintf
(
p
->
out
, "vfs.zName = \"%s\"%s\n", 
pVfs
->
zName
,

9153 
pVfs
==
pCurrent
 ? " <--- CURRENT" : "");

9154 
	`fprintf
(
p
->
out
, "vfs.iVersion = %d\n", 
pVfs
->
iVersion
);

9155 
	`fprintf
(
p
->
out
, "vfs.szOsFile = %d\n", 
pVfs
->
szOsFile
);

9156 
	`fprintf
(
p
->
out
, "vfs.mxPathname = %d\n", 
pVfs
->
mxPathname
);

9157 if( 
pVfs
->
pNext
 ){

9158 
	`fprintf
(
p
->
out
, "-----------------------------------\n");

9163 if( 
c
=='v' && 
	`strncmp
(
azArg
[0], "vfsname", 
n
)==0 ){

9164 const char *
zDbName
 = 
nArg
==2 ? 
azArg
[1] : "main";

9165 char *
zVfsName
 = 0;

9166 if( 
p
->
db
 ){

9167 
	`sqlite3_file_control
(
p
->
db
, 
zDbName
, 12, &
zVfsName
);

9168 if( 
zVfsName
 ){

9169 
	`fprintf
(
p
->
out
, "%s\n", 
zVfsName
);

9170 
	`sqlite3_free
(
zVfsName
);

9175 if( 
c
=='w' && 
	`strncmp
(
azArg
[0], "width", 
n
)==0 ){

9176 int 
j
;

9177 ((
nArg
<=(int)(sizeof(
azArg
)/sizeof(azArg[0]))) ? (void) (0) : 
	`__assert_fail
 ("nArg<=(int)(sizeof(azArg)/sizeof(azArg[0]))", "shell.c", 4290, 
__PRETTY_FUNCTION__
));

9178 for(
j
=1; j<
nArg
 && j<(int)(sizeof(
p
->
colWidth
)/sizeof(p->colWidth[0])); j++){

9179 
p
->
colWidth
[
j
-1] = (int)
	`integerValue
(
azArg
[j]);

9184 
	`fprintf
(
stderr
, "Error: unknown command or invalid arguments: "

9185 " \"%s\". Enter \".help\" for help\n", 
azArg
[0]);

9186 
rc
 = 1;

9189 
meta_command_exit
:

9190 if( 
p
->
outCount
 ){

9191 
p
->
outCount
--;

9192 if( 
p
->
outCount
==0 ) 
	`output_reset
(p);

9194 return 
rc
;

9195 
	}
}

9201 static int 
	$line_contains_semicolon
(const char *
z
, int 
N
){

9202 int 
i
;

9203 for(
i
=0; i<
N
; i++){ if( 
z
[i]==';' ) return 1; }

9205 
	}
}

9210 static int 
	$_all_whitespace
(const char *
z
){

9211 for(; *
z
; z++){

9212 if( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)
z
[0]))] & (unsigned short int) 
_ISspace
) ) continue;

9213 if( *
z
=='/' && z[1]=='*' ){

9214 
z
 += 2;

9215 while( *
z
 && (*z!='*' || z[1]!='/') ){ z++; }

9216 if( *
z
==0 ) return 0;

9217 
z
++;

9220 if( *
z
=='-' && z[1]=='-' ){

9221 
z
 += 2;

9222 while( *
z
 && *z!='\n' ){ z++; }

9223 if( *
z
==0 ) return 1;

9229 
	}
}

9236 static int 
	$line_is_command_terminator
(const char *
zLine
){

9237 while( ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)
zLine
[0]))] & (unsigned short int) 
_ISspace
) ){ zLine++; };

9238 if( 
zLine
[0]=='/' && 
	`_all_whitespace
(&zLine[1]) ){

9241 if( (char)
	`tolower
((unsigned char)
zLine
[0])=='g' && (char)tolower((unsigned char)zLine[1])=='o'

9242 && 
	`_all_whitespace
(&
zLine
[2]) ){

9246 
	}
}

9252 static int 
	$line_is_complete
(char *
zSql
, int 
nSql
){

9253 int 
rc
;

9254 if( 
zSql
==0 ) return 1;

9255 
zSql
[
nSql
] = ';';

9256 
zSql
[
nSql
+1] = 0;

9257 
rc
 = 
	`sqlite3_complete
(
zSql
);

9258 
zSql
[
nSql
] = 0;

9259 return 
rc
;

9260 
	}
}

9262 static int 
	$process_input
(
ShellState
 *
p
, 
FILE
 *
in
){

9263 char *
zLine
 = 0;

9264 char *
zSql
 = 0;

9265 int 
nLine
;

9266 int 
nSql
 = 0;

9267 int 
nAlloc
 = 0;

9268 int 
nSqlPrior
 = 0;

9269 char *
zErrMsg
;

9270 int 
rc
;

9271 int 
errCnt
 = 0;

9272 int 
lineno
 = 0;

9273 int 
startline
 = 0;

9275 while( 
errCnt
==0 || !
bail_on_error
 || (
in
==0 && 
stdin_is_interactive
) ){

9276 
	`fflush
(
p
->
out
);

9277 
zLine
 = 
	`one_input_line
(
in
, zLine, 
nSql
>0);

9278 if( 
zLine
==0 ){

9280 if( 
stdin_is_interactive
 ) 
	`printf
("\n");

9283 if( 
seenInterrupt
 ){

9284 if( 
in
!=0 ) break;

9285 
seenInterrupt
 = 0;

9287 
lineno
++;

9288 if( 
nSql
==0 && 
	`_all_whitespace
(
zLine
) ){

9289 if( 
p
->
echoOn
 ) 
	`printf
("%s\n", 
zLine
);

9292 if( 
zLine
 && zLine[0]=='.' && 
nSql
==0 ){

9293 if( 
p
->
echoOn
 ) 
	`printf
("%s\n", 
zLine
);

9294 
rc
 = 
	`do_meta_command
(
zLine
, 
p
);

9295 if( 
rc
==2 ){

9297 }else if( 
rc
 ){

9298 
errCnt
++;

9302 if( 
	`line_is_command_terminator
(
zLine
) && 
	`line_is_complete
(
zSql
, 
nSql
) ){

9303 
	`memcpy
(
zLine
,";",2);

9305 
nLine
 = 
	`strlen30
(
zLine
);

9306 if( 
nSql
+
nLine
+2>=
nAlloc
 ){

9307 
nAlloc
 = 
nSql
+
nLine
+100;

9308 
zSql
 = 
	`realloc
(zSql, 
nAlloc
);

9309 if( 
zSql
==0 ){

9310 
	`fprintf
(
stderr
, "Error: out of memory\n");

9311 
	`exit
(1);

9314 
nSqlPrior
 = 
nSql
;

9315 if( 
nSql
==0 ){

9316 int 
i
;

9317 for(
i
=0; 
zLine
[i] && ((*
	`__ctype_b_loc
 ())[(int) (((unsigned char)zLine[i]))] & (unsigned short int) 
_ISspace
); i++){}

9318 ((
nAlloc
>0 && 
zSql
!=0) ? (void) (0) : 
	`__assert_fail
 ("nAlloc>0 && zSql!=0", "shell.c", 4440, 
__PRETTY_FUNCTION__
));

9319 
	`memcpy
(
zSql
, 
zLine
+
i
, 
nLine
+1-i);

9320 
startline
 = 
lineno
;

9321 
nSql
 = 
nLine
-
i
;

9323 
zSql
[
nSql
++] = '\n';

9324 
	`memcpy
(
zSql
+
nSql
, 
zLine
, 
nLine
+1);

9325 
nSql
 += 
nLine
;

9327 if( 
nSql
 && 
	`line_contains_semicolon
(&
zSql
[
nSqlPrior
], nSql-nSqlPrior)

9328 && 
	`sqlite3_complete
(
zSql
) ){

9329 
p
->
cnt
 = 0;

9330 
	`open_db
(
p
, 0);

9331 if( 
p
->
backslashOn
 ) 
	`resolve_backslashes
(
zSql
);

9332 
	`beginTimer
();

9333 
rc
 = 
	`shell_exec
(
p
->
db
, 
zSql
, 
shell_callback
, p, &
zErrMsg
);

9334 
	`endTimer
();

9335 if( 
rc
 || 
zErrMsg
 ){

9336 char 
zPrefix
[100];

9337 if( 
in
!=0 || !
stdin_is_interactive
 ){

9338 
	`sqlite3_snprintf
(sizeof(
zPrefix
), zPrefix,

9339 "Error: near line %d:", 
startline
);

9341 
	`sqlite3_snprintf
(sizeof(
zPrefix
), zPrefix, "Error:");

9343 if( 
zErrMsg
!=0 ){

9344 
	`fprintf
(
stderr
, "%s %s\n", 
zPrefix
, 
zErrMsg
);

9345 
	`sqlite3_free
(
zErrMsg
);

9346 
zErrMsg
 = 0;

9348 
	`fprintf
(
stderr
, "%s %s\n", 
zPrefix
, 
	`sqlite3_errmsg
(
p
->
db
));

9350 
errCnt
++;

9351 }else if( 
p
->
countChanges
 ){

9352 
	`fprintf
(
p
->
out
, "changes: %3d total_changes: %d\n",

9353 
	`sqlite3_changes
(
p
->
db
), 
	`sqlite3_total_changes
(p->db));

9355 
nSql
 = 0;

9356 if( 
p
->
outCount
 ){

9357 
	`output_reset
(
p
);

9358 
p
->
outCount
 = 0;

9360 }else if( 
nSql
 && 
	`_all_whitespace
(
zSql
) ){

9361 if( 
p
->
echoOn
 ) 
	`printf
("%s\n", 
zSql
);

9362 
nSql
 = 0;

9365 if( 
nSql
 ){

9366 if( !
	`_all_whitespace
(
zSql
) ){

9367 
	`fprintf
(
stderr
, "Error: incomplete SQL: %s\n", 
zSql
);

9368 
errCnt
++;

9371 
	`free
(
zSql
);

9372 
	`free
(
zLine
);

9373 return 
errCnt
>0;

9374 
	}
}

9380 static char *
	$find_home_dir
(void){

9381 static char *
home_dir
 = ((void *)0);

9382 if( 
home_dir
 ) return home_dir;

9387 struct 
passwd
 *
pwent
;

9388 
uid_t
 
uid
 = 
	`getuid
();

9389 if( (
pwent
=
	`getpwuid
(
uid
)) != ((void *)0)) {

9390 
home_dir
 = 
pwent
->
pw_dir
;

9394 if (!
home_dir
) {

9395 
home_dir
 = 
	`getenv
("HOME");

9398 if( 
home_dir
 ){

9399 int 
n
 = 
	`strlen30
(
home_dir
) + 1;

9400 char *
z
 = 
	`malloc
( 
n
 );

9401 if( 
z
 ) 
	`memcpy
(z, 
home_dir
, 
n
);

9402 
home_dir
 = 
z
;

9405 return 
home_dir
;

9406 
	}
}

9414 static void 
	$process_sqliterc
(

9415 
ShellState
 *
p
,

9416 const char *
sqliterc_override


9418 char *
home_dir
 = ((void *)0);

9419 const char *
sqliterc
 = 
sqliterc_override
;

9420 char *
zBuf
 = 0;

9421 
FILE
 *
in
 = ((void *)0);

9423 if (
sqliterc
 == ((void *)0)) {

9424 
home_dir
 = 
	`find_home_dir
();

9425 if( 
home_dir
==0 ){

9426 
	`fprintf
(
stderr
, "-- warning: cannot find home directory;"

9430 
	`sqlite3_initialize
();

9431 
zBuf
 = 
	`sqlite3_mprintf
("%s/.sqliterc",
home_dir
);

9432 
sqliterc
 = 
zBuf
;

9434 
in
 = 
	`fopen
(
sqliterc
,"rb");

9435 if( 
in
 ){

9436 if( 
stdin_is_interactive
 ){

9437 
	`fprintf
(
stderr
,"-- Loading resources from %s\n",
sqliterc
);

9439 
	`process_input
(
p
,
in
);

9440 
	`fclose
(
in
);

9442 
	`sqlite3_free
(
zBuf
);

9443 
	}
}

9448 static const char 
	gzOptions
[] =

9483 static void 
	$usage
(int 
showDetail
){

9484 
	`fprintf
(
stderr
,

9487 "if the file does not previously exist.\n", 
Argv0
);

9488 if( 
showDetail
 ){

9489 
	`fprintf
(
stderr
, "OPTIONS include:\n%s", 
zOptions
);

9491 
	`fprintf
(
stderr
, "Use the -help option for additional information\n");

9493 
	`exit
(1);

9494 
	}
}

9499 static void 
	$main_init
(
ShellState
 *
data
) {

9500 
	`memset
(
data
, 0, sizeof(*data));

9501 
data
->
normalMode
 = data->
cMode
 = data->
mode
 = 2;

9502 
data
->
autoExplain
 = 1;

9503 
	`memcpy
(
data
->
colSeparator
,"|", 2);

9504 
	`memcpy
(
data
->
rowSeparator
,"\n", 2);

9505 
data
->
showHeader
 = 0;

9506 
data
->
shellFlgs
 = 0x00004;

9507 
	`sqlite3_config
(17, 1);

9508 
	`sqlite3_config
(16, 
shellLog
, 
data
);

9509 
	`sqlite3_config
(2);

9510 
	`sqlite3_snprintf
(sizeof(
mainPrompt
), mainPrompt,"sqlite> ");

9511 
	`sqlite3_snprintf
(sizeof(
continuePrompt
), continuePrompt," ...> ");

9512 
	}
}

9514 static void 
	$printBold
(const char *
zText
){

9515 
	`printf
("\033[1m%s\033[0m", 
zText
);

9516 
	}
}

9523 static char *
	$cmdline_option_value
(int 
argc
, char **
argv
, int 
i
){

9524 if( 
i
==
argc
 ){

9525 
	`fprintf
(
stderr
, "%s: Error: missing argument to %s\n",

9526 
argv
[0], argv[
argc
-1]);

9527 
	`exit
(1);

9529 return 
argv
[
i
];

9530 
	}
}

9532 int 
	$main
(int 
argc
, char **
argv
){

9533 char *
zErrMsg
 = 0;

9534 
ShellState
 
data
;

9535 const char *
zInitFile
 = 0;

9536 int 
i
;

9537 int 
rc
 = 0;

9538 int 
warnInmemoryDb
 = 0;

9539 int 
readStdin
 = 1;

9540 int 
nCmd
 = 0;

9541 char **
azCmd
 = 0;

9544 if( 
	`strcmp
(
	`sqlite3_sourceid
(),"2016-03-29 10:14:15 e9bb4cf40f4971974a74468ef922bdee481c988b")!=0 ){

9545 
	`fprintf
(
stderr
, "SQLite header and source version mismatch\n%s\n%s\n",

9546 
	`sqlite3_sourceid
(), "2016-03-29 10:14:15 e9bb4cf40f4971974a74468ef922bdee481c988b");

9547 
	`exit
(1);

9551 
	`setvbuf
(
stderr
, 0, 2, 0);

9552 
Argv0
 = 
argv
[0];

9553 
	`main_init
(&
data
);

9554 
stdin_is_interactive
 = 
	`isatty
(0);

9555 
stdout_is_console
 = 
	`isatty
(1);

9561 
	`signal
(2, 
interrupt_handler
);

9563 for(
i
=1; i<
argc
; i++){

9564 char *
z
;

9565 
z
 = 
argv
[
i
];

9566 if( 
z
[0]!='-' ){

9567 if( 
data
.
zDbFilename
==0 ){

9568 
data
.
zDbFilename
 = 
z
;

9572 
readStdin
 = 0;

9573 
nCmd
++;

9574 
azCmd
 = 
	`realloc
(azCmd, sizeof(azCmd[0])*
nCmd
);

9575 if( 
azCmd
==0 ){

9576 
	`fprintf
(
stderr
, "out of memory\n");

9577 
	`exit
(1);

9579 
azCmd
[
nCmd
-1] = 
z
;

9582 if( 
z
[1]=='-' ) z++;

9583 if( 
	`strcmp
(
z
,"-separator")==0

9584 || 
	`strcmp
(
z
,"-nullvalue")==0

9585 || 
	`strcmp
(
z
,"-newline")==0

9586 || 
	`strcmp
(
z
,"-cmd")==0

9588 (void)
	`cmdline_option_value
(
argc
, 
argv
, ++
i
);

9589 }else if( 
	`strcmp
(
z
,"-init")==0 ){

9590 
zInitFile
 = 
	`cmdline_option_value
(
argc
, 
argv
, ++
i
);

9591 }else if( 
	`strcmp
(
z
,"-batch")==0 ){

9596 
stdin_is_interactive
 = 0;

9597 }else if( 
	`strcmp
(
z
,"-heap")==0 ){

9599 }else if( 
	`strcmp
(
z
,"-scratch")==0 ){

9600 int 
n
, 
sz
;

9601 
sz
 = (int)
	`integerValue
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9602 if( 
sz
>400000 ) sz = 400000;

9603 if( 
sz
<2500 ) sz = 2500;

9604 
n
 = (int)
	`integerValue
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9605 if( 
n
>10 ) n = 10;

9606 if( 
n
<1 ) n = 1;

9607 
	`sqlite3_config
(6, 
	`malloc
(
n
*
sz
+1), sz, n);

9608 
data
.
shellFlgs
 |= 0x00001;

9609 }else if( 
	`strcmp
(
z
,"-pagecache")==0 ){

9610 int 
n
, 
sz
;

9611 
sz
 = (int)
	`integerValue
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9612 if( 
sz
>70000 ) sz = 70000;

9613 if( 
sz
<0 ) sz = 0;

9614 
n
 = (int)
	`integerValue
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9615 
	`sqlite3_config
(7,

9616 (
n
>0 && 
sz
>0) ? 
	`malloc
(n*sz) : 0, sz, n);

9617 
data
.
shellFlgs
 |= 0x00002;

9618 }else if( 
	`strcmp
(
z
,"-lookaside")==0 ){

9619 int 
n
, 
sz
;

9620 
sz
 = (int)
	`integerValue
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9621 if( 
sz
<0 ) sz = 0;

9622 
n
 = (int)
	`integerValue
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9623 if( 
n
<0 ) n = 0;

9624 
	`sqlite3_config
(13, 
sz
, 
n
);

9625 if( 
sz
*
n
==0 ) 
data
.
shellFlgs
 &= ~0x00004;

9627 }else if( 
	`strcmp
(
z
,"-mmap")==0 ){

9628 
sqlite3_int64
 
sz
 = 
	`integerValue
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9629 
	`sqlite3_config
(22, 
sz
, sz);

9630 }else if( 
	`strcmp
(
z
,"-vfs")==0 ){

9631 
sqlite3_vfs
 *
pVfs
 = 
	`sqlite3_vfs_find
(
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9632 if( 
pVfs
 ){

9633 
	`sqlite3_vfs_register
(
pVfs
, 1);

9635 
	`fprintf
(
stderr
, "no such VFS: \"%s\"\n", 
argv
[
i
]);

9636 
	`exit
(1);

9640 if( 
data
.
zDbFilename
==0 ){

9642 
data
.
zDbFilename
 = ":memory:";

9643 
warnInmemoryDb
 = 
argc
==1;

9649 
data
.
out
 = 
stdout
;

9656 if( 
	`access
(
data
.
zDbFilename
, 0)==0 ){

9657 
	`open_db
(&
data
, 0);

9664 
	`process_sqliterc
(&
data
,
zInitFile
);

9671 for(
i
=1; i<
argc
; i++){

9672 char *
z
 = 
argv
[
i
];

9673 if( 
z
[0]!='-' ) continue;

9674 if( 
z
[1]=='-' ){ z++; }

9675 if( 
	`strcmp
(
z
,"-init")==0 ){

9676 
i
++;

9677 }else if( 
	`strcmp
(
z
,"-html")==0 ){

9678 
data
.
mode
 = 4;

9679 }else if( 
	`strcmp
(
z
,"-list")==0 ){

9680 
data
.
mode
 = 2;

9681 }else if( 
	`strcmp
(
z
,"-line")==0 ){

9682 
data
.
mode
 = 0;

9683 }else if( 
	`strcmp
(
z
,"-column")==0 ){

9684 
data
.
mode
 = 1;

9685 }else if( 
	`strcmp
(
z
,"-csv")==0 ){

9686 
data
.
mode
 = 7;

9687 
	`memcpy
(
data
.
colSeparator
,",",2);

9688 }else if( 
	`strcmp
(
z
,"-ascii")==0 ){

9689 
data
.
mode
 = 9;

9690 
	`sqlite3_snprintf
(sizeof(
data
.
colSeparator
), data.colSeparator,

9692 
	`sqlite3_snprintf
(sizeof(
data
.
rowSeparator
), data.rowSeparator,

9694 }else if( 
	`strcmp
(
z
,"-separator")==0 ){

9695 
	`sqlite3_snprintf
(sizeof(
data
.
colSeparator
), data.colSeparator,

9696 "%s",
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9697 }else if( 
	`strcmp
(
z
,"-newline")==0 ){

9698 
	`sqlite3_snprintf
(sizeof(
data
.
rowSeparator
), data.rowSeparator,

9699 "%s",
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9700 }else if( 
	`strcmp
(
z
,"-nullvalue")==0 ){

9701 
	`sqlite3_snprintf
(sizeof(
data
.
nullValue
), data.nullValue,

9702 "%s",
	`cmdline_option_value
(
argc
,
argv
,++
i
));

9703 }else if( 
	`strcmp
(
z
,"-header")==0 ){

9704 
data
.
showHeader
 = 1;

9705 }else if( 
	`strcmp
(
z
,"-noheader")==0 ){

9706 
data
.
showHeader
 = 0;

9707 }else if( 
	`strcmp
(
z
,"-echo")==0 ){

9708 
data
.
echoOn
 = 1;

9709 }else if( 
	`strcmp
(
z
,"-eqp")==0 ){

9710 
data
.
autoEQP
 = 1;

9711 }else if( 
	`strcmp
(
z
,"-stats")==0 ){

9712 
data
.
statsOn
 = 1;

9713 }else if( 
	`strcmp
(
z
,"-scanstats")==0 ){

9714 
data
.
scanstatsOn
 = 1;

9715 }else if( 
	`strcmp
(
z
,"-backslash")==0 ){

9721 
data
.
backslashOn
 = 1;

9722 }else if( 
	`strcmp
(
z
,"-bail")==0 ){

9723 
bail_on_error
 = 1;

9724 }else if( 
	`strcmp
(
z
,"-version")==0 ){

9725 
	`printf
("%s %s\n", 
	`sqlite3_libversion
(), 
	`sqlite3_sourceid
());

9727 }else if( 
	`strcmp
(
z
,"-interactive")==0 ){

9728 
stdin_is_interactive
 = 1;

9729 }else if( 
	`strcmp
(
z
,"-batch")==0 ){

9730 
stdin_is_interactive
 = 0;

9731 }else if( 
	`strcmp
(
z
,"-heap")==0 ){

9732 
i
++;

9733 }else if( 
	`strcmp
(
z
,"-scratch")==0 ){

9734 
i
+=2;

9735 }else if( 
	`strcmp
(
z
,"-pagecache")==0 ){

9736 
i
+=2;

9737 }else if( 
	`strcmp
(
z
,"-lookaside")==0 ){

9738 
i
+=2;

9739 }else if( 
	`strcmp
(
z
,"-mmap")==0 ){

9740 
i
++;

9741 }else if( 
	`strcmp
(
z
,"-vfs")==0 ){

9742 
i
++;

9744 }else if( 
	`strcmp
(
z
,"-help")==0 ){

9745 
	`usage
(1);

9746 }else if( 
	`strcmp
(
z
,"-cmd")==0 ){

9751 if( 
i
==
argc
-1 ) break;

9752 
z
 = 
	`cmdline_option_value
(
argc
,
argv
,++
i
);

9753 if( 
z
[0]=='.' ){

9754 
rc
 = 
	`do_meta_command
(
z
, &
data
);

9755 if( 
rc
 && 
bail_on_error
 ) return rc==2 ? 0 : rc;

9757 
	`open_db
(&
data
, 0);

9758 
rc
 = 
	`shell_exec
(
data
.
db
, 
z
, 
shell_callback
, &data, &
zErrMsg
);

9759 if( 
zErrMsg
!=0 ){

9760 
	`fprintf
(
stderr
,"Error: %s\n", 
zErrMsg
);

9761 if( 
bail_on_error
 ) return 
rc
!=0 ? rc : 1;

9762 }else if( 
rc
!=0 ){

9763 
	`fprintf
(
stderr
,"Error: unable to process SQL \"%s\"\n", 
z
);

9764 if( 
bail_on_error
 ) return 
rc
;

9768 
	`fprintf
(
stderr
,"%s: Error: unknown option: %s\n", 
Argv0
, 
z
);

9769 
	`fprintf
(
stderr
,"Use -help for a list of options.\n");

9772 
data
.
cMode
 = data.
mode
;

9775 if( !
readStdin
 ){

9780 for(
i
=0; i<
nCmd
; i++){

9781 if( 
azCmd
[
i
][0]=='.' ){

9782 
rc
 = 
	`do_meta_command
(
azCmd
[
i
], &
data
);

9783 if( 
rc
 ) return rc==2 ? 0 : rc;

9785 
	`open_db
(&
data
, 0);

9786 
rc
 = 
	`shell_exec
(
data
.
db
, 
azCmd
[
i
], 
shell_callback
, &data, &
zErrMsg
);

9787 if( 
zErrMsg
!=0 ){

9788 
	`fprintf
(
stderr
,"Error: %s\n", 
zErrMsg
);

9789 return 
rc
!=0 ? rc : 1;

9790 }else if( 
rc
!=0 ){

9791 
	`fprintf
(
stderr
,"Error: unable to process SQL: %s\n", 
azCmd
[
i
]);

9792 return 
rc
;

9796 
	`free
(
azCmd
);

9800 if( 
stdin_is_interactive
 ){

9801 char *
zHome
;

9802 char *
zHistory
 = 0;

9803 int 
nHistory
;

9804 
	`printf
(

9807 
	`sqlite3_libversion
(), 
	`sqlite3_sourceid
()

9809 if( 
warnInmemoryDb
 ){

9810 
	`printf
("Connected to a ");

9811 
	`printBold
("transient in-memory database");

9812 
	`printf
(".\nUse \".open FILENAME\" to reopen on a "

9815 
zHome
 = 
	`find_home_dir
();

9816 if( 
zHome
 ){

9817 
nHistory
 = 
	`strlen30
(
zHome
) + 20;

9818 if( (
zHistory
 = 
	`malloc
(
nHistory
))!=0 ){

9819 
	`sqlite3_snprintf
(
nHistory
, 
zHistory
,"%s/.sqlite_history", 
zHome
);

9822 if( 
zHistory
 ){ ; }

9823 
rc
 = 
	`process_input
(&
data
, 0);

9824 if( 
zHistory
 ){

9827 
	`free
(
zHistory
);

9830 
rc
 = 
	`process_input
(&
data
, 
stdin
);

9833 
	`set_table_name
(&
data
, 0);

9834 if( 
data
.
db
 ){

9835 
	`sqlite3_close
(
data
.
db
);

9837 
	`sqlite3_free
(
data
.
zFreeOnClose
);

9838 return 
rc
;

9839 
	}
}

	@sqlite3.cpp.c

10 typedef 
__builtin_va_list
 
	t__gnuc_va_list
;

12 typedef 
__gnuc_va_list
 
	tva_list
;

15 const char 
	gsqlite3_version
[] = "3.12.0";

16 const char * 
sqlite3_libversion
(void);

17 const char * 
sqlite3_sourceid
(void);

18 int 
sqlite3_libversion_number
(void);

20 int 
sqlite3_compileoption_used
(const char *
zOptName
);

21 const char * 
sqlite3_compileoption_get
(int 
N
);

23 int 
sqlite3_threadsafe
(void);

25 typedef struct 
sqlite3
 
	tsqlite3
;

27 typedef long long int 
	tsqlite_int64
;

28 typedef unsigned long long int 
	tsqlite_uint64
;

30 typedef 
sqlite_int64
 
	tsqlite3_int64
;

31 typedef 
sqlite_uint64
 
	tsqlite3_uint64
;

33 int 
sqlite3_close
(
sqlite3
*);

34 int 
sqlite3_close_v2
(
sqlite3
*);

41 typedef int (*
	tsqlite3_callback
)(void*,int,char**, char**);

43 int 
	`sqlite3_exec
(

44 
sqlite3
*,

45 const char *
sql
,

46 int (*
callback
)(void*,int,char**,char**),

48 char **
errmsg


51 typedef struct 
sqlite3_file
 
	tsqlite3_file
;

52 struct 
	ssqlite3_file
 {

53 const struct 
sqlite3_io_methods
 *
pMethods
;

56 typedef struct 
sqlite3_io_methods
 
	tsqlite3_io_methods
;

57 struct 
	ssqlite3_io_methods
 {

58 int 
iVersion
;

59 int (*
xClose
)(
sqlite3_file
*);

60 int (*
xRead
)(
sqlite3_file
*, void*, int 
iAmt
, 
sqlite3_int64
 
iOfst
);

61 int (*
xWrite
)(
sqlite3_file
*, const void*, int 
iAmt
, 
sqlite3_int64
 
iOfst
);

62 int (*
xTruncate
)(
sqlite3_file
*, 
sqlite3_int64
 
size
);

63 int (*
xSync
)(
sqlite3_file
*, int 
flags
);

64 int (*
xFileSize
)(
sqlite3_file
*, 
sqlite3_int64
 *
pSize
);

65 int (*
xLock
)(
sqlite3_file
*, int);

66 int (*
xUnlock
)(
sqlite3_file
*, int);

67 int (*
xCheckReservedLock
)(
sqlite3_file
*, int *
pResOut
);

68 int (*
xFileControl
)(
sqlite3_file
*, int 
op
, void *
pArg
);

69 int (*
xSectorSize
)(
sqlite3_file
*);

70 int (*
xDeviceCharacteristics
)(
sqlite3_file
*);

72 int (*
xShmMap
)(
sqlite3_file
*, int 
iPg
, int 
pgsz
, int, void volatile**);

73 int (*
xShmLock
)(
sqlite3_file
*, int 
offset
, int 
n
, int 
flags
);

74 void (*
xShmBarrier
)(
sqlite3_file
*);

75 int (*
xShmUnmap
)(
sqlite3_file
*, int 
deleteFlag
);

77 int (*
xFetch
)(
sqlite3_file
*, 
sqlite3_int64
 
iOfst
, int 
iAmt
, void **
pp
);

78 int (*
xUnfetch
)(
sqlite3_file
*, 
sqlite3_int64
 
iOfst
, void *
p
);

83 typedef struct 
sqlite3_mutex
 
	tsqlite3_mutex
;

85 typedef struct 
sqlite3_vfs
 
	tsqlite3_vfs
;

86 typedef void (*
	tsqlite3_syscall_ptr
)(void);

87 struct 
	ssqlite3_vfs
 {

88 int 
iVersion
;

89 int 
szOsFile
;

90 int 
mxPathname
;

91 
sqlite3_vfs
 *
pNext
;

92 const char *
zName
;

93 void *
pAppData
;

94 int (*
xOpen
)(
sqlite3_vfs
*, const char *
zName
, 
sqlite3_file
*,

95 int 
flags
, int *
pOutFlags
);

96 int (*
xDelete
)(
sqlite3_vfs
*, const char *
zName
, int 
syncDir
);

97 int (*
xAccess
)(
sqlite3_vfs
*, const char *
zName
, int 
flags
, int *
pResOut
);

98 int (*
xFullPathname
)(
sqlite3_vfs
*, const char *
zName
, int 
nOut
, char *
zOut
);

99 void *(*
xDlOpen
)(
sqlite3_vfs
*, const char *
zFilename
);

100 void (*
xDlError
)(
sqlite3_vfs
*, int 
nByte
, char *
zErrMsg
);

101 void (*(*
xDlSym
)(
sqlite3_vfs
*,void*, const char *
zSymbol
))(void);

102 void (*
xDlClose
)(
sqlite3_vfs
*, void*);

103 int (*
xRandomness
)(
sqlite3_vfs
*, int 
nByte
, char *
zOut
);

104 int (*
xSleep
)(
sqlite3_vfs
*, int 
microseconds
);

105 int (*
xCurrentTime
)(
sqlite3_vfs
*, double*);

106 int (*
xGetLastError
)(
sqlite3_vfs
*, int, char *);

111 int (*
xCurrentTimeInt64
)(
sqlite3_vfs
*, 
sqlite3_int64
*);

116 int (*
xSetSystemCall
)(
sqlite3_vfs
*, const char *
zName
, 
sqlite3_syscall_ptr
);

117 
	`sqlite3_syscall_ptr
 (*
xGetSystemCall
)(
sqlite3_vfs
*, const char *
zName
);

118 const char *(*
xNextSystemCall
)(
sqlite3_vfs
*, const char *
zName
);

126 int 
	`sqlite3_initialize
(void);

127 int 
	`sqlite3_shutdown
(void);

128 int 
	`sqlite3_os_init
(void);

129 int 
	`sqlite3_os_end
(void);

131 int 
	`sqlite3_config
(int, ...);

133 int 
	`sqlite3_db_config
(
sqlite3
*, int 
op
, ...);

135 typedef struct 
sqlite3_mem_methods
 
	tsqlite3_mem_methods
;

136 struct 
	ssqlite3_mem_methods
 {

137 void *(*
xMalloc
)(int);

138 void (*
xFree
)(void*);

139 void *(*
xRealloc
)(void*,int);

140 int (*
xSize
)(void*);

141 int (*
xRoundup
)(int);

142 int (*
xInit
)(void*);

143 void (*
xShutdown
)(void*);

144 void *
pAppData
;

147 int 
	`sqlite3_extended_result_codes
(
sqlite3
*, int 
onoff
);

149 
sqlite3_int64
 
	`sqlite3_last_insert_rowid
(
sqlite3
*);

151 int 
	`sqlite3_changes
(
sqlite3
*);

153 int 
	`sqlite3_total_changes
(
sqlite3
*);

155 void 
	`sqlite3_interrupt
(
sqlite3
*);

157 int 
	`sqlite3_complete
(const char *
sql
);

158 int 
	`sqlite3_complete16
(const void *
sql
);

160 int 
	`sqlite3_busy_handler
(
sqlite3
*, int(*)(void*,int), void*);

162 int 
	`sqlite3_busy_timeout
(
sqlite3
*, int 
ms
);

164 int 
	`sqlite3_get_table
(

165 
sqlite3
 *
db
,

166 const char *
zSql
,

167 char ***
pazResult
,

168 int *
pnRow
,

169 int *
pnColumn
,

170 char **
pzErrmsg


172 void 
	`sqlite3_free_table
(char **
result
);

174 char * 
	`sqlite3_mprintf
(const char*,...);

175 char * 
	`sqlite3_vmprintf
(const char*, 
va_list
);

176 char * 
	`sqlite3_snprintf
(int,char*,const char*, ...);

177 char * 
	`sqlite3_vsnprintf
(int,char*,const char*, 
va_list
);

179 void * 
	`sqlite3_malloc
(int);

180 void * 
	`sqlite3_malloc64
(
sqlite3_uint64
);

181 void * 
	`sqlite3_realloc
(void*, int);

182 void * 
	`sqlite3_realloc64
(void*, 
sqlite3_uint64
);

183 void 
	`sqlite3_free
(void*);

184 
sqlite3_uint64
 
	`sqlite3_msize
(void*);

186 
sqlite3_int64
 
	`sqlite3_memory_used
(void);

187 
sqlite3_int64
 
	`sqlite3_memory_highwater
(int 
resetFlag
);

189 void 
	`sqlite3_randomness
(int 
N
, void *
P
);

191 int 
	`sqlite3_set_authorizer
(

192 
sqlite3
*,

193 int (*
xAuth
)(void*,int,const char*,const char*,const char*,const char*),

194 void *
pUserData


197 void * 
	`sqlite3_trace
(
sqlite3
*, void(*
xTrace
)(void*,const char*), void*);

198 void * 
	`sqlite3_profile
(
sqlite3
*,

199 void(*
xProfile
)(void*,const char*,
sqlite3_uint64
), void*);

201 void 
	`sqlite3_progress_handler
(
sqlite3
*, int, int(*)(void*), void*);

203 int 
	`sqlite3_open
(

204 const char *
filename
,

205 
sqlite3
 **
ppDb


207 int 
	`sqlite3_open16
(

208 const void *
filename
,

209 
sqlite3
 **
ppDb


211 int 
	`sqlite3_open_v2
(

212 const char *
filename
,

213 
sqlite3
 **
ppDb
,

214 int 
flags
,

215 const char *
zVfs


218 const char * 
	`sqlite3_uri_parameter
(const char *
zFilename
, const char *
zParam
);

219 int 
	`sqlite3_uri_boolean
(const char *
zFile
, const char *
zParam
, int 
bDefault
);

220 
sqlite3_int64
 
	`sqlite3_uri_int64
(const char*, const char*, sqlite3_int64);

222 int 
	`sqlite3_errcode
(
sqlite3
 *
db
);

223 int 
	`sqlite3_extended_errcode
(
sqlite3
 *
db
);

224 const char * 
	`sqlite3_errmsg
(
sqlite3
*);

225 const void * 
	`sqlite3_errmsg16
(
sqlite3
*);

226 const char * 
	`sqlite3_errstr
(int);

228 typedef struct 
sqlite3_stmt
 
	tsqlite3_stmt
;

230 int 
	`sqlite3_limit
(
sqlite3
*, int 
id
, int 
newVal
);

232 int 
	`sqlite3_prepare
(

233 
sqlite3
 *
db
,

234 const char *
zSql
,

235 int 
nByte
,

236 
sqlite3_stmt
 **
ppStmt
,

237 const char **
pzTail


239 int 
	`sqlite3_prepare_v2
(

240 
sqlite3
 *
db
,

241 const char *
zSql
,

242 int 
nByte
,

243 
sqlite3_stmt
 **
ppStmt
,

244 const char **
pzTail


246 int 
	`sqlite3_prepare16
(

247 
sqlite3
 *
db
,

248 const void *
zSql
,

249 int 
nByte
,

250 
sqlite3_stmt
 **
ppStmt
,

251 const void **
pzTail


253 int 
	`sqlite3_prepare16_v2
(

254 
sqlite3
 *
db
,

255 const void *
zSql
,

256 int 
nByte
,

257 
sqlite3_stmt
 **
ppStmt
,

258 const void **
pzTail


261 const char * 
	`sqlite3_sql
(
sqlite3_stmt
 *
pStmt
);

263 int 
	`sqlite3_stmt_readonly
(
sqlite3_stmt
 *
pStmt
);

265 int 
	`sqlite3_stmt_busy
(
sqlite3_stmt
*);

267 typedef struct 
Mem
 
	tsqlite3_value
;

269 typedef struct 
sqlite3_context
 
	tsqlite3_context
;

271 int 
	`sqlite3_bind_blob
(
sqlite3_stmt
*, int, const void*, int 
n
, void(*)(void*));

272 int 
	`sqlite3_bind_blob64
(
sqlite3_stmt
*, int, const void*, 
sqlite3_uint64
,

274 int 
	`sqlite3_bind_double
(
sqlite3_stmt
*, int, double);

275 int 
	`sqlite3_bind_int
(
sqlite3_stmt
*, int, int);

276 int 
	`sqlite3_bind_int64
(
sqlite3_stmt
*, int, 
sqlite3_int64
);

277 int 
	`sqlite3_bind_null
(
sqlite3_stmt
*, int);

278 int 
	`sqlite3_bind_text
(
sqlite3_stmt
*,int,const char*,int,void(*)(void*));

279 int 
	`sqlite3_bind_text16
(
sqlite3_stmt
*, int, const void*, int, void(*)(void*));

280 int 
	`sqlite3_bind_text64
(
sqlite3_stmt
*, int, const char*, 
sqlite3_uint64
,

281 void(*)(void*), unsigned char 
encoding
);

282 int 
	`sqlite3_bind_value
(
sqlite3_stmt
*, int, const 
sqlite3_value
*);

283 int 
	`sqlite3_bind_zeroblob
(
sqlite3_stmt
*, int, int 
n
);

284 int 
	`sqlite3_bind_zeroblob64
(
sqlite3_stmt
*, int, 
sqlite3_uint64
);

286 int 
	`sqlite3_bind_parameter_count
(
sqlite3_stmt
*);

288 const char * 
	`sqlite3_bind_parameter_name
(
sqlite3_stmt
*, int);

290 int 
	`sqlite3_bind_parameter_index
(
sqlite3_stmt
*, const char *
zName
);

292 int 
	`sqlite3_clear_bindings
(
sqlite3_stmt
*);

294 int 
	`sqlite3_column_count
(
sqlite3_stmt
 *
pStmt
);

296 const char * 
	`sqlite3_column_name
(
sqlite3_stmt
*, int 
N
);

297 const void * 
	`sqlite3_column_name16
(
sqlite3_stmt
*, int 
N
);

299 const char * 
	`sqlite3_column_database_name
(
sqlite3_stmt
*,int);

300 const void * 
	`sqlite3_column_database_name16
(
sqlite3_stmt
*,int);

301 const char * 
	`sqlite3_column_table_name
(
sqlite3_stmt
*,int);

302 const void * 
	`sqlite3_column_table_name16
(
sqlite3_stmt
*,int);

303 const char * 
	`sqlite3_column_origin_name
(
sqlite3_stmt
*,int);

304 const void * 
	`sqlite3_column_origin_name16
(
sqlite3_stmt
*,int);

306 const char * 
	`sqlite3_column_decltype
(
sqlite3_stmt
*,int);

307 const void * 
	`sqlite3_column_decltype16
(
sqlite3_stmt
*,int);

309 int 
	`sqlite3_step
(
sqlite3_stmt
*);

311 int 
	`sqlite3_data_count
(
sqlite3_stmt
 *
pStmt
);

313 const void * 
	`sqlite3_column_blob
(
sqlite3_stmt
*, int 
iCol
);

314 int 
	`sqlite3_column_bytes
(
sqlite3_stmt
*, int 
iCol
);

315 int 
	`sqlite3_column_bytes16
(
sqlite3_stmt
*, int 
iCol
);

316 double 
	`sqlite3_column_double
(
sqlite3_stmt
*, int 
iCol
);

317 int 
	`sqlite3_column_int
(
sqlite3_stmt
*, int 
iCol
);

318 
sqlite3_int64
 
	`sqlite3_column_int64
(
sqlite3_stmt
*, int 
iCol
);

319 const unsigned char * 
	`sqlite3_column_text
(
sqlite3_stmt
*, int 
iCol
);

320 const void * 
	`sqlite3_column_text16
(
sqlite3_stmt
*, int 
iCol
);

321 int 
	`sqlite3_column_type
(
sqlite3_stmt
*, int 
iCol
);

322 
sqlite3_value
 * 
	`sqlite3_column_value
(
sqlite3_stmt
*, int 
iCol
);

324 int 
	`sqlite3_finalize
(
sqlite3_stmt
 *
pStmt
);

326 int 
	`sqlite3_reset
(
sqlite3_stmt
 *
pStmt
);

328 int 
	`sqlite3_create_function
(

329 
sqlite3
 *
db
,

330 const char *
zFunctionName
,

331 int 
nArg
,

332 int 
eTextRep
,

333 void *
pApp
,

334 void (*
xFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

335 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
**),

336 void (*
xFinal
)(
sqlite3_context
*)

338 int 
	`sqlite3_create_function16
(

339 
sqlite3
 *
db
,

340 const void *
zFunctionName
,

341 int 
nArg
,

342 int 
eTextRep
,

343 void *
pApp
,

344 void (*
xFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

345 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
**),

346 void (*
xFinal
)(
sqlite3_context
*)

348 int 
	`sqlite3_create_function_v2
(

349 
sqlite3
 *
db
,

350 const char *
zFunctionName
,

351 int 
nArg
,

352 int 
eTextRep
,

353 void *
pApp
,

354 void (*
xFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

355 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
**),

356 void (*
xFinal
)(
sqlite3_context
*),

357 void(*
xDestroy
)(void*)

360 int 
	`sqlite3_aggregate_count
(
sqlite3_context
*);

361 int 
	`sqlite3_expired
(
sqlite3_stmt
*);

362 int 
	`sqlite3_transfer_bindings
(
sqlite3_stmt
*, sqlite3_stmt*);

363 int 
	`sqlite3_global_recover
(void);

364 void 
	`sqlite3_thread_cleanup
(void);

365 int 
	`sqlite3_memory_alarm
(void(*)(void*,
sqlite3_int64
,int),

366 void*,
sqlite3_int64
);

368 const void * 
	`sqlite3_value_blob
(
sqlite3_value
*);

369 int 
	`sqlite3_value_bytes
(
sqlite3_value
*);

370 int 
	`sqlite3_value_bytes16
(
sqlite3_value
*);

371 double 
	`sqlite3_value_double
(
sqlite3_value
*);

372 int 
	`sqlite3_value_int
(
sqlite3_value
*);

373 
sqlite3_int64
 
	`sqlite3_value_int64
(
sqlite3_value
*);

374 const unsigned char * 
	`sqlite3_value_text
(
sqlite3_value
*);

375 const void * 
	`sqlite3_value_text16
(
sqlite3_value
*);

376 const void * 
	`sqlite3_value_text16le
(
sqlite3_value
*);

377 const void * 
	`sqlite3_value_text16be
(
sqlite3_value
*);

378 int 
	`sqlite3_value_type
(
sqlite3_value
*);

379 int 
	`sqlite3_value_numeric_type
(
sqlite3_value
*);

381 unsigned int 
	`sqlite3_value_subtype
(
sqlite3_value
*);

383 
sqlite3_value
 * 
	`sqlite3_value_dup
(const sqlite3_value*);

384 void 
	`sqlite3_value_free
(
sqlite3_value
*);

386 void * 
	`sqlite3_aggregate_context
(
sqlite3_context
*, int 
nBytes
);

388 void * 
	`sqlite3_user_data
(
sqlite3_context
*);

390 
sqlite3
 * 
	`sqlite3_context_db_handle
(
sqlite3_context
*);

392 void * 
	`sqlite3_get_auxdata
(
sqlite3_context
*, int 
N
);

393 void 
	`sqlite3_set_auxdata
(
sqlite3_context
*, int 
N
, void*, void (*)(void*));

395 typedef void (*
	tsqlite3_destructor_type
)(void*);

397 void 
	`sqlite3_result_blob
(
sqlite3_context
*, const void*, int, void(*)(void*));

398 void 
	`sqlite3_result_blob64
(
sqlite3_context
*,const void*,

399 
sqlite3_uint64
,void(*)(void*));

400 void 
	`sqlite3_result_double
(
sqlite3_context
*, double);

401 void 
	`sqlite3_result_error
(
sqlite3_context
*, const char*, int);

402 void 
	`sqlite3_result_error16
(
sqlite3_context
*, const void*, int);

403 void 
	`sqlite3_result_error_toobig
(
sqlite3_context
*);

404 void 
	`sqlite3_result_error_nomem
(
sqlite3_context
*);

405 void 
	`sqlite3_result_error_code
(
sqlite3_context
*, int);

406 void 
	`sqlite3_result_int
(
sqlite3_context
*, int);

407 void 
	`sqlite3_result_int64
(
sqlite3_context
*, 
sqlite3_int64
);

408 void 
	`sqlite3_result_null
(
sqlite3_context
*);

409 void 
	`sqlite3_result_text
(
sqlite3_context
*, const char*, int, void(*)(void*));

410 void 
	`sqlite3_result_text64
(
sqlite3_context
*, const char*,
sqlite3_uint64
,

411 void(*)(void*), unsigned char 
encoding
);

412 void 
	`sqlite3_result_text16
(
sqlite3_context
*, const void*, int, void(*)(void*));

413 void 
	`sqlite3_result_text16le
(
sqlite3_context
*, const void*, int,void(*)(void*));

414 void 
	`sqlite3_result_text16be
(
sqlite3_context
*, const void*, int,void(*)(void*));

415 void 
	`sqlite3_result_value
(
sqlite3_context
*, 
sqlite3_value
*);

416 void 
	`sqlite3_result_zeroblob
(
sqlite3_context
*, int 
n
);

417 int 
	`sqlite3_result_zeroblob64
(
sqlite3_context
*, 
sqlite3_uint64
 
n
);

419 void 
	`sqlite3_result_subtype
(
sqlite3_context
*,unsigned int);

421 int 
	`sqlite3_create_collation
(

422 
sqlite3
*,

423 const char *
zName
,

424 int 
eTextRep
,

425 void *
pArg
,

426 int(*
xCompare
)(void*,int,const void*,int,const void*)

428 int 
	`sqlite3_create_collation_v2
(

429 
sqlite3
*,

430 const char *
zName
,

431 int 
eTextRep
,

432 void *
pArg
,

433 int(*
xCompare
)(void*,int,const void*,int,const void*),

434 void(*
xDestroy
)(void*)

436 int 
	`sqlite3_create_collation16
(

437 
sqlite3
*,

438 const void *
zName
,

439 int 
eTextRep
,

440 void *
pArg
,

441 int(*
xCompare
)(void*,int,const void*,int,const void*)

444 int 
	`sqlite3_collation_needed
(

445 
sqlite3
*,

447 void(*)(void*,
sqlite3
*,int 
eTextRep
,const char*)

449 int 
	`sqlite3_collation_needed16
(

450 
sqlite3
*,

452 void(*)(void*,
sqlite3
*,int 
eTextRep
,const void*)

455 int 
	`sqlite3_sleep
(int);

457 char *
sqlite3_temp_directory
;

459 char *
sqlite3_data_directory
;

461 int 
	`sqlite3_get_autocommit
(
sqlite3
*);

463 
sqlite3
 * 
	`sqlite3_db_handle
(
sqlite3_stmt
*);

465 const char * 
	`sqlite3_db_filename
(
sqlite3
 *
db
, const char *
zDbName
);

467 int 
	`sqlite3_db_readonly
(
sqlite3
 *
db
, const char *
zDbName
);

469 
sqlite3_stmt
 * 
	`sqlite3_next_stmt
(
sqlite3
 *
pDb
, sqlite3_stmt *
pStmt
);

471 void * 
	`sqlite3_commit_hook
(
sqlite3
*, int(*)(void*), void*);

472 void * 
	`sqlite3_rollback_hook
(
sqlite3
*, void(*)(void *), void*);

474 void * 
	`sqlite3_update_hook
(

475 
sqlite3
*,

476 void(*)(void *,int ,char const *,char const *,
sqlite3_int64
),

480 int 
	`sqlite3_enable_shared_cache
(int);

482 int 
	`sqlite3_release_memory
(int);

484 int 
	`sqlite3_db_release_memory
(
sqlite3
*);

486 
sqlite3_int64
 
	`sqlite3_soft_heap_limit64
(sqlite3_int64 
N
);

488 void 
	`sqlite3_soft_heap_limit
(int 
N
);

490 int 
	`sqlite3_table_column_metadata
(

491 
sqlite3
 *
db
,

492 const char *
zDbName
,

493 const char *
zTableName
,

494 const char *
zColumnName
,

495 char const **
pzDataType
,

496 char const **
pzCollSeq
,

497 int *
pNotNull
,

498 int *
pPrimaryKey
,

499 int *
pAutoinc


502 int 
	`sqlite3_load_extension
(

503 
sqlite3
 *
db
,

504 const char *
zFile
,

505 const char *
zProc
,

506 char **
pzErrMsg


509 int 
	`sqlite3_enable_load_extension
(
sqlite3
 *
db
, int 
onoff
);

511 int 
	`sqlite3_auto_extension
(void (*
xEntryPoint
)(void));

513 int 
	`sqlite3_cancel_auto_extension
(void (*
xEntryPoint
)(void));

521 void 
	`sqlite3_reset_auto_extension
(void);

523 typedef struct 
sqlite3_vtab
 
	tsqlite3_vtab
;

524 typedef struct 
sqlite3_index_info
 
	tsqlite3_index_info
;

525 typedef struct 
sqlite3_vtab_cursor
 
	tsqlite3_vtab_cursor
;

526 typedef struct 
sqlite3_module
 
	tsqlite3_module
;

528 struct 
	ssqlite3_module
 {

529 int 
iVersion
;

530 int (*
xCreate
)(
sqlite3
*, void *
pAux
,

531 int 
argc
, const char *const*
argv
,

532 
sqlite3_vtab
 **
ppVTab
, char**);

533 int (*
xConnect
)(
sqlite3
*, void *
pAux
,

534 int 
argc
, const char *const*
argv
,

535 
sqlite3_vtab
 **
ppVTab
, char**);

536 int (*
xBestIndex
)(
sqlite3_vtab
 *
pVTab
, 
sqlite3_index_info
*);

537 int (*
xDisconnect
)(
sqlite3_vtab
 *
pVTab
);

538 int (*
xDestroy
)(
sqlite3_vtab
 *
pVTab
);

539 int (*
xOpen
)(
sqlite3_vtab
 *
pVTab
, 
sqlite3_vtab_cursor
 **
ppCursor
);

540 int (*
xClose
)(
sqlite3_vtab_cursor
*);

541 int (*
xFilter
)(
sqlite3_vtab_cursor
*, int 
idxNum
, const char *
idxStr
,

542 int 
argc
, 
sqlite3_value
 **
argv
);

543 int (*
xNext
)(
sqlite3_vtab_cursor
*);

544 int (*
xEof
)(
sqlite3_vtab_cursor
*);

545 int (*
xColumn
)(
sqlite3_vtab_cursor
*, 
sqlite3_context
*, int);

546 int (*
xRowid
)(
sqlite3_vtab_cursor
*, 
sqlite3_int64
 *
pRowid
);

547 int (*
xUpdate
)(
sqlite3_vtab
 *, int, 
sqlite3_value
 **, 
sqlite3_int64
 *);

548 int (*
xBegin
)(
sqlite3_vtab
 *
pVTab
);

549 int (*
xSync
)(
sqlite3_vtab
 *
pVTab
);

550 int (*
xCommit
)(
sqlite3_vtab
 *
pVTab
);

551 int (*
xRollback
)(
sqlite3_vtab
 *
pVTab
);

552 int (*
xFindFunction
)(
sqlite3_vtab
 *
pVtab
, int 
nArg
, const char *
zName
,

553 void (**
pxFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

554 void **
ppArg
);

555 int (*
xRename
)(
sqlite3_vtab
 *
pVtab
, const char *
zNew
);

558 int (*
xSavepoint
)(
sqlite3_vtab
 *
pVTab
, int);

559 int (*
xRelease
)(
sqlite3_vtab
 *
pVTab
, int);

560 int (*
xRollbackTo
)(
sqlite3_vtab
 *
pVTab
, int);

563 struct 
	ssqlite3_index_info
 {

565 int 
nConstraint
;

566 struct 
	ssqlite3_index_constraint
 {

567 int 
iColumn
;

568 unsigned char 
op
;

569 unsigned char 
usable
;

570 int 
iTermOffset
;

571 } *
aConstraint
;

572 int 
nOrderBy
;

573 struct 
	ssqlite3_index_orderby
 {

574 int 
iColumn
;

575 unsigned char 
desc
;

576 } *
aOrderBy
;

578 struct 
	ssqlite3_index_constraint_usage
 {

579 int 
argvIndex
;

580 unsigned char 
omit
;

581 } *
aConstraintUsage
;

582 int 
idxNum
;

583 char *
idxStr
;

584 int 
needToFreeIdxStr
;

585 int 
orderByConsumed
;

586 double 
estimatedCost
;

588 
sqlite3_int64
 
estimatedRows
;

590 int 
idxFlags
;

592 
sqlite3_uint64
 
colUsed
;

595 int 
	`sqlite3_create_module
(

596 
sqlite3
 *
db
,

597 const char *
zName
,

598 const 
sqlite3_module
 *
p
,

599 void *
pClientData


601 int 
	`sqlite3_create_module_v2
(

602 
sqlite3
 *
db
,

603 const char *
zName
,

604 const 
sqlite3_module
 *
p
,

605 void *
pClientData
,

606 void(*
xDestroy
)(void*)

609 struct 
	ssqlite3_vtab
 {

610 const 
sqlite3_module
 *
pModule
;

611 int 
nRef
;

612 char *
zErrMsg
;

616 struct 
	ssqlite3_vtab_cursor
 {

617 
sqlite3_vtab
 *
pVtab
;

621 int 
	`sqlite3_declare_vtab
(
sqlite3
*, const char *
zSQL
);

623 int 
	`sqlite3_overload_function
(
sqlite3
*, const char *
zFuncName
, int 
nArg
);

625 typedef struct 
sqlite3_blob
 
	tsqlite3_blob
;

627 int 
	`sqlite3_blob_open
(

628 
sqlite3
*,

629 const char *
zDb
,

630 const char *
zTable
,

631 const char *
zColumn
,

632 
sqlite3_int64
 
iRow
,

633 int 
flags
,

634 
sqlite3_blob
 **
ppBlob


637 int 
	`sqlite3_blob_reopen
(
sqlite3_blob
 *, 
sqlite3_int64
);

639 int 
	`sqlite3_blob_close
(
sqlite3_blob
 *);

641 int 
	`sqlite3_blob_bytes
(
sqlite3_blob
 *);

643 int 
	`sqlite3_blob_read
(
sqlite3_blob
 *, void *
Z
, int 
N
, int 
iOffset
);

645 int 
	`sqlite3_blob_write
(
sqlite3_blob
 *, const void *
z
, int 
n
, int 
iOffset
);

647 
sqlite3_vfs
 * 
	`sqlite3_vfs_find
(const char *
zVfsName
);

648 int 
	`sqlite3_vfs_register
(
sqlite3_vfs
*, int 
makeDflt
);

649 int 
	`sqlite3_vfs_unregister
(
sqlite3_vfs
*);

651 
sqlite3_mutex
 * 
	`sqlite3_mutex_alloc
(int);

652 void 
	`sqlite3_mutex_free
(
sqlite3_mutex
*);

653 void 
	`sqlite3_mutex_enter
(
sqlite3_mutex
*);

654 int 
	`sqlite3_mutex_try
(
sqlite3_mutex
*);

655 void 
	`sqlite3_mutex_leave
(
sqlite3_mutex
*);

657 typedef struct 
sqlite3_mutex_methods
 
	tsqlite3_mutex_methods
;

658 struct 
	ssqlite3_mutex_methods
 {

659 int (*
xMutexInit
)(void);

660 int (*
xMutexEnd
)(void);

661 
sqlite3_mutex
 *(*
xMutexAlloc
)(int);

662 void (*
xMutexFree
)(
sqlite3_mutex
 *);

663 void (*
xMutexEnter
)(
sqlite3_mutex
 *);

664 int (*
xMutexTry
)(
sqlite3_mutex
 *);

665 void (*
xMutexLeave
)(
sqlite3_mutex
 *);

666 int (*
xMutexHeld
)(
sqlite3_mutex
 *);

667 int (*
xMutexNotheld
)(
sqlite3_mutex
 *);

670 int 
	`sqlite3_mutex_held
(
sqlite3_mutex
*);

671 int 
	`sqlite3_mutex_notheld
(
sqlite3_mutex
*);

673 
sqlite3_mutex
 * 
	`sqlite3_db_mutex
(
sqlite3
*);

675 int 
	`sqlite3_file_control
(
sqlite3
*, const char *
zDbName
, int 
op
, void*);

677 int 
	`sqlite3_test_control
(int 
op
, ...);

679 int 
	`sqlite3_status
(int 
op
, int *
pCurrent
, int *
pHighwater
, int 
resetFlag
);

680 int 
	`sqlite3_status64
(

681 int 
op
,

682 
sqlite3_int64
 *
pCurrent
,

683 
sqlite3_int64
 *
pHighwater
,

684 int 
resetFlag


687 int 
	`sqlite3_db_status
(
sqlite3
*, int 
op
, int *
pCur
, int *
pHiwtr
, int 
resetFlg
);

689 int 
	`sqlite3_stmt_status
(
sqlite3_stmt
*, int 
op
,int 
resetFlg
);

691 typedef struct 
sqlite3_pcache
 
	tsqlite3_pcache
;

693 typedef struct 
sqlite3_pcache_page
 
	tsqlite3_pcache_page
;

694 struct 
	ssqlite3_pcache_page
 {

695 void *
pBuf
;

696 void *
pExtra
;

699 typedef struct 
sqlite3_pcache_methods2
 
	tsqlite3_pcache_methods2
;

700 struct 
	ssqlite3_pcache_methods2
 {

701 int 
iVersion
;

702 void *
pArg
;

703 int (*
xInit
)(void*);

704 void (*
xShutdown
)(void*);

705 
sqlite3_pcache
 *(*
xCreate
)(int 
szPage
, int 
szExtra
, int 
bPurgeable
);

706 void (*
xCachesize
)(
sqlite3_pcache
*, int 
nCachesize
);

707 int (*
xPagecount
)(
sqlite3_pcache
*);

708 
sqlite3_pcache_page
 *(*
xFetch
)(
sqlite3_pcache
*, unsigned 
key
, int 
createFlag
);

709 void (*
xUnpin
)(
sqlite3_pcache
*, 
sqlite3_pcache_page
*, int 
discard
);

710 void (*
xRekey
)(
sqlite3_pcache
*, 
sqlite3_pcache_page
*,

711 unsigned 
oldKey
, unsigned 
newKey
);

712 void (*
xTruncate
)(
sqlite3_pcache
*, unsigned 
iLimit
);

713 void (*
xDestroy
)(
sqlite3_pcache
*);

714 void (*
xShrink
)(
sqlite3_pcache
*);

722 typedef struct 
sqlite3_pcache_methods
 
	tsqlite3_pcache_methods
;

723 struct 
	ssqlite3_pcache_methods
 {

724 void *
pArg
;

725 int (*
xInit
)(void*);

726 void (*
xShutdown
)(void*);

727 
sqlite3_pcache
 *(*
xCreate
)(int 
szPage
, int 
bPurgeable
);

728 void (*
xCachesize
)(
sqlite3_pcache
*, int 
nCachesize
);

729 int (*
xPagecount
)(
sqlite3_pcache
*);

730 void *(*
xFetch
)(
sqlite3_pcache
*, unsigned 
key
, int 
createFlag
);

731 void (*
xUnpin
)(
sqlite3_pcache
*, void*, int 
discard
);

732 void (*
xRekey
)(
sqlite3_pcache
*, void*, unsigned 
oldKey
, unsigned 
newKey
);

733 void (*
xTruncate
)(
sqlite3_pcache
*, unsigned 
iLimit
);

734 void (*
xDestroy
)(
sqlite3_pcache
*);

737 typedef struct 
sqlite3_backup
 
	tsqlite3_backup
;

739 
sqlite3_backup
 * 
	`sqlite3_backup_init
(

740 
sqlite3
 *
pDest
,

741 const char *
zDestName
,

742 
sqlite3
 *
pSource
,

743 const char *
zSourceName


745 int 
	`sqlite3_backup_step
(
sqlite3_backup
 *
p
, int 
nPage
);

746 int 
	`sqlite3_backup_finish
(
sqlite3_backup
 *
p
);

747 int 
	`sqlite3_backup_remaining
(
sqlite3_backup
 *
p
);

748 int 
	`sqlite3_backup_pagecount
(
sqlite3_backup
 *
p
);

750 int 
	`sqlite3_unlock_notify
(

751 
sqlite3
 *
pBlocked
,

752 void (*
xNotify
)(void **
apArg
, int 
nArg
),

753 void *
pNotifyArg


756 int 
	`sqlite3_stricmp
(const char *, const char *);

757 int 
	`sqlite3_strnicmp
(const char *, const char *, int);

759 int 
	`sqlite3_strglob
(const char *
zGlob
, const char *
zStr
);

761 int 
	`sqlite3_strlike
(const char *
zGlob
, const char *
zStr
, unsigned int 
cEsc
);

763 void 
	`sqlite3_log
(int 
iErrCode
, const char *
zFormat
, ...);

765 void * 
	`sqlite3_wal_hook
(

766 
sqlite3
*,

767 int(*)(void *,
sqlite3
*,const char*,int),

771 int 
	`sqlite3_wal_autocheckpoint
(
sqlite3
 *
db
, int 
N
);

773 int 
	`sqlite3_wal_checkpoint
(
sqlite3
 *
db
, const char *
zDb
);

775 int 
	`sqlite3_wal_checkpoint_v2
(

776 
sqlite3
 *
db
,

777 const char *
zDb
,

778 int 
eMode
,

779 int *
pnLog
,

780 int *
pnCkpt


783 int 
	`sqlite3_vtab_config
(
sqlite3
*, int 
op
, ...);

785 int 
	`sqlite3_vtab_on_conflict
(
sqlite3
 *);

787 int 
	`sqlite3_stmt_scanstatus
(

788 
sqlite3_stmt
 *
pStmt
,

789 int 
idx
,

790 int 
iScanStatusOp
,

791 void *
pOut


794 void 
	`sqlite3_stmt_scanstatus_reset
(
sqlite3_stmt
*);

796 int 
	`sqlite3_db_cacheflush
(
sqlite3
*);

798 int 
	`sqlite3_system_errno
(
sqlite3
*);

800 typedef struct 
sqlite3_snapshot
 
	tsqlite3_snapshot
;

802 int 
	`sqlite3_snapshot_get
(

803 
sqlite3
 *
db
,

804 const char *
zSchema
,

805 
sqlite3_snapshot
 **
ppSnapshot


808 int 
	`sqlite3_snapshot_open
(

809 
sqlite3
 *
db
,

810 const char *
zSchema
,

811 
sqlite3_snapshot
 *
pSnapshot


814 void 
	`sqlite3_snapshot_free
(
sqlite3_snapshot
*);

816 typedef struct 
sqlite3_rtree_geometry
 
	tsqlite3_rtree_geometry
;

817 typedef struct 
sqlite3_rtree_query_info
 
	tsqlite3_rtree_query_info
;

825 typedef double 
	tsqlite3_rtree_dbl
;

827 int 
	`sqlite3_rtree_geometry_callback
(

828 
sqlite3
 *
db
,

829 const char *
zGeom
,

830 int (*
xGeom
)(
sqlite3_rtree_geometry
*, int, 
sqlite3_rtree_dbl
*,int*),

831 void *
pContext


839 struct 
	ssqlite3_rtree_geometry
 {

840 void *
pContext
;

841 int 
nParam
;

842 
sqlite3_rtree_dbl
 *
aParam
;

843 void *
pUser
;

844 void (*
xDelUser
)(void *);

853 int 
	`sqlite3_rtree_query_callback
(

854 
sqlite3
 *
db
,

855 const char *
zQueryFunc
,

856 int (*
xQueryFunc
)(
sqlite3_rtree_query_info
*),

857 void *
pContext
,

858 void (*
xDestructor
)(void*)

861 struct 
	ssqlite3_rtree_query_info
 {

862 void *
pContext
;

863 int 
nParam
;

864 
sqlite3_rtree_dbl
 *
aParam
;

865 void *
pUser
;

866 void (*
xDelUser
)(void*);

867 
sqlite3_rtree_dbl
 *
aCoord
;

868 unsigned int *
anQueue
;

869 int 
nCoord
;

870 int 
iLevel
;

871 int 
mxLevel
;

872 
sqlite3_int64
 
iRowid
;

873 
sqlite3_rtree_dbl
 
rParentScore
;

874 int 
eParentWithin
;

875 int 
eWithin
;

876 
sqlite3_rtree_dbl
 
rScore
;

878 
sqlite3_value
 **
apSqlParam
;

881 typedef struct 
Fts5ExtensionApi
 
	tFts5ExtensionApi
;

882 typedef struct 
Fts5Context
 
	tFts5Context
;

883 typedef struct 
Fts5PhraseIter
 
	tFts5PhraseIter
;

885 typedef void (*
	tfts5_extension_function
)(

886 const 
	tFts5ExtensionApi
 *
	tpApi
,

887 
	tFts5Context
 *
	tpFts
,

888 
	tsqlite3_context
 *
	tpCtx
,

889 int 
	tnVal
,

890 
	tsqlite3_value
 **
	tapVal


893 struct 
	sFts5PhraseIter
 {

894 const unsigned char *
a
;

895 const unsigned char *
b
;

898 struct 
	sFts5ExtensionApi
 {

899 int 
iVersion
;

901 void *(*
xUserData
)(
Fts5Context
*);

903 int (*
xColumnCount
)(
Fts5Context
*);

904 int (*
xRowCount
)(
Fts5Context
*, 
sqlite3_int64
 *
pnRow
);

905 int (*
xColumnTotalSize
)(
Fts5Context
*, int 
iCol
, 
sqlite3_int64
 *
pnToken
);

907 int (*
xTokenize
)(
Fts5Context
*,

908 const char *
pText
, int 
nText
,

909 void *
pCtx
,

910 int (*
xToken
)(void*, int, const char*, int, int, int)

913 int (*
xPhraseCount
)(
Fts5Context
*);

914 int (*
xPhraseSize
)(
Fts5Context
*, int 
iPhrase
);

916 int (*
xInstCount
)(
Fts5Context
*, int *
pnInst
);

917 int (*
xInst
)(
Fts5Context
*, int 
iIdx
, int *
piPhrase
, int *
piCol
, int *
piOff
);

919 
	`sqlite3_int64
 (*
xRowid
)(
Fts5Context
*);

920 int (*
xColumnText
)(
Fts5Context
*, int 
iCol
, const char **
pz
, int *
pn
);

921 int (*
xColumnSize
)(
Fts5Context
*, int 
iCol
, int *
pnToken
);

923 int (*
xQueryPhrase
)(
Fts5Context
*, int 
iPhrase
, void *
pUserData
,

924 int(*)(const 
Fts5ExtensionApi
*,
Fts5Context
*,void*)

926 int (*
xSetAuxdata
)(
Fts5Context
*, void *
pAux
, void(*
xDelete
)(void*));

927 void *(*
xGetAuxdata
)(
Fts5Context
*, int 
bClear
);

929 int (*
xPhraseFirst
)(
Fts5Context
*, int 
iPhrase
, 
Fts5PhraseIter
*, int*, int*);

930 void (*
xPhraseNext
)(
Fts5Context
*, 
Fts5PhraseIter
*, int *
piCol
, int *
piOff
);

932 int (*
xPhraseFirstColumn
)(
Fts5Context
*, int 
iPhrase
, 
Fts5PhraseIter
*, int*);

933 void (*
xPhraseNextColumn
)(
Fts5Context
*, 
Fts5PhraseIter
*, int *
piCol
);

936 typedef struct 
Fts5Tokenizer
 
	tFts5Tokenizer
;

937 typedef struct 
fts5_tokenizer
 
	tfts5_tokenizer
;

938 struct 
	sfts5_tokenizer
 {

939 int (*
xCreate
)(void*, const char **
azArg
, int 
nArg
, 
Fts5Tokenizer
 **
ppOut
);

940 void (*
xDelete
)(
Fts5Tokenizer
*);

941 int (*
xTokenize
)(
Fts5Tokenizer
*,

942 void *
pCtx
,

943 int 
flags
,

944 const char *
pText
, int 
nText
,

945 int (*
xToken
)(

946 void *
pCtx
,

947 int 
tflags
,

948 const char *
pToken
,

949 int 
nToken
,

950 int 
iStart
,

951 int 
iEnd


956 typedef struct 
fts5_api
 
	tfts5_api
;

957 struct 
	sfts5_api
 {

958 int 
iVersion
;

961 int (*
xCreateTokenizer
)(

962 
fts5_api
 *
pApi
,

963 const char *
zName
,

964 void *
pContext
,

965 
fts5_tokenizer
 *
pTokenizer
,

966 void (*
xDestroy
)(void*)

970 int (*
xFindTokenizer
)(

971 
fts5_api
 *
pApi
,

972 const char *
zName
,

973 void **
ppContext
,

974 
fts5_tokenizer
 *
pTokenizer


978 int (*
xCreateFunction
)(

979 
fts5_api
 *
pApi
,

980 const char *
zName
,

981 void *
pContext
,

982 
fts5_extension_function
 
xFunction
,

983 void (*
xDestroy
)(void*)

987 typedef struct 
Hash
 
	tHash
;

988 typedef struct 
HashElem
 
	tHashElem
;

990 struct 
	sHash
 {

991 unsigned int 
htsize
;

992 unsigned int 
count
;

993 
HashElem
 *
first
;

994 struct 
	s_ht
 {

995 int 
count
;

996 
HashElem
 *
chain
;

997 } *
ht
;

1006 struct 
	sHashElem
 {

1007 
HashElem
 *
next
, *
prev
;

1008 void *
data
;

1009 const char *
pKey
;

1015 static void 
	`sqlite3HashInit
(
Hash
*);

1016 static void *
	`sqlite3HashInsert
(
Hash
*, const char *
pKey
, void *
pData
);

1017 static void *
	`sqlite3HashFind
(const 
Hash
*, const char *
pKey
);

1018 static void 
	`sqlite3HashClear
(
Hash
*);

1043 typedef long unsigned int 
	tsize_t
;

1052 typedef unsigned char 
	t__u_char
;

1053 typedef unsigned short int 
	t__u_short
;

1054 typedef unsigned int 
	t__u_int
;

1055 typedef unsigned long int 
	t__u_long
;

1058 typedef signed char 
	t__int8_t
;

1059 typedef unsigned char 
	t__uint8_t
;

1060 typedef signed short int 
	t__int16_t
;

1061 typedef unsigned short int 
	t__uint16_t
;

1062 typedef signed int 
	t__int32_t
;

1063 typedef unsigned int 
	t__uint32_t
;

1065 typedef signed long int 
	t__int64_t
;

1066 typedef unsigned long int 
	t__uint64_t
;

1074 typedef long int 
	t__quad_t
;

1075 typedef unsigned long int 
	t__u_quad_t
;

1081 typedef unsigned long int 
	t__dev_t
;

1082 typedef unsigned int 
	t__uid_t
;

1083 typedef unsigned int 
	t__gid_t
;

1084 typedef unsigned long int 
	t__ino_t
;

1085 typedef unsigned long int 
	t__ino64_t
;

1086 typedef unsigned int 
	t__mode_t
;

1087 typedef unsigned long int 
	t__nlink_t
;

1088 typedef long int 
	t__off_t
;

1089 typedef long int 
	t__off64_t
;

1090 typedef int 
	t__pid_t
;

1091 typedef struct { int 
__val
[2]; } 
	t__fsid_t
;

1092 typedef long int 
	t__clock_t
;

1093 typedef unsigned long int 
	t__rlim_t
;

1094 typedef unsigned long int 
	t__rlim64_t
;

1095 typedef unsigned int 
	t__id_t
;

1096 typedef long int 
	t__time_t
;

1097 typedef unsigned int 
	t__useconds_t
;

1098 typedef long int 
	t__suseconds_t
;

1100 typedef int 
	t__daddr_t
;

1101 typedef int 
	t__key_t
;

1104 typedef int 
	t__clockid_t
;

1107 typedef void * 
	t__timer_t
;

1110 typedef long int 
	t__blksize_t
;

1115 typedef long int 
	t__blkcnt_t
;

1116 typedef long int 
	t__blkcnt64_t
;

1119 typedef unsigned long int 
	t__fsblkcnt_t
;

1120 typedef unsigned long int 
	t__fsblkcnt64_t
;

1123 typedef unsigned long int 
	t__fsfilcnt_t
;

1124 typedef unsigned long int 
	t__fsfilcnt64_t
;

1127 typedef long int 
	t__fsword_t
;

1129 typedef long int 
	t__ssize_t
;

1132 typedef long int 
	t__syscall_slong_t
;

1134 typedef unsigned long int 
	t__syscall_ulong_t
;

1138 typedef 
__off64_t
 
	t__loff_t
;

1139 typedef 
__quad_t
 *
	t__qaddr_t
;

1140 typedef char *
	t__caddr_t
;

1143 typedef long int 
	t__intptr_t
;

1146 typedef unsigned int 
	t__socklen_t
;

1149 struct 
_IO_FILE
;

1153 typedef struct 
_IO_FILE
 
	tFILE
;

1160 typedef struct 
_IO_FILE
 
	t__FILE
;

1176 int 
__count
;

1180 unsigned int 
__wch
;

1184 char 
__wchb
[4];

1185 } 
__value
;

1186 } 
	t__mbstate_t
;

1190 
__off_t
 
__pos
;

1191 
__mbstate_t
 
__state
;

1192 } 
	t_G_fpos_t
;

1195 
__off64_t
 
__pos
;

1196 
__mbstate_t
 
__state
;

1197 } 
	t_G_fpos64_t
;

1200 struct 
_IO_jump_t
; struct 
_IO_FILE
;

1202 typedef void 
	t_IO_lock_t
;

1208 struct 
	s_IO_marker
 {

1209 struct 
_IO_marker
 *
_next
;

1210 struct 
_IO_FILE
 *
_sbuf
;

1214 int 
_pos
;

1219 enum 
	e__codecvt_result


1221 
__codecvt_ok
,

1222 
__codecvt_partial
,

1223 
__codecvt_error
,

1224 
__codecvt_noconv


1227 struct 
	s_IO_FILE
 {

1228 int 
_flags
;

1233 char* 
_IO_read_ptr
;

1234 char* 
_IO_read_end
;

1235 char* 
_IO_read_base
;

1236 char* 
_IO_write_base
;

1237 char* 
_IO_write_ptr
;

1238 char* 
_IO_write_end
;

1239 char* 
_IO_buf_base
;

1240 char* 
_IO_buf_end
;

1242 char *
_IO_save_base
;

1243 char *
_IO_backup_base
;

1244 char *
_IO_save_end
;

1246 struct 
_IO_marker
 *
_markers
;

1248 struct 
_IO_FILE
 *
_chain
;

1250 int 
_fileno
;

1254 int 
_flags2
;

1256 
__off_t
 
_old_offset
;

1260 unsigned short 
_cur_column
;

1261 signed char 
_vtable_offset
;

1262 char 
_shortbuf
[1];

1266 
_IO_lock_t
 *
_lock
;

1268 
__off64_t
 
_offset
;

1270 void *
__pad1
;

1271 void *
__pad2
;

1272 void *
__pad3
;

1273 void *
__pad4
;

1274 
size_t
 
__pad5
;

1276 int 
_mode
;

1278 char 
_unused2
[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (
size_t
)];

1283 typedef struct 
_IO_FILE
 
	t_IO_FILE
;

1286 struct 
_IO_FILE_plus
;

1288 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdin_
;

1289 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdout_
;

1290 extern struct 
_IO_FILE_plus
 
_IO_2_1_stderr_
;

1292 typedef 
__ssize_t
 
	t__io_read_fn
 (void *
	t__cookie
, char *
	t__buf
, 
	tsize_t
 
	t__nbytes
);

1300 typedef 
__ssize_t
 
	t__io_write_fn
 (void *
	t__cookie
, const char *
	t__buf
,

1301 
	tsize_t
 
	t__n
);

1309 typedef int 
	t__io_seek_fn
 (void *
	t__cookie
, 
	t__off64_t
 *
	t__pos
, int 
	t__w
);

1312 typedef int 
	t__io_close_fn
 (void *
	t__cookie
);

1317 typedef 
__io_read_fn
 
	tcookie_read_function_t
;

1318 typedef 
__io_write_fn
 
	tcookie_write_function_t
;

1319 typedef 
__io_seek_fn
 
	tcookie_seek_function_t
;

1320 typedef 
__io_close_fn
 
	tcookie_close_function_t
;

1325 
__io_read_fn
 *
read
;

1326 
__io_write_fn
 *
write
;

1327 
__io_seek_fn
 *
seek
;

1328 
__io_close_fn
 *
close
;

1329 } 
	t_IO_cookie_io_functions_t
;

1330 typedef 
_IO_cookie_io_functions_t
 
	tcookie_io_functions_t
;

1332 struct 
_IO_cookie_file
;

1335 extern void 
	`_IO_cookie_init
 (struct 
_IO_cookie_file
 *
__cfile
, int 
__read_write
,

1336 void *
__cookie
, 
_IO_cookie_io_functions_t
 
__fns
);

1344 extern int 
	`__underflow
 (
_IO_FILE
 *);

1345 extern int 
	`__uflow
 (
_IO_FILE
 *);

1346 extern int 
	`__overflow
 (
_IO_FILE
 *, int);

1348 extern int 
	`_IO_getc
 (
_IO_FILE
 *
__fp
);

1349 extern int 
	`_IO_putc
 (int 
__c
, 
_IO_FILE
 *
__fp
);

1350 extern int 
	$_IO_feof
 (
_IO_FILE
 *
__fp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1351 extern int 
	$_IO_ferror
 (
_IO_FILE
 *
__fp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1353 extern int 
	`_IO_peekc_locked
 (
_IO_FILE
 *
__fp
);

1359 extern void 
	$_IO_flockfile
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1360 extern void 
	$_IO_funlockfile
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1361 extern int 
	$_IO_ftrylockfile
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1363 extern int 
	`_IO_vfscanf
 (
_IO_FILE
 * 
__restrict
, const char * __restrict,

1364 
__gnuc_va_list
, int *
__restrict
);

1365 extern int 
	`_IO_vfprintf
 (
_IO_FILE
 *
__restrict
, const char *__restrict,

1366 
__gnuc_va_list
);

1367 extern 
__ssize_t
 
	`_IO_padn
 (
_IO_FILE
 *, int, __ssize_t);

1368 extern 
size_t
 
	`_IO_sgetn
 (
_IO_FILE
 *, void *, size_t);

1370 extern 
__off64_t
 
	`_IO_seekoff
 (
_IO_FILE
 *, __off64_t, int, int);

1371 extern 
__off64_t
 
	`_IO_seekpos
 (
_IO_FILE
 *, __off64_t, int);

1373 extern void 
	$_IO_free_backup_area
 (
_IO_FILE
 *) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1376 typedef 
__off64_t
 
	toff_t
;

1381 typedef 
__off64_t
 
	toff64_t
;

1386 typedef 
__ssize_t
 
	tssize_t
;

1396 typedef 
_G_fpos64_t
 
	tfpos_t
;

1400 typedef 
_G_fpos64_t
 
	tfpos64_t
;

1407 extern struct 
_IO_FILE
 *
stdin
;

1408 extern struct 
_IO_FILE
 *
stdout
;

1409 extern struct 
_IO_FILE
 *
stderr
;

1417 extern int 
	$remove
 (const char *
__filename
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1419 extern int 
	$rename
 (const char *
__old
, const char *
__new
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1424 extern int 
	$renameat
 (int 
__oldfd
, const char *
__old
, int 
__newfd
,

1425 const char *
__new
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1430 extern 
FILE
 *
	$tmpfile
 (void) 
	`__asm__
 ("" "tmpfile64") ;

1437 extern 
FILE
 *
	`tmpfile64
 (void) ;

1441 extern char *
	$tmpnam
 (char *
__s
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1447 extern char *
	$tmpnam_r
 (char *
__s
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1449 extern char *
	$tempnam
 (const char *
__dir
, const char *
__pfx
)

1450 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

1459 extern int 
	`fclose
 (
FILE
 *
__stream
);

1464 extern int 
	`fflush
 (
FILE
 *
__stream
);

1467 extern int 
	`fflush_unlocked
 (
FILE
 *
__stream
);

1469 extern int 
	`fcloseall
 (void);

1475 extern 
FILE
 *
	$fopen
 (const char *
__restrict
 
__filename
, const char *__restrict 
__modes
) 
	`__asm__
 ("" "fopen64")

1478 extern 
FILE
 *
	$freopen
 (const char *
__restrict
 
__filename
, const char *__restrict 
__modes
, 
FILE
 *__restrict 
__stream
) 
	`__asm__
 ("" "freopen64")

1489 extern 
FILE
 *
	`fopen64
 (const char *
__restrict
 
__filename
,

1490 const char *
__restrict
 
__modes
) ;

1491 extern 
FILE
 *
	`freopen64
 (const char *
__restrict
 
__filename
,

1492 const char *
__restrict
 
__modes
,

1493 
FILE
 *
__restrict
 
__stream
) ;

1498 extern 
FILE
 *
	$fdopen
 (int 
__fd
, const char *
__modes
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1504 extern 
FILE
 *
	$fopencookie
 (void *
__restrict
 
__magic_cookie
,

1505 const char *
__restrict
 
__modes
,

1506 
_IO_cookie_io_functions_t
 
__io_funcs
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1511 extern 
FILE
 *
	$fmemopen
 (void *
__s
, 
size_t
 
__len
, const char *
__modes
)

1512 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1517 extern 
FILE
 *
	$open_memstream
 (char **
__bufloc
, 
size_t
 *
__sizeloc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1524 extern void 
	$setbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1528 extern int 
	$setvbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

1529 int 
__modes
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1535 extern void 
	$setbuffer
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

1536 
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1539 extern void 
	$setlinebuf
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1548 extern int 
	`fprintf
 (
FILE
 *
__restrict
 
__stream
,

1549 const char *
__restrict
 
__format
, ...);

1554 extern int 
	`printf
 (const char *
__restrict
 
__format
, ...);

1556 extern int 
	$sprintf
 (char *
__restrict
 
__s
,

1557 const char *
__restrict
 
__format
, ...) 
	`__attribute__
 ((
__nothrow__
));

1563 extern int 
	`vfprintf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

1564 
__gnuc_va_list
 
__arg
);

1569 extern int 
	`vprintf
 (const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
);

1571 extern int 
	$vsprintf
 (char *
__restrict
 
__s
, const char *__restrict 
__format
,

1572 
__gnuc_va_list
 
__arg
) 
	`__attribute__
 ((
__nothrow__
));

1578 extern int 
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

1579 const char *
__restrict
 
__format
, ...)

1580 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 3, 4)));

1582 extern int 
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

1583 const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
)

1584 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 3, 0)));

1591 extern int 
	$vasprintf
 (char **
__restrict
 
__ptr
, const char *__restrict 
__f
,

1592 
__gnuc_va_list
 
__arg
)

1593 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 2, 0))) ;

1594 extern int 
	$__asprintf
 (char **
__restrict
 
__ptr
,

1595 const char *
__restrict
 
__fmt
, ...)

1596 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 2, 3))) ;

1597 extern int 
	$asprintf
 (char **
__restrict
 
__ptr
,

1598 const char *
__restrict
 
__fmt
, ...)

1599 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 2, 3))) ;

1604 extern int 
	$vdprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
,

1605 
__gnuc_va_list
 
__arg
)

1606 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

1607 extern int 
	$dprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
, ...)

1608 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

1617 extern int 
	`fscanf
 (
FILE
 *
__restrict
 
__stream
,

1618 const char *
__restrict
 
__format
, ...) ;

1623 extern int 
	`scanf
 (const char *
__restrict
 
__format
, ...) ;

1625 extern int 
	$sscanf
 (const char *
__restrict
 
__s
,

1626 const char *
__restrict
 
__format
, ...) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1636 extern int 
	$vfscanf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

1637 
__gnuc_va_list
 
__arg
)

1638 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0))) ;

1644 extern int 
	$vscanf
 (const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
)

1645 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 1, 0))) ;

1648 extern int 
	$vsscanf
 (const char *
__restrict
 
__s
,

1649 const char *
__restrict
 
__format
, 
__gnuc_va_list
 
__arg
)

1650 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__format__
 (
__scanf__
, 2, 0)));

1661 extern int 
	`fgetc
 (
FILE
 *
__stream
);

1662 extern int 
	`getc
 (
FILE
 *
__stream
);

1668 extern int 
	`getchar
 (void);

1671 extern int 
	`getc_unlocked
 (
FILE
 *
__stream
);

1672 extern int 
	`getchar_unlocked
 (void);

1674 extern int 
	`fgetc_unlocked
 (
FILE
 *
__stream
);

1686 extern int 
	`fputc
 (int 
__c
, 
FILE
 *
__stream
);

1687 extern int 
	`putc
 (int 
__c
, 
FILE
 *
__stream
);

1693 extern int 
	`putchar
 (int 
__c
);

1696 extern int 
	`fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

1704 extern int 
	`putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

1705 extern int 
	`putchar_unlocked
 (int 
__c
);

1712 extern int 
	`getw
 (
FILE
 *
__stream
);

1715 extern int 
	`putw
 (int 
__w
, 
FILE
 *
__stream
);

1724 extern char *
	`fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

1729 extern char *
	`fgets_unlocked
 (char *
__restrict
 
__s
, int 
__n
,

1730 
FILE
 *
__restrict
 
__stream
) ;

1732 extern 
__ssize_t
 
	`__getdelim
 (char **
__restrict
 
__lineptr
,

1733 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

1734 
FILE
 *
__restrict
 
__stream
) ;

1735 extern 
__ssize_t
 
	`getdelim
 (char **
__restrict
 
__lineptr
,

1736 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

1737 
FILE
 *
__restrict
 
__stream
) ;

1745 extern 
__ssize_t
 
	`getline
 (char **
__restrict
 
__lineptr
,

1746 
size_t
 *
__restrict
 
__n
,

1747 
FILE
 *
__restrict
 
__stream
) ;

1756 extern int 
	`fputs
 (const char *
__restrict
 
__s
, 
FILE
 *__restrict 
__stream
);

1762 extern int 
	`puts
 (const char *
__s
);

1769 extern int 
	`ungetc
 (int 
__c
, 
FILE
 *
__stream
);

1776 extern 
size_t
 
	`fread
 (void *
__restrict
 
__ptr
, size_t 
__size
,

1777 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) ;

1782 extern 
size_t
 
	`fwrite
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

1783 
size_t
 
__n
, 
FILE
 *
__restrict
 
__s
);

1786 extern int 
	`fputs_unlocked
 (const char *
__restrict
 
__s
,

1787 
FILE
 *
__restrict
 
__stream
);

1789 extern 
size_t
 
	`fread_unlocked
 (void *
__restrict
 
__ptr
, size_t 
__size
,

1790 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) ;

1791 extern 
size_t
 
	`fwrite_unlocked
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

1792 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
);

1801 extern int 
	`fseek
 (
FILE
 *
__stream
, long int 
__off
, int 
__whence
);

1806 extern long int 
	`ftell
 (
FILE
 *
__stream
) ;

1811 extern void 
	`rewind
 (
FILE
 *
__stream
);

1814 extern int 
	$fseeko
 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
) 
	`__asm__
 ("" "fseeko64")

1817 extern 
__off64_t
 
	$ftello
 (
FILE
 *
__stream
) 
	`__asm__
 ("" "ftello64");

1827 extern int 
	$fgetpos
 (
FILE
 *
__restrict
 
__stream
, 
fpos_t
 *__restrict 
__pos
) 
	`__asm__
 ("" "fgetpos64")

1829 extern int 
	$fsetpos
 (
FILE
 *
__stream
, const 
fpos_t
 *
__pos
) 
	`__asm__
 ("" "fsetpos64")

1839 extern int 
	`fseeko64
 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
);

1840 extern 
__off64_t
 
	`ftello64
 (
FILE
 *
__stream
) ;

1841 extern int 
	`fgetpos64
 (
FILE
 *
__restrict
 
__stream
, 
fpos64_t
 *__restrict 
__pos
);

1842 extern int 
	`fsetpos64
 (
FILE
 *
__stream
, const 
fpos64_t
 *
__pos
);

1847 extern void 
	$clearerr
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1849 extern int 
	$feof
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1851 extern int 
	$ferror
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1856 extern void 
	$clearerr_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1857 extern int 
	$feof_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1858 extern int 
	$ferror_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1867 extern void 
	`perror
 (const char *
__s
);

1876 extern int 
sys_nerr
;

1877 extern const char *const 
sys_errlist
[];

1880 extern int 
_sys_nerr
;

1881 extern const char *const 
_sys_errlist
[];

1887 extern int 
	$fileno
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1892 extern int 
	$fileno_unlocked
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1894 extern 
FILE
 *
	`popen
 (const char *
__command
, const char *
__modes
) ;

1900 extern int 
	`pclose
 (
FILE
 *
__stream
);

1906 extern char *
	$ctermid
 (char *
__s
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1912 extern char *
	`cuserid
 (char *
__s
);

1917 struct 
obstack
;

1920 extern int 
	$obstack_printf
 (struct 
obstack
 *
__restrict
 
__obstack
,

1921 const char *
__restrict
 
__format
, ...)

1922 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 2, 3)));

1923 extern int 
	$obstack_vprintf
 (struct 
obstack
 *
__restrict
 
__obstack
,

1924 const char *
__restrict
 
__format
,

1925 
__gnuc_va_list
 
__args
)

1926 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__format__
 (
__printf__
, 2, 0)));

1934 extern void 
	$flockfile
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1938 extern int 
	$ftrylockfile
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

1941 extern void 
	$funlockfile
 (
FILE
 *
__stream
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

1949 typedef int 
	twchar_t
;

1981 static 
__inline
 unsigned int

1982 
	$__bswap_32
 (unsigned int 
__bsx
)

1984 return 
	`__builtin_bswap32
 (
__bsx
);

1985 
	}
}

1987 static 
__inline
 
__uint64_t


1988 
	$__bswap_64
 (
__uint64_t
 
__bsx
)

1990 return 
	`__builtin_bswap64
 (
__bsx
);

1991 
	}
}

1995 union 
	uwait


1997 int 
	mw_status
;

2001 unsigned int 
	m__w_termsig
:7;

2002 unsigned int 
	m__w_coredump
:1;

2003 unsigned int 
	m__w_retcode
:8;

2012 } 
	m__wait_terminated
;

2016 unsigned int 
	m__w_stopval
:8;

2017 unsigned int 
	m__w_stopsig
:8;

2025 } 
	m__wait_stopped
;

2031 union 
wait
 *
	m__uptr
;

2032 int *
	m__iptr
;

2033 } 
	t__WAIT_STATUS
 
	t__attribute__
 ((
	t__transparent_union__
));

2039 int 
	mquot
;

2040 int 
	mrem
;

2041 } 
	tdiv_t
;

2047 long int 
	mquot
;

2048 long int 
	mrem
;

2049 } 
	tldiv_t
;

2057 
__extension__
 typedef struct

2059 long long int 
	mquot
;

2060 long long int 
	mrem
;

2061 } 
	tlldiv_t
;

2065 extern 
size_t
 
	$__ctype_get_mb_cur_max
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2070 extern double 
	$atof
 (const char *
__nptr
)

2071 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2073 extern int 
	$atoi
 (const char *
__nptr
)

2074 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2076 extern long int 
	$atol
 (const char *
__nptr
)

2077 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2083 
__extension__
 extern long long int 
	$atoll
 (const char *
__nptr
)

2084 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2090 extern double 
	$strtod
 (const char *
__restrict
 
__nptr
,

2091 char **
__restrict
 
__endptr
)

2092 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2098 extern float 
	$strtof
 (const char *
__restrict
 
__nptr
,

2099 char **
__restrict
 
__endptr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2101 extern long double 
	$strtold
 (const char *
__restrict
 
__nptr
,

2102 char **
__restrict
 
__endptr
)

2103 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2109 extern long int 
	$strtol
 (const char *
__restrict
 
__nptr
,

2110 char **
__restrict
 
__endptr
, int 
__base
)

2111 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2113 extern unsigned long int 
	$strtoul
 (const char *
__restrict
 
__nptr
,

2114 char **
__restrict
 
__endptr
, int 
__base
)

2115 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2120 
__extension__


2121 extern long long int 
	$strtoq
 (const char *
__restrict
 
__nptr
,

2122 char **
__restrict
 
__endptr
, int 
__base
)

2123 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2125 
__extension__


2126 extern unsigned long long int 
	$strtouq
 (const char *
__restrict
 
__nptr
,

2127 char **
__restrict
 
__endptr
, int 
__base
)

2128 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2134 
__extension__


2135 extern long long int 
	$strtoll
 (const char *
__restrict
 
__nptr
,

2136 char **
__restrict
 
__endptr
, int 
__base
)

2137 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2139 
__extension__


2140 extern unsigned long long int 
	$strtoull
 (const char *
__restrict
 
__nptr
,

2141 char **
__restrict
 
__endptr
, int 
__base
)

2142 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2147 typedef struct 
	s__locale_struct


2150 struct 
__locale_data
 *
__locales
[13];

2153 const unsigned short int *
__ctype_b
;

2154 const int *
__ctype_tolower
;

2155 const int *
__ctype_toupper
;

2158 const char *
__names
[13];

2159 } *
	t__locale_t
;

2162 typedef 
__locale_t
 
	tlocale_t
;

2167 extern long int 
	$strtol_l
 (const char *
__restrict
 
__nptr
,

2168 char **
__restrict
 
__endptr
, int 
__base
,

2169 
__locale_t
 
__loc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 4)));

2171 extern unsigned long int 
	$strtoul_l
 (const char *
__restrict
 
__nptr
,

2172 char **
__restrict
 
__endptr
,

2173 int 
__base
, 
__locale_t
 
__loc
)

2174 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 4)));

2176 
__extension__


2177 extern long long int 
	$strtoll_l
 (const char *
__restrict
 
__nptr
,

2178 char **
__restrict
 
__endptr
, int 
__base
,

2179 
__locale_t
 
__loc
)

2180 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 4)));

2182 
__extension__


2183 extern unsigned long long int 
	$strtoull_l
 (const char *
__restrict
 
__nptr
,

2184 char **
__restrict
 
__endptr
,

2185 int 
__base
, 
__locale_t
 
__loc
)

2186 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 4)));

2188 extern double 
	$strtod_l
 (const char *
__restrict
 
__nptr
,

2189 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

2190 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

2192 extern float 
	$strtof_l
 (const char *
__restrict
 
__nptr
,

2193 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

2194 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

2196 extern long double 
	$strtold_l
 (const char *
__restrict
 
__nptr
,

2197 char **
__restrict
 
__endptr
,

2198 
__locale_t
 
__loc
)

2199 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

2201 extern char *
	$l64a
 (long int 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2204 extern long int 
	$a64l
 (const char *
__s
)

2205 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2218 typedef 
__u_char
 
	tu_char
;

2219 typedef 
__u_short
 
	tu_short
;

2220 typedef 
__u_int
 
	tu_int
;

2221 typedef 
__u_long
 
	tu_long
;

2222 typedef 
__quad_t
 
	tquad_t
;

2223 typedef 
__u_quad_t
 
	tu_quad_t
;

2224 typedef 
__fsid_t
 
	tfsid_t
;

2229 typedef 
__loff_t
 
	tloff_t
;

2235 typedef 
__ino64_t
 
	tino_t
;

2240 typedef 
__ino64_t
 
	tino64_t
;

2245 typedef 
__dev_t
 
	tdev_t
;

2250 typedef 
__gid_t
 
	tgid_t
;

2255 typedef 
__mode_t
 
	tmode_t
;

2260 typedef 
__nlink_t
 
	tnlink_t
;

2265 typedef 
__uid_t
 
	tuid_t
;

2267 typedef 
__pid_t
 
	tpid_t
;

2273 typedef 
__id_t
 
	tid_t
;

2275 typedef 
__daddr_t
 
	tdaddr_t
;

2276 typedef 
__caddr_t
 
	tcaddr_t
;

2282 typedef 
__key_t
 
	tkey_t
;

2288 typedef 
__clock_t
 
	tclock_t
;

2295 typedef 
__time_t
 
	ttime_t
;

2300 typedef 
__clockid_t
 
	tclockid_t
;

2302 typedef 
__timer_t
 
	ttimer_t
;

2307 typedef 
__useconds_t
 
	tuseconds_t
;

2311 typedef 
__suseconds_t
 
	tsuseconds_t
;

2322 typedef unsigned long int 
	tulong
;

2323 typedef unsigned short int 
	tushort
;

2324 typedef unsigned int 
	tuint
;

2326 typedef int 
	tint8_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__QI__
)));

2327 typedef int 
	tint16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

2328 typedef int 
	tint32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

2329 typedef int 
	tint64_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__DI__
)));

2332 typedef unsigned int 
	tu_int8_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__QI__
)));

2333 typedef unsigned int 
	tu_int16_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__HI__
)));

2334 typedef unsigned int 
	tu_int32_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__SI__
)));

2335 typedef unsigned int 
	tu_int64_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__DI__
)));

2337 typedef int 
	tregister_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__word__
)));

2350 typedef int 
	t__sig_atomic_t
;

2357 unsigned long int 
__val
[(1024 / (8 * sizeof (unsigned long int)))];

2358 } 
	t__sigset_t
;

2363 typedef 
__sigset_t
 
	tsigset_t
;

2371 struct 
	stimespec


2373 
__time_t
 
tv_sec
;

2374 
__syscall_slong_t
 
tv_nsec
;

2380 struct 
	stimeval


2382 
__time_t
 
tv_sec
;

2383 
__suseconds_t
 
tv_usec
;

2387 typedef long int 
	t__fd_mask
;

2394 
__fd_mask
 
fds_bits
[1024 / (8 * (int) sizeof (__fd_mask))];

2400 } 
	tfd_set
;

2407 typedef 
__fd_mask
 
	tfd_mask
;

2411 extern int 
	`select
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

2412 
fd_set
 *
__restrict
 
__writefds
,

2413 
fd_set
 *
__restrict
 
__exceptfds
,

2414 struct 
timeval
 *
__restrict
 
__timeout
);

2416 extern int 
	`pselect
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

2417 
fd_set
 *
__restrict
 
__writefds
,

2418 
fd_set
 *
__restrict
 
__exceptfds
,

2419 const struct 
timespec
 *
__restrict
 
__timeout
,

2420 const 
__sigset_t
 *
__restrict
 
__sigmask
);

2430 
__extension__


2431 extern unsigned int 
	$gnu_dev_major
 (unsigned long long int 
__dev
)

2432 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

2433 
__extension__


2434 extern unsigned int 
	$gnu_dev_minor
 (unsigned long long int 
__dev
)

2435 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

2436 
__extension__


2437 extern unsigned long long int 
	$gnu_dev_makedev
 (unsigned int 
__major
,

2438 unsigned int 
__minor
)

2439 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

2448 typedef 
__blksize_t
 
	tblksize_t
;

2450 typedef 
__blkcnt64_t
 
	tblkcnt_t
;

2454 typedef 
__fsblkcnt64_t
 
	tfsblkcnt_t
;

2458 typedef 
__fsfilcnt64_t
 
	tfsfilcnt_t
;

2464 typedef 
__blkcnt64_t
 
	tblkcnt64_t
;

2465 typedef 
__fsblkcnt64_t
 
	tfsblkcnt64_t
;

2466 typedef 
__fsfilcnt64_t
 
	tfsfilcnt64_t
;

2477 typedef unsigned long int 
	tpthread_t
;

2480 union 
	upthread_attr_t


2482 char 
__size
[56];

2483 long int 
__align
;

2486 typedef union 
pthread_attr_t
 
	tpthread_attr_t
;

2492 typedef struct 
	s__pthread_internal_list


2494 struct 
__pthread_internal_list
 *
__prev
;

2495 struct 
__pthread_internal_list
 *
__next
;

2496 } 
	t__pthread_list_t
;

2500 struct 
	s__pthread_mutex_s


2502 int 
__lock
;

2503 unsigned int 
__count
;

2504 int 
__owner
;

2506 unsigned int 
__nusers
;

2510 int 
__kind
;

2512 short 
__spins
;

2513 short 
__elision
;

2514 
__pthread_list_t
 
__list
;

2516 } 
__data
;

2517 char 
__size
[40];

2518 long int 
__align
;

2519 } 
	tpthread_mutex_t
;

2523 char 
__size
[4];

2524 int 
__align
;

2525 } 
	tpthread_mutexattr_t
;

2534 int 
__lock
;

2535 unsigned int 
__futex
;

2536 
__extension__
 unsigned long long int 
__total_seq
;

2537 
__extension__
 unsigned long long int 
__wakeup_seq
;

2538 
__extension__
 unsigned long long int 
__woken_seq
;

2539 void *
__mutex
;

2540 unsigned int 
__nwaiters
;

2541 unsigned int 
__broadcast_seq
;

2542 } 
__data
;

2543 char 
__size
[48];

2544 
__extension__
 long long int 
__align
;

2545 } 
	tpthread_cond_t
;

2549 char 
__size
[4];

2550 int 
__align
;

2551 } 
	tpthread_condattr_t
;

2555 typedef unsigned int 
	tpthread_key_t
;

2559 typedef int 
	tpthread_once_t
;

2570 int 
__lock
;

2571 unsigned int 
__nr_readers
;

2572 unsigned int 
__readers_wakeup
;

2573 unsigned int 
__writer_wakeup
;

2574 unsigned int 
__nr_readers_queued
;

2575 unsigned int 
__nr_writers_queued
;

2576 int 
__writer
;

2577 int 
__shared
;

2578 signed char 
__rwelision
;

2583 unsigned char 
__pad1
[7];

2586 unsigned long int 
__pad2
;

2589 unsigned int 
__flags
;

2591 } 
__data
;

2593 char 
__size
[56];

2594 long int 
__align
;

2595 } 
	tpthread_rwlock_t
;

2599 char 
__size
[8];

2600 long int 
__align
;

2601 } 
	tpthread_rwlockattr_t
;

2607 typedef volatile int 
	tpthread_spinlock_t
;

2614 char 
__size
[32];

2615 long int 
__align
;

2616 } 
	tpthread_barrier_t
;

2620 char 
__size
[4];

2621 int 
__align
;

2622 } 
	tpthread_barrierattr_t
;

2634 extern long int 
	$random
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2637 extern void 
	$srandom
 (unsigned int 
__seed
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2643 extern char *
	$initstate
 (unsigned int 
__seed
, char *
__statebuf
,

2644 
size_t
 
__statelen
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

2648 extern char *
	$setstate
 (char *
__statebuf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2656 struct 
	srandom_data


2658 
int32_t
 *
fptr
;

2659 
int32_t
 *
rptr
;

2660 
int32_t
 *
state
;

2661 int 
rand_type
;

2662 int 
rand_deg
;

2663 int 
rand_sep
;

2664 
int32_t
 *
end_ptr
;

2667 extern int 
	$random_r
 (struct 
random_data
 *
__restrict
 
__buf
,

2668 
int32_t
 *
__restrict
 
__result
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2670 extern int 
	$srandom_r
 (unsigned int 
__seed
, struct 
random_data
 *
__buf
)

2671 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

2673 extern int 
	$initstate_r
 (unsigned int 
__seed
, char *
__restrict
 
__statebuf
,

2674 
size_t
 
__statelen
,

2675 struct 
random_data
 *
__restrict
 
__buf
)

2676 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 4)));

2678 extern int 
	$setstate_r
 (char *
__restrict
 
__statebuf
,

2679 struct 
random_data
 *
__restrict
 
__buf
)

2680 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2687 extern int 
	$rand
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2689 extern void 
	$srand
 (unsigned int 
__seed
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2694 extern int 
	$rand_r
 (unsigned int *
__seed
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2702 extern double 
	$drand48
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2703 extern double 
	$erand48
 (unsigned short int 
__xsubi
[3]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2706 extern long int 
	$lrand48
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2707 extern long int 
	$nrand48
 (unsigned short int 
__xsubi
[3])

2708 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2711 extern long int 
	$mrand48
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2712 extern long int 
	$jrand48
 (unsigned short int 
__xsubi
[3])

2713 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2716 extern void 
	$srand48
 (long int 
__seedval
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2717 extern unsigned short int *
	$seed48
 (unsigned short int 
__seed16v
[3])

2718 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2719 extern void 
	$lcong48
 (unsigned short int 
__param
[7]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2725 struct 
	sdrand48_data


2727 unsigned short int 
__x
[3];

2728 unsigned short int 
__old_x
[3];

2729 unsigned short int 
__c
;

2730 unsigned short int 
__init
;

2731 
__extension__
 unsigned long long int 
__a
;

2736 extern int 
	$drand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

2737 double *
__restrict
 
__result
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2738 extern int 
	$erand48_r
 (unsigned short int 
__xsubi
[3],

2739 struct 
drand48_data
 *
__restrict
 
__buffer
,

2740 double *
__restrict
 
__result
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2743 extern int 
	$lrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

2744 long int *
__restrict
 
__result
)

2745 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2746 extern int 
	$nrand48_r
 (unsigned short int 
__xsubi
[3],

2747 struct 
drand48_data
 *
__restrict
 
__buffer
,

2748 long int *
__restrict
 
__result
)

2749 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2752 extern int 
	$mrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

2753 long int *
__restrict
 
__result
)

2754 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2755 extern int 
	$jrand48_r
 (unsigned short int 
__xsubi
[3],

2756 struct 
drand48_data
 *
__restrict
 
__buffer
,

2757 long int *
__restrict
 
__result
)

2758 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2761 extern int 
	$srand48_r
 (long int 
__seedval
, struct 
drand48_data
 *
__buffer
)

2762 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

2764 extern int 
	$seed48_r
 (unsigned short int 
__seed16v
[3],

2765 struct 
drand48_data
 *
__buffer
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2767 extern int 
	$lcong48_r
 (unsigned short int 
__param
[7],

2768 struct 
drand48_data
 *
__buffer
)

2769 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

2779 extern void *
	$malloc
 (
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

2781 extern void *
	$calloc
 (
size_t
 
__nmemb
, size_t 
__size
)

2782 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

2793 extern void *
	$realloc
 (void *
__ptr
, 
size_t
 
__size
)

2794 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__warn_unused_result__
));

2796 extern void 
	$free
 (void *
__ptr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2801 extern void 
	$cfree
 (void *
__ptr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2816 extern void *
	$alloca
 (
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2829 extern void *
	$valloc
 (
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) ;

2834 extern int 
	$posix_memalign
 (void **
__memptr
, 
size_t
 
__alignment
, size_t 
__size
)

2835 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2840 extern void *
	$aligned_alloc
 (
size_t
 
__alignment
, size_t 
__size
)

2841 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) __attribute__ ((
	`__alloc_size__
 (2))) ;

2846 extern void 
	$abort
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

2850 extern int 
	`atexit
 (void (*
__func
) (void)) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2858 extern int 
	`at_quick_exit
 (void (*
__func
) (void)) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2866 extern int 
	`on_exit
 (void (*
__func
) (int 
__status
, void *
__arg
), void *__arg)

2867 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2874 extern void 
	$exit
 (int 
__status
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

2880 extern void 
	$quick_exit
 (int 
__status
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

2888 extern void 
	$_Exit
 (int 
__status
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__noreturn__
));

2895 extern char *
	$getenv
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2901 extern char *
	$secure_getenv
 (const char *
__name
)

2902 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2909 extern int 
	$putenv
 (char *
__string
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2915 extern int 
	$setenv
 (const char *
__name
, const char *
__value
, int 
__replace
)

2916 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

2919 extern int 
	$unsetenv
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2926 extern int 
	$clearenv
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

2928 extern char *
	$mktemp
 (char *
__template
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

2930 extern int 
	$mkstemp
 (char *
__template
) 
	`__asm__
 ("" "mkstemp64")

2931 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2937 extern int 
	$mkstemp64
 (char *
__template
) 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2939 extern int 
	$mkstemps
 (char *
__template
, int 
__suffixlen
) 
	`__asm__
 ("" "mkstemps64")

2940 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2946 extern int 
	$mkstemps64
 (char *
__template
, int 
__suffixlen
)

2947 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2949 extern char *
	$mkdtemp
 (char *
__template
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2951 extern int 
	$mkostemp
 (char *
__template
, int 
__flags
) 
	`__asm__
 ("" "mkostemp64")

2952 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2958 extern int 
	$mkostemp64
 (char *
__template
, int 
__flags
) 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2960 extern int 
	$mkostemps
 (char *
__template
, int 
__suffixlen
, int 
__flags
) 
	`__asm__
 ("" "mkostemps64")

2962 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2968 extern int 
	$mkostemps64
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

2969 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

2979 extern int 
	`system
 (const char *
__command
) ;

2986 extern char *
	$canonicalize_file_name
 (const char *
__name
)

2987 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

2989 extern char *
	$realpath
 (const char *
__restrict
 
__name
,

2990 char *
__restrict
 
__resolved
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

2997 typedef int (*
	t__compar_fn_t
) (const void *, const void *);

3000 typedef 
__compar_fn_t
 
	tcomparison_fn_t
;

3004 typedef int (*
	t__compar_d_fn_t
) (const void *, const void *, void *);

3010 extern void *
	$bsearch
 (const void *
__key
, const void *
__base
,

3011 
size_t
 
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
)

3012 
	`__attribute__
 ((
	`__nonnull__
 (1, 2, 5))) ;

3020 extern void 
	$qsort
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

3021 
__compar_fn_t
 
__compar
) 
	`__attribute__
 ((
	`__nonnull__
 (1, 4)));

3023 extern void 
	$qsort_r
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

3024 
__compar_d_fn_t
 
__compar
, void *
__arg
)

3025 
	`__attribute__
 ((
	`__nonnull__
 (1, 4)));

3030 extern int 
	$abs
 (int 
__x
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

3031 extern long int 
	$labs
 (long int 
__x
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

3035 
__extension__
 extern long long int 
	$llabs
 (long long int 
__x
)

3036 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

3044 extern 
div_t
 
	$div
 (int 
__numer
, int 
__denom
)

3045 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

3046 extern 
ldiv_t
 
	$ldiv
 (long int 
__numer
, long int 
__denom
)

3047 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

3052 
__extension__
 extern 
lldiv_t
 
	$lldiv
 (long long int 
__numer
,

3053 long long int 
__denom
)

3054 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
)) ;

3057 extern char *
	$ecvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

3058 int *
__restrict
 
__sign
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

3063 extern char *
	$fcvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

3064 int *
__restrict
 
__sign
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

3069 extern char *
	$gcvt
 (double 
__value
, int 
__ndigit
, char *
__buf
)

3070 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3))) ;

3075 extern char *
	$qecvt
 (long double 
__value
, int 
__ndigit
,

3076 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

3077 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

3078 extern char *
	$qfcvt
 (long double 
__value
, int 
__ndigit
,

3079 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

3080 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4))) ;

3081 extern char *
	$qgcvt
 (long double 
__value
, int 
__ndigit
, char *
__buf
)

3082 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3))) ;

3087 extern int 
	$ecvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

3088 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

3089 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

3090 extern int 
	$fcvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

3091 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

3092 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

3094 extern int 
	$qecvt_r
 (long double 
__value
, int 
__ndigit
,

3095 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

3096 char *
__restrict
 
__buf
, 
size_t
 
__len
)

3097 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

3098 extern int 
	$qfcvt_r
 (long double 
__value
, int 
__ndigit
,

3099 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

3100 char *
__restrict
 
__buf
, 
size_t
 
__len
)

3101 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4, 5)));

3108 extern int 
	$mblen
 (const char *
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3111 extern int 
	$mbtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

3112 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3115 extern int 
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3119 extern 
size_t
 
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__pwcs
,

3120 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3122 extern 
size_t
 
	$wcstombs
 (char *
__restrict
 
__s
,

3123 const 
wchar_t
 *
__restrict
 
__pwcs
, 
size_t
 
__n
)

3124 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3133 extern int 
	$rpmatch
 (const char *
__response
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

3135 extern int 
	$getsubopt
 (char **
__restrict
 
__optionp
,

3136 char *const *
__restrict
 
__tokens
,

3137 char **
__restrict
 
__valuep
)

3138 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2, 3))) ;

3144 extern void 
	$setkey
 (const char *
__key
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3152 extern int 
	`posix_openpt
 (int 
__oflag
) ;

3160 extern int 
	$grantpt
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3164 extern int 
	$unlockpt
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3169 extern char *
	$ptsname
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

3176 extern int 
	$ptsname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

3177 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

3180 extern int 
	`getpt
 (void);

3187 extern int 
	$getloadavg
 (double 
__loadavg
[], int 
__nelem
)

3188 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3214 extern void *
	$memcpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

3215 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3218 extern void *
	$memmove
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

3219 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3226 extern void *
	$memccpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

3227 int 
__c
, 
size_t
 
__n
)

3228 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3234 extern void *
	$memset
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3237 extern int 
	$memcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

3238 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3240 extern void *
	$memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

3241 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3245 extern void *
	$rawmemchr
 (const void *
__s
, int 
__c
)

3246 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3248 extern void *
	$memrchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

3249 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3256 extern char *
	$strcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

3257 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3259 extern char *
	$strncpy
 (char *
__restrict
 
__dest
,

3260 const char *
__restrict
 
__src
, 
size_t
 
__n
)

3261 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3264 extern char *
	$strcat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

3265 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3267 extern char *
	$strncat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
,

3268 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3271 extern int 
	$strcmp
 (const char *
__s1
, const char *
__s2
)

3272 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3274 extern int 
	$strncmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

3275 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3278 extern int 
	$strcoll
 (const char *
__s1
, const char *
__s2
)

3279 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3281 extern 
size_t
 
	$strxfrm
 (char *
__restrict
 
__dest
,

3282 const char *
__restrict
 
__src
, 
size_t
 
__n
)

3283 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

3286 extern int 
	$strcoll_l
 (const char *
__s1
, const char *
__s2
, 
__locale_t
 
__l
)

3287 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2, 3)));

3289 extern 
size_t
 
	$strxfrm_l
 (char *
__dest
, const char *
__src
, 
size_t
 
__n
,

3290 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 4)));

3295 extern char *
	$strdup
 (const char *
__s
)

3296 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) __attribute__ ((
	`__nonnull__
 (1)));

3303 extern char *
	$strndup
 (const char *
__string
, 
size_t
 
__n
)

3304 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__malloc__
)) __attribute__ ((
	`__nonnull__
 (1)));

3308 extern char *
	$strchr
 (const char *
__s
, int 
__c
)

3309 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3311 extern char *
	$strrchr
 (const char *
__s
, int 
__c
)

3312 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3316 extern char *
	$strchrnul
 (const char *
__s
, int 
__c
)

3317 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3324 extern 
size_t
 
	$strcspn
 (const char *
__s
, const char *
__reject
)

3325 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3328 extern 
size_t
 
	$strspn
 (const char *
__s
, const char *
__accept
)

3329 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3331 extern char *
	$strpbrk
 (const char *
__s
, const char *
__accept
)

3332 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3334 extern char *
	$strstr
 (const char *
__haystack
, const char *
__needle
)

3335 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3340 extern char *
	$strtok
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
)

3341 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

3346 extern char *
	$__strtok_r
 (char *
__restrict
 
__s
,

3347 const char *
__restrict
 
__delim
,

3348 char **
__restrict
 
__save_ptr
)

3349 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

3351 extern char *
	$strtok_r
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
,

3352 char **
__restrict
 
__save_ptr
)

3353 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

3355 extern char *
	$strcasestr
 (const char *
__haystack
, const char *
__needle
)

3356 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3364 extern void *
	$memmem
 (const void *
__haystack
, 
size_t
 
__haystacklen
,

3365 const void *
__needle
, 
size_t
 
__needlelen
)

3366 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

3370 extern void *
	$__mempcpy
 (void *
__restrict
 
__dest
,

3371 const void *
__restrict
 
__src
, 
size_t
 
__n
)

3372 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3373 extern void *
	$mempcpy
 (void *
__restrict
 
__dest
,

3374 const void *
__restrict
 
__src
, 
size_t
 
__n
)

3375 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3381 extern 
size_t
 
	$strlen
 (const char *
__s
)

3382 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3388 extern 
size_t
 
	$strnlen
 (const char *
__string
, 
size_t
 
__maxlen
)

3389 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3395 extern char *
	$strerror
 (int 
__errnum
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3398 extern char *
	$strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

3399 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

3405 extern char *
	$strerror_l
 (int 
__errnum
, 
__locale_t
 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3411 extern void 
	$__bzero
 (void *
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3415 extern void 
	$bcopy
 (const void *
__src
, void *
__dest
, 
size_t
 
__n
)

3416 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3419 extern void 
	$bzero
 (void *
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3422 extern int 
	$bcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

3423 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3425 extern char *
	$index
 (const char *
__s
, int 
__c
)

3426 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3428 extern char *
	$rindex
 (const char *
__s
, int 
__c
)

3429 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1)));

3434 extern int 
	$ffs
 (int 
__i
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

3439 extern int 
	$ffsl
 (long int 
__l
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

3440 
__extension__
 extern int 
	$ffsll
 (long long int 
__ll
)

3441 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

3445 extern int 
	$strcasecmp
 (const char *
__s1
, const char *
__s2
)

3446 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3449 extern int 
	$strncasecmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

3450 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3456 extern int 
	$strcasecmp_l
 (const char *
__s1
, const char *
__s2
,

3457 
__locale_t
 
__loc
)

3458 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2, 3)));

3460 extern int 
	$strncasecmp_l
 (const char *
__s1
, const char *
__s2
,

3461 
size_t
 
__n
, 
__locale_t
 
__loc
)

3462 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2, 4)));

3468 extern char *
	$strsep
 (char **
__restrict
 
__stringp
,

3469 const char *
__restrict
 
__delim
)

3470 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3475 extern char *
	$strsignal
 (int 
__sig
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

3478 extern char *
	$__stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

3479 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3480 extern char *
	$stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

3481 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3485 extern char *
	$__stpncpy
 (char *
__restrict
 
__dest
,

3486 const char *
__restrict
 
__src
, 
size_t
 
__n
)

3487 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3488 extern char *
	$stpncpy
 (char *
__restrict
 
__dest
,

3489 const char *
__restrict
 
__src
, 
size_t
 
__n
)

3490 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3495 extern int 
	$strverscmp
 (const char *
__s1
, const char *
__s2
)

3496 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__pure__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

3499 extern char *
	$strfry
 (char *
__string
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3502 extern void *
	$memfrob
 (void *
__s
, 
size_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3504 extern char *
	$basename
 (const char *
__filename
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

3512 typedef long int 
	tptrdiff_t
;

3515 typedef 
sqlite_int64
 
	ti64
;

3516 typedef 
sqlite_uint64
 
	tu64
;

3517 typedef unsigned int 
	tu32
;

3518 typedef unsigned short int 
	tu16
;

3519 typedef short int 
	ti16
;

3520 typedef unsigned char 
	tu8
;

3521 typedef signed char 
	ti8
;

3523 typedef 
u32
 
	ttRowcnt
;

3525 typedef short int 
	tLogEst
;

3527 typedef 
u64
 
	tuptr
;

3529 typedef struct 
BusyHandler
 
	tBusyHandler
;

3530 struct 
	sBusyHandler
 {

3531 int (*
xFunc
)(void *,int);

3532 void *
pArg
;

3533 int 
nBusy
;

3536 typedef struct 
AggInfo
 
	tAggInfo
;

3537 typedef struct 
AuthContext
 
	tAuthContext
;

3538 typedef struct 
AutoincInfo
 
	tAutoincInfo
;

3539 typedef struct 
Bitvec
 
	tBitvec
;

3540 typedef struct 
CollSeq
 
	tCollSeq
;

3541 typedef struct 
Column
 
	tColumn
;

3542 typedef struct 
Db
 
	tDb
;

3543 typedef struct 
Schema
 
	tSchema
;

3544 typedef struct 
Expr
 
	tExpr
;

3545 typedef struct 
ExprList
 
	tExprList
;

3546 typedef struct 
ExprSpan
 
	tExprSpan
;

3547 typedef struct 
FKey
 
	tFKey
;

3548 typedef struct 
FuncDestructor
 
	tFuncDestructor
;

3549 typedef struct 
FuncDef
 
	tFuncDef
;

3550 typedef struct 
FuncDefHash
 
	tFuncDefHash
;

3551 typedef struct 
IdList
 
	tIdList
;

3552 typedef struct 
Index
 
	tIndex
;

3553 typedef struct 
IndexSample
 
	tIndexSample
;

3554 typedef struct 
KeyClass
 
	tKeyClass
;

3555 typedef struct 
KeyInfo
 
	tKeyInfo
;

3556 typedef struct 
Lookaside
 
	tLookaside
;

3557 typedef struct 
LookasideSlot
 
	tLookasideSlot
;

3558 typedef struct 
Module
 
	tModule
;

3559 typedef struct 
NameContext
 
	tNameContext
;

3560 typedef struct 
Parse
 
	tParse
;

3561 typedef struct 
PrintfArguments
 
	tPrintfArguments
;

3562 typedef struct 
RowSet
 
	tRowSet
;

3563 typedef struct 
Savepoint
 
	tSavepoint
;

3564 typedef struct 
Select
 
	tSelect
;

3565 typedef struct 
SQLiteThread
 
	tSQLiteThread
;

3566 typedef struct 
SelectDest
 
	tSelectDest
;

3567 typedef struct 
SrcList
 
	tSrcList
;

3568 typedef struct 
StrAccum
 
	tStrAccum
;

3569 typedef struct 
Table
 
	tTable
;

3570 typedef struct 
TableLock
 
	tTableLock
;

3571 typedef struct 
Token
 
	tToken
;

3572 typedef struct 
TreeView
 
	tTreeView
;

3573 typedef struct 
Trigger
 
	tTrigger
;

3574 typedef struct 
TriggerPrg
 
	tTriggerPrg
;

3575 typedef struct 
TriggerStep
 
	tTriggerStep
;

3576 typedef struct 
UnpackedRecord
 
	tUnpackedRecord
;

3577 typedef struct 
VTable
 
	tVTable
;

3578 typedef struct 
VtabCtx
 
	tVtabCtx
;

3579 typedef struct 
Walker
 
	tWalker
;

3580 typedef struct 
WhereInfo
 
	tWhereInfo
;

3581 typedef struct 
With
 
	tWith
;

3583 typedef struct 
Btree
 
	tBtree
;

3584 typedef struct 
BtCursor
 
	tBtCursor
;

3585 typedef struct 
BtShared
 
	tBtShared
;

3588 static int 
	`sqlite3BtreeOpen
(

3589 
sqlite3_vfs
 *
pVfs
,

3590 const char *
zFilename
,

3591 
sqlite3
 *
db
,

3592 
Btree
 **
ppBtree
,

3593 int 
flags
,

3594 int 
vfsFlags


3597 static int 
	`sqlite3BtreeClose
(
Btree
*);

3598 static int 
	`sqlite3BtreeSetCacheSize
(
Btree
*,int);

3599 static int 
	`sqlite3BtreeSetSpillSize
(
Btree
*,int);

3601 static int 
	`sqlite3BtreeSetMmapLimit
(
Btree
*,
sqlite3_int64
);

3603 static int 
	`sqlite3BtreeSetPagerFlags
(
Btree
*,unsigned);

3604 static int 
	`sqlite3BtreeSetPageSize
(
Btree
 *
p
, int 
nPagesize
, int 
nReserve
, int 
eFix
);

3605 static int 
	`sqlite3BtreeGetPageSize
(
Btree
*);

3606 static int 
	`sqlite3BtreeMaxPageCount
(
Btree
*,int);

3607 static 
u32
 
	`sqlite3BtreeLastPage
(
Btree
*);

3608 static int 
	`sqlite3BtreeSecureDelete
(
Btree
*,int);

3609 static int 
	`sqlite3BtreeGetOptimalReserve
(
Btree
*);

3610 static int 
	`sqlite3BtreeGetReserveNoMutex
(
Btree
 *
p
);

3611 static int 
	`sqlite3BtreeSetAutoVacuum
(
Btree
 *, int);

3612 static int 
	`sqlite3BtreeGetAutoVacuum
(
Btree
 *);

3613 static int 
	`sqlite3BtreeBeginTrans
(
Btree
*,int);

3614 static int 
	`sqlite3BtreeCommitPhaseOne
(
Btree
*, const char *
zMaster
);

3615 static int 
	`sqlite3BtreeCommitPhaseTwo
(
Btree
*, int);

3616 static int 
	`sqlite3BtreeCommit
(
Btree
*);

3617 static int 
	`sqlite3BtreeRollback
(
Btree
*,int,int);

3618 static int 
	`sqlite3BtreeBeginStmt
(
Btree
*,int);

3619 static int 
	`sqlite3BtreeCreateTable
(
Btree
*, int*, int 
flags
);

3620 static int 
	`sqlite3BtreeIsInTrans
(
Btree
*);

3621 static int 
	`sqlite3BtreeIsInReadTrans
(
Btree
*);

3622 static int 
	`sqlite3BtreeIsInBackup
(
Btree
*);

3623 static void *
	`sqlite3BtreeSchema
(
Btree
 *, int, void(*)(void *));

3624 static int 
	`sqlite3BtreeSchemaLocked
(
Btree
 *
pBtree
);

3625 static int 
	`sqlite3BtreeLockTable
(
Btree
 *
pBtree
, int 
iTab
, 
u8
 
isWriteLock
);

3626 static int 
	`sqlite3BtreeSavepoint
(
Btree
 *, int, int);

3628 static const char *
	`sqlite3BtreeGetFilename
(
Btree
 *);

3629 static const char *
	`sqlite3BtreeGetJournalname
(
Btree
 *);

3630 static int 
	`sqlite3BtreeCopyFile
(
Btree
 *, Btree *);

3632 static int 
	`sqlite3BtreeIncrVacuum
(
Btree
 *);

3634 static int 
	`sqlite3BtreeDropTable
(
Btree
*, int, int*);

3635 static int 
	`sqlite3BtreeClearTable
(
Btree
*, int, int*);

3636 static int 
	`sqlite3BtreeClearTableOfCursor
(
BtCursor
*);

3637 static int 
	`sqlite3BtreeTripAllCursors
(
Btree
*, int, int);

3639 static void 
	`sqlite3BtreeGetMeta
(
Btree
 *
pBtree
, int 
idx
, 
u32
 *
pValue
);

3640 static int 
	`sqlite3BtreeUpdateMeta
(
Btree
*, int 
idx
, 
u32
 
value
);

3642 static int 
	`sqlite3BtreeNewDb
(
Btree
 *
p
);

3644 static int 
	`sqlite3BtreeCursor
(

3645 
Btree
*,

3646 int 
iTable
,

3647 int 
wrFlag
,

3648 struct 
KeyInfo
*,

3649 
BtCursor
 *
pCursor


3651 static int 
	`sqlite3BtreeCursorSize
(void);

3652 static void 
	`sqlite3BtreeCursorZero
(
BtCursor
*);

3653 static void 
	`sqlite3BtreeCursorHintFlags
(
BtCursor
*, unsigned);

3658 static int 
	`sqlite3BtreeCloseCursor
(
BtCursor
*);

3659 static int 
	`sqlite3BtreeMovetoUnpacked
(

3660 
BtCursor
*,

3661 
UnpackedRecord
 *
pUnKey
,

3662 
i64
 
intKey
,

3663 int 
bias
,

3664 int *
pRes


3666 static int 
	`sqlite3BtreeCursorHasMoved
(
BtCursor
*);

3667 static int 
	`sqlite3BtreeCursorRestore
(
BtCursor
*, int*);

3668 static int 
	`sqlite3BtreeDelete
(
BtCursor
*, 
u8
 
flags
);

3674 static int 
	`sqlite3BtreeInsert
(
BtCursor
*, const void *
pKey
, 
i64
 
nKey
,

3675 const void *
pData
, int 
nData
,

3676 int 
nZero
, int 
bias
, int 
seekResult
);

3677 static int 
	`sqlite3BtreeFirst
(
BtCursor
*, int *
pRes
);

3678 static int 
	`sqlite3BtreeLast
(
BtCursor
*, int *
pRes
);

3679 static int 
	`sqlite3BtreeNext
(
BtCursor
*, int *
pRes
);

3680 static int 
	`sqlite3BtreeEof
(
BtCursor
*);

3681 static int 
	`sqlite3BtreePrevious
(
BtCursor
*, int *
pRes
);

3682 static int 
	`sqlite3BtreeKeySize
(
BtCursor
*, 
i64
 *
pSize
);

3683 static int 
	`sqlite3BtreeKey
(
BtCursor
*, 
u32
 
offset
, u32 
amt
, void*);

3684 static const void *
	`sqlite3BtreeKeyFetch
(
BtCursor
*, 
u32
 *
pAmt
);

3685 static const void *
	`sqlite3BtreeDataFetch
(
BtCursor
*, 
u32
 *
pAmt
);

3686 static int 
	`sqlite3BtreeDataSize
(
BtCursor
*, 
u32
 *
pSize
);

3687 static int 
	`sqlite3BtreeData
(
BtCursor
*, 
u32
 
offset
, u32 
amt
, void*);

3689 static char *
	`sqlite3BtreeIntegrityCheck
(
Btree
*, int *
aRoot
, int 
nRoot
, int, int*);

3690 static struct 
Pager
 *
	`sqlite3BtreePager
(
Btree
*);

3692 static int 
	`sqlite3BtreePutData
(
BtCursor
*, 
u32
 
offset
, u32 
amt
, void*);

3693 static void 
	`sqlite3BtreeIncrblobCursor
(
BtCursor
 *);

3694 static void 
	`sqlite3BtreeClearCursor
(
BtCursor
 *);

3695 static int 
	`sqlite3BtreeSetVersion
(
Btree
 *
pBt
, int 
iVersion
);

3696 static int 
	`sqlite3BtreeCursorHasHint
(
BtCursor
*, unsigned int 
mask
);

3697 static int 
	`sqlite3BtreeIsReadonly
(
Btree
 *
pBt
);

3698 static int 
	`sqlite3HeaderSizeBtree
(void);

3705 static int 
	`sqlite3BtreeCount
(
BtCursor
 *, 
i64
 *);

3707 static int 
	`sqlite3BtreeCheckpoint
(
Btree
*, int, int *, int *);

3709 static void 
	`sqlite3BtreeEnter
(
Btree
*);

3710 static void 
	`sqlite3BtreeEnterAll
(
sqlite3
*);

3711 static int 
	`sqlite3BtreeSharable
(
Btree
*);

3712 static void 
	`sqlite3BtreeEnterCursor
(
BtCursor
*);

3714 static void 
	`sqlite3BtreeLeave
(
Btree
*);

3715 static void 
	`sqlite3BtreeLeaveCursor
(
BtCursor
*);

3716 static void 
	`sqlite3BtreeLeaveAll
(
sqlite3
*);

3718 typedef struct 
Vdbe
 
	tVdbe
;

3724 typedef struct 
Mem
 
	tMem
;

3725 typedef struct 
SubProgram
 
	tSubProgram
;

3732 struct 
	sVdbeOp
 {

3733 
u8
 
opcode
;

3734 signed char 
p4type
;

3735 
u8
 
opflags
;

3736 
u8
 
p5
;

3737 int 
p1
;

3738 int 
p2
;

3739 int 
p3
;

3740 union 
	up4union
 {

3741 int 
i
;

3742 void *
p
;

3743 char *
z
;

3744 
i64
 *
pI64
;

3745 double *
pReal
;

3746 
FuncDef
 *
pFunc
;

3747 
sqlite3_context
 *
pCtx
;

3748 
CollSeq
 *
pColl
;

3749 
Mem
 *
pMem
;

3750 
VTable
 *
pVtab
;

3751 
KeyInfo
 *
pKeyInfo
;

3752 int *
ai
;

3753 
SubProgram
 *
pProgram
;

3757 int (*
xAdvance
)(
BtCursor
 *, int *);

3758 } 
p4
;

3761 typedef struct 
VdbeOp
 
	tVdbeOp
;

3767 struct 
	sSubProgram
 {

3768 
VdbeOp
 *
aOp
;

3769 int 
nOp
;

3770 int 
nMem
;

3771 int 
nCsr
;

3772 int 
nOnce
;

3773 void *
token
;

3774 
SubProgram
 *
pNext
;

3781 struct 
	sVdbeOpList
 {

3782 
u8
 
opcode
;

3783 signed char 
p1
;

3784 signed char 
p2
;

3785 signed char 
p3
;

3787 typedef struct 
VdbeOpList
 
	tVdbeOpList
;

3789 static 
Vdbe
 *
	`sqlite3VdbeCreate
(
Parse
*);

3790 static int 
	`sqlite3VdbeAddOp0
(
Vdbe
*,int);

3791 static int 
	`sqlite3VdbeAddOp1
(
Vdbe
*,int,int);

3792 static int 
	`sqlite3VdbeAddOp2
(
Vdbe
*,int,int,int);

3793 static int 
	`sqlite3VdbeGoto
(
Vdbe
*,int);

3794 static int 
	`sqlite3VdbeLoadString
(
Vdbe
*,int,const char*);

3795 static void 
	`sqlite3VdbeMultiLoad
(
Vdbe
*,int,const char*,...);

3796 static int 
	`sqlite3VdbeAddOp3
(
Vdbe
*,int,int,int,int);

3797 static int 
	`sqlite3VdbeAddOp4
(
Vdbe
*,int,int,int,int,const char *
zP4
,int);

3798 static int 
	`sqlite3VdbeAddOp4Dup8
(
Vdbe
*,int,int,int,int,const 
u8
*,int);

3799 static int 
	`sqlite3VdbeAddOp4Int
(
Vdbe
*,int,int,int,int,int);

3800 static void 
	`sqlite3VdbeEndCoroutine
(
Vdbe
*,int);

3806 static 
VdbeOp
 *
	`sqlite3VdbeAddOpList
(
Vdbe
*, int 
nOp
, 
VdbeOpList
 const *
aOp
, int 
iLineno
);

3807 static void 
	`sqlite3VdbeAddParseSchemaOp
(
Vdbe
*,int,char*);

3808 static void 
	`sqlite3VdbeChangeOpcode
(
Vdbe
*, 
u32
 
addr
, 
u8
);

3809 static void 
	`sqlite3VdbeChangeP1
(
Vdbe
*, 
u32
 
addr
, int 
P1
);

3810 static void 
	`sqlite3VdbeChangeP2
(
Vdbe
*, 
u32
 
addr
, int 
P2
);

3811 static void 
	`sqlite3VdbeChangeP3
(
Vdbe
*, 
u32
 
addr
, int 
P3
);

3812 static void 
	`sqlite3VdbeChangeP5
(
Vdbe
*, 
u8
 
P5
);

3813 static void 
	`sqlite3VdbeJumpHere
(
Vdbe
*, int 
addr
);

3814 static int 
	`sqlite3VdbeChangeToNoop
(
Vdbe
*, int 
addr
);

3815 static int 
	`sqlite3VdbeDeletePriorOpcode
(
Vdbe
*, 
u8
 
op
);

3816 static void 
	`sqlite3VdbeChangeP4
(
Vdbe
*, int 
addr
, const char *
zP4
, int 
N
);

3817 static void 
	`sqlite3VdbeSetP4KeyInfo
(
Parse
*, 
Index
*);

3818 static void 
	`sqlite3VdbeUsesBtree
(
Vdbe
*, int);

3819 static 
VdbeOp
 *
	`sqlite3VdbeGetOp
(
Vdbe
*, int);

3820 static int 
	`sqlite3VdbeMakeLabel
(
Vdbe
*);

3821 static void 
	`sqlite3VdbeRunOnlyOnce
(
Vdbe
*);

3822 static void 
	`sqlite3VdbeReusable
(
Vdbe
*);

3823 static void 
	`sqlite3VdbeDelete
(
Vdbe
*);

3824 static void 
	`sqlite3VdbeClearObject
(
sqlite3
*,
Vdbe
*);

3825 static void 
	`sqlite3VdbeMakeReady
(
Vdbe
*,
Parse
*);

3826 static int 
	`sqlite3VdbeFinalize
(
Vdbe
*);

3827 static void 
	`sqlite3VdbeResolveLabel
(
Vdbe
*, int);

3828 static int 
	`sqlite3VdbeCurrentAddr
(
Vdbe
*);

3832 static void 
	`sqlite3VdbeResetStepResult
(
Vdbe
*);

3833 static void 
	`sqlite3VdbeRewind
(
Vdbe
*);

3834 static int 
	`sqlite3VdbeReset
(
Vdbe
*);

3835 static void 
	`sqlite3VdbeSetNumCols
(
Vdbe
*,int);

3836 static int 
	`sqlite3VdbeSetColName
(
Vdbe
*, int, int, const char *, void(*)(void*));

3837 static void 
	`sqlite3VdbeCountChanges
(
Vdbe
*);

3838 static 
sqlite3
 *
	`sqlite3VdbeDb
(
Vdbe
*);

3839 static void 
	`sqlite3VdbeSetSql
(
Vdbe
*, const char *
z
, int 
n
, int);

3840 static void 
	`sqlite3VdbeSwap
(
Vdbe
*,Vdbe*);

3841 static 
VdbeOp
 *
	`sqlite3VdbeTakeOpArray
(
Vdbe
*, int*, int*);

3842 static 
sqlite3_value
 *
	`sqlite3VdbeGetBoundValue
(
Vdbe
*, int, 
u8
);

3843 static void 
	`sqlite3VdbeSetVarmask
(
Vdbe
*, int);

3845 static char *
	`sqlite3VdbeExpandSql
(
Vdbe
*, const char*);

3847 static int 
	`sqlite3MemCompare
(const 
Mem
*, const Mem*, const 
CollSeq
*);

3849 static void 
	`sqlite3VdbeRecordUnpack
(
KeyInfo
*,int,const void*,
UnpackedRecord
*);

3850 static int 
	`sqlite3VdbeRecordCompare
(int,const void*,
UnpackedRecord
*);

3851 static int 
	`sqlite3VdbeRecordCompareWithSkip
(int, const void *, 
UnpackedRecord
 *, int);

3852 static 
UnpackedRecord
 *
	`sqlite3VdbeAllocUnpackedRecord
(
KeyInfo
 *, char *, int, char **);

3854 typedef int (*
	tRecordCompare
)(int,const void*,
	tUnpackedRecord
*);

3855 static 
RecordCompare
 
	`sqlite3VdbeFindCompare
(
UnpackedRecord
*);

3858 static void 
	`sqlite3VdbeLinkSubProgram
(
Vdbe
 *, 
SubProgram
 *);

3860 typedef 
u32
 
	tPgno
;

3865 typedef struct 
Pager
 
	tPager
;

3870 typedef struct 
PgHdr
 
	tDbPage
;

3872 static int 
	`sqlite3PagerOpen
(

3873 
sqlite3_vfs
*,

3874 
Pager
 **
ppPager
,

3879 void(*)(
DbPage
*)

3881 static int 
	`sqlite3PagerClose
(
Pager
 *
pPager
);

3882 static int 
	`sqlite3PagerReadFileheader
(
Pager
*, int, unsigned char*);

3885 static void 
	`sqlite3PagerSetBusyhandler
(
Pager
*, int(*)(void *), void *);

3886 static int 
	`sqlite3PagerSetPagesize
(
Pager
*, 
u32
*, int);

3890 static int 
	`sqlite3PagerMaxPageCount
(
Pager
*, int);

3891 static void 
	`sqlite3PagerSetCachesize
(
Pager
*, int);

3892 static int 
	`sqlite3PagerSetSpillsize
(
Pager
*, int);

3893 static void 
	`sqlite3PagerSetMmapLimit
(
Pager
 *, 
sqlite3_int64
);

3894 static void 
	`sqlite3PagerShrink
(
Pager
*);

3895 static void 
	`sqlite3PagerSetFlags
(
Pager
*,unsigned);

3896 static int 
	`sqlite3PagerLockingMode
(
Pager
 *, int);

3897 static int 
	`sqlite3PagerSetJournalMode
(
Pager
 *, int);

3898 static int 
	`sqlite3PagerGetJournalMode
(
Pager
*);

3899 static int 
	`sqlite3PagerOkToChangeJournalMode
(
Pager
*);

3900 static 
i64
 
	`sqlite3PagerJournalSizeLimit
(
Pager
 *, i64);

3901 static 
sqlite3_backup
 **
	`sqlite3PagerBackupPtr
(
Pager
*);

3902 static int 
	`sqlite3PagerFlush
(
Pager
*);

3905 static int 
	`sqlite3PagerGet
(
Pager
 *
pPager
, 
Pgno
 
pgno
, 
DbPage
 **
ppPage
, int 
clrFlag
);

3906 static 
DbPage
 *
	`sqlite3PagerLookup
(
Pager
 *
pPager
, 
Pgno
 
pgno
);

3907 static void 
	`sqlite3PagerRef
(
DbPage
*);

3908 static void 
	`sqlite3PagerUnref
(
DbPage
*);

3909 static void 
	`sqlite3PagerUnrefNotNull
(
DbPage
*);

3912 static int 
	`sqlite3PagerWrite
(
DbPage
*);

3913 static void 
	`sqlite3PagerDontWrite
(
DbPage
*);

3914 static int 
	`sqlite3PagerMovepage
(
Pager
*,
DbPage
*,
Pgno
,int);

3915 static int 
	`sqlite3PagerPageRefcount
(
DbPage
*);

3916 static void *
	`sqlite3PagerGetData
(
DbPage
 *);

3917 static void *
	`sqlite3PagerGetExtra
(
DbPage
 *);

3920 static void 
	`sqlite3PagerPagecount
(
Pager
*, int*);

3921 static int 
	`sqlite3PagerBegin
(
Pager
*, int 
exFlag
, int);

3922 static int 
	`sqlite3PagerCommitPhaseOne
(
Pager
*,const char *
zMaster
, int);

3923 static int 
	`sqlite3PagerExclusiveLock
(
Pager
*);

3924 static int 
	`sqlite3PagerSync
(
Pager
 *
pPager
, const char *
zMaster
);

3925 static int 
	`sqlite3PagerCommitPhaseTwo
(
Pager
*);

3926 static int 
	`sqlite3PagerRollback
(
Pager
*);

3927 static int 
	`sqlite3PagerOpenSavepoint
(
Pager
 *
pPager
, int 
n
);

3928 static int 
	`sqlite3PagerSavepoint
(
Pager
 *
pPager
, int 
op
, int 
iSavepoint
);

3929 static int 
	`sqlite3PagerSharedLock
(
Pager
 *
pPager
);

3932 static int 
	`sqlite3PagerCheckpoint
(
Pager
 *
pPager
, int, int*, int*);

3933 static int 
	`sqlite3PagerWalSupported
(
Pager
 *
pPager
);

3934 static int 
	`sqlite3PagerWalCallback
(
Pager
 *
pPager
);

3935 static int 
	`sqlite3PagerOpenWal
(
Pager
 *
pPager
, int *
pisOpen
);

3936 static int 
	`sqlite3PagerCloseWal
(
Pager
 *
pPager
);

3938 static 
u8
 
	`sqlite3PagerIsreadonly
(
Pager
*);

3939 static 
u32
 
	`sqlite3PagerDataVersion
(
Pager
*);

3943 static int 
	`sqlite3PagerMemUsed
(
Pager
*);

3944 static const char *
	`sqlite3PagerFilename
(
Pager
*, int);

3945 static 
sqlite3_vfs
 *
	`sqlite3PagerVfs
(
Pager
*);

3946 static 
sqlite3_file
 *
	`sqlite3PagerFile
(
Pager
*);

3947 static 
sqlite3_file
 *
	`sqlite3PagerJrnlFile
(
Pager
*);

3948 static const char *
	`sqlite3PagerJournalname
(
Pager
*);

3949 static void *
	`sqlite3PagerTempSpace
(
Pager
*);

3950 static int 
	`sqlite3PagerIsMemdb
(
Pager
*);

3951 static void 
	`sqlite3PagerCacheStat
(
Pager
 *, int, int, int *);

3952 static void 
	`sqlite3PagerClearCache
(
Pager
 *);

3953 static int 
	`sqlite3SectorSize
(
sqlite3_file
 *);

3956 static void 
	`sqlite3PagerTruncateImage
(
Pager
*,
Pgno
);

3958 static void 
	`sqlite3PagerRekey
(
DbPage
*, 
Pgno
, 
u16
);

3960 typedef struct 
PgHdr
 
	tPgHdr
;

3961 typedef struct 
PCache
 
	tPCache
;

3967 struct 
	sPgHdr
 {

3968 
sqlite3_pcache_page
 *
pPage
;

3969 void *
pData
;

3970 void *
pExtra
;

3971 
PgHdr
 *
pDirty
;

3972 
Pager
 *
pPager
;

3973 
Pgno
 
pgno
;

3977 
u16
 
flags
;

3983 
i16
 
nRef
;

3984 
PCache
 *
pCache
;

3986 
PgHdr
 *
pDirtyNext
;

3987 
PgHdr
 *
pDirtyPrev
;

3990 static int 
	`sqlite3PcacheInitialize
(void);

3991 static void 
	`sqlite3PcacheShutdown
(void);

3996 static void 
	`sqlite3PCacheBufferSetup
(void *, int 
sz
, int 
n
);

4002 static int 
	`sqlite3PcacheOpen
(

4003 int 
szPage
,

4004 int 
szExtra
,

4005 int 
bPurgeable
,

4006 int (*
xStress
)(void*, 
PgHdr
*),

4007 void *
pStress
,

4008 
PCache
 *
pToInit


4012 static int 
	`sqlite3PcacheSetPageSize
(
PCache
 *, int);

4017 static int 
	`sqlite3PcacheSize
(void);

4022 static 
sqlite3_pcache_page
 *
	`sqlite3PcacheFetch
(
PCache
*, 
Pgno
, int 
createFlag
);

4023 static int 
	`sqlite3PcacheFetchStress
(
PCache
*, 
Pgno
, 
sqlite3_pcache_page
**);

4024 static 
PgHdr
 *
	`sqlite3PcacheFetchFinish
(
PCache
*, 
Pgno
, 
sqlite3_pcache_page
 *
pPage
);

4025 static void 
	`sqlite3PcacheRelease
(
PgHdr
*);

4027 static void 
	`sqlite3PcacheDrop
(
PgHdr
*);

4028 static void 
	`sqlite3PcacheMakeDirty
(
PgHdr
*);

4029 static void 
	`sqlite3PcacheMakeClean
(
PgHdr
*);

4030 static void 
	`sqlite3PcacheCleanAll
(
PCache
*);

4033 static void 
	`sqlite3PcacheMove
(
PgHdr
*, 
Pgno
);

4036 static void 
	`sqlite3PcacheTruncate
(
PCache
*, 
Pgno
 
x
);

4039 static 
PgHdr
 *
	`sqlite3PcacheDirtyList
(
PCache
*);

4042 static void 
	`sqlite3PcacheClose
(
PCache
*);

4045 static void 
	`sqlite3PcacheClearSyncFlags
(
PCache
 *);

4048 static void 
	`sqlite3PcacheClear
(
PCache
*);

4051 static int 
	`sqlite3PcacheRefCount
(
PCache
*);

4054 static void 
	`sqlite3PcacheRef
(
PgHdr
*);

4056 static int 
	`sqlite3PcachePageRefcount
(
PgHdr
*);

4059 static int 
	`sqlite3PcachePagecount
(
PCache
*);

4061 static void 
	`sqlite3PcacheSetCachesize
(
PCache
 *, int);

4063 static int 
	`sqlite3PcacheSetSpillsize
(
PCache
 *, int);

4066 static void 
	`sqlite3PcacheShrink
(
PCache
*);

4068 static void 
	`sqlite3PCacheSetDefault
(void);

4071 static int 
	`sqlite3HeaderSizePcache
(void);

4072 static int 
	`sqlite3HeaderSizePcache1
(void);

4074 static int 
	`sqlite3OsInit
(void);

4079 static int 
	`sqlite3OsClose
(
sqlite3_file
*);

4080 static int 
	`sqlite3OsRead
(
sqlite3_file
*, void*, int 
amt
, 
i64
 
offset
);

4081 static int 
	`sqlite3OsWrite
(
sqlite3_file
*, const void*, int 
amt
, 
i64
 
offset
);

4082 static int 
	`sqlite3OsTruncate
(
sqlite3_file
*, 
i64
 
size
);

4083 static int 
	`sqlite3OsSync
(
sqlite3_file
*, int);

4084 static int 
	`sqlite3OsFileSize
(
sqlite3_file
*, 
i64
 *
pSize
);

4085 static int 
	`sqlite3OsLock
(
sqlite3_file
*, int);

4086 static int 
	`sqlite3OsUnlock
(
sqlite3_file
*, int);

4087 static int 
	`sqlite3OsCheckReservedLock
(
sqlite3_file
 *
id
, int *
pResOut
);

4088 static int 
	`sqlite3OsFileControl
(
sqlite3_file
*,int,void*);

4089 static void 
	`sqlite3OsFileControlHint
(
sqlite3_file
*,int,void*);

4091 static int 
	`sqlite3OsSectorSize
(
sqlite3_file
 *
id
);

4092 static int 
	`sqlite3OsDeviceCharacteristics
(
sqlite3_file
 *
id
);

4093 static int 
	`sqlite3OsShmMap
(
sqlite3_file
 *,int,int,int,void volatile **);

4094 static int 
	`sqlite3OsShmLock
(
sqlite3_file
 *
id
, int, int, int);

4095 static void 
	`sqlite3OsShmBarrier
(
sqlite3_file
 *
id
);

4096 static int 
	`sqlite3OsShmUnmap
(
sqlite3_file
 *
id
, int);

4097 static int 
	`sqlite3OsFetch
(
sqlite3_file
 *
id
, 
i64
, int, void **);

4098 static int 
	`sqlite3OsUnfetch
(
sqlite3_file
 *, 
i64
, void *);

4104 static int 
	`sqlite3OsOpen
(
sqlite3_vfs
 *, const char *, 
sqlite3_file
*, int, int *);

4105 static int 
	`sqlite3OsDelete
(
sqlite3_vfs
 *, const char *, int);

4106 static int 
	`sqlite3OsAccess
(
sqlite3_vfs
 *, const char *, int, int *
pResOut
);

4107 static int 
	`sqlite3OsFullPathname
(
sqlite3_vfs
 *, const char *, int, char *);

4109 static void *
	`sqlite3OsDlOpen
(
sqlite3_vfs
 *, const char *);

4110 static void 
	`sqlite3OsDlError
(
sqlite3_vfs
 *, int, char *);

4111 static void (*
	$sqlite3OsDlSym
(
sqlite3_vfs
 *, void *, const char *))(void);

4112 static void 
	`sqlite3OsDlClose
(
sqlite3_vfs
 *, void *);

4114 static int 
	`sqlite3OsRandomness
(
sqlite3_vfs
 *, int, char *);

4115 static int 
	`sqlite3OsSleep
(
sqlite3_vfs
 *, int);

4116 static int 
	`sqlite3OsGetLastError
(
sqlite3_vfs
*);

4117 static int 
	`sqlite3OsCurrentTimeInt64
(
sqlite3_vfs
 *, 
sqlite3_int64
*);

4123 static int 
	`sqlite3OsOpenMalloc
(
sqlite3_vfs
 *, const char *, 
sqlite3_file
 **, int,int*);

4124 static int 
	`sqlite3OsCloseFree
(
sqlite3_file
 *);

4126 struct 
	sDb
 {

4127 char *
zName
;

4128 
Btree
 *
pBt
;

4129 
u8
 
safety_level
;

4130 
u8
 
bSyncSet
;

4131 
Schema
 *
pSchema
;

4134 struct 
	sSchema
 {

4135 int 
schema_cookie
;

4136 int 
iGeneration
;

4137 
Hash
 
tblHash
;

4138 
Hash
 
idxHash
;

4139 
Hash
 
trigHash
;

4140 
Hash
 
fkeyHash
;

4141 
Table
 *
pSeqTab
;

4142 
u8
 
file_format
;

4143 
u8
 
enc
;

4144 
u16
 
schemaFlags
;

4145 int 
cache_size
;

4148 struct 
	sLookaside
 {

4149 
u32
 
bDisable
;

4150 
u16
 
sz
;

4151 
u8
 
bMalloced
;

4152 int 
nOut
;

4153 int 
mxOut
;

4154 int 
anStat
[3];

4155 
LookasideSlot
 *
pFree
;

4156 void *
pStart
;

4157 void *
pEnd
;

4159 struct 
	sLookasideSlot
 {

4160 
LookasideSlot
 *
pNext
;

4163 struct 
	sFuncDefHash
 {

4164 
FuncDef
 *
a
[23];

4167 typedef int (*
	tsqlite3_xauth
)(void*,int,const char*,const char*,const char*,

4175 struct 
	ssqlite3
 {

4176 
sqlite3_vfs
 *
pVfs
;

4177 struct 
Vdbe
 *
pVdbe
;

4178 
CollSeq
 *
pDfltColl
;

4179 
sqlite3_mutex
 *
mutex
;

4180 
Db
 *
aDb
;

4181 int 
nDb
;

4182 int 
flags
;

4183 
i64
 
lastRowid
;

4184 
i64
 
szMmap
;

4185 unsigned int 
openFlags
;

4186 int 
errCode
;

4187 int 
errMask
;

4188 int 
iSysErrno
;

4189 
u16
 
dbOptFlags
;

4190 
u8
 
enc
;

4191 
u8
 
autoCommit
;

4192 
u8
 
temp_store
;

4193 
u8
 
mallocFailed
;

4194 
u8
 
bBenignMalloc
;

4195 
u8
 
dfltLockMode
;

4196 signed char 
nextAutovac
;

4197 
u8
 
suppressErr
;

4198 
u8
 
vtabOnConflict
;

4199 
u8
 
isTransactionSavepoint
;

4200 int 
nextPagesize
;

4201 
u32
 
magic
;

4202 int 
nChange
;

4203 int 
nTotalChange
;

4204 int 
aLimit
[(11 +1)];

4205 int 
nMaxSorterMmap
;

4206 struct 
	ssqlite3InitInfo
 {

4207 int 
newTnum
;

4208 
u8
 
iDb
;

4209 
u8
 
busy
;

4210 
u8
 
orphanTrigger
;

4211 
u8
 
imposterTable
;

4212 } 
init
;

4213 int 
nVdbeActive
;

4214 int 
nVdbeRead
;

4215 int 
nVdbeWrite
;

4216 int 
nVdbeExec
;

4217 int 
nVDestroy
;

4218 int 
nExtension
;

4219 void **
aExtension
;

4220 void (*
xTrace
)(void*,const char*);

4221 void *
pTraceArg
;

4222 void (*
xProfile
)(void*,const char*,
u64
);

4223 void *
pProfileArg
;

4224 void *
pCommitArg
;

4225 int (*
xCommitCallback
)(void*);

4226 void *
pRollbackArg
;

4227 void (*
xRollbackCallback
)(void*);

4228 void *
pUpdateArg
;

4229 void (*
xUpdateCallback
)(void*,int, const char*,const char*,
sqlite_int64
);

4231 int (*
xWalCallback
)(void *, 
sqlite3
 *, const char *, int);

4232 void *
pWalArg
;

4234 void(*
xCollNeeded
)(void*,
sqlite3
*,int 
eTextRep
,const char*);

4235 void(*
xCollNeeded16
)(void*,
sqlite3
*,int 
eTextRep
,const void*);

4236 void *
pCollNeededArg
;

4237 
sqlite3_value
 *
pErr
;

4239 volatile int 
isInterrupted
;

4240 double 
notUsed1
;

4241 } 
u1
;

4242 
Lookaside
 
lookaside
;

4244 
sqlite3_xauth
 
xAuth
;

4245 void *
pAuthArg
;

4248 int (*
xProgress
)(void *);

4249 void *
pProgressArg
;

4250 unsigned 
nProgressOps
;

4253 int 
nVTrans
;

4254 
Hash
 
aModule
;

4255 
VtabCtx
 *
pVtabCtx
;

4256 
VTable
 **
aVTrans
;

4257 
VTable
 *
pDisconnect
;

4259 
Hash
 
aFunc
;

4260 
Hash
 
aCollSeq
;

4261 
BusyHandler
 
busyHandler
;

4262 
Db
 
aDbStatic
[2];

4263 
Savepoint
 *
pSavepoint
;

4264 int 
busyTimeout
;

4265 int 
nSavepoint
;

4266 int 
nStatement
;

4267 
i64
 
nDeferredCons
;

4268 
i64
 
nDeferredImmCons
;

4269 int *
pnBytesFreed
;

4273 struct 
	sFuncDef
 {

4274 
i8
 
nArg
;

4275 
u16
 
funcFlags
;

4276 void *
pUserData
;

4277 
FuncDef
 *
pNext
;

4278 void (*
xSFunc
)(
sqlite3_context
*,int,
sqlite3_value
**);

4279 void (*
xFinalize
)(
sqlite3_context
*);

4280 const char *
zName
;

4282 
FuncDef
 *
pHash
;

4283 
FuncDestructor
 *
pDestructor
;

4284 } 
u
;

4287 struct 
	sFuncDestructor
 {

4288 int 
nRef
;

4289 void (*
xDestroy
)(void *);

4290 void *
pUserData
;

4293 struct 
	sSavepoint
 {

4294 char *
zName
;

4295 
i64
 
nDeferredCons
;

4296 
i64
 
nDeferredImmCons
;

4297 
Savepoint
 *
pNext
;

4300 struct 
	sModule
 {

4301 const 
sqlite3_module
 *
pModule
;

4302 const char *
zName
;

4303 void *
pAux
;

4304 void (*
xDestroy
)(void *);

4305 
Table
 *
pEpoTab
;

4312 struct 
	sColumn
 {

4313 char *
zName
;

4314 
Expr
 *
pDflt
;

4315 char *
zColl
;

4316 
u8
 
notNull
;

4317 char 
affinity
;

4318 
u8
 
szEst
;

4319 
u8
 
colFlags
;

4322 struct 
	sCollSeq
 {

4323 char *
zName
;

4324 
u8
 
enc
;

4325 void *
pUser
;

4326 int (*
xCmp
)(void*,int, const void*, int, const void*);

4327 void (*
xDel
)(void*);

4330 struct 
	sVTable
 {

4331 
sqlite3
 *
db
;

4332 
Module
 *
pMod
;

4333 
sqlite3_vtab
 *
pVtab
;

4334 int 
nRef
;

4335 
u8
 
bConstraint
;

4336 int 
iSavepoint
;

4337 
VTable
 *
pNext
;

4344 struct 
	sTable
 {

4345 char *
zName
;

4346 
Column
 *
aCol
;

4347 
Index
 *
pIndex
;

4348 
Select
 *
pSelect
;

4349 
FKey
 *
pFKey
;

4350 char *
zColAff
;

4351 
ExprList
 *
pCheck
;

4353 int 
tnum
;

4354 
i16
 
iPKey
;

4355 
i16
 
nCol
;

4356 
u16
 
nRef
;

4357 
LogEst
 
nRowLogEst
;

4358 
LogEst
 
szTabRow
;

4362 
u8
 
tabFlags
;

4363 
u8
 
keyConf
;

4365 int 
addColOffset
;

4368 int 
nModuleArg
;

4369 char **
azModuleArg
;

4370 
VTable
 *
pVTable
;

4372 
Trigger
 *
pTrigger
;

4373 
Schema
 *
pSchema
;

4374 
Table
 *
pNextZombie
;

4377 struct 
	sFKey
 {

4378 
Table
 *
pFrom
;

4379 
FKey
 *
pNextFrom
;

4380 char *
zTo
;

4381 
FKey
 *
pNextTo
;

4382 
FKey
 *
pPrevTo
;

4383 int 
nCol
;

4385 
u8
 
isDeferred
;

4386 
u8
 
aAction
[2];

4387 
Trigger
 *
apTrigger
[2];

4388 struct 
	ssColMap
 {

4389 int 
iFrom
;

4390 char *
zCol
;

4391 } 
aCol
[1];

4394 struct 
	sKeyInfo
 {

4395 
u32
 
nRef
;

4396 
u8
 
enc
;

4397 
u16
 
nField
;

4398 
u16
 
nXField
;

4399 
sqlite3
 *
db
;

4400 
u8
 *
aSortOrder
;

4401 
CollSeq
 *
aColl
[1];

4404 struct 
	sUnpackedRecord
 {

4405 
KeyInfo
 *
pKeyInfo
;

4406 
Mem
 *
aMem
;

4407 
u16
 
nField
;

4408 
i8
 
default_rc
;

4409 
u8
 
errCode
;

4410 
i8
 
r1
;

4411 
i8
 
r2
;

4412 
u8
 
eqSeen
;

4415 struct 
	sIndex
 {

4416 char *
zName
;

4417 
i16
 *
aiColumn
;

4418 
LogEst
 *
aiRowLogEst
;

4419 
Table
 *
pTable
;

4420 char *
zColAff
;

4421 
Index
 *
pNext
;

4422 
Schema
 *
pSchema
;

4423 
u8
 *
aSortOrder
;

4424 const char **
azColl
;

4425 
Expr
 *
pPartIdxWhere
;

4426 
ExprList
 *
aColExpr
;

4427 int 
tnum
;

4428 
LogEst
 
szIdxRow
;

4429 
u16
 
nKeyCol
;

4430 
u16
 
nColumn
;

4431 
u8
 
onError
;

4432 unsigned 
idxType
:2;

4433 unsigned 
bUnordered
:1;

4434 unsigned 
uniqNotNull
:1;

4435 unsigned 
isResized
:1;

4436 unsigned 
isCovering
:1;

4437 unsigned 
noSkipScan
:1;

4441 struct 
	sIndexSample
 {

4442 void *
p
;

4443 int 
n
;

4444 
tRowcnt
 *
anEq
;

4445 
tRowcnt
 *
anLt
;

4446 
tRowcnt
 *
anDLt
;

4449 struct 
	sToken
 {

4450 const char *
z
;

4451 unsigned int 
n
;

4454 struct 
	sAggInfo
 {

4455 
u8
 
directMode
;

4457 
u8
 
useSortingIdx
;

4459 int 
sortingIdx
;

4460 int 
sortingIdxPTab
;

4461 int 
nSortingColumn
;

4462 int 
mnReg
, 
mxReg
;

4463 
ExprList
 *
pGroupBy
;

4464 struct 
	sAggInfo_col
 {

4465 
Table
 *
pTab
;

4466 int 
iTable
;

4467 int 
iColumn
;

4468 int 
iSorterColumn
;

4469 int 
iMem
;

4470 
Expr
 *
pExpr
;

4471 } *
aCol
;

4472 int 
nColumn
;

4473 int 
nAccumulator
;

4476 struct 
	sAggInfo_func
 {

4477 
Expr
 *
pExpr
;

4478 
FuncDef
 *
pFunc
;

4479 int 
iMem
;

4480 int 
iDistinct
;

4481 } *
aFunc
;

4482 int 
nFunc
;

4485 typedef 
i16
 
	tynVar
;

4487 struct 
	sExpr
 {

4488 
u8
 
op
;

4489 char 
affinity
;

4490 
u32
 
flags
;

4492 char *
zToken
;

4493 int 
iValue
;

4494 } 
u
;

4501 
Expr
 *
pLeft
;

4502 
Expr
 *
pRight
;

4504 
ExprList
 *
pList
;

4505 
Select
 *
pSelect
;

4506 } 
x
;

4514 int 
nHeight
;

4516 int 
iTable
;

4520 
ynVar
 
iColumn
;

4522 
i16
 
iAgg
;

4523 
i16
 
iRightJoinTable
;

4524 
u8
 
op2
;

4527 
AggInfo
 *
pAggInfo
;

4528 
Table
 *
pTab
;

4531 struct 
	sExprList
 {

4532 int 
nExpr
;

4533 struct 
	sExprList_item
 {

4534 
Expr
 *
pExpr
;

4535 char *
zName
;

4536 char *
zSpan
;

4537 
u8
 
sortOrder
;

4538 unsigned 
done
 :1;

4539 unsigned 
bSpanIsTab
 :1;

4540 unsigned 
reusable
 :1;

4543 
u16
 
iOrderByCol
;

4544 
u16
 
iAlias
;

4545 } 
x
;

4546 int 
iConstExprReg
;

4547 } 
u
;

4548 } *
a
;

4556 struct 
	sExprSpan
 {

4557 
Expr
 *
pExpr
;

4558 const char *
zStart
;

4559 const char *
zEnd
;

4562 struct 
	sIdList
 {

4563 struct 
	sIdList_item
 {

4564 char *
zName
;

4565 int 
idx
;

4566 } *
a
;

4567 int 
nId
;

4570 typedef 
u64
 
	tBitmask
;

4572 struct 
	sSrcList
 {

4573 int 
nSrc
;

4574 
u32
 
nAlloc
;

4575 struct 
	sSrcList_item
 {

4576 
Schema
 *
pSchema
;

4577 char *
zDatabase
;

4578 char *
zName
;

4579 char *
zAlias
;

4580 
Table
 *
pTab
;

4581 
Select
 *
pSelect
;

4582 int 
addrFillSub
;

4583 int 
regReturn
;

4584 int 
regResult
;

4586 
u8
 
jointype
;

4587 unsigned 
notIndexed
 :1;

4588 unsigned 
isIndexedBy
 :1;

4589 unsigned 
isTabFunc
 :1;

4590 unsigned 
isCorrelated
 :1;

4591 unsigned 
viaCoroutine
 :1;

4592 unsigned 
isRecursive
 :1;

4593 } 
fg
;

4595 
u8
 
iSelectId
;

4597 int 
iCursor
;

4598 
Expr
 *
pOn
;

4599 
IdList
 *
pUsing
;

4600 
Bitmask
 
colUsed
;

4602 char *
zIndexedBy
;

4603 
ExprList
 *
pFuncArg
;

4604 } 
u1
;

4605 
Index
 *
pIBIndex
;

4606 } 
a
[1];

4609 struct 
	sNameContext
 {

4610 
Parse
 *
pParse
;

4611 
SrcList
 *
pSrcList
;

4612 
ExprList
 *
pEList
;

4613 
AggInfo
 *
pAggInfo
;

4614 
NameContext
 *
pNext
;

4615 int 
nRef
;

4616 int 
nErr
;

4617 
u16
 
ncFlags
;

4620 struct 
	sSelect
 {

4621 
ExprList
 *
pEList
;

4622 
u8
 
op
;

4623 
LogEst
 
nSelectRow
;

4624 
u32
 
selFlags
;

4625 int 
iLimit
, 
iOffset
;

4629 int 
addrOpenEphm
[2];

4630 
SrcList
 *
pSrc
;

4631 
Expr
 *
pWhere
;

4632 
ExprList
 *
pGroupBy
;

4633 
Expr
 *
pHaving
;

4634 
ExprList
 *
pOrderBy
;

4635 
Select
 *
pPrior
;

4636 
Select
 *
pNext
;

4637 
Expr
 *
pLimit
;

4638 
Expr
 *
pOffset
;

4639 
With
 *
pWith
;

4642 struct 
	sSelectDest
 {

4643 
u8
 
eDest
;

4644 char 
affSdst
;

4645 int 
iSDParm
;

4646 int 
iSdst
;

4647 int 
nSdst
;

4648 
ExprList
 *
pOrderBy
;

4651 struct 
	sAutoincInfo
 {

4652 
AutoincInfo
 *
pNext
;

4653 
Table
 *
pTab
;

4654 int 
iDb
;

4655 int 
regCtr
;

4658 struct 
	sTriggerPrg
 {

4659 
Trigger
 *
pTrigger
;

4660 
TriggerPrg
 *
pNext
;

4661 
SubProgram
 *
pProgram
;

4662 int 
orconf
;

4663 
u32
 
aColmask
[2];

4666 typedef unsigned int 
	tyDbMask
;

4668 struct 
	sParse
 {

4669 
sqlite3
 *
db
;

4670 char *
zErrMsg
;

4671 
Vdbe
 *
pVdbe
;

4672 int 
rc
;

4673 
u8
 
colNamesSet
;

4674 
u8
 
checkSchema
;

4675 
u8
 
nested
;

4676 
u8
 
nTempReg
;

4677 
u8
 
isMultiWrite
;

4678 
u8
 
mayAbort
;

4679 
u8
 
hasCompound
;

4680 
u8
 
okConstFactor
;

4681 
u8
 
disableLookaside
;

4682 int 
aTempReg
[8];

4683 int 
nRangeReg
;

4684 int 
iRangeReg
;

4685 int 
nErr
;

4686 int 
nTab
;

4687 int 
nMem
;

4688 int 
nSet
;

4689 int 
nOnce
;

4690 int 
nOpAlloc
;

4691 int 
szOpAlloc
;

4692 int 
iFixedOp
;

4693 int 
ckBase
;

4694 int 
iSelfTab
;

4695 int 
iCacheLevel
;

4696 int 
iCacheCnt
;

4697 int 
nLabel
;

4698 int *
aLabel
;

4699 struct 
	syColCache
 {

4700 int 
iTable
;

4701 
i16
 
iColumn
;

4702 
u8
 
tempReg
;

4703 int 
iLevel
;

4704 int 
iReg
;

4705 int 
lru
;

4706 } 
aColCache
[10];

4707 
ExprList
 *
pConstExpr
;

4708 
Token
 
constraintName
;

4709 
yDbMask
 
writeMask
;

4710 
yDbMask
 
cookieMask
;

4711 int 
cookieValue
[10 +2];

4712 int 
regRowid
;

4713 int 
regRoot
;

4714 int 
nMaxArg
;

4720 int 
nTableLock
;

4721 
TableLock
 *
aTableLock
;

4723 
AutoincInfo
 *
pAinc
;

4726 
Parse
 *
pToplevel
;

4727 
Table
 *
pTriggerTab
;

4728 int 
addrCrTab
;

4729 
u32
 
nQueryLoop
;

4730 
u32
 
oldmask
;

4731 
u32
 
newmask
;

4732 
u8
 
eTriggerOp
;

4733 
u8
 
eOrconf
;

4734 
u8
 
disableTriggers
;

4736 
ynVar
 
nVar
;

4737 int 
nzVar
;

4738 
u8
 
iPkSortOrder
;

4739 
u8
 
explain
;

4741 
u8
 
declareVtab
;

4742 int 
nVtabLock
;

4744 int 
nAlias
;

4745 int 
nHeight
;

4747 int 
iSelectId
;

4748 int 
iNextSelectId
;

4750 char **
azVar
;

4751 
Vdbe
 *
pReprepare
;

4752 const char *
zTail
;

4753 
Table
 *
pNewTable
;

4754 
Trigger
 *
pNewTrigger
;

4755 const char *
zAuthContext
;

4756 
Token
 
sNameToken
;

4757 
Token
 
sLastToken
;

4759 
Token
 
sArg
;

4760 
Table
 **
apVtabLock
;

4762 
Table
 *
pZombieTab
;

4763 
TriggerPrg
 *
pTriggerPrg
;

4764 
With
 *
pWith
;

4765 
With
 *
pWithToFree
;

4768 struct 
	sAuthContext
 {

4769 const char *
zAuthContext
;

4770 
Parse
 *
pParse
;

4773 struct 
	sTrigger
 {

4774 char *
zName
;

4775 char *
table
;

4776 
u8
 
op
;

4777 
u8
 
tr_tm
;

4778 
Expr
 *
pWhen
;

4779 
IdList
 *
pColumns
;

4781 
Schema
 *
pSchema
;

4782 
Schema
 *
pTabSchema
;

4783 
TriggerStep
 *
step_list
;

4784 
Trigger
 *
pNext
;

4787 struct 
	sTriggerStep
 {

4788 
u8
 
op
;

4789 
u8
 
orconf
;

4790 
Trigger
 *
pTrig
;

4791 
Select
 *
pSelect
;

4792 char *
zTarget
;

4793 
Expr
 *
pWhere
;

4794 
ExprList
 *
pExprList
;

4795 
IdList
 *
pIdList
;

4796 
TriggerStep
 *
pNext
;

4797 
TriggerStep
 *
pLast
;

4805 typedef struct 
DbFixer
 
	tDbFixer
;

4806 struct 
	sDbFixer
 {

4807 
Parse
 *
pParse
;

4808 
Schema
 *
pSchema
;

4809 int 
bVarOnly
;

4810 const char *
zDb
;

4811 const char *
zType
;

4812 const 
Token
 *
pName
;

4819 struct 
	sStrAccum
 {

4820 
sqlite3
 *
db
;

4821 char *
zBase
;

4822 char *
zText
;

4823 
u32
 
nChar
;

4824 
u32
 
nAlloc
;

4825 
u32
 
mxAlloc
;

4826 
u8
 
accError
;

4827 
u8
 
printfFlags
;

4831 
sqlite3
 *
db
;

4832 char **
pzErrMsg
;

4833 int 
iDb
;

4834 int 
rc
;

4835 } 
	tInitData
;

4842 struct 
	sSqlite3Config
 {

4843 int 
bMemstat
;

4844 int 
bCoreMutex
;

4845 int 
bFullMutex
;

4846 int 
bOpenUri
;

4847 int 
bUseCis
;

4848 int 
mxStrlen
;

4849 int 
neverCorrupt
;

4850 int 
szLookaside
;

4851 int 
nLookaside
;

4852 int 
nStmtSpill
;

4853 
sqlite3_mem_methods
 
m
;

4854 
sqlite3_mutex_methods
 
mutex
;

4855 
sqlite3_pcache_methods2
 
pcache2
;

4856 void *
pHeap
;

4857 int 
nHeap
;

4858 int 
mnReq
, 
mxReq
;

4859 
sqlite3_int64
 
szMmap
;

4860 
sqlite3_int64
 
mxMmap
;

4861 void *
pScratch
;

4862 int 
szScratch
;

4863 int 
nScratch
;

4864 void *
pPage
;

4865 int 
szPage
;

4866 int 
nPage
;

4867 int 
mxParserStack
;

4868 int 
sharedCacheEnabled
;

4869 
u32
 
szPma
;

4872 int 
isInit
;

4873 int 
inProgress
;

4874 int 
isMutexInit
;

4875 int 
isMallocInit
;

4876 int 
isPCacheInit
;

4877 int 
nRefInitMutex
;

4878 
sqlite3_mutex
 *
pInitMutex
;

4879 void (*
xLog
)(void*,int,const char*);

4880 void *
pLogArg
;

4882 int (*
xTestCallback
)(int);

4884 int 
bLocaltimeFault
;

4887 struct 
	sWalker
 {

4888 
Parse
 *
pParse
;

4889 int (*
xExprCallback
)(
Walker
*, 
Expr
*);

4890 int (*
xSelectCallback
)(
Walker
*,
Select
*);

4891 void (*
xSelectCallback2
)(
Walker
*,
Select
*);

4892 int 
walkerDepth
;

4893 
u8
 
eCode
;

4895 
NameContext
 *
pNC
;

4896 int 
n
;

4897 int 
iCur
;

4898 
SrcList
 *
pSrcList
;

4899 struct 
SrcCount
 *
pSrcCount
;

4900 struct 
CCurHint
 *
pCCurHint
;

4901 int *
aiCol
;

4902 } 
u
;

4906 static int 
	`sqlite3WalkExpr
(
Walker
*, 
Expr
*);

4907 static int 
	`sqlite3WalkExprList
(
Walker
*, 
ExprList
*);

4908 static int 
	`sqlite3WalkSelect
(
Walker
*, 
Select
*);

4909 static int 
	`sqlite3WalkSelectExpr
(
Walker
*, 
Select
*);

4910 static int 
	`sqlite3WalkSelectFrom
(
Walker
*, 
Select
*);

4911 static int 
	`sqlite3ExprWalkNoop
(
Walker
*, 
Expr
*);

4913 struct 
	sWith
 {

4914 int 
nCte
;

4915 
With
 *
pOuter
;

4916 struct 
	sCte
 {

4917 char *
zName
;

4918 
ExprList
 *
pCols
;

4919 
Select
 *
pSelect
;

4920 const char *
zCteErr
;

4921 } 
a
[1];

4924 static int 
	`sqlite3CorruptError
(int);

4925 static int 
	`sqlite3MisuseError
(int);

4926 static int 
	`sqlite3CantopenError
(int);

4928 static int 
	`sqlite3IsIdChar
(
u8
);

4934 static int 
	`sqlite3StrICmp
(const char*,const char*);

4935 static int 
	`sqlite3Strlen30
(const char*);

4936 static char *
	`sqlite3ColumnType
(
Column
*,char*);

4939 static int 
	`sqlite3MallocInit
(void);

4940 static void 
	`sqlite3MallocEnd
(void);

4941 static void *
	`sqlite3Malloc
(
u64
);

4942 static void *
	`sqlite3MallocZero
(
u64
);

4943 static void *
	`sqlite3DbMallocZero
(
sqlite3
*, 
u64
);

4944 static void *
	`sqlite3DbMallocRaw
(
sqlite3
*, 
u64
);

4945 static void *
	`sqlite3DbMallocRawNN
(
sqlite3
*, 
u64
);

4946 static char *
	`sqlite3DbStrDup
(
sqlite3
*,const char*);

4947 static char *
	`sqlite3DbStrNDup
(
sqlite3
*,const char*, 
u64
);

4948 static void *
	`sqlite3Realloc
(void*, 
u64
);

4949 static void *
	`sqlite3DbReallocOrFree
(
sqlite3
 *, void *, 
u64
);

4950 static void *
	`sqlite3DbRealloc
(
sqlite3
 *, void *, 
u64
);

4951 static void 
	`sqlite3DbFree
(
sqlite3
*, void*);

4952 static int 
	`sqlite3MallocSize
(void*);

4953 static int 
	`sqlite3DbMallocSize
(
sqlite3
*, void*);

4954 static void *
	`sqlite3ScratchMalloc
(int);

4955 static void 
	`sqlite3ScratchFree
(void*);

4956 static void *
	`sqlite3PageMalloc
(int);

4957 static void 
	`sqlite3PageFree
(void*);

4958 static void 
	`sqlite3MemSetDefault
(void);

4960 static void 
	`sqlite3BenignMallocHooks
(void (*)(void), void (*)(void));

4962 static int 
	`sqlite3HeapNearlyFull
(void);

4964 static 
sqlite3_mutex_methods
 const *
	`sqlite3DefaultMutex
(void);

4965 static 
sqlite3_mutex_methods
 const *
	`sqlite3NoopMutex
(void);

4966 static 
sqlite3_mutex
 *
	`sqlite3MutexAlloc
(int);

4967 static int 
	`sqlite3MutexInit
(void);

4968 static int 
	`sqlite3MutexEnd
(void);

4971 static void 
	`sqlite3MemoryBarrier
(void);

4976 static 
sqlite3_int64
 
	`sqlite3StatusValue
(int);

4977 static void 
	`sqlite3StatusUp
(int, int);

4978 static void 
	`sqlite3StatusDown
(int, int);

4979 static void 
	`sqlite3StatusHighwater
(int, int);

4982 static 
sqlite3_mutex
 *
	`sqlite3Pcache1Mutex
(void);

4983 static 
sqlite3_mutex
 *
	`sqlite3MallocMutex
(void);

4986 static int 
	`sqlite3IsNaN
(double);

4988 struct 
	sPrintfArguments
 {

4989 int 
nArg
;

4990 int 
nUsed
;

4991 
sqlite3_value
 **
apArg
;

4994 static void 
	`sqlite3VXPrintf
(
StrAccum
*, const char*, 
va_list
);

4995 static void 
	`sqlite3XPrintf
(
StrAccum
*, const char*, ...);

4996 static char *
	`sqlite3MPrintf
(
sqlite3
*,const char*, ...);

4997 static char *
	`sqlite3VMPrintf
(
sqlite3
*,const char*, 
va_list
);

4999 static void 
	`sqlite3SetString
(char **, 
sqlite3
*, const char*);

5000 static void 
	`sqlite3ErrorMsg
(
Parse
*, const char*, ...);

5001 static int 
	`sqlite3Dequote
(char*);

5002 static void 
	`sqlite3TokenInit
(
Token
*,char*);

5003 static int 
	`sqlite3KeywordCode
(const unsigned char*, int);

5004 static int 
	`sqlite3RunParser
(
Parse
*, const char*, char **);

5005 static void 
	`sqlite3FinishCoding
(
Parse
*);

5006 static int 
	`sqlite3GetTempReg
(
Parse
*);

5007 static void 
	`sqlite3ReleaseTempReg
(
Parse
*,int);

5008 static int 
	`sqlite3GetTempRange
(
Parse
*,int);

5009 static void 
	`sqlite3ReleaseTempRange
(
Parse
*,int,int);

5010 static void 
	`sqlite3ClearTempRegCache
(
Parse
*);

5014 static 
Expr
 *
	`sqlite3ExprAlloc
(
sqlite3
*,int,const 
Token
*,int);

5015 static 
Expr
 *
	`sqlite3Expr
(
sqlite3
*,int,const char*);

5016 static void 
	`sqlite3ExprAttachSubtrees
(
sqlite3
*,
Expr
*,Expr*,Expr*);

5017 static 
Expr
 *
	`sqlite3PExpr
(
Parse
*, int, Expr*, Expr*, const 
Token
*);

5018 static 
Expr
 *
	`sqlite3ExprAnd
(
sqlite3
*,Expr*, Expr*);

5019 static 
Expr
 *
	`sqlite3ExprFunction
(
Parse
*,
ExprList
*, 
Token
*);

5020 static void 
	`sqlite3ExprAssignVarNumber
(
Parse
*, 
Expr
*);

5021 static void 
	`sqlite3ExprDelete
(
sqlite3
*, 
Expr
*);

5022 static 
ExprList
 *
	`sqlite3ExprListAppend
(
Parse
*,ExprList*,
Expr
*);

5023 static void 
	`sqlite3ExprListSetSortOrder
(
ExprList
*,int);

5024 static void 
	`sqlite3ExprListSetName
(
Parse
*,
ExprList
*,
Token
*,int);

5025 static void 
	`sqlite3ExprListSetSpan
(
Parse
*,
ExprList
*,
ExprSpan
*);

5026 static void 
	`sqlite3ExprListDelete
(
sqlite3
*, 
ExprList
*);

5027 static 
u32
 
	`sqlite3ExprListFlags
(const 
ExprList
*);

5028 static int 
	`sqlite3Init
(
sqlite3
*, char**);

5029 static int 
	`sqlite3InitCallback
(void*, int, char**, char**);

5030 static void 
	`sqlite3Pragma
(
Parse
*,
Token
*,Token*,Token*,int);

5031 static void 
	`sqlite3ResetAllSchemasOfConnection
(
sqlite3
*);

5032 static void 
	`sqlite3ResetOneSchema
(
sqlite3
*,int);

5033 static void 
	`sqlite3CollapseDatabaseArray
(
sqlite3
*);

5034 static void 
	`sqlite3CommitInternalChanges
(
sqlite3
*);

5035 static void 
	`sqlite3DeleteColumnNames
(
sqlite3
*,
Table
*);

5036 static int 
	`sqlite3ColumnsFromExprList
(
Parse
*,
ExprList
*,
i16
*,
Column
**);

5037 static 
Table
 *
	`sqlite3ResultSetOfSelect
(
Parse
*,
Select
*);

5038 static void 
	`sqlite3OpenMasterTable
(
Parse
 *, int);

5039 static 
Index
 *
	`sqlite3PrimaryKeyIndex
(
Table
*);

5040 static 
i16
 
	`sqlite3ColumnOfIndex
(
Index
*, i16);

5041 static void 
	`sqlite3StartTable
(
Parse
*,
Token
*,Token*,int,int,int,int);

5047 static void 
	`sqlite3AddColumn
(
Parse
*,
Token
*,Token*);

5048 static void 
	`sqlite3AddNotNull
(
Parse
*, int);

5049 static void 
	`sqlite3AddPrimaryKey
(
Parse
*, 
ExprList
*, int, int, int);

5050 static void 
	`sqlite3AddCheckConstraint
(
Parse
*, 
Expr
*);

5051 static void 
	`sqlite3AddDefaultValue
(
Parse
*,
ExprSpan
*);

5052 static void 
	`sqlite3AddCollateType
(
Parse
*, 
Token
*);

5053 static void 
	`sqlite3EndTable
(
Parse
*,
Token
*,Token*,
u8
,
Select
*);

5054 static int 
	`sqlite3ParseUri
(const char*,const char*,unsigned int*,

5055 
sqlite3_vfs
**,char**,char **);

5056 static 
Btree
 *
	`sqlite3DbNameToBtree
(
sqlite3
*,const char*);

5057 static int 
	`sqlite3CodeOnce
(
Parse
 *);

5062 static int 
	`sqlite3FaultSim
(int);

5065 static 
Bitvec
 *
	`sqlite3BitvecCreate
(
u32
);

5066 static int 
	`sqlite3BitvecTest
(
Bitvec
*, 
u32
);

5067 static int 
	`sqlite3BitvecTestNotNull
(
Bitvec
*, 
u32
);

5068 static int 
	`sqlite3BitvecSet
(
Bitvec
*, 
u32
);

5069 static void 
	`sqlite3BitvecClear
(
Bitvec
*, 
u32
, void*);

5070 static void 
	`sqlite3BitvecDestroy
(
Bitvec
*);

5071 static 
u32
 
	`sqlite3BitvecSize
(
Bitvec
*);

5073 static int 
	`sqlite3BitvecBuiltinTest
(int,int*);

5076 static 
RowSet
 *
	`sqlite3RowSetInit
(
sqlite3
*, void*, unsigned int);

5077 static void 
	`sqlite3RowSetClear
(
RowSet
*);

5078 static void 
	`sqlite3RowSetInsert
(
RowSet
*, 
i64
);

5079 static int 
	`sqlite3RowSetTest
(
RowSet
*, int 
iBatch
, 
i64
);

5080 static int 
	`sqlite3RowSetNext
(
RowSet
*, 
i64
*);

5082 static void 
	`sqlite3CreateView
(
Parse
*,
Token
*,Token*,Token*,
ExprList
*,
Select
*,int,int);

5085 static int 
	`sqlite3ViewGetColumnNames
(
Parse
*,
Table
*);

5093 static void 
	`sqlite3DropTable
(
Parse
*, 
SrcList
*, int, int);

5094 static void 
	`sqlite3CodeDropTable
(
Parse
*, 
Table
*, int, int);

5095 static void 
	`sqlite3DeleteTable
(
sqlite3
*, 
Table
*);

5097 static void 
	`sqlite3AutoincrementBegin
(
Parse
 *
pParse
);

5098 static void 
	`sqlite3AutoincrementEnd
(
Parse
 *
pParse
);

5103 static void 
	`sqlite3Insert
(
Parse
*, 
SrcList
*, 
Select
*, 
IdList
*, int);

5104 static void *
	`sqlite3ArrayAllocate
(
sqlite3
*,void*,int,int*,int*);

5105 static 
IdList
 *
	`sqlite3IdListAppend
(
sqlite3
*, IdList*, 
Token
*);

5106 static int 
	`sqlite3IdListIndex
(
IdList
*,const char*);

5107 static 
SrcList
 *
	`sqlite3SrcListEnlarge
(
sqlite3
*, SrcList*, int, int);

5108 static 
SrcList
 *
	`sqlite3SrcListAppend
(
sqlite3
*, SrcList*, 
Token
*, Token*);

5109 static 
SrcList
 *
	`sqlite3SrcListAppendFromTerm
(
Parse
*, SrcList*, 
Token
*, Token*,

5110 
Token
*, 
Select
*, 
Expr
*, 
IdList
*);

5111 static void 
	`sqlite3SrcListIndexedBy
(
Parse
 *, 
SrcList
 *, 
Token
 *);

5112 static void 
	`sqlite3SrcListFuncArgs
(
Parse
*, 
SrcList
*, 
ExprList
*);

5113 static int 
	`sqlite3IndexedByLookup
(
Parse
 *, struct 
SrcList_item
 *);

5114 static void 
	`sqlite3SrcListShiftJoinType
(
SrcList
*);

5115 static void 
	`sqlite3SrcListAssignCursors
(
Parse
*, 
SrcList
*);

5116 static void 
	`sqlite3IdListDelete
(
sqlite3
*, 
IdList
*);

5117 static void 
	`sqlite3SrcListDelete
(
sqlite3
*, 
SrcList
*);

5118 static 
Index
 *
	`sqlite3AllocateIndexObject
(
sqlite3
*,
i16
,int,char**);

5119 static 
Index
 *
	`sqlite3CreateIndex
(
Parse
*,
Token
*,Token*,
SrcList
*,
ExprList
*,int,Token*,

5120 
Expr
*, int, int);

5121 static void 
	`sqlite3DropIndex
(
Parse
*, 
SrcList
*, int);

5122 static int 
	`sqlite3Select
(
Parse
*, 
Select
*, 
SelectDest
*);

5123 static 
Select
 *
	`sqlite3SelectNew
(
Parse
*,
ExprList
*,
SrcList
*,
Expr
*,ExprList*,

5124 
Expr
*,
ExprList
*,
u32
,Expr*,Expr*);

5125 static void 
	`sqlite3SelectDelete
(
sqlite3
*, 
Select
*);

5126 static 
Table
 *
	`sqlite3SrcListLookup
(
Parse
*, 
SrcList
*);

5127 static int 
	`sqlite3IsReadOnly
(
Parse
*, 
Table
*, int);

5128 static void 
	`sqlite3OpenTable
(
Parse
*, int 
iCur
, int 
iDb
, 
Table
*, int);

5132 static void 
	`sqlite3DeleteFrom
(
Parse
*, 
SrcList
*, 
Expr
*);

5133 static void 
	`sqlite3Update
(
Parse
*, 
SrcList
*, 
ExprList
*, 
Expr
*, int);

5134 static 
WhereInfo
 *
	`sqlite3WhereBegin
(
Parse
*,
SrcList
*,
Expr
*,
ExprList
*,ExprList*,
u16
,int);

5135 static void 
	`sqlite3WhereEnd
(
WhereInfo
*);

5136 static 
LogEst
 
	`sqlite3WhereOutputRowCount
(
WhereInfo
*);

5137 static int 
	`sqlite3WhereIsDistinct
(
WhereInfo
*);

5138 static int 
	`sqlite3WhereIsOrdered
(
WhereInfo
*);

5139 static int 
	`sqlite3WhereIsSorted
(
WhereInfo
*);

5140 static int 
	`sqlite3WhereContinueLabel
(
WhereInfo
*);

5141 static int 
	`sqlite3WhereBreakLabel
(
WhereInfo
*);

5142 static int 
	`sqlite3WhereOkOnePass
(
WhereInfo
*, int*);

5146 static void 
	`sqlite3ExprCodeLoadIndexColumn
(
Parse
*, 
Index
*, int, int, int);

5147 static int 
	`sqlite3ExprCodeGetColumn
(
Parse
*, 
Table
*, int, int, int, 
u8
);

5148 static void 
	`sqlite3ExprCodeGetColumnToReg
(
Parse
*, 
Table
*, int, int, int);

5149 static void 
	`sqlite3ExprCodeGetColumnOfTable
(
Vdbe
*, 
Table
*, int, int, int);

5150 static void 
	`sqlite3ExprCodeMove
(
Parse
*, int, int, int);

5151 static void 
	`sqlite3ExprCacheStore
(
Parse
*, int, int, int);

5152 static void 
	`sqlite3ExprCachePush
(
Parse
*);

5153 static void 
	`sqlite3ExprCachePop
(
Parse
*);

5154 static void 
	`sqlite3ExprCacheRemove
(
Parse
*, int, int);

5155 static void 
	`sqlite3ExprCacheClear
(
Parse
*);

5156 static void 
	`sqlite3ExprCacheAffinityChange
(
Parse
*, int, int);

5157 static void 
	`sqlite3ExprCode
(
Parse
*, 
Expr
*, int);

5158 static void 
	`sqlite3ExprCodeCopy
(
Parse
*, 
Expr
*, int);

5159 static void 
	`sqlite3ExprCodeFactorable
(
Parse
*, 
Expr
*, int);

5160 static void 
	`sqlite3ExprCodeAtInit
(
Parse
*, 
Expr
*, int, 
u8
);

5161 static int 
	`sqlite3ExprCodeTemp
(
Parse
*, 
Expr
*, int*);

5162 static int 
	`sqlite3ExprCodeTarget
(
Parse
*, 
Expr
*, int);

5163 static void 
	`sqlite3ExprCodeAndCache
(
Parse
*, 
Expr
*, int);

5164 static int 
	`sqlite3ExprCodeExprList
(
Parse
*, 
ExprList
*, int, int, 
u8
);

5168 static void 
	`sqlite3ExprIfTrue
(
Parse
*, 
Expr
*, int, int);

5169 static void 
	`sqlite3ExprIfFalse
(
Parse
*, 
Expr
*, int, int);

5170 static void 
	`sqlite3ExprIfFalseDup
(
Parse
*, 
Expr
*, int, int);

5171 static 
Table
 *
	`sqlite3FindTable
(
sqlite3
*,const char*, const char*);

5172 static 
Table
 *
	`sqlite3LocateTable
(
Parse
*,int 
isView
,const char*, const char*);

5173 static 
Table
 *
	`sqlite3LocateTableItem
(
Parse
*,int 
isView
,struct 
SrcList_item
 *);

5174 static 
Index
 *
	`sqlite3FindIndex
(
sqlite3
*,const char*, const char*);

5175 static void 
	`sqlite3UnlinkAndDeleteTable
(
sqlite3
*,int,const char*);

5176 static void 
	`sqlite3UnlinkAndDeleteIndex
(
sqlite3
*,int,const char*);

5177 static void 
	`sqlite3Vacuum
(
Parse
*);

5178 static int 
	`sqlite3RunVacuum
(char**, 
sqlite3
*);

5179 static char *
	`sqlite3NameFromToken
(
sqlite3
*, 
Token
*);

5180 static int 
	`sqlite3ExprCompare
(
Expr
*, Expr*, int);

5181 static int 
	`sqlite3ExprListCompare
(
ExprList
*, ExprList*, int);

5182 static int 
	`sqlite3ExprImpliesExpr
(
Expr
*, Expr*, int);

5183 static void 
	`sqlite3ExprAnalyzeAggregates
(
NameContext
*, 
Expr
*);

5184 static void 
	`sqlite3ExprAnalyzeAggList
(
NameContext
*,
ExprList
*);

5185 static int 
	`sqlite3FunctionUsesThisSrc
(
Expr
*, 
SrcList
*);

5186 static 
Vdbe
 *
	`sqlite3GetVdbe
(
Parse
*);

5188 static void 
	`sqlite3PrngSaveState
(void);

5189 static void 
	`sqlite3PrngRestoreState
(void);

5191 static void 
	`sqlite3RollbackAll
(
sqlite3
*,int);

5192 static void 
	`sqlite3CodeVerifySchema
(
Parse
*, int);

5193 static void 
	`sqlite3CodeVerifyNamedSchema
(
Parse
*, const char *
zDb
);

5194 static void 
	`sqlite3BeginTransaction
(
Parse
*, int);

5195 static void 
	`sqlite3CommitTransaction
(
Parse
*);

5196 static void 
	`sqlite3RollbackTransaction
(
Parse
*);

5197 static void 
	`sqlite3Savepoint
(
Parse
*, int, 
Token
*);

5198 static void 
	`sqlite3CloseSavepoints
(
sqlite3
 *);

5199 static void 
	`sqlite3LeaveMutexAndCloseZombie
(
sqlite3
*);

5200 static int 
	`sqlite3ExprIsConstant
(
Expr
*);

5201 static int 
	`sqlite3ExprIsConstantNotJoin
(
Expr
*);

5202 static int 
	`sqlite3ExprIsConstantOrFunction
(
Expr
*, 
u8
);

5203 static int 
	`sqlite3ExprIsTableConstant
(
Expr
*,int);

5207 static int 
	`sqlite3ExprIsInteger
(
Expr
*, int*);

5208 static int 
	`sqlite3ExprCanBeNull
(const 
Expr
*);

5209 static int 
	`sqlite3ExprNeedsNoAffinityChange
(const 
Expr
*, char);

5210 static int 
	`sqlite3IsRowid
(const char*);

5211 static void 
	`sqlite3GenerateRowDelete
(

5212 
Parse
*,
Table
*,
Trigger
*,int,int,int,
i16
,
u8
,u8,u8,int);

5213 static void 
	`sqlite3GenerateRowIndexDelete
(
Parse
*, 
Table
*, int, int, int*, int);

5214 static int 
	`sqlite3GenerateIndexKey
(
Parse
*, 
Index
*, int, int, int, int*,Index*,int);

5215 static void 
	`sqlite3ResolvePartIdxLabel
(
Parse
*,int);

5216 static void 
	`sqlite3GenerateConstraintChecks
(
Parse
*,
Table
*,int*,int,int,int,int,

5217 
u8
,u8,int,int*,int*);

5218 static void 
	`sqlite3CompleteInsertion
(
Parse
*,
Table
*,int,int,int,int*,int,int,int);

5219 static int 
	`sqlite3OpenTableAndIndices
(
Parse
*, 
Table
*, int, 
u8
, int, u8*, int*, int*);

5220 static void 
	`sqlite3BeginWriteOperation
(
Parse
*, int, int);

5221 static void 
	`sqlite3MultiWrite
(
Parse
*);

5222 static void 
	`sqlite3MayAbort
(
Parse
*);

5223 static void 
	`sqlite3HaltConstraint
(
Parse
*, int, int, char*, 
i8
, 
u8
);

5224 static void 
	`sqlite3UniqueConstraint
(
Parse
*, int, 
Index
*);

5225 static void 
	`sqlite3RowidConstraint
(
Parse
*, int, 
Table
*);

5226 static 
Expr
 *
	`sqlite3ExprDup
(
sqlite3
*,Expr*,int);

5227 static 
ExprList
 *
	`sqlite3ExprListDup
(
sqlite3
*,ExprList*,int);

5228 static 
SrcList
 *
	`sqlite3SrcListDup
(
sqlite3
*,SrcList*,int);

5229 static 
IdList
 *
	`sqlite3IdListDup
(
sqlite3
*,IdList*);

5230 static 
Select
 *
	`sqlite3SelectDup
(
sqlite3
*,Select*,int);

5236 static void 
	`sqlite3InsertBuiltinFuncs
(
FuncDef
*,int);

5237 static 
FuncDef
 *
	`sqlite3FindFunction
(
sqlite3
*,const char*,int,
u8
,u8);

5238 static void 
	`sqlite3RegisterBuiltinFunctions
(void);

5239 static void 
	`sqlite3RegisterDateTimeFunctions
(void);

5240 static void 
	`sqlite3RegisterPerConnectionBuiltinFunctions
(
sqlite3
*);

5241 static int 
	`sqlite3SafetyCheckOk
(
sqlite3
*);

5242 static int 
	`sqlite3SafetyCheckSickOrOk
(
sqlite3
*);

5243 static void 
	`sqlite3ChangeCookie
(
Parse
*, int);

5246 static void 
	`sqlite3MaterializeView
(
Parse
*, 
Table
*, 
Expr
*, int);

5250 static void 
	`sqlite3BeginTrigger
(
Parse
*, 
Token
*,Token*,int,int,
IdList
*,
SrcList
*,

5251 
Expr
*,int, int);

5252 static void 
	`sqlite3FinishTrigger
(
Parse
*, 
TriggerStep
*, 
Token
*);

5253 static void 
	`sqlite3DropTrigger
(
Parse
*, 
SrcList
*, int);

5254 static void 
	`sqlite3DropTriggerPtr
(
Parse
*, 
Trigger
*);

5255 static 
Trigger
 *
	`sqlite3TriggersExist
(
Parse
 *, 
Table
*, int, 
ExprList
*, int *
pMask
);

5256 static 
Trigger
 *
	`sqlite3TriggerList
(
Parse
 *, 
Table
 *);

5257 static void 
	`sqlite3CodeRowTrigger
(
Parse
*, 
Trigger
 *, int, 
ExprList
*, int, 
Table
 *,

5259 static void 
	`sqlite3CodeRowTriggerDirect
(
Parse
 *, 
Trigger
 *, 
Table
 *, int, int, int);

5260 void 
	`sqliteViewTriggers
(
Parse
*, 
Table
*, 
Expr
*, int, 
ExprList
*);

5261 static void 
	`sqlite3DeleteTriggerStep
(
sqlite3
*, 
TriggerStep
*);

5262 static 
TriggerStep
 *
	`sqlite3TriggerSelectStep
(
sqlite3
*,
Select
*);

5263 static 
TriggerStep
 *
	`sqlite3TriggerInsertStep
(
sqlite3
*,
Token
*, 
IdList
*,

5264 
Select
*,
u8
);

5265 static 
TriggerStep
 *
	`sqlite3TriggerUpdateStep
(
sqlite3
*,
Token
*,
ExprList
*, 
Expr
*, 
u8
);

5266 static 
TriggerStep
 *
	`sqlite3TriggerDeleteStep
(
sqlite3
*,
Token
*, 
Expr
*);

5267 static void 
	`sqlite3DeleteTrigger
(
sqlite3
*, 
Trigger
*);

5268 static void 
	`sqlite3UnlinkAndDeleteTrigger
(
sqlite3
*,int,const char*);

5269 static 
u32
 
	`sqlite3TriggerColmask
(
Parse
*,
Trigger
*,
ExprList
*,int,int,
Table
*,int);

5271 static int 
	`sqlite3JoinType
(
Parse
*, 
Token
*, Token*, Token*);

5272 static void 
	`sqlite3CreateForeignKey
(
Parse
*, 
ExprList
*, 
Token
*, ExprList*, int);

5273 static void 
	`sqlite3DeferForeignKey
(
Parse
*, int);

5275 static void 
	`sqlite3AuthRead
(
Parse
*,
Expr
*,
Schema
*,
SrcList
*);

5276 static int 
	`sqlite3AuthCheck
(
Parse
*,int, const char*, const char*, const char*);

5277 static void 
	`sqlite3AuthContextPush
(
Parse
*, 
AuthContext
*, const char*);

5278 static void 
	`sqlite3AuthContextPop
(
AuthContext
*);

5279 static int 
	`sqlite3AuthReadCol
(
Parse
*, const char *, const char *, int);

5286 static void 
	`sqlite3Attach
(
Parse
*, 
Expr
*, Expr*, Expr*);

5287 static void 
	`sqlite3Detach
(
Parse
*, 
Expr
*);

5288 static void 
	`sqlite3FixInit
(
DbFixer
*, 
Parse
*, int, const char*, const 
Token
*);

5289 static int 
	`sqlite3FixSrcList
(
DbFixer
*, 
SrcList
*);

5290 static int 
	`sqlite3FixSelect
(
DbFixer
*, 
Select
*);

5291 static int 
	`sqlite3FixExpr
(
DbFixer
*, 
Expr
*);

5292 static int 
	`sqlite3FixExprList
(
DbFixer
*, 
ExprList
*);

5293 static int 
	`sqlite3FixTriggerStep
(
DbFixer
*, 
TriggerStep
*);

5294 static int 
	`sqlite3AtoF
(const char *
z
, double*, int, 
u8
);

5295 static int 
	`sqlite3GetInt32
(const char *, int*);

5296 static int 
	`sqlite3Atoi
(const char*);

5297 static int 
	`sqlite3Utf16ByteLen
(const void *
pData
, int 
nChar
);

5298 static int 
	`sqlite3Utf8CharLen
(const char *
pData
, int 
nByte
);

5299 static 
u32
 
	`sqlite3Utf8Read
(const 
u8
**);

5300 static 
LogEst
 
	`sqlite3LogEst
(
u64
);

5301 static 
LogEst
 
	`sqlite3LogEstAdd
(LogEst,LogEst);

5303 static 
LogEst
 
	`sqlite3LogEstFromDouble
(double);

5305 static int 
	`sqlite3PutVarint
(unsigned char*, 
u64
);

5306 static 
u8
 
	`sqlite3GetVarint
(const unsigned char *, 
u64
 *);

5307 static 
u8
 
	`sqlite3GetVarint32
(const unsigned char *, 
u32
 *);

5308 static int 
	`sqlite3VarintLen
(
u64
 
v
);

5310 static const char *
	`sqlite3IndexAffinityStr
(
sqlite3
*, 
Index
*);

5311 static void 
	`sqlite3TableAffinity
(
Vdbe
*, 
Table
*, int);

5312 static char 
	`sqlite3CompareAffinity
(
Expr
 *
pExpr
, char 
aff2
);

5313 static int 
	`sqlite3IndexAffinityOk
(
Expr
 *
pExpr
, char 
idx_affinity
);

5314 static char 
	`sqlite3ExprAffinity
(
Expr
 *
pExpr
);

5315 static int 
	`sqlite3Atoi64
(const char*, 
i64
*, int, 
u8
);

5316 static int 
	`sqlite3DecOrHexToI64
(const char*, 
i64
*);

5317 static void 
	`sqlite3ErrorWithMsg
(
sqlite3
*, int, const char*,...);

5318 static void 
	`sqlite3Error
(
sqlite3
*,int);

5319 static void 
	`sqlite3SystemError
(
sqlite3
*,int);

5320 static void *
	`sqlite3HexToBlob
(
sqlite3
*, const char *
z
, int 
n
);

5321 static 
u8
 
	`sqlite3HexToInt
(int 
h
);

5322 static int 
	`sqlite3TwoPartName
(
Parse
 *, 
Token
 *, Token *, Token **);

5328 static const char *
	`sqlite3ErrStr
(int);

5329 static int 
	`sqlite3ReadSchema
(
Parse
 *
pParse
);

5330 static 
CollSeq
 *
	`sqlite3FindCollSeq
(
sqlite3
*,
u8
 
enc
, const char*,int);

5331 static 
CollSeq
 *
	`sqlite3LocateCollSeq
(
Parse
 *
pParse
, const char*
zName
);

5332 static 
CollSeq
 *
	`sqlite3ExprCollSeq
(
Parse
 *
pParse
, 
Expr
 *
pExpr
);

5333 static 
Expr
 *
	`sqlite3ExprAddCollateToken
(
Parse
 *
pParse
, Expr*, const 
Token
*, int);

5334 static 
Expr
 *
	`sqlite3ExprAddCollateString
(
Parse
*,Expr*,const char*);

5335 static 
Expr
 *
	`sqlite3ExprSkipCollate
(Expr*);

5336 static int 
	`sqlite3CheckCollSeq
(
Parse
 *, 
CollSeq
 *);

5337 static int 
	`sqlite3CheckObjectName
(
Parse
 *, const char *);

5338 static void 
	`sqlite3VdbeSetChanges
(
sqlite3
 *, int);

5339 static int 
	`sqlite3AddInt64
(
i64
*,i64);

5340 static int 
	`sqlite3SubInt64
(
i64
*,i64);

5341 static int 
	`sqlite3MulInt64
(
i64
*,i64);

5342 static int 
	`sqlite3AbsInt32
(int);

5348 static 
u8
 
	`sqlite3GetBoolean
(const char *
z
,u8);

5350 static const void *
	`sqlite3ValueText
(
sqlite3_value
*, 
u8
);

5351 static int 
	`sqlite3ValueBytes
(
sqlite3_value
*, 
u8
);

5352 static void 
	`sqlite3ValueSetStr
(
sqlite3_value
*, int, const void *,
u8
,

5354 static void 
	`sqlite3ValueSetNull
(
sqlite3_value
*);

5355 static void 
	`sqlite3ValueFree
(
sqlite3_value
*);

5356 static 
sqlite3_value
 *
	`sqlite3ValueNew
(
sqlite3
 *);

5357 static char *
	`sqlite3Utf16to8
(
sqlite3
 *, const void*, int, 
u8
);

5358 static int 
	`sqlite3ValueFromExpr
(
sqlite3
 *, 
Expr
 *, 
u8
, u8, 
sqlite3_value
 **);

5359 static void 
	`sqlite3ValueApplyAffinity
(
sqlite3_value
 *, 
u8
, u8);

5361 static void 
	`sqlite3RootPageMoved
(
sqlite3
*, int, int, int);

5362 static void 
	`sqlite3Reindex
(
Parse
*, 
Token
*, Token*);

5363 static void 
	`sqlite3AlterFunctions
(void);

5364 static void 
	`sqlite3AlterRenameTable
(
Parse
*, 
SrcList
*, 
Token
*);

5365 static int 
	`sqlite3GetToken
(const unsigned char *, int *);

5366 static void 
	`sqlite3NestedParse
(
Parse
*, const char*, ...);

5367 static void 
	`sqlite3ExpirePreparedStatements
(
sqlite3
*);

5368 static int 
	`sqlite3CodeSubselect
(
Parse
 *, 
Expr
 *, int, int);

5369 static void 
	`sqlite3SelectPrep
(
Parse
*, 
Select
*, 
NameContext
*);

5370 static void 
	`sqlite3SelectWrongNumTermsError
(
Parse
 *
pParse
, 
Select
 *
p
);

5371 static int 
	`sqlite3MatchSpanName
(const char*, const char*, const char*, const char*);

5372 static int 
	`sqlite3ResolveExprNames
(
NameContext
*, 
Expr
*);

5373 static int 
	`sqlite3ResolveExprListNames
(
NameContext
*, 
ExprList
*);

5374 static void 
	`sqlite3ResolveSelectNames
(
Parse
*, 
Select
*, 
NameContext
*);

5375 static void 
	`sqlite3ResolveSelfReference
(
Parse
*,
Table
*,int,
Expr
*,
ExprList
*);

5376 static int 
	`sqlite3ResolveOrderGroupBy
(
Parse
*, 
Select
*, 
ExprList
*, const char*);

5377 static void 
	`sqlite3ColumnDefault
(
Vdbe
 *, 
Table
 *, int, int);

5378 static void 
	`sqlite3AlterFinishAddColumn
(
Parse
 *, 
Token
 *);

5379 static void 
	`sqlite3AlterBeginAddColumn
(
Parse
 *, 
SrcList
 *);

5380 static 
CollSeq
 *
	`sqlite3GetCollSeq
(
Parse
*, 
u8
, CollSeq *, const char*);

5381 static char 
	`sqlite3AffinityType
(const char*, 
u8
*);

5382 static void 
	`sqlite3Analyze
(
Parse
*, 
Token
*, Token*);

5383 static int 
	`sqlite3InvokeBusyHandler
(
BusyHandler
*);

5384 static int 
	`sqlite3FindDb
(
sqlite3
*, 
Token
*);

5385 static int 
	`sqlite3FindDbName
(
sqlite3
 *, const char *);

5386 static int 
	`sqlite3AnalysisLoad
(
sqlite3
*,int 
iDB
);

5387 static void 
	`sqlite3DeleteIndexSamples
(
sqlite3
*,
Index
*);

5388 static void 
	`sqlite3DefaultRowEst
(
Index
*);

5389 static void 
	`sqlite3RegisterLikeFunctions
(
sqlite3
*, int);

5390 static int 
	`sqlite3IsLikeFunction
(
sqlite3
*,
Expr
*,int*,char*);

5391 static void 
	`sqlite3SchemaClear
(void *);

5392 static 
Schema
 *
	`sqlite3SchemaGet
(
sqlite3
 *, 
Btree
 *);

5393 static int 
	`sqlite3SchemaToIndex
(
sqlite3
 *
db
, 
Schema
 *);

5394 static 
KeyInfo
 *
	`sqlite3KeyInfoAlloc
(
sqlite3
*,int,int);

5395 static void 
	`sqlite3KeyInfoUnref
(
KeyInfo
*);

5396 static 
KeyInfo
 *
	`sqlite3KeyInfoRef
(KeyInfo*);

5397 static 
KeyInfo
 *
	`sqlite3KeyInfoOfIndex
(
Parse
*, 
Index
*);

5401 static int 
	`sqlite3CreateFunc
(
sqlite3
 *, const char *, int, int, void *,

5402 void (*)(
sqlite3_context
*,int,
sqlite3_value
 **),

5403 void (*)(
sqlite3_context
*,int,
sqlite3_value
 **), void (*)(sqlite3_context*),

5404 
FuncDestructor
 *
pDestructor


5406 static void 
	`sqlite3OomFault
(
sqlite3
*);

5407 static void 
	`sqlite3OomClear
(
sqlite3
*);

5408 static int 
	`sqlite3ApiExit
(
sqlite3
 *
db
, int);

5409 static int 
	`sqlite3OpenTempDatabase
(
Parse
 *);

5411 static void 
	`sqlite3StrAccumInit
(
StrAccum
*, 
sqlite3
*, char*, int, int);

5412 static void 
	`sqlite3StrAccumAppend
(
StrAccum
*,const char*,int);

5413 static void 
	`sqlite3StrAccumAppendAll
(
StrAccum
*,const char*);

5414 static void 
	`sqlite3AppendChar
(
StrAccum
*,int,char);

5415 static char *
	`sqlite3StrAccumFinish
(
StrAccum
*);

5416 static void 
	`sqlite3StrAccumReset
(
StrAccum
*);

5417 static void 
	`sqlite3SelectDestInit
(
SelectDest
*,int,int);

5418 static 
Expr
 *
	`sqlite3CreateColumnExpr
(
sqlite3
 *, 
SrcList
 *, int, int);

5420 static void 
	`sqlite3BackupRestart
(
sqlite3_backup
 *);

5421 static void 
	`sqlite3BackupUpdate
(
sqlite3_backup
 *, 
Pgno
, const 
u8
 *);

5423 static void *
	`sqlite3ParserAlloc
(void*(*)(
u64
));

5424 static void 
	`sqlite3ParserFree
(void*, void(*)(void*));

5425 static void 
	`sqlite3Parser
(void*, int, 
Token
, 
Parse
*);

5430 static void 
	`sqlite3AutoLoadExtensions
(
sqlite3
*);

5432 static void 
	`sqlite3CloseExtensions
(
sqlite3
*);

5438 static void 
	`sqlite3TableLock
(
Parse
 *, int, int, 
u8
, const char *);

5440 static void 
	`sqlite3VtabClear
(
sqlite3
 *
db
, 
Table
*);

5441 static void 
	`sqlite3VtabDisconnect
(
sqlite3
 *
db
, 
Table
 *
p
);

5442 static int 
	`sqlite3VtabSync
(
sqlite3
 *
db
, 
Vdbe
*);

5443 static int 
	`sqlite3VtabRollback
(
sqlite3
 *
db
);

5444 static int 
	`sqlite3VtabCommit
(
sqlite3
 *
db
);

5445 static void 
	`sqlite3VtabLock
(
VTable
 *);

5446 static void 
	`sqlite3VtabUnlock
(
VTable
 *);

5447 static void 
	`sqlite3VtabUnlockList
(
sqlite3
*);

5448 static int 
	`sqlite3VtabSavepoint
(
sqlite3
 *, int, int);

5449 static void 
	`sqlite3VtabImportErrmsg
(
Vdbe
*, 
sqlite3_vtab
*);

5450 static 
VTable
 *
	`sqlite3GetVTable
(
sqlite3
*, 
Table
*);

5453 static int 
	`sqlite3VtabEponymousTableInit
(
Parse
*,
Module
*);

5454 static void 
	`sqlite3VtabEponymousTableClear
(
sqlite3
*,
Module
*);

5455 static void 
	`sqlite3VtabMakeWritable
(
Parse
*,
Table
*);

5456 static void 
	`sqlite3VtabBeginParse
(
Parse
*, 
Token
*, Token*, Token*, int);

5457 static void 
	`sqlite3VtabFinishParse
(
Parse
*, 
Token
*);

5458 static void 
	`sqlite3VtabArgInit
(
Parse
*);

5459 static void 
	`sqlite3VtabArgExtend
(
Parse
*, 
Token
*);

5460 static int 
	`sqlite3VtabCallCreate
(
sqlite3
*, int, const char *, char **);

5461 static int 
	`sqlite3VtabCallConnect
(
Parse
*, 
Table
*);

5462 static int 
	`sqlite3VtabCallDestroy
(
sqlite3
*, int, const char *);

5463 static int 
	`sqlite3VtabBegin
(
sqlite3
 *, 
VTable
 *);

5464 static 
FuncDef
 *
	`sqlite3VtabOverloadFunction
(
sqlite3
 *,FuncDef*, int 
nArg
, 
Expr
*);

5465 static void 
	`sqlite3InvalidFunction
(
sqlite3_context
*,int,
sqlite3_value
**);

5466 static 
sqlite3_int64
 
	`sqlite3StmtCurrentTime
(
sqlite3_context
*);

5467 static int 
	`sqlite3VdbeParameterIndex
(
Vdbe
*, const char*, int);

5468 static int 
	`sqlite3TransferBindings
(
sqlite3_stmt
 *, sqlite3_stmt *);

5469 static void 
	`sqlite3ParserReset
(
Parse
*);

5470 static int 
	`sqlite3Reprepare
(
Vdbe
*);

5471 static void 
	`sqlite3ExprListCheckLength
(
Parse
*, 
ExprList
*, const char*);

5472 static 
CollSeq
 *
	`sqlite3BinaryCompareCollSeq
(
Parse
 *, 
Expr
 *, Expr *);

5473 static int 
	`sqlite3TempInMemory
(const 
sqlite3
*);

5474 static const char *
	`sqlite3JournalModename
(int);

5476 static int 
	`sqlite3Checkpoint
(
sqlite3
*, int, int, int*, int*);

5477 static int 
	`sqlite3WalDefaultHook
(void*,
sqlite3
*,const char*,int);

5480 static 
With
 *
	`sqlite3WithAdd
(
Parse
*,With*,
Token
*,
ExprList
*,
Select
*);

5481 static void 
	`sqlite3WithDelete
(
sqlite3
*,
With
*);

5482 static void 
	`sqlite3WithPush
(
Parse
*, 
With
*, 
u8
);

5484 static void 
	`sqlite3FkCheck
(
Parse
*, 
Table
*, int, int, int*, int);

5485 static void 
	`sqlite3FkDropTable
(
Parse
*, 
SrcList
 *, 
Table
*);

5486 static void 
	`sqlite3FkActions
(
Parse
*, 
Table
*, 
ExprList
*, int, int*, int);

5487 static int 
	`sqlite3FkRequired
(
Parse
*, 
Table
*, int*, int);

5488 static 
u32
 
	`sqlite3FkOldmask
(
Parse
*, 
Table
*);

5489 static 
FKey
 *
	`sqlite3FkReferences
(
Table
 *);

5491 static void 
	`sqlite3FkDelete
(
sqlite3
 *, 
Table
*);

5492 static int 
	`sqlite3FkLocateIndex
(
Parse
*,
Table
*,
FKey
*,
Index
**,int**);

5494 static void 
	`sqlite3BeginBenignMalloc
(void);

5495 static void 
	`sqlite3EndBenignMalloc
(void);

5497 static int 
	`sqlite3FindInIndex
(
Parse
 *, 
Expr
 *, 
u32
, int*);

5499 static int 
	`sqlite3JournalOpen
(
sqlite3_vfs
 *, const char *, 
sqlite3_file
 *, int, int);

5500 static int 
	`sqlite3JournalSize
(
sqlite3_vfs
 *);

5505 static int 
	`sqlite3JournalIsInMemory
(
sqlite3_file
 *
p
);

5506 static void 
	`sqlite3MemJournalOpen
(
sqlite3_file
 *);

5508 static void 
	`sqlite3ExprSetHeightAndFlags
(
Parse
 *
pParse
, 
Expr
 *
p
);

5510 static int 
	`sqlite3SelectExprHeight
(
Select
 *);

5511 static int 
	`sqlite3ExprCheckHeight
(
Parse
*, int);

5517 static 
u32
 
	`sqlite3Get4byte
(const 
u8
*);

5518 static void 
	`sqlite3Put4byte
(
u8
*, 
u32
);

5520 static int 
	`sqlite3ThreadCreate
(
SQLiteThread
**,void*(*)(void*),void*);

5521 static int 
	`sqlite3ThreadJoin
(
SQLiteThread
*, void**);

5523 static const unsigned char 
sqlite3UpperToLower
[] = {

5541 
	}
};

5543 static const unsigned char 
	gsqlite3CtypeMap
[256] = {

5581 static struct 
Sqlite3Config
 
	gsqlite3Config
 = {

5630 static 
FuncDefHash
 
	gsqlite3BuiltinFunctions
;

5635 static const 
Token
 
	gsqlite3IntTokens
[] = {

5640 static int 
	gsqlite3PendingByte
 = 0x40000000;

5642 static const unsigned char 
	gsqlite3OpcodeProperty
[] = { 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x03, 0x12, 0x08, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x02, 0x02, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x26, 0x26, 0x10, 0x10, 0x00, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x00, 0x00, 0x10, 0x01, 0x01, 0x01, 0x01, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x23, 0x0b, 0x01, 0x10, 0x10, 0x00, 0x01, 0x04, 0x03, 0x1a, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x10, 0x10, 0x01, 0x00, 0x00, 0x00,};

5647 static const char 
	gsqlite3StrBINARY
[] = "BINARY";

5649 static const char * const 
	gazCompileOpt
[] = {

5657 int 
	$sqlite3_compileoption_used
(const char *
zOptName
)

5660 int 
i
, 
n
;

5668 if( 
	`sqlite3_strnicmp
(
zOptName
, "SQLITE_", 7)==0 ) zOptName += 7;

5669 
n
 = 
	`sqlite3Strlen30
(
zOptName
);

5673 for(
i
=0; i<((int)(sizeof(
azCompileOpt
)/sizeof(azCompileOpt[0]))); i++)

5676 if( 
	`sqlite3_strnicmp
(
zOptName
, 
azCompileOpt
[
i
], 
n
)==0

5677 && 
	`sqlite3IsIdChar
((unsigned char)
azCompileOpt
[
i
][
n
])==0

5685 
	}
}

5691 const char * 
	$sqlite3_compileoption_get
(int 
N
)

5694 if( 
N
>=0 && N<((int)(sizeof(
azCompileOpt
)/sizeof(azCompileOpt[0]))) )

5697 return 
azCompileOpt
[
N
];

5700 
	}
}

5702 typedef struct 
VdbeOp
 
	tOp
;

5707 typedef unsigned 
	tBool
;

5710 typedef struct 
VdbeSorter
 
	tVdbeSorter
;

5713 typedef struct 
Explain
 
	tExplain
;

5716 typedef struct 
AuxData
 
	tAuxData
;

5718 typedef struct 
VdbeCursor
 
	tVdbeCursor
;

5719 struct 
	sVdbeCursor
 {

5720 
u8
 
	meCurType
;

5721 
i8
 
	miDb
;

5722 
u8
 
	mnullRow
;

5723 
u8
 
	mdeferredMoveto
;

5724 
u8
 
	misTable
;

5729 
Bool
 
	misEphemeral
:1;

5730 
Bool
 
	museRandomRowid
:1;

5731 
Bool
 
	misOrdered
:1;

5732 
Pgno
 
	mpgnoRoot
;

5733 
i16
 
	mnField
;

5734 
u16
 
	mnHdrParsed
;

5736 
BtCursor
 *
	mpCursor
;

5737 
sqlite3_vtab_cursor
 *
	mpVCur
;

5738 int 
	mpseudoTableReg
;

5739 
VdbeSorter
 *
	mpSorter
;

5740 } 
	muc
;

5741 
Btree
 *
	mpBt
;

5742 
KeyInfo
 *
	mpKeyInfo
;

5743 int 
	mseekResult
;

5744 
i64
 
	mseqCount
;

5745 
i64
 
	mmovetoTarget
;

5746 
VdbeCursor
 *
	mpAltCursor
;

5747 int *
	maAltMap
;

5749 
u32
 
	mcacheStatus
;

5750 
u32
 
	mpayloadSize
;

5751 
u32
 
	mszRow
;

5752 
u32
 
	miHdrOffset
;

5753 const 
u8
 *
	maRow
;

5754 
u32
 *
	maOffset
;

5755 
u32
 
	maType
[1];

5761 typedef struct 
VdbeFrame
 
	tVdbeFrame
;

5762 struct 
	sVdbeFrame
 {

5763 
Vdbe
 *
	mv
;

5764 
VdbeFrame
 *
	mpParent
;

5765 
Op
 *
	maOp
;

5766 
i64
 *
	manExec
;

5767 
Mem
 *
	maMem
;

5768 
u8
 *
	maOnceFlag
;

5769 
VdbeCursor
 **
	mapCsr
;

5770 void *
	mtoken
;

5771 
i64
 
	mlastRowid
;

5772 
AuxData
 *
	mpAuxData
;

5773 int 
	mnCursor
;

5774 int 
	mpc
;

5775 int 
	mnOp
;

5776 int 
	mnMem
;

5777 int 
	mnOnceFlag
;

5778 int 
	mnChildMem
;

5779 int 
	mnChildCsr
;

5780 int 
	mnChange
;

5781 int 
	mnDbChange
;

5784 struct 
	sMem
 {

5785 union 
	uMemValue
 {

5786 double 
	mr
;

5787 
i64
 
	mi
;

5788 int 
	mnZero
;

5789 
FuncDef
 *
	mpDef
;

5790 
RowSet
 *
	mpRowSet
;

5791 
VdbeFrame
 *
	mpFrame
;

5792 } 
	mu
;

5793 
u16
 
	mflags
;

5794 
u8
 
	menc
;

5795 
u8
 
	meSubtype
;

5796 int 
	mn
;

5797 char *
	mz
;

5799 char *
	mzMalloc
;

5800 int 
	mszMalloc
;

5801 
u32
 
	muTemp
;

5802 
sqlite3
 *
	mdb
;

5803 void (*
	mxDel
)(void*);

5810 struct 
	sAuxData
 {

5811 int 
	miOp
;

5812 int 
	miArg
;

5813 void *
	mpAux
;

5814 void (*
	mxDelete
)(void *);

5815 
AuxData
 *
	mpNext
;

5818 struct 
	ssqlite3_context
 {

5819 
Mem
 *
	mpOut
;

5820 
FuncDef
 *
	mpFunc
;

5821 
Mem
 *
	mpMem
;

5822 
Vdbe
 *
	mpVdbe
;

5823 int 
	miOp
;

5824 int 
	misError
;

5825 
u8
 
	mskipFlag
;

5826 
u8
 
	mfErrorOrAux
;

5827 
u8
 
	margc
;

5828 
sqlite3_value
 *
	margv
[1];

5835 struct 
	sExplain
 {

5836 
Vdbe
 *
	mpVdbe
;

5837 
StrAccum
 
	mstr
;

5838 int 
	mnIndent
;

5839 
u16
 
	maIndent
[100];

5840 char 
	mzBase
[100];

5846 typedef unsigned 
	tbft
;

5848 typedef struct 
ScanStatus
 
	tScanStatus
;

5849 struct 
	sScanStatus
 {

5850 int 
	maddrExplain
;

5851 int 
	maddrLoop
;

5852 int 
	maddrVisit
;

5853 int 
	miSelectID
;

5854 
LogEst
 
	mnEst
;

5855 char *
	mzName
;

5858 struct 
	sVdbe
 {

5859 
sqlite3
 *
	mdb
;

5860 
Op
 *
	maOp
;

5861 
Mem
 *
	maMem
;

5862 
Mem
 **
	mapArg
;

5863 
Mem
 *
	maColName
;

5864 
Mem
 *
	mpResultSet
;

5865 
Parse
 *
	mpParse
;

5866 int 
	mnMem
;

5867 int 
	mnOp
;

5868 int 
	mnCursor
;

5869 
u32
 
	mmagic
;

5870 char *
	mzErrMsg
;

5871 
Vdbe
 *
	mpPrev
,*
	mpNext
;

5872 
VdbeCursor
 **
	mapCsr
;

5873 
Mem
 *
	maVar
;

5874 char **
	mazVar
;

5875 
ynVar
 
	mnVar
;

5876 
ynVar
 
	mnzVar
;

5877 
u32
 
	mcacheCtr
;

5878 int 
	mpc
;

5879 int 
	mrc
;

5883 
u16
 
	mnResColumn
;

5884 
u8
 
	merrorAction
;

5885 
bft
 
	mexpired
:1;

5886 
bft
 
	mdoingRerun
:1;

5887 
u8
 
	mminWriteFileFormat
;

5888 
bft
 
	mexplain
:2;

5889 
bft
 
	mchangeCntOn
:1;

5890 
bft
 
	mrunOnlyOnce
:1;

5891 
bft
 
	musesStmtJournal
:1;

5892 
bft
 
	mreadOnly
:1;

5893 
bft
 
	mbIsReader
:1;

5894 
bft
 
	misPrepareV2
:1;

5895 int 
	mnChange
;

5896 
yDbMask
 
	mbtreeMask
;

5897 
yDbMask
 
	mlockMask
;

5898 int 
	miStatement
;

5899 
u32
 
	maCounter
[5];

5901 
i64
 
	mstartTime
;

5903 
i64
 
	miCurrentTime
;

5904 
i64
 
	mnFkConstraint
;

5905 
i64
 
	mnStmtDefCons
;

5906 
i64
 
	mnStmtDefImmCons
;

5907 char *
	mzSql
;

5908 void *
	mpFree
;

5909 
VdbeFrame
 *
	mpFrame
;

5910 
VdbeFrame
 *
	mpDelFrame
;

5911 int 
	mnFrame
;

5912 
u32
 
	mexpmask
;

5913 
SubProgram
 *
	mpProgram
;

5914 int 
	mnOnceFlag
;

5915 
u8
 *
	maOnceFlag
;

5916 
AuxData
 *
	mpAuxData
;

5924 static void 
sqlite3VdbeError
(
Vdbe
*, const char *, ...);

5925 static void 
sqlite3VdbeFreeCursor
(
Vdbe
 *, 
VdbeCursor
*);

5926 void 
sqliteVdbePopStack
(
Vdbe
*,int);

5927 static int 
sqlite3VdbeCursorMoveto
(
VdbeCursor
**, int*);

5928 static int 
sqlite3VdbeCursorRestore
(
VdbeCursor
*);

5932 static 
u32
 
sqlite3VdbeSerialTypeLen
(u32);

5933 static 
u8
 
sqlite3VdbeOneByteSerialTypeLen
(u8);

5934 static 
u32
 
sqlite3VdbeSerialType
(
Mem
*, int, u32*);

5935 static 
u32
 
sqlite3VdbeSerialPut
(unsigned char*, 
Mem
*, u32);

5936 static 
u32
 
sqlite3VdbeSerialGet
(const unsigned char*, u32, 
Mem
*);

5937 static void 
sqlite3VdbeDeleteAuxData
(
sqlite3
*, 
AuxData
**, int, int);

5939 int 
sqlite2BtreeKeyCompare
(
BtCursor
 *, const void *, int, int, int *);

5940 static int 
sqlite3VdbeIdxKeyCompare
(
sqlite3
*,
VdbeCursor
*,
UnpackedRecord
*,int*);

5941 static int 
sqlite3VdbeIdxRowid
(
sqlite3
*, 
BtCursor
*, 
i64
*);

5942 static int 
sqlite3VdbeExec
(
Vdbe
*);

5943 static int 
sqlite3VdbeList
(
Vdbe
*);

5944 static int 
sqlite3VdbeHalt
(
Vdbe
*);

5945 static int 
sqlite3VdbeChangeEncoding
(
Mem
 *, int);

5946 static int 
sqlite3VdbeMemTooBig
(
Mem
*);

5947 static int 
sqlite3VdbeMemCopy
(
Mem
*, const Mem*);

5948 static void 
sqlite3VdbeMemShallowCopy
(
Mem
*, const Mem*, int);

5949 static void 
sqlite3VdbeMemMove
(
Mem
*, Mem*);

5950 static int 
sqlite3VdbeMemNulTerminate
(
Mem
*);

5951 static int 
sqlite3VdbeMemSetStr
(
Mem
*, const char*, int, 
u8
, void(*)(void*));

5952 static void 
	`sqlite3VdbeMemSetInt64
(
Mem
*, 
i64
);

5956 static void 
	`sqlite3VdbeMemSetDouble
(
Mem
*, double);

5958 static void 
	`sqlite3VdbeMemInit
(
Mem
*,
sqlite3
*,
u16
);

5959 static void 
	`sqlite3VdbeMemSetNull
(
Mem
*);

5960 static void 
	`sqlite3VdbeMemSetZeroBlob
(
Mem
*,int);

5961 static void 
	`sqlite3VdbeMemSetRowSet
(
Mem
*);

5962 static int 
	`sqlite3VdbeMemMakeWriteable
(
Mem
*);

5963 static int 
	`sqlite3VdbeMemStringify
(
Mem
*, 
u8
, u8);

5964 static 
i64
 
	`sqlite3VdbeIntValue
(
Mem
*);

5965 static int 
	`sqlite3VdbeMemIntegerify
(
Mem
*);

5966 static double 
	`sqlite3VdbeRealValue
(
Mem
*);

5967 static void 
	`sqlite3VdbeIntegerAffinity
(
Mem
*);

5968 static int 
	`sqlite3VdbeMemRealify
(
Mem
*);

5969 static int 
	`sqlite3VdbeMemNumerify
(
Mem
*);

5970 static void 
	`sqlite3VdbeMemCast
(
Mem
*,
u8
,u8);

5971 static int 
	`sqlite3VdbeMemFromBtree
(
BtCursor
*,
u32
,u32,int,
Mem
*);

5972 static void 
	`sqlite3VdbeMemRelease
(
Mem
 *
p
);

5973 static int 
	`sqlite3VdbeMemFinalize
(
Mem
*, 
FuncDef
*);

5974 static const char *
	`sqlite3OpcodeName
(int);

5975 static int 
	`sqlite3VdbeMemGrow
(
Mem
 *
pMem
, int 
n
, int 
preserve
);

5976 static int 
	`sqlite3VdbeMemClearAndResize
(
Mem
 *
pMem
, int 
n
);

5977 static int 
	`sqlite3VdbeCloseStatement
(
Vdbe
 *, int);

5978 static void 
	`sqlite3VdbeFrameDelete
(
VdbeFrame
*);

5979 static int 
	`sqlite3VdbeFrameRestore
(
VdbeFrame
 *);

5980 static int 
	`sqlite3VdbeTransferError
(
Vdbe
 *
p
);

5982 static int 
	`sqlite3VdbeSorterInit
(
sqlite3
 *, int, 
VdbeCursor
 *);

5983 static void 
	`sqlite3VdbeSorterReset
(
sqlite3
 *, 
VdbeSorter
 *);

5984 static void 
	`sqlite3VdbeSorterClose
(
sqlite3
 *, 
VdbeCursor
 *);

5985 static int 
	`sqlite3VdbeSorterRowkey
(const 
VdbeCursor
 *, 
Mem
 *);

5986 static int 
	`sqlite3VdbeSorterNext
(
sqlite3
 *, const 
VdbeCursor
 *, int *);

5987 static int 
	`sqlite3VdbeSorterRewind
(const 
VdbeCursor
 *, int *);

5988 static int 
	`sqlite3VdbeSorterWrite
(const 
VdbeCursor
 *, 
Mem
 *);

5989 static int 
	`sqlite3VdbeSorterCompare
(const 
VdbeCursor
 *, 
Mem
 *, int, int *);

5992 static void 
	`sqlite3VdbeEnter
(
Vdbe
*);

5998 static void 
	`sqlite3VdbeLeave
(
Vdbe
*);

6000 static int 
	`sqlite3VdbeCheckFk
(
Vdbe
 *, int);

6005 static int 
	`sqlite3VdbeMemTranslate
(
Mem
*, 
u8
);

6010 static int 
	`sqlite3VdbeMemHandleBom
(
Mem
 *
pMem
);

6013 static int 
	`sqlite3VdbeMemExpandBlob
(
Mem
 *);

6015 typedef 
sqlite3_int64
 
	tsqlite3StatValueType
;

6019 typedef struct 
sqlite3StatType
 
	tsqlite3StatType
;

6020 static struct 
	ssqlite3StatType
 {

6021 
sqlite3StatValueType
 
nowValue
[10];

6022 
sqlite3StatValueType
 
mxValue
[10];

6023 } 
sqlite3Stat
 = { {0,}, {0,} 
	}
};

6029 static const char 
	gstatMutex
[] = {

6042 static 
sqlite3_int64
 
	$sqlite3StatusValue
(int 
op
)

6050 return 
sqlite3Stat
.
nowValue
[
op
];

6051 
	}
}

6053 static void 
	$sqlite3StatusUp
(int 
op
, int 
N
)

6061 
sqlite3Stat
.
nowValue
[
op
] += 
N
;

6062 if( 
sqlite3Stat
.
nowValue
[
op
]>sqlite3Stat.
mxValue
[op] )

6065 
sqlite3Stat
.
mxValue
[
op
] = sqlite3Stat.
nowValue
[op];

6067 
	}
}

6068 static void 
	$sqlite3StatusDown
(int 
op
, int 
N
)

6077 
sqlite3Stat
.
nowValue
[
op
] -= 
N
;

6078 
	}
}

6084 static void 
	$sqlite3StatusHighwater
(int 
op
, int 
X
)

6087 
sqlite3StatValueType
 
newValue
;

6090 
newValue
 = (
sqlite3StatValueType
)
X
;

6099 if( 
newValue
>
sqlite3Stat
.
mxValue
[
op
] )

6102 
sqlite3Stat
.
mxValue
[
op
] = 
newValue
;

6104 
	}
}

6109 int 
	$sqlite3_status64
(

6110 int 
op
,

6111 
sqlite3_int64
 *
pCurrent
,

6112 
sqlite3_int64
 *
pHighwater
,

6113 int 
resetFlag


6117 
sqlite3_mutex
 *
pMutex
;

6119 if( 
op
<0 || op>=((int)(sizeof(
sqlite3Stat
.
nowValue
)/sizeof(sqlite3Stat.nowValue[0]))) )

6122 return 
	`sqlite3MisuseError
(16513);

6127 
pMutex
 = 
statMutex
[
op
] ? 
	`sqlite3Pcache1Mutex
() : 
	`sqlite3MallocMutex
();

6128 
	`sqlite3_mutex_enter
(
pMutex
);

6129 *
pCurrent
 = 
sqlite3Stat
.
nowValue
[
op
];

6130 *
pHighwater
 = 
sqlite3Stat
.
mxValue
[
op
];

6131 if( 
resetFlag
 )

6134 
sqlite3Stat
.
mxValue
[
op
] = sqlite3Stat.
nowValue
[op];

6136 
	`sqlite3_mutex_leave
(
pMutex
);

6137 (void)
pMutex
;

6139 
	}
}

6140 int 
	$sqlite3_status
(int 
op
, int *
pCurrent
, int *
pHighwater
, int 
resetFlag
)

6143 
sqlite3_int64
 
iCur
, 
iHwtr
;

6144 int 
rc
;

6148 
rc
 = 
	`sqlite3_status64
(
op
, &
iCur
, &
iHwtr
, 
resetFlag
);

6149 if( 
rc
==0 )

6152 *
pCurrent
 = (int)
iCur
;

6153 *
pHighwater
 = (int)
iHwtr
;

6155 return 
rc
;

6156 
	}
}

6161 int 
	$sqlite3_db_status
(

6162 
sqlite3
 *
db
,

6163 int 
op
,

6164 int *
pCurrent
,

6165 int *
pHighwater
,

6166 int 
resetFlag


6170 int 
rc
 = 0;

6176 
	`sqlite3_mutex_enter
(
db
->
mutex
);

6177 switch( 
op
 )

6181 *
pCurrent
 = 
db
->
lookaside
.
nOut
;

6182 *
pHighwater
 = 
db
->
lookaside
.
mxOut
;

6183 if( 
resetFlag
 )

6186 
db
->
lookaside
.
mxOut
 = db->lookaside.
nOut
;

6199 *
pCurrent
 = 0;

6200 *
pHighwater
 = 
db
->
lookaside
.
anStat
[
op
 - 4];

6201 if( 
resetFlag
 )

6204 
db
->
lookaside
.
anStat
[
op
 - 4] = 0;

6215 int 
totalUsed
 = 0;

6216 int 
i
;

6217 
	`sqlite3BtreeEnterAll
(
db
);

6218 for(
i
=0; i<
db
->
nDb
; i++)

6221 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

6222 if( 
pBt
 )

6225 
Pager
 *
pPager
 = 
	`sqlite3BtreePager
(
pBt
);

6226 
totalUsed
 += 
	`sqlite3PagerMemUsed
(
pPager
);

6229 
	`sqlite3BtreeLeaveAll
(
db
);

6230 *
pCurrent
 = 
totalUsed
;

6231 *
pHighwater
 = 0;

6241 int 
i
;

6242 int 
nByte
 = 0;

6244 
	`sqlite3BtreeEnterAll
(
db
);

6245 
db
->
pnBytesFreed
 = &
nByte
;

6246 for(
i
=0; i<
db
->
nDb
; i++)

6249 
Schema
 *
pSchema
 = 
db
->
aDb
[
i
].pSchema;

6250 if( (
pSchema
!=0) )

6253 
HashElem
 *
p
;

6255 
nByte
 += 
sqlite3Config
.
m
.
	`xRoundup
(sizeof(
HashElem
)) * (

6256 
pSchema
->
tblHash
.
count


6257 + 
pSchema
->
trigHash
.
count


6258 + 
pSchema
->
idxHash
.
count


6259 + 
pSchema
->
fkeyHash
.
count


6261 
nByte
 += 
	`sqlite3_msize
(
pSchema
->
tblHash
.
ht
);

6262 
nByte
 += 
	`sqlite3_msize
(
pSchema
->
trigHash
.
ht
);

6263 
nByte
 += 
	`sqlite3_msize
(
pSchema
->
idxHash
.
ht
);

6264 
nByte
 += 
	`sqlite3_msize
(
pSchema
->
fkeyHash
.
ht
);

6266 for(
p
=((&
pSchema
->
trigHash
)->
first
); p; p=((p)->
next
))

6269 
	`sqlite3DeleteTrigger
(
db
, (
Trigger
*)((
p
)->
data
));

6271 for(
p
=((&
pSchema
->
tblHash
)->
first
); p; p=((p)->
next
))

6274 
	`sqlite3DeleteTable
(
db
, (
Table
 *)((
p
)->
data
));

6278 
db
->
pnBytesFreed
 = 0;

6279 
	`sqlite3BtreeLeaveAll
(
db
);

6281 *
pHighwater
 = 0;

6282 *
pCurrent
 = 
nByte
;

6292 struct 
Vdbe
 *
pVdbe
;

6293 int 
nByte
 = 0;

6295 
db
->
pnBytesFreed
 = &
nByte
;

6296 for(
pVdbe
=
db
->pVdbe; pVdbe; pVdbe=pVdbe->
pNext
)

6299 
	`sqlite3VdbeClearObject
(
db
, 
pVdbe
);

6300 
	`sqlite3DbFree
(
db
, 
pVdbe
);

6302 
db
->
pnBytesFreed
 = 0;

6304 *
pHighwater
 = 0;

6305 *
pCurrent
 = 
nByte
;

6318 int 
i
;

6319 int 
nRet
 = 0;

6323 for(
i
=0; i<
db
->
nDb
; i++)

6326 if( 
db
->
aDb
[
i
].
pBt
 )

6329 
Pager
 *
pPager
 = 
	`sqlite3BtreePager
(
db
->
aDb
[
i
].
pBt
);

6330 
	`sqlite3PagerCacheStat
(
pPager
, 
op
, 
resetFlag
, &
nRet
);

6333 *
pHighwater
 = 0;

6336 *
pCurrent
 = 
nRet
;

6345 *
pHighwater
 = 0;

6346 *
pCurrent
 = 
db
->
nDeferredImmCons
>0 || db->
nDeferredCons
>0;

6351 
rc
 = 1;

6354 
	`sqlite3_mutex_leave
(
db
->
mutex
);

6355 return 
rc
;

6356 
	}
}

6377 struct 
	stimex


6379 unsigned int 
	mmodes
;

6380 
__syscall_slong_t
 
	moffset
;

6381 
__syscall_slong_t
 
	mfreq
;

6382 
__syscall_slong_t
 
	mmaxerror
;

6383 
__syscall_slong_t
 
	mesterror
;

6384 int 
	mstatus
;

6385 
__syscall_slong_t
 
	mconstant
;

6386 
__syscall_slong_t
 
	mprecision
;

6387 
__syscall_slong_t
 
	mtolerance
;

6388 struct 
timeval
 
	mtime
;

6389 
__syscall_slong_t
 
	mtick
;

6390 
__syscall_slong_t
 
	mppsfreq
;

6391 
__syscall_slong_t
 
	mjitter
;

6392 int 
	mshift
;

6393 
__syscall_slong_t
 
	mstabil
;

6394 
__syscall_slong_t
 
	mjitcnt
;

6395 
__syscall_slong_t
 
	mcalcnt
;

6396 
__syscall_slong_t
 
	merrcnt
;

6397 
__syscall_slong_t
 
	mstbcnt
;

6399 int 
	mtai
;

6411 extern int 
	$clock_adjtime
 (
__clockid_t
 
__clock_id
, struct 
timex
 *
__utx
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6418 struct 
	stm


6420 int 
tm_sec
;

6421 int 
tm_min
;

6422 int 
tm_hour
;

6423 int 
tm_mday
;

6424 int 
tm_mon
;

6425 int 
tm_year
;

6426 int 
tm_wday
;

6427 int 
tm_yday
;

6428 int 
tm_isdst
;

6431 long int 
tm_gmtoff
;

6432 const char *
tm_zone
;

6446 struct 
	sitimerspec


6448 struct 
timespec
 
it_interval
;

6449 struct 
timespec
 
it_value
;

6453 struct 
sigevent
;

6458 extern 
clock_t
 
	$clock
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6461 extern 
time_t
 
	$time
 (
time_t
 *
__timer
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6464 extern double 
	$difftime
 (
time_t
 
__time1
, time_t 
__time0
)

6465 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

6468 extern 
time_t
 
	$mktime
 (struct 
tm
 *
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6474 extern 
size_t
 
	$strftime
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

6475 const char *
__restrict
 
__format
,

6476 const struct 
tm
 *
__restrict
 
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6482 extern char *
	$strptime
 (const char *
__restrict
 
__s
,

6483 const char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
)

6484 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6492 extern 
size_t
 
	$strftime_l
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

6493 const char *
__restrict
 
__format
,

6494 const struct 
tm
 *
__restrict
 
__tp
,

6495 
__locale_t
 
__loc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6499 extern char *
	$strptime_l
 (const char *
__restrict
 
__s
,

6500 const char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
,

6501 
__locale_t
 
__loc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6508 extern struct 
tm
 *
	$gmtime
 (const 
time_t
 *
__timer
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6512 extern struct 
tm
 *
	$localtime
 (const 
time_t
 *
__timer
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6518 extern struct 
tm
 *
	$gmtime_r
 (const 
time_t
 *
__restrict
 
__timer
,

6519 struct 
tm
 *
__restrict
 
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6523 extern struct 
tm
 *
	$localtime_r
 (const 
time_t
 *
__restrict
 
__timer
,

6524 struct 
tm
 *
__restrict
 
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6530 extern char *
	$asctime
 (const struct 
tm
 *
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6533 extern char *
	$ctime
 (const 
time_t
 *
__timer
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6541 extern char *
	$asctime_r
 (const struct 
tm
 *
__restrict
 
__tp
,

6542 char *
__restrict
 
__buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6545 extern char *
	$ctime_r
 (const 
time_t
 *
__restrict
 
__timer
,

6546 char *
__restrict
 
__buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6551 extern char *
__tzname
[2];

6552 extern int 
__daylight
;

6553 extern long int 
__timezone
;

6558 extern char *
tzname
[2];

6562 extern void 
	$tzset
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6566 extern int 
daylight
;

6567 extern long int 
timezone
;

6573 extern int 
	$stime
 (const 
time_t
 *
__when
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6575 extern 
time_t
 
	$timegm
 (struct 
tm
 *
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6578 extern 
time_t
 
	$timelocal
 (struct 
tm
 *
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6581 extern int 
	$dysize
 (int 
__year
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

6583 extern int 
	`nanosleep
 (const struct 
timespec
 *
__requested_time
,

6584 struct 
timespec
 *
__remaining
);

6588 extern int 
	$clock_getres
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__res
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6591 extern int 
	$clock_gettime
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__tp
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6594 extern int 
	$clock_settime
 (
clockid_t
 
__clock_id
, const struct 
timespec
 *
__tp
)

6595 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6602 extern int 
	`clock_nanosleep
 (
clockid_t
 
__clock_id
, int 
__flags
,

6603 const struct 
timespec
 *
__req
,

6604 struct 
timespec
 *
__rem
);

6607 extern int 
	$clock_getcpuclockid
 (
pid_t
 
__pid
, 
clockid_t
 *
__clock_id
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6612 extern int 
	$timer_create
 (
clockid_t
 
__clock_id
,

6613 struct 
sigevent
 *
__restrict
 
__evp
,

6614 
timer_t
 *
__restrict
 
__timerid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6617 extern int 
	$timer_delete
 (
timer_t
 
__timerid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6620 extern int 
	$timer_settime
 (
timer_t
 
__timerid
, int 
__flags
,

6621 const struct 
itimerspec
 *
__restrict
 
__value
,

6622 struct 
itimerspec
 *
__restrict
 
__ovalue
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6625 extern int 
	$timer_gettime
 (
timer_t
 
__timerid
, struct 
itimerspec
 *
__value
)

6626 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6629 extern int 
	$timer_getoverrun
 (
timer_t
 
__timerid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

6635 extern int 
	$timespec_get
 (struct 
timespec
 *
__ts
, int 
__base
)

6636 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

6638 extern int 
getdate_err
;

6640 extern struct 
tm
 *
	`getdate
 (const char *
__string
);

6642 extern int 
	`getdate_r
 (const char *
__restrict
 
__string
,

6643 struct 
tm
 *
__restrict
 
__resbufp
);

6655 typedef struct 
DateTime
 
	tDateTime
;

6656 struct 
	sDateTime
 {

6657 
sqlite3_int64
 
iJD
;

6658 int 
Y
, 
M
, 
D
;

6659 int 
h
, 
m
;

6660 int 
tz
;

6661 double 
s
;

6662 char 
validYMD
;

6663 char 
validHMS
;

6664 char 
validJD
;

6665 char 
validTZ
;

6666 char 
tzSet
;

6669 static int 
	$getDigits
(const char *
zDate
, const char *
zFormat
, ...)

6674 static const 
u16
 
aMx
[] = { 12, 14, 24, 31, 59, 9999 };

6675 
va_list
 
ap
;

6676 int 
cnt
 = 0;

6677 char 
nextC
;

6678 
	`__builtin_va_start
(
ap
,
zFormat
);

6680 char 
N
 = 
zFormat
[0] - '0';

6681 char 
min
 = 
zFormat
[1] - '0';

6682 int 
val
 = 0;

6683 
u16
 
max
;

6686 
max
 = 
aMx
[
zFormat
[2] - 'a'];

6687 
nextC
 = 
zFormat
[3];

6688 
val
 = 0;

6689 while( 
N
-- )

6692 if( !(
sqlite3CtypeMap
[(unsigned char)(*
zDate
)]&0x04) )

6695 goto 
end_getDigits
;

6697 
val
 = val*10 + *
zDate
 - '0';

6698 
zDate
++;

6700 if( 
val
<(int)
min
 || val>(int)
max
 || (
nextC
!=0 && nextC!=*
zDate
) )

6703 goto 
end_getDigits
;

6705 *
	`__builtin_va_arg
(
ap
,int*) = 
val
;

6706 
zDate
++;

6707 
cnt
++;

6708 
zFormat
 += 4;

6709 }while( 
nextC
 );

6710 
end_getDigits
:

6711 
	`__builtin_va_end
(
ap
);

6712 return 
cnt
;

6713 
	}
}

6715 static int 
	$parseTimezone
(const char *
zDate
, 
DateTime
 *
p
)

6718 int 
sgn
 = 0;

6719 int 
nHr
, 
nMn
;

6720 int 
c
;

6721 while( (
sqlite3CtypeMap
[(unsigned char)(*
zDate
)]&0x01) )

6723 
zDate
++; }

6724 
p
->
tz
 = 0;

6725 
c
 = *
zDate
;

6726 if( 
c
=='-' )

6729 
sgn
 = -1;

6730 }else if( 
c
=='+' )

6733 
sgn
 = +1;

6734 }else if( 
c
=='Z' || c=='z' )

6737 
zDate
++;

6738 goto 
zulu_time
;

6740 return 
c
!=0;

6742 
zDate
++;

6743 if( 
	`getDigits
(
zDate
, "20b:20e", &
nHr
, &
nMn
)!=2 )

6748 
zDate
 += 5;

6749 
p
->
tz
 = 
sgn
*(
nMn
 + 
nHr
*60);

6750 
zulu_time
:

6751 while( (
sqlite3CtypeMap
[(unsigned char)(*
zDate
)]&0x01) )

6753 
zDate
++; }

6754 
p
->
tzSet
 = 1;

6755 return *
zDate
!=0;

6756 
	}
}

6758 static int 
	$parseHhMmSs
(const char *
zDate
, 
DateTime
 *
p
)

6761 int 
h
, 
m
, 
s
;

6762 double 
ms
 = 0.0;

6763 if( 
	`getDigits
(
zDate
, "20c:20e", &
h
, &
m
)!=2 )

6768 
zDate
 += 5;

6769 if( *
zDate
==':' )

6772 
zDate
++;

6773 if( 
	`getDigits
(
zDate
, "20e", &
s
)!=1 )

6778 
zDate
 += 2;

6779 if( *
zDate
=='.' && (
sqlite3CtypeMap
[(unsigned char)(zDate[1])]&0x04) )

6782 double 
rScale
 = 1.0;

6783 
zDate
++;

6784 while( (
sqlite3CtypeMap
[(unsigned char)(*
zDate
)]&0x04) )

6787 
ms
 = ms*10.0 + *
zDate
 - '0';

6788 
rScale
 *= 10.0;

6789 
zDate
++;

6791 
ms
 /= 
rScale
;

6794 
s
 = 0;

6796 
p
->
validJD
 = 0;

6797 
p
->
validHMS
 = 1;

6798 
p
->
h
 = h;

6799 
p
->
m
 = m;

6800 
p
->
s
 = s + 
ms
;

6801 if( 
	`parseTimezone
(
zDate
, 
p
) ) return 1;

6802 
p
->
validTZ
 = (p->
tz
!=0)?1:0;

6804 
	}
}

6812 static void 
	$computeJD
(
DateTime
 *
p
)

6815 int 
Y
, 
M
, 
D
, 
A
, 
B
, 
X1
, 
X2
;

6817 if( 
p
->
validJD
 ) return;

6818 if( 
p
->
validYMD
 )

6821 
Y
 = 
p
->Y;

6822 
M
 = 
p
->M;

6823 
D
 = 
p
->D;

6825 
Y
 = 2000;

6826 
M
 = 1;

6827 
D
 = 1;

6829 if( 
M
<=2 )

6832 
Y
--;

6833 
M
 += 12;

6835 
A
 = 
Y
/100;

6836 
B
 = 2 - 
A
 + (A/4);

6837 
X1
 = 36525*(
Y
+4716)/100;

6838 
X2
 = 306001*(
M
+1)/10000;

6839 
p
->
iJD
 = (
sqlite3_int64
)((
X1
 + 
X2
 + 
D
 + 
B
 - 1524.5 ) * 86400000);

6840 
p
->
validJD
 = 1;

6841 if( 
p
->
validHMS
 )

6844 
p
->
iJD
 += p->
h
*3600000 + p->
m
*60000 + (
sqlite3_int64
)(p->
s
*1000);

6845 if( 
p
->
validTZ
 )

6848 
p
->
iJD
 -= p->
tz
*60000;

6849 
p
->
validYMD
 = 0;

6850 
p
->
validHMS
 = 0;

6851 
p
->
validTZ
 = 0;

6854 
	}
}

6856 static int 
	$parseYyyyMmDd
(const char *
zDate
, 
DateTime
 *
p
)

6859 int 
Y
, 
M
, 
D
, 
neg
;

6861 if( 
zDate
[0]=='-' )

6864 
zDate
++;

6865 
neg
 = 1;

6867 
neg
 = 0;

6869 if( 
	`getDigits
(
zDate
, "40f-21a-21d", &
Y
, &
M
, &
D
)!=3 )

6874 
zDate
 += 10;

6875 while( (
sqlite3CtypeMap
[(unsigned char)(*
zDate
)]&0x01) || 'T'==*(
u8
*)zDate )

6877 
zDate
++; }

6878 if( 
	`parseHhMmSs
(
zDate
, 
p
)==0 )

6882 }else if( *
zDate
==0 )

6885 
p
->
validHMS
 = 0;

6889 
p
->
validJD
 = 0;

6890 
p
->
validYMD
 = 1;

6891 
p
->
Y
 = 
neg
 ? -Y : Y;

6892 
p
->
M
 = M;

6893 
p
->
D
 = D;

6894 if( 
p
->
validTZ
 )

6897 
	`computeJD
(
p
);

6900 
	}
}

6907 static int 
	$setDateTimeToCurrent
(
sqlite3_context
 *
context
, 
DateTime
 *
p
)

6910 
p
->
iJD
 = 
	`sqlite3StmtCurrentTime
(
context
);

6911 if( 
p
->
iJD
>0 )

6914 
p
->
validJD
 = 1;

6919 
	}
}

6921 static int 
	$parseDateOrTime
(

6922 
sqlite3_context
 *
context
,

6923 const char *
zDate
,

6924 
DateTime
 *
p


6928 double 
r
;

6929 if( 
	`parseYyyyMmDd
(
zDate
,
p
)==0 )

6933 }else if( 
	`parseHhMmSs
(
zDate
, 
p
)==0 )

6937 }else if( 
	`sqlite3StrICmp
(
zDate
,"now")==0)

6940 return 
	`setDateTimeToCurrent
(
context
, 
p
);

6941 }else if( 
	`sqlite3AtoF
(
zDate
, &
r
, 
	`sqlite3Strlen30
(zDate), 1) )

6944 
p
->
iJD
 = (
sqlite3_int64
)(
r
*86400000.0 + 0.5);

6945 
p
->
validJD
 = 1;

6949 
	}
}

6954 static void 
	$computeYMD
(
DateTime
 *
p
)

6957 int 
Z
, 
A
, 
B
, 
C
, 
D
, 
E
, 
X1
;

6958 if( 
p
->
validYMD
 ) return;

6959 if( !
p
->
validJD
 )

6962 
p
->
Y
 = 2000;

6963 
p
->
M
 = 1;

6964 
p
->
D
 = 1;

6966 
Z
 = (int)((
p
->
iJD
 + 43200000)/86400000);

6967 
A
 = (int)((
Z
 - 1867216.25)/36524.25);

6968 
A
 = 
Z
 + 1 + A - (A/4);

6969 
B
 = 
A
 + 1524;

6970 
C
 = (int)((
B
 - 122.1)/365.25);

6971 
D
 = (36525*(
C
&32767))/100;

6972 
E
 = (int)((
B
-
D
)/30.6001);

6973 
X1
 = (int)(30.6001*
E
);

6974 
p
->
D
 = 
B
 - D - 
X1
;

6975 
p
->
M
 = 
E
<14 ? E-1 : E-13;

6976 
p
->
Y
 = p->
M
>2 ? 
C
 - 4716 : C - 4715;

6978 
p
->
validYMD
 = 1;

6979 
	}
}

6984 static void 
	$computeHMS
(
DateTime
 *
p
)

6987 int 
s
;

6988 if( 
p
->
validHMS
 ) return;

6989 
	`computeJD
(
p
);

6990 
s
 = (int)((
p
->
iJD
 + 43200000) % 86400000);

6991 
p
->
s
 = s/1000.0;

6992 
s
 = (int)
p
->s;

6993 
p
->
s
 -= s;

6994 
p
->
h
 = 
s
/3600;

6995 
s
 -= 
p
->
h
*3600;

6996 
p
->
m
 = 
s
/60;

6997 
p
->
s
 += s - p->
m
*60;

6998 
p
->
validHMS
 = 1;

6999 
	}
}

7004 static void 
	$computeYMD_HMS
(
DateTime
 *
p
)

7007 
	`computeYMD
(
p
);

7008 
	`computeHMS
(
p
);

7009 
	}
}

7014 static void 
	$clearYMD_HMS_TZ
(
DateTime
 *
p
)

7017 
p
->
validYMD
 = 0;

7018 
p
->
validHMS
 = 0;

7019 
p
->
validTZ
 = 0;

7020 
	}
}

7022 static int 
	$osLocaltime
(
time_t
 *
t
, struct 
tm
 *
pTm
)

7025 int 
rc
;

7027 struct 
tm
 *
pX
;

7029 
sqlite3_mutex
 *
mutex
 = 
	`sqlite3MutexAlloc
(2);

7031 
	`sqlite3_mutex_enter
(
mutex
);

7032 
pX
 = 
	`localtime
(
t
);

7034 if( 
sqlite3Config
.
bLocaltimeFault
 ) 
pX
 = 0;

7036 if( 
pX
 ) *
pTm
 = *pX;

7037 
	`sqlite3_mutex_leave
(
mutex
);

7038 
rc
 = 
pX
==0;

7040 return 
rc
;

7041 
	}
}

7043 static 
sqlite3_int64
 
	$localtimeOffset
(

7044 
DateTime
 *
p
,

7045 
sqlite3_context
 *
pCtx
,

7046 int *
pRc


7050 
DateTime
 
x
, 
y
;

7051 
time_t
 
t
;

7052 struct 
tm
 
sLocal
;

7055 
	`memset
(&
sLocal
, 0, sizeof(sLocal));

7057 
x
 = *
p
;

7058 
	`computeYMD_HMS
(&
x
);

7059 if( 
x
.
Y
<1971 || x.Y>=2038 )

7067 
x
.
Y
 = 2000;

7068 
x
.
M
 = 1;

7069 
x
.
D
 = 1;

7070 
x
.
h
 = 0;

7071 
x
.
m
 = 0;

7072 
x
.
s
 = 0.0;

7074 int 
s
 = (int)(
x
.s + 0.5);

7075 
x
.
s
 = s;

7077 
x
.
tz
 = 0;

7078 
x
.
validJD
 = 0;

7079 
	`computeJD
(&
x
);

7080 
t
 = (
time_t
)(
x
.
iJD
/1000 - 21086676*(
i64
)10000);

7081 if( 
	`osLocaltime
(&
t
, &
sLocal
) )

7084 
	`sqlite3_result_error
(
pCtx
, "local time unavailable", -1);

7085 *
pRc
 = 1;

7088 
y
.
Y
 = 
sLocal
.
tm_year
 + 1900;

7089 
y
.
M
 = 
sLocal
.
tm_mon
 + 1;

7090 
y
.
D
 = 
sLocal
.
tm_mday
;

7091 
y
.
h
 = 
sLocal
.
tm_hour
;

7092 
y
.
m
 = 
sLocal
.
tm_min
;

7093 
y
.
s
 = 
sLocal
.
tm_sec
;

7094 
y
.
validYMD
 = 1;

7095 
y
.
validHMS
 = 1;

7096 
y
.
validJD
 = 0;

7097 
y
.
validTZ
 = 0;

7098 
	`computeJD
(&
y
);

7099 *
pRc
 = 0;

7100 return 
y
.
iJD
 - 
x
.iJD;

7101 
	}
}

7103 static int 
	$parseModifier
(
sqlite3_context
 *
pCtx
, const char *
zMod
, 
DateTime
 *
p
)

7106 int 
rc
 = 1;

7107 int 
n
;

7108 double 
r
;

7109 char *
z
, 
zBuf
[30];

7110 
z
 = 
zBuf
;

7111 for(
n
=0; n<((int)(sizeof(
zBuf
)/sizeof(zBuf[0])))-1 && 
zMod
[n]; n++)

7114 
z
[
n
] = (char)
sqlite3UpperToLower
[(
u8
)
zMod
[n]];

7116 
z
[
n
] = 0;

7117 switch( 
z
[0] )

7127 if( 
	`strcmp
(
z
, "localtime")==0 )

7130 
	`computeJD
(
p
);

7131 
p
->
iJD
 += 
	`localtimeOffset
(p, 
pCtx
, &
rc
);

7132 
	`clearYMD_HMS_TZ
(
p
);

7144 if( 
	`strcmp
(
z
, "unixepoch")==0 && 
p
->
validJD
 )

7147 
p
->
iJD
 = (p->iJD + 43200)/86400 + 21086676*(
i64
)10000000;

7148 
	`clearYMD_HMS_TZ
(
p
);

7149 
rc
 = 0;

7152 else if( 
	`strcmp
(
z
, "utc")==0 )

7155 if( 
p
->
tzSet
==0 )

7158 
sqlite3_int64
 
c1
;

7159 
	`computeJD
(
p
);

7160 
c1
 = 
	`localtimeOffset
(
p
, 
pCtx
, &
rc
);

7161 if( 
rc
==0 )

7164 
p
->
iJD
 -= 
c1
;

7165 
	`clearYMD_HMS_TZ
(
p
);

7166 
p
->
iJD
 += 
c1
 - 
	`localtimeOffset
(p, 
pCtx
, &
rc
);

7168 
p
->
tzSet
 = 1;

7170 
rc
 = 0;

7184 if( 
	`strncmp
(
z
, "weekday ", 8)==0

7185 && 
	`sqlite3AtoF
(&
z
[8], &
r
, 
	`sqlite3Strlen30
(&z[8]), 1)

7186 && (
n
=(int)
r
)==r && n>=0 && r<7 )

7189 
sqlite3_int64
 
Z
;

7190 
	`computeYMD_HMS
(
p
);

7191 
p
->
validTZ
 = 0;

7192 
p
->
validJD
 = 0;

7193 
	`computeJD
(
p
);

7194 
Z
 = ((
p
->
iJD
 + 129600000)/86400000) % 7;

7195 if( 
Z
>
n
 ) Z -= 7;

7196 
p
->
iJD
 += (
n
 - 
Z
)*86400000;

7197 
	`clearYMD_HMS_TZ
(
p
);

7198 
rc
 = 0;

7209 if( 
	`strncmp
(
z
, "start of ", 9)!=0 ) break;

7210 
z
 += 9;

7211 
	`computeYMD
(
p
);

7212 
p
->
validHMS
 = 1;

7213 
p
->
h
 = p->
m
 = 0;

7214 
p
->
s
 = 0.0;

7215 
p
->
validTZ
 = 0;

7216 
p
->
validJD
 = 0;

7217 if( 
	`strcmp
(
z
,"month")==0 )

7220 
p
->
D
 = 1;

7221 
rc
 = 0;

7222 }else if( 
	`strcmp
(
z
,"year")==0 )

7225 
	`computeYMD
(
p
);

7226 
p
->
M
 = 1;

7227 
p
->
D
 = 1;

7228 
rc
 = 0;

7229 }else if( 
	`strcmp
(
z
,"day")==0 )

7232 
rc
 = 0;

7248 double 
rRounder
;

7249 for(
n
=1; 
z
[n] && z[n]!=':' && !(
sqlite3CtypeMap
[(unsigned char)(z[n])]&0x01); n++)

7252 if( !
	`sqlite3AtoF
(
z
, &
r
, 
n
, 1) )

7255 
rc
 = 1;

7258 if( 
z
[
n
]==':' )

7266 const char *
z2
 = 
z
;

7267 
DateTime
 
tx
;

7268 
sqlite3_int64
 
day
;

7269 if( !(
sqlite3CtypeMap
[(unsigned char)(*
z2
)]&0x04) ) z2++;

7270 
	`memset
(&
tx
, 0, sizeof(tx));

7271 if( 
	`parseHhMmSs
(
z2
, &
tx
) ) break;

7272 
	`computeJD
(&
tx
);

7273 
tx
.
iJD
 -= 43200000;

7274 
day
 = 
tx
.
iJD
/86400000;

7275 
tx
.
iJD
 -= 
day
*86400000;

7276 if( 
z
[0]=='-' ) 
tx
.
iJD
 = -tx.iJD;

7277 
	`computeJD
(
p
);

7278 
	`clearYMD_HMS_TZ
(
p
);

7279 
p
->
iJD
 += 
tx
.iJD;

7280 
rc
 = 0;

7283 
z
 += 
n
;

7284 while( (
sqlite3CtypeMap
[(unsigned char)(*
z
)]&0x01) ) z++;

7285 
n
 = 
	`sqlite3Strlen30
(
z
);

7286 if( 
n
>10 || n<3 ) break;

7287 if( 
z
[
n
-1]=='s' )

7289 
z
[
n
-1] = 0; n--; }

7290 
	`computeJD
(
p
);

7291 
rc
 = 0;

7292 
rRounder
 = 
r
<0 ? -0.5 : +0.5;

7293 if( 
n
==3 && 
	`strcmp
(
z
,"day")==0 )

7296 
p
->
iJD
 += (
sqlite3_int64
)(
r
*86400000.0 + 
rRounder
);

7297 }else if( 
n
==4 && 
	`strcmp
(
z
,"hour")==0 )

7300 
p
->
iJD
 += (
sqlite3_int64
)(
r
*(86400000.0/24.0) + 
rRounder
);

7301 }else if( 
n
==6 && 
	`strcmp
(
z
,"minute")==0 )

7304 
p
->
iJD
 += (
sqlite3_int64
)(
r
*(86400000.0/(24.0*60.0)) + 
rRounder
);

7305 }else if( 
n
==6 && 
	`strcmp
(
z
,"second")==0 )

7308 
p
->
iJD
 += (
sqlite3_int64
)(
r
*(86400000.0/(24.0*60.0*60.0)) + 
rRounder
);

7309 }else if( 
n
==5 && 
	`strcmp
(
z
,"month")==0 )

7312 int 
x
, 
y
;

7313 
	`computeYMD_HMS
(
p
);

7314 
p
->
M
 += (int)
r
;

7315 
x
 = 
p
->
M
>0 ? (p->M-1)/12 : (p->M-12)/12;

7316 
p
->
Y
 += 
x
;

7317 
p
->
M
 -= 
x
*12;

7318 
p
->
validJD
 = 0;

7319 
	`computeJD
(
p
);

7320 
y
 = (int)
r
;

7321 if( 
y
!=
r
 )

7324 
p
->
iJD
 += (
sqlite3_int64
)((
r
 - 
y
)*30.0*86400000.0 + 
rRounder
);

7326 }else if( 
n
==4 && 
	`strcmp
(
z
,"year")==0 )

7329 int 
y
 = (int)
r
;

7330 
	`computeYMD_HMS
(
p
);

7331 
p
->
Y
 += 
y
;

7332 
p
->
validJD
 = 0;

7333 
	`computeJD
(
p
);

7334 if( 
y
!=
r
 )

7337 
p
->
iJD
 += (
sqlite3_int64
)((
r
 - 
y
)*365.0*86400000.0 + 
rRounder
);

7340 
rc
 = 1;

7342 
	`clearYMD_HMS_TZ
(
p
);

7349 return 
rc
;

7350 
	}
}

7352 static int 
	$isDate
(

7353 
sqlite3_context
 *
context
,

7354 int 
argc
,

7355 
sqlite3_value
 **
argv
,

7356 
DateTime
 *
p


7360 int 
i
;

7361 const unsigned char *
z
;

7362 int 
eType
;

7363 
	`memset
(
p
, 0, sizeof(*p));

7364 if( 
argc
==0 )

7367 return 
	`setDateTimeToCurrent
(
context
, 
p
);

7369 if( (
eType
 = 
	`sqlite3_value_type
(
argv
[0]))==2

7370 || 
eType
==1 )

7373 
p
->
iJD
 = (
sqlite3_int64
)(
	`sqlite3_value_double
(
argv
[0])*86400000.0 + 0.5);

7374 
p
->
validJD
 = 1;

7376 
z
 = 
	`sqlite3_value_text
(
argv
[0]);

7377 if( !
z
 || 
	`parseDateOrTime
(
context
, (char*)z, 
p
) )

7383 for(
i
=1; i<
argc
; i++)

7386 
z
 = 
	`sqlite3_value_text
(
argv
[
i
]);

7387 if( 
z
==0 || 
	`parseModifier
(
context
, (char*)z, 
p
) ) return 1;

7390 
	}
}

7392 static void 
	$juliandayFunc
(

7393 
sqlite3_context
 *
context
,

7394 int 
argc
,

7395 
sqlite3_value
 **
argv


7399 
DateTime
 
x
;

7400 if( 
	`isDate
(
context
, 
argc
, 
argv
, &
x
)==0 )

7403 
	`computeJD
(&
x
);

7404 
	`sqlite3_result_double
(
context
, 
x
.
iJD
/86400000.0);

7406 
	}
}

7413 static void 
	$datetimeFunc
(

7414 
sqlite3_context
 *
context
,

7415 int 
argc
,

7416 
sqlite3_value
 **
argv


7420 
DateTime
 
x
;

7421 if( 
	`isDate
(
context
, 
argc
, 
argv
, &
x
)==0 )

7424 char 
zBuf
[100];

7425 
	`computeYMD_HMS
(&
x
);

7426 
	`sqlite3_snprintf
(sizeof(
zBuf
), zBuf, "%04d-%02d-%02d %02d:%02d:%02d",

7427 
x
.
Y
, x.
M
, x.
D
, x.
h
, x.
m
, (int)(x.
s
));

7428 
	`sqlite3_result_text
(
context
, 
zBuf
, -1, ((
sqlite3_destructor_type
)-1));

7430 
	}
}

7437 static void 
	$timeFunc
(

7438 
sqlite3_context
 *
context
,

7439 int 
argc
,

7440 
sqlite3_value
 **
argv


7444 
DateTime
 
x
;

7445 if( 
	`isDate
(
context
, 
argc
, 
argv
, &
x
)==0 )

7448 char 
zBuf
[100];

7449 
	`computeHMS
(&
x
);

7450 
	`sqlite3_snprintf
(sizeof(
zBuf
), zBuf, "%02d:%02d:%02d", 
x
.
h
, x.
m
, (int)x.
s
);

7451 
	`sqlite3_result_text
(
context
, 
zBuf
, -1, ((
sqlite3_destructor_type
)-1));

7453 
	}
}

7460 static void 
	$dateFunc
(

7461 
sqlite3_context
 *
context
,

7462 int 
argc
,

7463 
sqlite3_value
 **
argv


7467 
DateTime
 
x
;

7468 if( 
	`isDate
(
context
, 
argc
, 
argv
, &
x
)==0 )

7471 char 
zBuf
[100];

7472 
	`computeYMD
(&
x
);

7473 
	`sqlite3_snprintf
(sizeof(
zBuf
), zBuf, "%04d-%02d-%02d", 
x
.
Y
, x.
M
, x.
D
);

7474 
	`sqlite3_result_text
(
context
, 
zBuf
, -1, ((
sqlite3_destructor_type
)-1));

7476 
	}
}

7478 static void 
	$strftimeFunc
(

7479 
sqlite3_context
 *
context
,

7480 int 
argc
,

7481 
sqlite3_value
 **
argv


7485 
DateTime
 
x
;

7486 
u64
 
n
;

7487 
size_t
 
i
,
j
;

7488 char *
z
;

7489 
sqlite3
 *
db
;

7490 const char *
zFmt
;

7491 char 
zBuf
[100];

7492 if( 
argc
==0 ) return;

7493 
zFmt
 = (const char*)
	`sqlite3_value_text
(
argv
[0]);

7494 if( 
zFmt
==0 || 
	`isDate
(
context
, 
argc
-1, 
argv
+1, &
x
) ) return;

7495 
db
 = 
	`sqlite3_context_db_handle
(
context
);

7496 for(
i
=0, 
n
=1; 
zFmt
[i]; i++, n++)

7499 if( 
zFmt
[
i
]=='%' )

7502 switch( 
zFmt
[
i
+1] )

7511 
n
++;

7517 
n
 += 8;

7520 
n
 += 3;

7523 
n
 += 8;

7527 
n
 += 50;

7532 
i
++;

7539 if( 
n
<sizeof(
zBuf
) )

7542 
z
 = 
zBuf
;

7543 }else if( 
n
>(
u64
)
db
->
aLimit
[0] )

7546 
	`sqlite3_result_error_toobig
(
context
);

7549 
z
 = 
	`sqlite3DbMallocRawNN
(
db
, (int)
n
);

7550 if( 
z
==0 )

7553 
	`sqlite3_result_error_nomem
(
context
);

7557 
	`computeJD
(&
x
);

7558 
	`computeYMD_HMS
(&
x
);

7559 for(
i
=
j
=0; 
zFmt
[i]; i++)

7562 if( 
zFmt
[
i
]!='%' )

7565 
z
[
j
++] = 
zFmt
[
i
];

7567 
i
++;

7568 switch( 
zFmt
[
i
] )

7571 case 'd': 
	`sqlite3_snprintf
(3, &
z
[
j
],"%02d",
x
.
D
); j+=2; break;

7573 double 
s
 = 
x
.s;

7574 if( 
s
>59.999 ) s = 59.999;

7575 
	`sqlite3_snprintf
(7, &
z
[
j
],"%06.3f", 
s
);

7576 
j
 += 
	`sqlite3Strlen30
(&
z
[j]);

7579 case 'H': 
	`sqlite3_snprintf
(3, &
z
[
j
],"%02d",
x
.
h
); j+=2; break;

7582 int 
nDay
;

7583 
DateTime
 
y
 = 
x
;

7584 
y
.
validJD
 = 0;

7585 
y
.
M
 = 1;

7586 
y
.
D
 = 1;

7587 
	`computeJD
(&
y
);

7588 
nDay
 = (int)((
x
.
iJD
-
y
.iJD+43200000)/86400000);

7589 if( 
zFmt
[
i
]=='W' )

7592 int 
wd
;

7593 
wd
 = (int)(((
x
.
iJD
+43200000)/86400000)%7);

7594 
	`sqlite3_snprintf
(3, &
z
[
j
],"%02d",(
nDay
+7-
wd
)/7);

7595 
j
 += 2;

7597 
	`sqlite3_snprintf
(4, &
z
[
j
],"%03d",
nDay
+1);

7598 
j
 += 3;

7603 
	`sqlite3_snprintf
(20, &
z
[
j
],"%.16g",
x
.
iJD
/86400000.0);

7604 
j
+=
	`sqlite3Strlen30
(&
z
[j]);

7607 case 'm': 
	`sqlite3_snprintf
(3, &
z
[
j
],"%02d",
x
.
M
); j+=2; break;

7608 case 'M': 
	`sqlite3_snprintf
(3, &
z
[
j
],"%02d",
x
.
m
); j+=2; break;

7610 
	`sqlite3_snprintf
(30,&
z
[
j
],"%lld",

7611 (
i64
)(
x
.
iJD
/1000 - 21086676*(i64)10000));

7612 
j
 += 
	`sqlite3Strlen30
(&
z
[j]);

7615 case 'S': 
	`sqlite3_snprintf
(3,&
z
[
j
],"%02d",(int)
x
.
s
); j+=2; break;

7617 
z
[
j
++] = (char)(((
x
.
iJD
+129600000)/86400000) % 7) + '0';

7621 
	`sqlite3_snprintf
(5,&
z
[
j
],"%04d",
x
.
Y
); j+=
	`sqlite3Strlen30
(&z[j]);

7624 default: 
z
[
j
++] = '%'; break;

7628 
z
[
j
] = 0;

7629 
	`sqlite3_result_text
(
context
, 
z
, -1,

7630 
z
==
zBuf
 ? ((
sqlite3_destructor_type
)-1) : ((sqlite3_destructor_type)
sqlite3MallocSize
));

7631 
	}
}

7638 static void 
	$ctimeFunc
(

7639 
sqlite3_context
 *
context
,

7640 int 
NotUsed
,

7641 
sqlite3_value
 **
NotUsed2


7645 (void)(
NotUsed
),(void)(
NotUsed2
);

7646 
	`timeFunc
(
context
, 0, 0);

7647 
	}
}

7654 static void 
	$cdateFunc
(

7655 
sqlite3_context
 *
context
,

7656 int 
NotUsed
,

7657 
sqlite3_value
 **
NotUsed2


7661 (void)(
NotUsed
),(void)(
NotUsed2
);

7662 
	`dateFunc
(
context
, 0, 0);

7663 
	}
}

7670 static void 
	$ctimestampFunc
(

7671 
sqlite3_context
 *
context
,

7672 int 
NotUsed
,

7673 
sqlite3_value
 **
NotUsed2


7677 (void)(
NotUsed
),(void)(
NotUsed2
);

7678 
	`datetimeFunc
(
context
, 0, 0);

7679 
	}
}

7681 static void 
	$sqlite3RegisterDateTimeFunctions
(void)

7684 static 
FuncDef
 
aDateTimeFuncs
[] = {

7686 {-1, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
juliandayFunc
, 0, "julianday", {0} },

7687 {-1, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
dateFunc
, 0, "date", {0} },

7688 {-1, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
timeFunc
, 0, "time", {0} },

7689 {-1, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
datetimeFunc
, 0, "datetime", {0} },

7690 {-1, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
strftimeFunc
, 0, "strftime", {0} },

7691 {0, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
ctimeFunc
, 0, "current_time", {0} },

7692 {0, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
ctimestampFunc
, 0, "current_timestamp", {0} },

7693 {0, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
cdateFunc
, 0, "current_date", {0} },

7700 
	`sqlite3InsertBuiltinFuncs
(
aDateTimeFuncs
, ((int)(sizeof(aDateTimeFuncs)/sizeof(aDateTimeFuncs[0]))));

7701 
	}
}

7703 static int 
	$sqlite3OsClose
(
sqlite3_file
 *
pId
)

7706 int 
rc
 = 0;

7707 if( 
pId
->
pMethods
 )

7710 
rc
 = 
pId
->
pMethods
->
	`xClose
(pId);

7711 
pId
->
pMethods
 = 0;

7713 return 
rc
;

7714 
	}
}

7715 static int 
	$sqlite3OsRead
(
sqlite3_file
 *
id
, void *
pBuf
, int 
amt
, 
i64
 
offset
)

7719 return 
id
->
pMethods
->
	`xRead
(id, 
pBuf
, 
amt
, 
offset
);

7720 
	}
}

7721 static int 
	$sqlite3OsWrite
(
sqlite3_file
 *
id
, const void *
pBuf
, int 
amt
, 
i64
 
offset
)

7725 return 
id
->
pMethods
->
	`xWrite
(id, 
pBuf
, 
amt
, 
offset
);

7726 
	}
}

7727 static int 
	$sqlite3OsTruncate
(
sqlite3_file
 *
id
, 
i64
 
size
)

7730 return 
id
->
pMethods
->
	`xTruncate
(id, 
size
);

7731 
	}
}

7732 static int 
	$sqlite3OsSync
(
sqlite3_file
 *
id
, int 
flags
)

7736 return 
id
->
pMethods
->
	`xSync
(id, 
flags
);

7737 
	}
}

7738 static int 
	$sqlite3OsFileSize
(
sqlite3_file
 *
id
, 
i64
 *
pSize
)

7742 return 
id
->
pMethods
->
	`xFileSize
(id, 
pSize
);

7743 
	}
}

7744 static int 
	$sqlite3OsLock
(
sqlite3_file
 *
id
, int 
lockType
)

7748 return 
id
->
pMethods
->
	`xLock
(id, 
lockType
);

7749 
	}
}

7750 static int 
	$sqlite3OsUnlock
(
sqlite3_file
 *
id
, int 
lockType
)

7753 return 
id
->
pMethods
->
	`xUnlock
(id, 
lockType
);

7754 
	}
}

7755 static int 
	$sqlite3OsCheckReservedLock
(
sqlite3_file
 *
id
, int *
pResOut
)

7759 return 
id
->
pMethods
->
	`xCheckReservedLock
(id, 
pResOut
);

7760 
	}
}

7762 static int 
	$sqlite3OsFileControl
(
sqlite3_file
 *
id
, int 
op
, void *
pArg
)

7766 return 
id
->
pMethods
->
	`xFileControl
(id, 
op
, 
pArg
);

7767 
	}
}

7768 static void 
	$sqlite3OsFileControlHint
(
sqlite3_file
 *
id
, int 
op
, void *
pArg
)

7771 (void)
id
->
pMethods
->
	`xFileControl
(id, 
op
, 
pArg
);

7772 
	}
}

7774 static int 
	$sqlite3OsSectorSize
(
sqlite3_file
 *
id
)

7777 int (*
xSectorSize
)(
sqlite3_file
*) = 
id
->
pMethods
->xSectorSize;

7778 return (
xSectorSize
 ? 
	`xSectorSize
(
id
) : 4096);

7779 
	}
}

7780 static int 
	$sqlite3OsDeviceCharacteristics
(
sqlite3_file
 *
id
)

7783 return 
id
->
pMethods
->
	`xDeviceCharacteristics
(id);

7784 
	}
}

7785 static int 
	$sqlite3OsShmLock
(
sqlite3_file
 *
id
, int 
offset
, int 
n
, int 
flags
)

7788 return 
id
->
pMethods
->
	`xShmLock
(id, 
offset
, 
n
, 
flags
);

7789 
	}
}

7790 static void 
	$sqlite3OsShmBarrier
(
sqlite3_file
 *
id
)

7793 
id
->
pMethods
->
	`xShmBarrier
(id);

7794 
	}
}

7795 static int 
	$sqlite3OsShmUnmap
(
sqlite3_file
 *
id
, int 
deleteFlag
)

7798 return 
id
->
pMethods
->
	`xShmUnmap
(id, 
deleteFlag
);

7799 
	}
}

7800 static int 
	$sqlite3OsShmMap
(

7801 
sqlite3_file
 *
id
,

7802 int 
iPage
,

7803 int 
pgsz
,

7804 int 
bExtend
,

7805 void volatile **
pp


7810 return 
id
->
pMethods
->
	`xShmMap
(id, 
iPage
, 
pgsz
, 
bExtend
, 
pp
);

7811 
	}
}

7815 static int 
	$sqlite3OsFetch
(
sqlite3_file
 *
id
, 
i64
 
iOff
, int 
iAmt
, void **
pp
)

7819 return 
id
->
pMethods
->
	`xFetch
(id, 
iOff
, 
iAmt
, 
pp
);

7820 
	}
}

7821 static int 
	$sqlite3OsUnfetch
(
sqlite3_file
 *
id
, 
i64
 
iOff
, void *
p
)

7824 return 
id
->
pMethods
->
	`xUnfetch
(id, 
iOff
, 
p
);

7825 
	}
}

7827 static int 
	$sqlite3OsOpen
(

7828 
sqlite3_vfs
 *
pVfs
,

7829 const char *
zPath
,

7830 
sqlite3_file
 *
pFile
,

7831 int 
flags
,

7832 int *
pFlagsOut


7836 int 
rc
;

7842 
rc
 = 
pVfs
->
	`xOpen
(pVfs, 
zPath
, 
pFile
, 
flags
 & 0x87f7f, 
pFlagsOut
);

7844 return 
rc
;

7845 
	}
}

7846 static int 
	$sqlite3OsDelete
(
sqlite3_vfs
 *
pVfs
, const char *
zPath
, int 
dirSync
)

7851 return 
pVfs
->
	`xDelete
(pVfs, 
zPath
, 
dirSync
);

7852 
	}
}

7853 static int 
	$sqlite3OsAccess
(

7854 
sqlite3_vfs
 *
pVfs
,

7855 const char *
zPath
,

7856 int 
flags
,

7857 int *
pResOut


7862 return 
pVfs
->
	`xAccess
(pVfs, 
zPath
, 
flags
, 
pResOut
);

7863 
	}
}

7864 static int 
	$sqlite3OsFullPathname
(

7865 
sqlite3_vfs
 *
pVfs
,

7866 const char *
zPath
,

7867 int 
nPathOut
,

7868 char *
zPathOut


7873 
zPathOut
[0] = 0;

7874 return 
pVfs
->
	`xFullPathname
(pVfs, 
zPath
, 
nPathOut
, 
zPathOut
);

7875 
	}
}

7877 static void *
	$sqlite3OsDlOpen
(
sqlite3_vfs
 *
pVfs
, const char *
zPath
)

7880 return 
pVfs
->
	`xDlOpen
(pVfs, 
zPath
);

7881 
	}
}

7882 static void 
	$sqlite3OsDlError
(
sqlite3_vfs
 *
pVfs
, int 
nByte
, char *
zBufOut
)

7885 
pVfs
->
	`xDlError
(pVfs, 
nByte
, 
zBufOut
);

7886 
	}
}

7887 static void (*
	$sqlite3OsDlSym
(
sqlite3_vfs
 *
pVfs
, void *
pHdle
, const char *
zSym
))(void)

7890 return 
pVfs
->
	`xDlSym
(pVfs, 
pHdle
, 
zSym
);

7891 
	}
}

7892 static void 
	$sqlite3OsDlClose
(
sqlite3_vfs
 *
pVfs
, void *
pHandle
)

7895 
pVfs
->
	`xDlClose
(pVfs, 
pHandle
);

7896 
	}
}

7898 static int 
	$sqlite3OsRandomness
(
sqlite3_vfs
 *
pVfs
, int 
nByte
, char *
zBufOut
)

7901 return 
pVfs
->
	`xRandomness
(pVfs, 
nByte
, 
zBufOut
);

7902 
	}
}

7903 static int 
	$sqlite3OsSleep
(
sqlite3_vfs
 *
pVfs
, int 
nMicro
)

7906 return 
pVfs
->
	`xSleep
(pVfs, 
nMicro
);

7907 
	}
}

7908 static int 
	$sqlite3OsGetLastError
(
sqlite3_vfs
 *
pVfs
)

7911 return 
pVfs
->
xGetLastError
 ? pVfs->
	`xGetLastError
(pVfs, 0, 0) : 0;

7912 
	}
}

7913 static int 
	$sqlite3OsCurrentTimeInt64
(
sqlite3_vfs
 *
pVfs
, 
sqlite3_int64
 *
pTimeOut
)

7916 int 
rc
;

7923 if( 
pVfs
->
iVersion
>=2 && pVfs->
xCurrentTimeInt64
 )

7926 
rc
 = 
pVfs
->
	`xCurrentTimeInt64
(pVfs, 
pTimeOut
);

7928 double 
r
;

7929 
rc
 = 
pVfs
->
	`xCurrentTime
(pVfs, &
r
);

7930 *
pTimeOut
 = (
sqlite3_int64
)(
r
*86400000.0);

7932 return 
rc
;

7933 
	}
}

7935 static int 
	$sqlite3OsOpenMalloc
(

7936 
sqlite3_vfs
 *
pVfs
,

7937 const char *
zFile
,

7938 
sqlite3_file
 **
ppFile
,

7939 int 
flags
,

7940 int *
pOutFlags


7944 int 
rc
;

7945 
sqlite3_file
 *
pFile
;

7946 
pFile
 = (
sqlite3_file
 *)
	`sqlite3MallocZero
(
pVfs
->
szOsFile
);

7947 if( 
pFile
 )

7950 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
zFile
, 
pFile
, 
flags
, 
pOutFlags
);

7951 if( 
rc
!=0 )

7954 
	`sqlite3_free
(
pFile
);

7956 *
ppFile
 = 
pFile
;

7959 
rc
 = 7;

7961 return 
rc
;

7962 
	}
}

7963 static int 
	$sqlite3OsCloseFree
(
sqlite3_file
 *
pFile
)

7966 int 
rc
 = 0;

7968 
rc
 = 
	`sqlite3OsClose
(
pFile
);

7969 
	`sqlite3_free
(
pFile
);

7970 return 
rc
;

7971 
	}
}

7979 static int 
	$sqlite3OsInit
(void)

7982 void *
p
 = 
	`sqlite3_malloc
(10);

7983 if( 
p
==0 ) return 7;

7984 
	`sqlite3_free
(
p
);

7985 return 
	`sqlite3_os_init
();

7986 
	}
}

7991 static 
sqlite3_vfs
 * 
	gvfsList
 = 0;

7998 
sqlite3_vfs
 * 
	$sqlite3_vfs_find
(const char *
zVfs
)

8001 
sqlite3_vfs
 *
pVfs
 = 0;

8003 
sqlite3_mutex
 *
mutex
;

8006 int 
rc
 = 
	`sqlite3_initialize
();

8007 if( 
rc
 ) return 0;

8010 
mutex
 = 
	`sqlite3MutexAlloc
(2);

8012 
	`sqlite3_mutex_enter
(
mutex
);

8013 for(
pVfs
 = 
vfsList
; pVfs; pVfs=pVfs->
pNext
)

8016 if( 
zVfs
==0 ) break;

8017 if( 
	`strcmp
(
zVfs
, 
pVfs
->
zName
)==0 ) break;

8019 
	`sqlite3_mutex_leave
(
mutex
);

8020 return 
pVfs
;

8021 
	}
}

8026 static void 
	$vfsUnlink
(
sqlite3_vfs
 *
pVfs
)

8030 if( 
pVfs
==0 )

8034 }else if( 
vfsList
==
pVfs
 )

8037 
vfsList
 = 
pVfs
->
pNext
;

8038 }else if( 
vfsList
 )

8041 
sqlite3_vfs
 *
p
 = 
vfsList
;

8042 while( 
p
->
pNext
 && p->pNext!=
pVfs
 )

8045 
p
 = p->
pNext
;

8047 if( 
p
->
pNext
==
pVfs
 )

8050 
p
->
pNext
 = 
pVfs
->pNext;

8053 
	}
}

8060 int 
	$sqlite3_vfs_register
(
sqlite3_vfs
 *
pVfs
, int 
makeDflt
)

8063 
sqlite3_mutex
 *
mutex
;

8065 int 
rc
 = 
	`sqlite3_initialize
();

8066 if( 
rc
 ) return rc;

8072 
mutex
 = 
	`sqlite3MutexAlloc
(2);

8073 
	`sqlite3_mutex_enter
(
mutex
);

8074 
	`vfsUnlink
(
pVfs
);

8075 if( 
makeDflt
 || 
vfsList
==0 )

8078 
pVfs
->
pNext
 = 
vfsList
;

8079 
vfsList
 = 
pVfs
;

8081 
pVfs
->
pNext
 = 
vfsList
->pNext;

8082 
vfsList
->
pNext
 = 
pVfs
;

8085 
	`sqlite3_mutex_leave
(
mutex
);

8087 
	}
}

8092 int 
	$sqlite3_vfs_unregister
(
sqlite3_vfs
 *
pVfs
)

8096 
sqlite3_mutex
 *
mutex
 = 
	`sqlite3MutexAlloc
(2);

8098 
	`sqlite3_mutex_enter
(
mutex
);

8099 
	`vfsUnlink
(
pVfs
);

8100 
	`sqlite3_mutex_leave
(
mutex
);

8102 
	}
}

8104 typedef struct 
BenignMallocHooks
 
	tBenignMallocHooks
;

8105 static struct 
	sBenignMallocHooks
 {

8106 void (*
	mxBenignBegin
)(void);

8107 void (*
	mxBenignEnd
)(void);

8108 } 
	gsqlite3Hooks
 = { 0, 0 };

8110 static void 
sqlite3BenignMallocHooks
(

8111 void (*
xBenignBegin
)(void),

8112 void (*
xBenignEnd
)(void)

8117 
sqlite3Hooks
.
xBenignBegin
 = xBenignBegin;

8118 
sqlite3Hooks
.
xBenignEnd
 = xBenignEnd;

8119 
	}
}

8126 static void 
	$sqlite3BeginBenignMalloc
(void)

8130 if( 
sqlite3Hooks
.
xBenignBegin
 )

8133 
sqlite3Hooks
.
	`xBenignBegin
();

8135 
	}
}

8136 static void 
	$sqlite3EndBenignMalloc
(void)

8140 if( 
sqlite3Hooks
.
xBenignEnd
 )

8143 
sqlite3Hooks
.
	`xBenignEnd
();

8145 
	}
}

8147 static void *
	$sqlite3MemMalloc
(int 
nByte
)

8151 
sqlite3_int64
 *
p
;

8153 
nByte
 = (((nByte)+7)&~7);

8154 
p
 = 
	`malloc
(
nByte
+8);

8155 if( 
p
 )

8158 
p
[0] = 
nByte
;

8159 
p
++;

8162 
	`sqlite3_log
(7, "failed to allocate %u bytes of memory", 
nByte
);

8164 return (void *)
p
;

8166 
	}
}

8168 static void 
	$sqlite3MemFree
(void *
pPrior
)

8174 
sqlite3_int64
 *
p
 = (sqlite3_int64*)
pPrior
;

8176 
p
--;

8177 
	`free
(
p
);

8179 
	}
}

8185 static int 
	$sqlite3MemSize
(void *
pPrior
)

8192 
sqlite3_int64
 *
p
;

8194 
p
 = (
sqlite3_int64
*)
pPrior
;

8195 
p
--;

8196 return (int)
p
[0];

8198 
	}
}

8200 static void *
	$sqlite3MemRealloc
(void *
pPrior
, int 
nByte
)

8204 
sqlite3_int64
 *
p
 = (sqlite3_int64*)
pPrior
;

8207 
p
--;

8208 
p
 = 
	`realloc
((p),(
nByte
+8));

8209 if( 
p
 )

8212 
p
[0] = 
nByte
;

8213 
p
++;

8216 
	`sqlite3_log
(7,

8218 
	`sqlite3MemSize
(
pPrior
), 
nByte
);

8220 return (void*)
p
;

8222 
	}
}

8227 static int 
	$sqlite3MemRoundup
(int 
n
)

8230 return (((
n
)+7)&~7);

8231 
	}
}

8236 static int 
	$sqlite3MemInit
(void *
NotUsed
)

8240 (void)(
NotUsed
);

8242 
	}
}

8247 static void 
	$sqlite3MemShutdown
(void *
NotUsed
)

8250 (void)(
NotUsed
);

8252 
	}
}

8260 static void 
	$sqlite3MemSetDefault
(void)

8263 static const 
sqlite3_mem_methods
 
defaultMethods
 = {

8264 
sqlite3MemMalloc
,

8265 
sqlite3MemFree
,

8266 
sqlite3MemRealloc
,

8267 
sqlite3MemSize
,

8268 
sqlite3MemRoundup
,

8269 
sqlite3MemInit
,

8270 
sqlite3MemShutdown
,

8273 
	`sqlite3_config
(4, &
defaultMethods
);

8274 
	}
}

8276 static int 
	$sqlite3MutexInit
(void)

8279 int 
rc
 = 0;

8280 if( !
sqlite3Config
.
mutex
.
xMutexAlloc
 )

8288 
sqlite3_mutex_methods
 const *
pFrom
;

8289 
sqlite3_mutex_methods
 *
pTo
 = &
sqlite3Config
.
mutex
;

8291 if( 
sqlite3Config
.
bCoreMutex
 )

8294 
pFrom
 = 
	`sqlite3DefaultMutex
();

8296 
pFrom
 = 
	`sqlite3NoopMutex
();

8298 
pTo
->
xMutexInit
 = 
pFrom
->xMutexInit;

8299 
pTo
->
xMutexEnd
 = 
pFrom
->xMutexEnd;

8300 
pTo
->
xMutexFree
 = 
pFrom
->xMutexFree;

8301 
pTo
->
xMutexEnter
 = 
pFrom
->xMutexEnter;

8302 
pTo
->
xMutexTry
 = 
pFrom
->xMutexTry;

8303 
pTo
->
xMutexLeave
 = 
pFrom
->xMutexLeave;

8304 
pTo
->
xMutexHeld
 = 
pFrom
->xMutexHeld;

8305 
pTo
->
xMutexNotheld
 = 
pFrom
->xMutexNotheld;

8306 
	`sqlite3MemoryBarrier
();

8307 
pTo
->
xMutexAlloc
 = 
pFrom
->xMutexAlloc;

8310 
rc
 = 
sqlite3Config
.
mutex
.
	`xMutexInit
();

8316 return 
rc
;

8317 
	}
}

8323 static int 
	$sqlite3MutexEnd
(void)

8326 int 
rc
 = 0;

8327 if( 
sqlite3Config
.
mutex
.
xMutexEnd
 )

8330 
rc
 = 
sqlite3Config
.
mutex
.
	`xMutexEnd
();

8337 return 
rc
;

8338 
	}
}

8343 
sqlite3_mutex
 * 
	$sqlite3_mutex_alloc
(int 
id
)

8347 if( 
id
<=1 && 
	`sqlite3_initialize
() ) return 0;

8348 if( 
id
>1 && 
	`sqlite3MutexInit
() ) return 0;

8351 return 
sqlite3Config
.
mutex
.
	`xMutexAlloc
(
id
);

8352 
	}
}

8354 static 
sqlite3_mutex
 *
	$sqlite3MutexAlloc
(int 
id
)

8357 if( !
sqlite3Config
.
bCoreMutex
 )

8364 return 
sqlite3Config
.
mutex
.
	`xMutexAlloc
(
id
);

8365 
	}
}

8370 void 
	$sqlite3_mutex_free
(
sqlite3_mutex
 *
p
)

8373 if( 
p
 )

8377 
sqlite3Config
.
mutex
.
	`xMutexFree
(
p
);

8379 
	}
}

8385 void 
	$sqlite3_mutex_enter
(
sqlite3_mutex
 *
p
)

8388 if( 
p
 )

8392 
sqlite3Config
.
mutex
.
	`xMutexEnter
(
p
);

8394 
	}
}

8400 int 
	$sqlite3_mutex_try
(
sqlite3_mutex
 *
p
)

8403 int 
rc
 = 0;

8404 if( 
p
 )

8408 return 
sqlite3Config
.
mutex
.
	`xMutexTry
(
p
);

8410 return 
rc
;

8411 
	}
}

8419 void 
	$sqlite3_mutex_leave
(
sqlite3_mutex
 *
p
)

8422 if( 
p
 )

8426 
sqlite3Config
.
mutex
.
	`xMutexLeave
(
p
);

8428 
	}
}

8430 static int 
	$noopMutexInit
(void)

8432 return 0; 
	}
}

8433 static int 
	$noopMutexEnd
(void)

8435 return 0; 
	}
}

8436 static 
sqlite3_mutex
 *
	$noopMutexAlloc
(int 
id
)

8439 (void)(
id
);

8440 return (
sqlite3_mutex
*)8;

8441 
	}
}

8442 static void 
	$noopMutexFree
(
sqlite3_mutex
 *
p
)

8444 (void)(
p
); return; 
	}
}

8445 static void 
	$noopMutexEnter
(
sqlite3_mutex
 *
p
)

8447 (void)(
p
); return; 
	}
}

8448 static int 
	$noopMutexTry
(
sqlite3_mutex
 *
p
)

8451 (void)(
p
);

8453 
	}
}

8454 static void 
	$noopMutexLeave
(
sqlite3_mutex
 *
p
)

8456 (void)(
p
); return; 
	}
}

8458 static 
sqlite3_mutex_methods
 const *
	$sqlite3NoopMutex
(void)

8461 static const 
sqlite3_mutex_methods
 
sMutex
 = {

8462 
noopMutexInit
,

8463 
noopMutexEnd
,

8464 
noopMutexAlloc
,

8465 
noopMutexFree
,

8466 
noopMutexEnter
,

8467 
noopMutexTry
,

8468 
noopMutexLeave
,

8474 return &
sMutex
;

8475 
	}
}

8486 struct 
	ssched_param


8488 int 
	m__sched_priority
;

8495 extern int 
clone
 (int (*
__fn
) (void *
__arg
), void *
__child_stack
,

8496 int 
__flags
, void *
__arg
, ...) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8499 extern int 
	$unshare
 (int 
__flags
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8502 extern int 
	$sched_getcpu
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8505 extern int 
	$setns
 (int 
__fd
, int 
__nstype
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8517 struct 
	s__sched_param


8519 int 
__sched_priority
;

8522 typedef unsigned long int 
	t__cpu_mask
;

8531 
__cpu_mask
 
__bits
[1024 / (8 * sizeof (__cpu_mask))];

8532 } 
	tcpu_set_t
;

8536 extern int 
	$__sched_cpucount
 (
size_t
 
__setsize
, const 
cpu_set_t
 *
__setp
)

8537 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8538 extern 
cpu_set_t
 *
	$__sched_cpualloc
 (
size_t
 
__count
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

8539 extern void 
	$__sched_cpufree
 (
cpu_set_t
 *
__set
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8550 extern int 
	$sched_setparam
 (
__pid_t
 
__pid
, const struct 
sched_param
 *
__param
)

8551 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8554 extern int 
	$sched_getparam
 (
__pid_t
 
__pid
, struct 
sched_param
 *
__param
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8557 extern int 
	$sched_setscheduler
 (
__pid_t
 
__pid
, int 
__policy
,

8558 const struct 
sched_param
 *
__param
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8561 extern int 
	$sched_getscheduler
 (
__pid_t
 
__pid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8564 extern int 
	$sched_yield
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8567 extern int 
	$sched_get_priority_max
 (int 
__algorithm
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8570 extern int 
	$sched_get_priority_min
 (int 
__algorithm
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8573 extern int 
	$sched_rr_get_interval
 (
__pid_t
 
__pid
, struct 
timespec
 *
__t
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8575 extern int 
	$sched_setaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

8576 const 
cpu_set_t
 *
__cpuset
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8579 extern int 
	$sched_getaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

8580 
cpu_set_t
 *
__cpuset
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8596 typedef long int 
	t__jmp_buf
[8];

8605 
PTHREAD_CREATE_JOINABLE
,

8607 
PTHREAD_CREATE_DETACHED


8615 
PTHREAD_MUTEX_TIMED_NP
,

8616 
PTHREAD_MUTEX_RECURSIVE_NP
,

8617 
PTHREAD_MUTEX_ERRORCHECK_NP
,

8618 
PTHREAD_MUTEX_ADAPTIVE_NP


8621 
PTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

8622 
PTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

8623 
PTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

8624 
PTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


8628 , 
PTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


8637 
PTHREAD_MUTEX_STALLED
,

8638 
PTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

8639 
PTHREAD_MUTEX_ROBUST
,

8640 
PTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


8649 
PTHREAD_PRIO_NONE
,

8650 
PTHREAD_PRIO_INHERIT
,

8651 
PTHREAD_PRIO_PROTECT


8656 
PTHREAD_RWLOCK_PREFER_READER_NP
,

8657 
PTHREAD_RWLOCK_PREFER_WRITER_NP
,

8658 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

8659 
PTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


8664 
PTHREAD_INHERIT_SCHED
,

8666 
PTHREAD_EXPLICIT_SCHED


8674 
PTHREAD_SCOPE_SYSTEM
,

8676 
PTHREAD_SCOPE_PROCESS


8684 
PTHREAD_PROCESS_PRIVATE
,

8686 
PTHREAD_PROCESS_SHARED


8690 struct 
	s_pthread_cleanup_buffer


8692 void (*
__routine
) (void *);

8693 void *
__arg
;

8694 int 
__canceltype
;

8695 struct 
_pthread_cleanup_buffer
 *
__prev
;

8701 
PTHREAD_CANCEL_ENABLE
,

8703 
PTHREAD_CANCEL_DISABLE


8708 
PTHREAD_CANCEL_DEFERRED
,

8710 
PTHREAD_CANCEL_ASYNCHRONOUS


8719 extern int 
	`pthread_create
 (
pthread_t
 *
__restrict
 
__newthread
,

8720 const 
pthread_attr_t
 *
__restrict
 
__attr
,

8721 void *(*
__start_routine
) (void *),

8722 void *
__restrict
 
__arg
) 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

8728 extern void 
	$pthread_exit
 (void *
__retval
) 
	`__attribute__
 ((
__noreturn__
));

8736 extern int 
	`pthread_join
 (
pthread_t
 
__th
, void **
__thread_return
);

8741 extern int 
	$pthread_tryjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8749 extern int 
	`pthread_timedjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
,

8750 const struct 
timespec
 *
__abstime
);

8757 extern int 
	$pthread_detach
 (
pthread_t
 
__th
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8761 extern 
pthread_t
 
	$pthread_self
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

8764 extern int 
	$pthread_equal
 (
pthread_t
 
__thread1
, pthread_t 
__thread2
)

8765 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

8773 extern int 
	$pthread_attr_init
 (
pthread_attr_t
 *
__attr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8776 extern int 
	$pthread_attr_destroy
 (
pthread_attr_t
 *
__attr
)

8777 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8780 extern int 
	$pthread_attr_getdetachstate
 (const 
pthread_attr_t
 *
__attr
,

8781 int *
__detachstate
)

8782 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8785 extern int 
	$pthread_attr_setdetachstate
 (
pthread_attr_t
 *
__attr
,

8786 int 
__detachstate
)

8787 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8791 extern int 
	$pthread_attr_getguardsize
 (const 
pthread_attr_t
 *
__attr
,

8792 
size_t
 *
__guardsize
)

8793 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8796 extern int 
	$pthread_attr_setguardsize
 (
pthread_attr_t
 *
__attr
,

8797 
size_t
 
__guardsize
)

8798 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8802 extern int 
	$pthread_attr_getschedparam
 (const 
pthread_attr_t
 *
__restrict
 
__attr
,

8803 struct 
sched_param
 *
__restrict
 
__param
)

8804 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8807 extern int 
	$pthread_attr_setschedparam
 (
pthread_attr_t
 *
__restrict
 
__attr
,

8808 const struct 
sched_param
 *
__restrict


8809 
__param
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8812 extern int 
	$pthread_attr_getschedpolicy
 (const 
pthread_attr_t
 *
__restrict


8813 
__attr
, int *
__restrict
 
__policy
)

8814 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8817 extern int 
	$pthread_attr_setschedpolicy
 (
pthread_attr_t
 *
__attr
, int 
__policy
)

8818 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8821 extern int 
	$pthread_attr_getinheritsched
 (const 
pthread_attr_t
 *
__restrict


8822 
__attr
, int *
__restrict
 
__inherit
)

8823 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8826 extern int 
	$pthread_attr_setinheritsched
 (
pthread_attr_t
 *
__attr
,

8827 int 
__inherit
)

8828 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8832 extern int 
	$pthread_attr_getscope
 (const 
pthread_attr_t
 *
__restrict
 
__attr
,

8833 int *
__restrict
 
__scope
)

8834 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8837 extern int 
	$pthread_attr_setscope
 (
pthread_attr_t
 *
__attr
, int 
__scope
)

8838 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8841 extern int 
	$pthread_attr_getstackaddr
 (const 
pthread_attr_t
 *
__restrict


8842 
__attr
, void **
__restrict
 
__stackaddr
)

8843 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	$__nonnull__
 (1, 2))) 
	`__attribute__
 ((
__deprecated__
));

8849 extern int 
	$pthread_attr_setstackaddr
 (
pthread_attr_t
 *
__attr
,

8850 void *
__stackaddr
)

8851 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	$__nonnull__
 (1))) 
	`__attribute__
 ((
__deprecated__
));

8854 extern int 
	$pthread_attr_getstacksize
 (const 
pthread_attr_t
 *
__restrict


8855 
__attr
, 
size_t
 *
__restrict
 
__stacksize
)

8856 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

8861 extern int 
	$pthread_attr_setstacksize
 (
pthread_attr_t
 *
__attr
,

8862 
size_t
 
__stacksize
)

8863 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8867 extern int 
	$pthread_attr_getstack
 (const 
pthread_attr_t
 *
__restrict
 
__attr
,

8868 void **
__restrict
 
__stackaddr
,

8869 
size_t
 *
__restrict
 
__stacksize
)

8870 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2, 3)));

8875 extern int 
	$pthread_attr_setstack
 (
pthread_attr_t
 *
__attr
, void *
__stackaddr
,

8876 
size_t
 
__stacksize
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8882 extern int 
	$pthread_attr_setaffinity_np
 (
pthread_attr_t
 *
__attr
,

8883 
size_t
 
__cpusetsize
,

8884 const 
cpu_set_t
 *
__cpuset
)

8885 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

8889 extern int 
	$pthread_attr_getaffinity_np
 (const 
pthread_attr_t
 *
__attr
,

8890 
size_t
 
__cpusetsize
,

8891 
cpu_set_t
 *
__cpuset
)

8892 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

8895 extern int 
	$pthread_getattr_default_np
 (
pthread_attr_t
 *
__attr
)

8896 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8900 extern int 
	$pthread_setattr_default_np
 (const 
pthread_attr_t
 *
__attr
)

8901 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

8906 extern int 
	$pthread_getattr_np
 (
pthread_t
 
__th
, 
pthread_attr_t
 *
__attr
)

8907 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

8915 extern int 
	$pthread_setschedparam
 (
pthread_t
 
__target_thread
, int 
__policy
,

8916 const struct 
sched_param
 *
__param
)

8917 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3)));

8920 extern int 
	$pthread_getschedparam
 (
pthread_t
 
__target_thread
,

8921 int *
__restrict
 
__policy
,

8922 struct 
sched_param
 *
__restrict
 
__param
)

8923 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

8926 extern int 
	$pthread_setschedprio
 (
pthread_t
 
__target_thread
, int 
__prio
)

8927 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8932 extern int 
	$pthread_getname_np
 (
pthread_t
 
__target_thread
, char *
__buf
,

8933 
size_t
 
__buflen
)

8934 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

8937 extern int 
	$pthread_setname_np
 (
pthread_t
 
__target_thread
, const char *
__name
)

8938 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

8944 extern int 
	$pthread_getconcurrency
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8947 extern int 
	$pthread_setconcurrency
 (int 
__level
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8955 extern int 
	$pthread_yield
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

8960 extern int 
	$pthread_setaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

8961 const 
cpu_set_t
 *
__cpuset
)

8962 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3)));

8965 extern int 
	$pthread_getaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

8966 
cpu_set_t
 *
__cpuset
)

8967 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3)));

8969 extern int 
	`pthread_once
 (
pthread_once_t
 *
__once_control
,

8970 void (*
__init_routine
) (void)) 
	`__attribute__
 ((
	`__nonnull__
 (1, 2)));

8972 extern int 
	`pthread_setcancelstate
 (int 
__state
, int *
__oldstate
);

8976 extern int 
	`pthread_setcanceltype
 (int 
__type
, int *
__oldtype
);

8979 extern int 
	`pthread_cancel
 (
pthread_t
 
__th
);

8984 extern void 
	`pthread_testcancel
 (void);

8993 
__jmp_buf
 
__cancel_jmp_buf
;

8994 int 
__mask_was_saved
;

8995 } 
__cancel_jmp_buf
[1];

8996 void *
__pad
[4];

8997 } 
	t__pthread_unwind_buf_t
 
	t__attribute__
 ((
	t__aligned__
));

8999 struct 
	s__pthread_cleanup_frame


9001 void (*
__cancel_routine
) (void *);

9002 void *
__cancel_arg
;

9003 int 
__do_it
;

9004 int 
__cancel_type
;

9007 extern void 
	`__pthread_register_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

9010 extern void 
	`__pthread_unregister_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

9013 extern void 
	`__pthread_register_cancel_defer
 (
__pthread_unwind_buf_t
 *
__buf
)

9016 extern void 
	`__pthread_unregister_cancel_restore
 (
__pthread_unwind_buf_t
 *
__buf
)

9021 extern void 
	$__pthread_unwind_next
 (
__pthread_unwind_buf_t
 *
__buf
)

9022 
	`__attribute__
 ((
__noreturn__
))

9024 
	`__attribute__
 ((
__weak__
))

9030 struct 
__jmp_buf_tag
;

9031 extern int 
	$__sigsetjmp
 (struct 
__jmp_buf_tag
 *
__env
, int 
__savemask
) 
	`__attribute__
 ((
__nothrow__
));

9037 extern int 
	$pthread_mutex_init
 (
pthread_mutex_t
 *
__mutex
,

9038 const 
pthread_mutexattr_t
 *
__mutexattr
)

9039 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9042 extern int 
	$pthread_mutex_destroy
 (
pthread_mutex_t
 *
__mutex
)

9043 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9046 extern int 
	$pthread_mutex_trylock
 (
pthread_mutex_t
 *
__mutex
)

9047 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9050 extern int 
	$pthread_mutex_lock
 (
pthread_mutex_t
 *
__mutex
)

9051 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9055 extern int 
	$pthread_mutex_timedlock
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

9056 const struct 
timespec
 *
__restrict


9057 
__abstime
) 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9061 extern int 
	$pthread_mutex_unlock
 (
pthread_mutex_t
 *
__mutex
)

9062 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9066 extern int 
	$pthread_mutex_getprioceiling
 (const 
pthread_mutex_t
 *

9067 
__restrict
 
__mutex
,

9068 int *
__restrict
 
__prioceiling
)

9069 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9073 extern int 
	$pthread_mutex_setprioceiling
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

9074 int 
__prioceiling
,

9075 int *
__restrict
 
__old_ceiling
)

9076 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

9081 extern int 
	$pthread_mutex_consistent
 (
pthread_mutex_t
 *
__mutex
)

9082 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9084 extern int 
	$pthread_mutex_consistent_np
 (
pthread_mutex_t
 *
__mutex
)

9085 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9087 extern int 
	$pthread_mutexattr_init
 (
pthread_mutexattr_t
 *
__attr
)

9088 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9091 extern int 
	$pthread_mutexattr_destroy
 (
pthread_mutexattr_t
 *
__attr
)

9092 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9095 extern int 
	$pthread_mutexattr_getpshared
 (const 
pthread_mutexattr_t
 *

9096 
__restrict
 
__attr
,

9097 int *
__restrict
 
__pshared
)

9098 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9101 extern int 
	$pthread_mutexattr_setpshared
 (
pthread_mutexattr_t
 *
__attr
,

9102 int 
__pshared
)

9103 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9107 extern int 
	$pthread_mutexattr_gettype
 (const 
pthread_mutexattr_t
 *
__restrict


9108 
__attr
, int *
__restrict
 
__kind
)

9109 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9114 extern int 
	$pthread_mutexattr_settype
 (
pthread_mutexattr_t
 *
__attr
, int 
__kind
)

9115 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9119 extern int 
	$pthread_mutexattr_getprotocol
 (const 
pthread_mutexattr_t
 *

9120 
__restrict
 
__attr
,

9121 int *
__restrict
 
__protocol
)

9122 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9126 extern int 
	$pthread_mutexattr_setprotocol
 (
pthread_mutexattr_t
 *
__attr
,

9127 int 
__protocol
)

9128 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9131 extern int 
	$pthread_mutexattr_getprioceiling
 (const 
pthread_mutexattr_t
 *

9132 
__restrict
 
__attr
,

9133 int *
__restrict
 
__prioceiling
)

9134 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9137 extern int 
	$pthread_mutexattr_setprioceiling
 (
pthread_mutexattr_t
 *
__attr
,

9138 int 
__prioceiling
)

9139 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9143 extern int 
	$pthread_mutexattr_getrobust
 (const 
pthread_mutexattr_t
 *
__attr
,

9144 int *
__robustness
)

9145 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9147 extern int 
	$pthread_mutexattr_getrobust_np
 (const 
pthread_mutexattr_t
 *
__attr
,

9148 int *
__robustness
)

9149 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9153 extern int 
	$pthread_mutexattr_setrobust
 (
pthread_mutexattr_t
 *
__attr
,

9154 int 
__robustness
)

9155 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9157 extern int 
	$pthread_mutexattr_setrobust_np
 (
pthread_mutexattr_t
 *
__attr
,

9158 int 
__robustness
)

9159 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9161 extern int 
	$pthread_rwlock_init
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

9162 const 
pthread_rwlockattr_t
 *
__restrict


9163 
__attr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9166 extern int 
	$pthread_rwlock_destroy
 (
pthread_rwlock_t
 *
__rwlock
)

9167 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9170 extern int 
	$pthread_rwlock_rdlock
 (
pthread_rwlock_t
 *
__rwlock
)

9171 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9174 extern int 
	$pthread_rwlock_tryrdlock
 (
pthread_rwlock_t
 *
__rwlock
)

9175 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9179 extern int 
	$pthread_rwlock_timedrdlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

9180 const struct 
timespec
 *
__restrict


9181 
__abstime
) 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9185 extern int 
	$pthread_rwlock_wrlock
 (
pthread_rwlock_t
 *
__rwlock
)

9186 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9189 extern int 
	$pthread_rwlock_trywrlock
 (
pthread_rwlock_t
 *
__rwlock
)

9190 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9194 extern int 
	$pthread_rwlock_timedwrlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

9195 const struct 
timespec
 *
__restrict


9196 
__abstime
) 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9200 extern int 
	$pthread_rwlock_unlock
 (
pthread_rwlock_t
 *
__rwlock
)

9201 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9207 extern int 
	$pthread_rwlockattr_init
 (
pthread_rwlockattr_t
 *
__attr
)

9208 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9211 extern int 
	$pthread_rwlockattr_destroy
 (
pthread_rwlockattr_t
 *
__attr
)

9212 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9215 extern int 
	$pthread_rwlockattr_getpshared
 (const 
pthread_rwlockattr_t
 *

9216 
__restrict
 
__attr
,

9217 int *
__restrict
 
__pshared
)

9218 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9221 extern int 
	$pthread_rwlockattr_setpshared
 (
pthread_rwlockattr_t
 *
__attr
,

9222 int 
__pshared
)

9223 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9226 extern int 
	$pthread_rwlockattr_getkind_np
 (const 
pthread_rwlockattr_t
 *

9227 
__restrict
 
__attr
,

9228 int *
__restrict
 
__pref
)

9229 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9232 extern int 
	$pthread_rwlockattr_setkind_np
 (
pthread_rwlockattr_t
 *
__attr
,

9233 int 
__pref
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9241 extern int 
	$pthread_cond_init
 (
pthread_cond_t
 *
__restrict
 
__cond
,

9242 const 
pthread_condattr_t
 *
__restrict
 
__cond_attr
)

9243 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9246 extern int 
	$pthread_cond_destroy
 (
pthread_cond_t
 *
__cond
)

9247 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9250 extern int 
	$pthread_cond_signal
 (
pthread_cond_t
 *
__cond
)

9251 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9254 extern int 
	$pthread_cond_broadcast
 (
pthread_cond_t
 *
__cond
)

9255 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9262 extern int 
	$pthread_cond_wait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

9263 
pthread_mutex_t
 *
__restrict
 
__mutex
)

9264 
	`__attribute__
 ((
	`__nonnull__
 (1, 2)));

9266 extern int 
	$pthread_cond_timedwait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

9267 
pthread_mutex_t
 *
__restrict
 
__mutex
,

9268 const struct 
timespec
 *
__restrict
 
__abstime
)

9269 
	`__attribute__
 ((
	`__nonnull__
 (1, 2, 3)));

9274 extern int 
	$pthread_condattr_init
 (
pthread_condattr_t
 *
__attr
)

9275 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9278 extern int 
	$pthread_condattr_destroy
 (
pthread_condattr_t
 *
__attr
)

9279 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9282 extern int 
	$pthread_condattr_getpshared
 (const 
pthread_condattr_t
 *

9283 
__restrict
 
__attr
,

9284 int *
__restrict
 
__pshared
)

9285 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9288 extern int 
	$pthread_condattr_setpshared
 (
pthread_condattr_t
 *
__attr
,

9289 int 
__pshared
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9293 extern int 
	$pthread_condattr_getclock
 (const 
pthread_condattr_t
 *

9294 
__restrict
 
__attr
,

9295 
__clockid_t
 *
__restrict
 
__clock_id
)

9296 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9299 extern int 
	$pthread_condattr_setclock
 (
pthread_condattr_t
 *
__attr
,

9300 
__clockid_t
 
__clock_id
)

9301 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9303 extern int 
	$pthread_spin_init
 (
pthread_spinlock_t
 *
__lock
, int 
__pshared
)

9304 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9307 extern int 
	$pthread_spin_destroy
 (
pthread_spinlock_t
 *
__lock
)

9308 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9311 extern int 
	$pthread_spin_lock
 (
pthread_spinlock_t
 *
__lock
)

9312 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9315 extern int 
	$pthread_spin_trylock
 (
pthread_spinlock_t
 *
__lock
)

9316 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9319 extern int 
	$pthread_spin_unlock
 (
pthread_spinlock_t
 *
__lock
)

9320 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9327 extern int 
	$pthread_barrier_init
 (
pthread_barrier_t
 *
__restrict
 
__barrier
,

9328 const 
pthread_barrierattr_t
 *
__restrict


9329 
__attr
, unsigned int 
__count
)

9330 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9333 extern int 
	$pthread_barrier_destroy
 (
pthread_barrier_t
 *
__barrier
)

9334 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9337 extern int 
	$pthread_barrier_wait
 (
pthread_barrier_t
 *
__barrier
)

9338 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

9342 extern int 
	$pthread_barrierattr_init
 (
pthread_barrierattr_t
 *
__attr
)

9343 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9346 extern int 
	$pthread_barrierattr_destroy
 (
pthread_barrierattr_t
 *
__attr
)

9347 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9350 extern int 
	$pthread_barrierattr_getpshared
 (const 
pthread_barrierattr_t
 *

9351 
__restrict
 
__attr
,

9352 int *
__restrict
 
__pshared
)

9353 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

9356 extern int 
	$pthread_barrierattr_setpshared
 (
pthread_barrierattr_t
 *
__attr
,

9357 int 
__pshared
)

9358 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9360 extern int 
	`pthread_key_create
 (
pthread_key_t
 *
__key
,

9361 void (*
__destr_function
) (void *))

9362 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

9365 extern int 
	$pthread_key_delete
 (
pthread_key_t
 
__key
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

9368 extern void *
	$pthread_getspecific
 (
pthread_key_t
 
__key
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

9371 extern int 
	$pthread_setspecific
 (
pthread_key_t
 
__key
,

9372 const void *
__pointer
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

9377 extern int 
	$pthread_getcpuclockid
 (
pthread_t
 
__thread_id
,

9378 
__clockid_t
 *
__clock_id
)

9379 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

9381 extern int 
	`pthread_atfork
 (void (*
__prepare
) (void),

9382 void (*
__parent
) (void),

9383 void (*
__child
) (void)) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

9388 struct 
	ssqlite3_mutex
 {

9389 
pthread_mutex_t
 
mutex
;

9393 static void 
	$sqlite3MemoryBarrier
(void)

9399 
	`__sync_synchronize
();

9401 
	}
}

9406 static int 
	$pthreadMutexInit
(void)

9408 return 0; 
	}
}

9409 static int 
	$pthreadMutexEnd
(void)

9411 return 0; 
	}
}

9413 static 
sqlite3_mutex
 *
	$pthreadMutexAlloc
(int 
iType
)

9416 static 
sqlite3_mutex
 
staticMutexes
[] = {

9430 
sqlite3_mutex
 *
p
;

9431 switch( 
iType
 )

9435 
p
 = 
	`sqlite3MallocZero
( sizeof(*p) );

9436 if( 
p
 )

9445 
pthread_mutexattr_t
 
recursiveAttr
;

9446 
	`pthread_mutexattr_init
(&
recursiveAttr
);

9447 
	`pthread_mutexattr_settype
(&
recursiveAttr
, 
PTHREAD_MUTEX_RECURSIVE
);

9448 
	`pthread_mutex_init
(&
p
->
mutex
, &
recursiveAttr
);

9449 
	`pthread_mutexattr_destroy
(&
recursiveAttr
);

9455 
p
 = 
	`sqlite3MallocZero
( sizeof(*p) );

9456 if( 
p
 )

9459 
	`pthread_mutex_init
(&
p
->
mutex
, 0);

9470 
p
 = &
staticMutexes
[
iType
-2];

9477 return 
p
;

9478 
	}
}

9486 static void 
	$pthreadMutexFree
(
sqlite3_mutex
 *
p
)

9494 
	`pthread_mutex_destroy
(&
p
->
mutex
);

9495 
	`sqlite3_free
(
p
);

9502 
	}
}

9504 static void 
	$pthreadMutexEnter
(
sqlite3_mutex
 *
p
)

9509 
	`pthread_mutex_lock
(&
p
->
mutex
);

9511 
	}
}

9512 static int 
	$pthreadMutexTry
(
sqlite3_mutex
 *
p
)

9515 int 
rc
;

9518 if( 
	`pthread_mutex_trylock
(&
p
->
mutex
)==0 )

9525 
rc
 = 0;

9527 
rc
 = 5;

9536 return 
rc
;

9537 
	}
}

9545 static void 
	$pthreadMutexLeave
(
sqlite3_mutex
 *
p
)

9560 
	`pthread_mutex_unlock
(&
p
->
mutex
);

9568 
	}
}

9570 static 
sqlite3_mutex_methods
 const *
	$sqlite3DefaultMutex
(void)

9573 static const 
sqlite3_mutex_methods
 
sMutex
 = {

9574 
pthreadMutexInit
,

9575 
pthreadMutexEnd
,

9576 
pthreadMutexAlloc
,

9577 
pthreadMutexFree
,

9578 
pthreadMutexEnter
,

9579 
pthreadMutexTry
,

9580 
pthreadMutexLeave
,

9590 return &
sMutex
;

9591 
	}
}

9593 int 
	$sqlite3_release_memory
(int 
n
)

9602 (void)(
n
);

9605 
	}
}

9611 typedef struct 
	sScratchFreeslot
 {

9612 struct 
ScratchFreeslot
 *
	mpNext
;

9613 } 
	tScratchFreeslot
;

9618 static struct 
	sMem0Global
 {

9619 
sqlite3_mutex
 *
	mmutex
;

9620 
sqlite3_int64
 
	malarmThreshold
;

9628 void *
	mpScratchEnd
;

9629 
ScratchFreeslot
 *
	mpScratchFree
;

9630 
u32
 
	mnScratchFree
;

9636 int 
	mnearlyFull
;

9637 } 
	gmem0
 = { 0, 0, 0, 0, 0, 0 };

9644 static 
sqlite3_mutex
 *
	$sqlite3MallocMutex
(void)

9647 return 
mem0
.
mutex
;

9648 
	}
}

9656 int 
sqlite3_memory_alarm
(

9657 void(*
xCallback
)(void *
pArg
, 
sqlite3_int64
 
used
,int 
N
),

9658 void *
pArg
,

9659 
sqlite3_int64
 
iThreshold


9663 (void)
xCallback
;

9664 (void)
pArg
;

9665 (void)
iThreshold
;

9667 
	}
}

9674 
sqlite3_int64
 
	$sqlite3_soft_heap_limit64
(
sqlite3_int64
 
n
)

9677 
sqlite3_int64
 
priorLimit
;

9678 
sqlite3_int64
 
excess
;

9679 
sqlite3_int64
 
nUsed
;

9681 int 
rc
 = 
	`sqlite3_initialize
();

9682 if( 
rc
 ) return -1;

9684 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

9685 
priorLimit
 = 
mem0
.
alarmThreshold
;

9686 if( 
n
<0 )

9689 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9690 return 
priorLimit
;

9692 
mem0
.
alarmThreshold
 = 
n
;

9693 
nUsed
 = 
	`sqlite3StatusValue
(0);

9694 
mem0
.
nearlyFull
 = (
n
>0 && n<=
nUsed
);

9695 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9696 
excess
 = 
	`sqlite3_memory_used
() - 
n
;

9697 if( 
excess
>0 ) 
	`sqlite3_release_memory
((int)(excess & 0x7fffffff));

9698 return 
priorLimit
;

9699 
	}
}

9700 void 
	$sqlite3_soft_heap_limit
(int 
n
)

9703 if( 
n
<0 ) n = 0;

9704 
	`sqlite3_soft_heap_limit64
(
n
);

9705 
	}
}

9710 static int 
	$sqlite3MallocInit
(void)

9713 int 
rc
;

9714 if( 
sqlite3Config
.
m
.
xMalloc
==0 )

9717 
	`sqlite3MemSetDefault
();

9719 
	`memset
(&
mem0
, 0, sizeof(mem0));

9720 
mem0
.
mutex
 = 
	`sqlite3MutexAlloc
(3);

9721 if( 
sqlite3Config
.
pScratch
 && sqlite3Config.
szScratch
>=100

9722 && 
sqlite3Config
.
nScratch
>0 )

9725 int 
i
, 
n
, 
sz
;

9726 
ScratchFreeslot
 *
pSlot
;

9727 
sz
 = ((
sqlite3Config
.
szScratch
)&~7);

9728 
sqlite3Config
.
szScratch
 = 
sz
;

9729 
pSlot
 = (
ScratchFreeslot
*)
sqlite3Config
.
pScratch
;

9730 
n
 = 
sqlite3Config
.
nScratch
;

9731 
mem0
.
pScratchFree
 = 
pSlot
;

9732 
mem0
.
nScratchFree
 = 
n
;

9733 for(
i
=0; i<
n
-1; i++)

9736 
pSlot
->
pNext
 = (
ScratchFreeslot
*)(
sz
+(char*)pSlot);

9737 
pSlot
 = pSlot->
pNext
;

9739 
pSlot
->
pNext
 = 0;

9740 
mem0
.
pScratchEnd
 = (void*)&
pSlot
[1];

9742 
mem0
.
pScratchEnd
 = 0;

9743 
sqlite3Config
.
pScratch
 = 0;

9744 
sqlite3Config
.
szScratch
 = 0;

9745 
sqlite3Config
.
nScratch
 = 0;

9747 if( 
sqlite3Config
.
pPage
==0 || sqlite3Config.
szPage
<512

9748 || 
sqlite3Config
.
nPage
<=0 )

9751 
sqlite3Config
.
pPage
 = 0;

9752 
sqlite3Config
.
szPage
 = 0;

9754 
rc
 = 
sqlite3Config
.
m
.
	`xInit
(sqlite3Config.m.
pAppData
);

9755 if( 
rc
!=0 ) 
	`memset
(&
mem0
, 0, sizeof(mem0));

9756 return 
rc
;

9757 
	}
}

9764 static int 
	$sqlite3HeapNearlyFull
(void)

9767 return 
mem0
.
nearlyFull
;

9768 
	}
}

9773 static void 
	$sqlite3MallocEnd
(void)

9776 if( 
sqlite3Config
.
m
.
xShutdown
 )

9779 
sqlite3Config
.
m
.
	`xShutdown
(sqlite3Config.m.
pAppData
);

9781 
	`memset
(&
mem0
, 0, sizeof(mem0));

9782 
	}
}

9787 
sqlite3_int64
 
	$sqlite3_memory_used
(void)

9790 
sqlite3_int64
 
res
, 
mx
;

9791 
	`sqlite3_status64
(0, &
res
, &
mx
, 0);

9792 return 
res
;

9793 
	}
}

9800 
sqlite3_int64
 
	$sqlite3_memory_highwater
(int 
resetFlag
)

9803 
sqlite3_int64
 
res
, 
mx
;

9804 
	`sqlite3_status64
(0, &
res
, &
mx
, 
resetFlag
);

9805 return 
mx
;

9806 
	}
}

9811 static void 
	$sqlite3MallocAlarm
(int 
nByte
)

9814 if( 
mem0
.
alarmThreshold
<=0 ) return;

9815 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9816 
	`sqlite3_release_memory
(
nByte
);

9817 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

9818 
	}
}

9824 static int 
	$mallocWithAlarm
(int 
n
, void **
pp
)

9827 int 
nFull
;

9828 void *
p
;

9830 
nFull
 = 
sqlite3Config
.
m
.
	`xRoundup
(
n
);

9831 
	`sqlite3StatusHighwater
(5, 
n
);

9832 if( 
mem0
.
alarmThreshold
>0 )

9835 
sqlite3_int64
 
nUsed
 = 
	`sqlite3StatusValue
(0);

9836 if( 
nUsed
 >= 
mem0
.
alarmThreshold
 - 
nFull
 )

9839 
mem0
.
nearlyFull
 = 1;

9840 
	`sqlite3MallocAlarm
(
nFull
);

9842 
mem0
.
nearlyFull
 = 0;

9845 
p
 = 
sqlite3Config
.
m
.
	`xMalloc
(
nFull
);

9852 if( 
p
 )

9855 
nFull
 = 
	`sqlite3MallocSize
(
p
);

9856 
	`sqlite3StatusUp
(0, 
nFull
);

9857 
	`sqlite3StatusUp
(9, 1);

9859 *
pp
 = 
p
;

9860 return 
nFull
;

9861 
	}
}

9867 static void *
	$sqlite3Malloc
(
u64
 
n
)

9870 void *
p
;

9871 if( 
n
==0 || n>=0x7fffff00 )

9879 
p
 = 0;

9880 }else if( 
sqlite3Config
.
bMemstat
 )

9883 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

9884 
	`mallocWithAlarm
((int)
n
, &
p
);

9885 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9887 
p
 = 
sqlite3Config
.
m
.
	`xMalloc
((int)
n
);

9890 return 
p
;

9891 
	}
}

9898 void * 
	$sqlite3_malloc
(int 
n
)

9902 if( 
	`sqlite3_initialize
() ) return 0;

9904 return 
n
<=0 ? 0 : 
	`sqlite3Malloc
(n);

9905 
	}
}

9906 void * 
	$sqlite3_malloc64
(
sqlite3_uint64
 
n
)

9910 if( 
	`sqlite3_initialize
() ) return 0;

9912 return 
	`sqlite3Malloc
(
n
);

9913 
	}
}

9915 static void *
	$sqlite3ScratchMalloc
(int 
n
)

9918 void *
p
;

9921 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

9922 
	`sqlite3StatusHighwater
(8, 
n
);

9923 if( 
mem0
.
nScratchFree
 && 
sqlite3Config
.
szScratch
>=
n
 )

9926 
p
 = 
mem0
.
pScratchFree
;

9927 
mem0
.
pScratchFree
 = mem0.pScratchFree->
pNext
;

9928 
mem0
.
nScratchFree
--;

9929 
	`sqlite3StatusUp
(3, 1);

9930 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9932 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9933 
p
 = 
	`sqlite3Malloc
(
n
);

9934 if( 
sqlite3Config
.
bMemstat
 && 
p
 )

9937 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

9938 
	`sqlite3StatusUp
(4, 
	`sqlite3MallocSize
(
p
));

9939 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9945 return 
p
;

9946 
	}
}

9947 static void 
	$sqlite3ScratchFree
(void *
p
)

9950 if( 
p
 )

9954 if( (((
uptr
)(
p
)>=(uptr)(
sqlite3Config
.
pScratch
))&&((uptr)(p)<(uptr)(
mem0
.
pScratchEnd
))) )

9958 
ScratchFreeslot
 *
pSlot
;

9959 
pSlot
 = (
ScratchFreeslot
*)
p
;

9960 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

9961 
pSlot
->
pNext
 = 
mem0
.
pScratchFree
;

9962 
mem0
.
pScratchFree
 = 
pSlot
;

9963 
mem0
.
nScratchFree
++;

9965 
	`sqlite3StatusDown
(3, 1);

9966 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9972 if( 
sqlite3Config
.
bMemstat
 )

9975 int 
iSize
 = 
	`sqlite3MallocSize
(
p
);

9976 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

9977 
	`sqlite3StatusDown
(4, 
iSize
);

9978 
	`sqlite3StatusDown
(0, 
iSize
);

9979 
	`sqlite3StatusDown
(9, 1);

9980 
sqlite3Config
.
m
.
	`xFree
(
p
);

9981 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

9983 
sqlite3Config
.
m
.
	`xFree
(
p
);

9987 
	}
}

9993 static int 
	$isLookaside
(
sqlite3
 *
db
, void *
p
)

9996 return (((
uptr
)(
p
)>=(uptr)(
db
->
lookaside
.
pStart
))&&((uptr)(p)<(uptr)(db->lookaside.
pEnd
)));

9997 
	}
}

9999 static int 
	$sqlite3MallocSize
(void *
p
)

10003 return 
sqlite3Config
.
m
.
	`xSize
(
p
);

10004 
	}
}

10005 static int 
	$sqlite3DbMallocSize
(
sqlite3
 *
db
, void *
p
)

10009 if( 
db
==0 || !
	`isLookaside
(db,
p
) )

10013 return 
sqlite3Config
.
m
.
	`xSize
(
p
);

10016 return 
db
->
lookaside
.
sz
;

10018 
	}
}

10019 
sqlite3_uint64
 
	$sqlite3_msize
(void *
p
)

10024 return 
p
 ? 
sqlite3Config
.
m
.
	`xSize
(p) : 0;

10025 
	}
}

10030 void 
	$sqlite3_free
(void *
p
)

10033 if( 
p
==0 ) return;

10036 if( 
sqlite3Config
.
bMemstat
 )

10039 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

10040 
	`sqlite3StatusDown
(0, 
	`sqlite3MallocSize
(
p
));

10041 
	`sqlite3StatusDown
(9, 1);

10042 
sqlite3Config
.
m
.
	`xFree
(
p
);

10043 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

10045 
sqlite3Config
.
m
.
	`xFree
(
p
);

10047 
	}
}

10053 static 
__attribute__
((
noinline
)) void 
	$measureAllocationSize
(
sqlite3
 *
db
, void *
p
)

10056 *
db
->
pnBytesFreed
 += 
	`sqlite3DbMallocSize
(db,
p
);

10057 
	}
}

10063 static void 
	$sqlite3DbFree
(
sqlite3
 *
db
, void *
p
)

10067 if( 
p
==0 ) return;

10068 if( 
db
 )

10071 if( 
db
->
pnBytesFreed
 )

10074 
	`measureAllocationSize
(
db
, 
p
);

10077 if( 
	`isLookaside
(
db
, 
p
) )

10080 
LookasideSlot
 *
pBuf
 = (LookasideSlot*)
p
;

10085 
pBuf
->
pNext
 = 
db
->
lookaside
.
pFree
;

10086 
db
->
lookaside
.
pFree
 = 
pBuf
;

10087 
db
->
lookaside
.
nOut
--;

10095 
	`sqlite3_free
(
p
);

10096 
	}
}

10101 static void *
	$sqlite3Realloc
(void *
pOld
, 
u64
 
nBytes
)

10104 int 
nOld
, 
nNew
, 
nDiff
;

10105 void *
pNew
;

10108 if( 
pOld
==0 )

10111 return 
	`sqlite3Malloc
(
nBytes
);

10113 if( 
nBytes
==0 )

10116 
	`sqlite3_free
(
pOld
);

10119 if( 
nBytes
>=0x7fffff00 )

10125 
nOld
 = 
	`sqlite3MallocSize
(
pOld
);

10129 
nNew
 = 
sqlite3Config
.
m
.
	`xRoundup
((int)
nBytes
);

10130 if( 
nOld
==
nNew
 )

10133 
pNew
 = 
pOld
;

10134 }else if( 
sqlite3Config
.
bMemstat
 )

10137 
	`sqlite3_mutex_enter
(
mem0
.
mutex
);

10138 
	`sqlite3StatusHighwater
(5, (int)
nBytes
);

10139 
nDiff
 = 
nNew
 - 
nOld
;

10140 if( 
	`sqlite3StatusValue
(0) >=

10141 
mem0
.
alarmThreshold
-
nDiff
 )

10144 
	`sqlite3MallocAlarm
(
nDiff
);

10146 
pNew
 = 
sqlite3Config
.
m
.
	`xRealloc
(
pOld
, 
nNew
);

10147 if( 
pNew
==0 && 
mem0
.
alarmThreshold
>0 )

10150 
	`sqlite3MallocAlarm
((int)
nBytes
);

10151 
pNew
 = 
sqlite3Config
.
m
.
	`xRealloc
(
pOld
, 
nNew
);

10153 if( 
pNew
 )

10156 
nNew
 = 
	`sqlite3MallocSize
(
pNew
);

10157 
	`sqlite3StatusUp
(0, 
nNew
-
nOld
);

10159 
	`sqlite3_mutex_leave
(
mem0
.
mutex
);

10161 
pNew
 = 
sqlite3Config
.
m
.
	`xRealloc
(
pOld
, 
nNew
);

10164 return 
pNew
;

10165 
	}
}

10171 void * 
	$sqlite3_realloc
(void *
pOld
, int 
n
)

10175 if( 
	`sqlite3_initialize
() ) return 0;

10177 if( 
n
<0 ) n = 0;

10178 return 
	`sqlite3Realloc
(
pOld
, 
n
);

10179 
	}
}

10180 void * 
	$sqlite3_realloc64
(void *
pOld
, 
sqlite3_uint64
 
n
)

10184 if( 
	`sqlite3_initialize
() ) return 0;

10186 return 
	`sqlite3Realloc
(
pOld
, 
n
);

10187 
	}
}

10193 static void *
	$sqlite3MallocZero
(
u64
 
n
)

10196 void *
p
 = 
	`sqlite3Malloc
(
n
);

10197 if( 
p
 )

10200 
	`memset
(
p
, 0, (
size_t
)
n
);

10202 return 
p
;

10203 
	}
}

10209 static void *
	$sqlite3DbMallocZero
(
sqlite3
 *
db
, 
u64
 
n
)

10212 void *
p
;

10214 
p
 = 
	`sqlite3DbMallocRaw
(
db
, 
n
);

10215 if( 
p
 ) 
	`memset
(p, 0, (
size_t
)
n
);

10216 return 
p
;

10217 
	}
}

10223 static 
__attribute__
((
noinline
)) void *
	$dbMallocRawFinish
(
sqlite3
 *
db
, 
u64
 
n
)

10226 void *
p
;

10228 
p
 = 
	`sqlite3Malloc
(
n
);

10229 if( !
p
 ) 
	`sqlite3OomFault
(
db
);

10232 return 
p
;

10233 
	}
}

10235 static void *
	$sqlite3DbMallocRaw
(
sqlite3
 *
db
, 
u64
 
n
)

10238 void *
p
;

10239 if( 
db
 ) return 
	`sqlite3DbMallocRawNN
(db, 
n
);

10240 
p
 = 
	`sqlite3Malloc
(
n
);

10242 return 
p
;

10243 
	}
}

10244 static void *
	$sqlite3DbMallocRawNN
(
sqlite3
 *
db
, 
u64
 
n
)

10248 
LookasideSlot
 *
pBuf
;

10252 if( 
db
->
lookaside
.
bDisable
==0 )

10256 if( 
n
>
db
->
lookaside
.
sz
 )

10259 
db
->
lookaside
.
anStat
[1]++;

10260 }else if( (
pBuf
 = 
db
->
lookaside
.
pFree
)==0 )

10263 
db
->
lookaside
.
anStat
[2]++;

10265 
db
->
lookaside
.
pFree
 = 
pBuf
->
pNext
;

10266 
db
->
lookaside
.
nOut
++;

10267 
db
->
lookaside
.
anStat
[0]++;

10268 if( 
db
->
lookaside
.
nOut
>db->lookaside.
mxOut
 )

10271 
db
->
lookaside
.
mxOut
 = db->lookaside.
nOut
;

10273 return (void*)
pBuf
;

10275 }else if( 
db
->
mallocFailed
 )

10281 return 
	`dbMallocRawFinish
(
db
, 
n
);

10282 
	}
}

10285 static 
__attribute__
((
noinline
)) void *
dbReallocFinish
(
sqlite3
 *
db
, void *
p
, 
u64
 
n
);

10291 static void *
	$sqlite3DbRealloc
(
sqlite3
 *
db
, void *
p
, 
u64
 
n
)

10295 if( 
p
==0 ) return 
	`sqlite3DbMallocRawNN
(
db
, 
n
);

10297 if( 
	`isLookaside
(
db
,
p
) && 
n
<=db->
lookaside
.
sz
 ) return p;

10298 return 
	`dbReallocFinish
(
db
, 
p
, 
n
);

10299 
	}
}

10300 static 
__attribute__
((
noinline
)) void *
	$dbReallocFinish
(
sqlite3
 *
db
, void *
p
, 
u64
 
n
)

10303 void *
pNew
 = 0;

10306 if( 
db
->
mallocFailed
==0 )

10309 if( 
	`isLookaside
(
db
, 
p
) )

10312 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, 
n
);

10313 if( 
pNew
 )

10316 
	`memcpy
(
pNew
, 
p
, 
db
->
lookaside
.
sz
);

10317 
	`sqlite3DbFree
(
db
, 
p
);

10323 
pNew
 = 
	`sqlite3_realloc64
(
p
, 
n
);

10324 if( !
pNew
 )

10327 
	`sqlite3OomFault
(
db
);

10333 return 
pNew
;

10334 
	}
}

10340 static void *
	$sqlite3DbReallocOrFree
(
sqlite3
 *
db
, void *
p
, 
u64
 
n
)

10343 void *
pNew
;

10344 
pNew
 = 
	`sqlite3DbRealloc
(
db
, 
p
, 
n
);

10345 if( !
pNew
 )

10348 
	`sqlite3DbFree
(
db
, 
p
);

10350 return 
pNew
;

10351 
	}
}

10353 static char *
	$sqlite3DbStrDup
(
sqlite3
 *
db
, const char *
z
)

10356 char *
zNew
;

10357 
size_t
 
n
;

10358 if( 
z
==0 )

10363 
n
 = 
	`sqlite3Strlen30
(
z
) + 1;

10365 
zNew
 = 
	`sqlite3DbMallocRaw
(
db
, (int)
n
);

10366 if( 
zNew
 )

10369 
	`memcpy
(
zNew
, 
z
, 
n
);

10371 return 
zNew
;

10372 
	}
}

10373 static char *
	$sqlite3DbStrNDup
(
sqlite3
 *
db
, const char *
z
, 
u64
 
n
)

10376 char *
zNew
;

10378 if( 
z
==0 )

10384 
zNew
 = 
	`sqlite3DbMallocRawNN
(
db
, 
n
+1);

10385 if( 
zNew
 )

10388 
	`memcpy
(
zNew
, 
z
, (
size_t
)
n
);

10389 
zNew
[
n
] = 0;

10391 return 
zNew
;

10392 
	}
}

10397 static void 
	$sqlite3SetString
(char **
pz
, 
sqlite3
 *
db
, const char *
zNew
)

10400 
	`sqlite3DbFree
(
db
, *
pz
);

10401 *
pz
 = 
	`sqlite3DbStrDup
(
db
, 
zNew
);

10402 
	}
}

10410 static void 
	$sqlite3OomFault
(
sqlite3
 *
db
)

10413 if( 
db
->
mallocFailed
==0 && db->
bBenignMalloc
==0 )

10416 
db
->
mallocFailed
 = 1;

10417 if( 
db
->
nVdbeExec
>0 )

10420 
db
->
u1
.
isInterrupted
 = 1;

10422 
db
->
lookaside
.
bDisable
++;

10424 
	}
}

10426 static void 
	$sqlite3OomClear
(
sqlite3
 *
db
)

10429 if( 
db
->
mallocFailed
 && db->
nVdbeExec
==0 )

10432 
db
->
mallocFailed
 = 0;

10433 
db
->
u1
.
isInterrupted
 = 0;

10435 
db
->
lookaside
.
bDisable
--;

10437 
	}
}

10442 static 
__attribute__
((
noinline
)) int 
	$apiOomError
(
sqlite3
 *
db
)

10445 
	`sqlite3OomClear
(
db
);

10446 
	`sqlite3Error
(
db
, 7);

10448 
	}
}

10450 static int 
	$sqlite3ApiExit
(
sqlite3
* 
db
, int 
rc
)

10459 if( 
db
->
mallocFailed
 || 
rc
==(10 | (12<<8)) )

10462 return 
	`apiOomError
(
db
);

10464 return 
rc
 & 
db
->
errMask
;

10465 
	}
}

10467 typedef unsigned char 
	tetByte
;

10473 typedef struct 
	set_info
 {

10474 char 
	mfmttype
;

10475 
etByte
 
	mbase
;

10476 
etByte
 
	mflags
;

10477 
etByte
 
	mtype
;

10478 
etByte
 
	mcharset
;

10479 
etByte
 
	mprefix
;

10480 } 
	tet_info
;

10482 static const char 
	gaDigits
[] = "0123456789ABCDEF0123456789abcdef";

10483 static const char 
	gaPrefix
[] = "-x0\000X0";

10484 static const 
et_info
 
	gfmtinfo
[] = {

10515 static char 
	$et_getdigit
(long double *
val
, int *
cnt
)

10518 int 
digit
;

10519 long double 
d
;

10520 if( (*
cnt
)<=0 ) return '0';

10521 (*
cnt
)--;

10522 
digit
 = (int)*
val
;

10523 
d
 = 
digit
;

10524 
digit
 += '0';

10525 *
val
 = (*val - 
d
)*10.0;

10526 return (char)
digit
;

10527 
	}
}

10533 static void 
	$setStrAccumError
(
StrAccum
 *
p
, 
u8
 
eError
)

10537 
p
->
accError
 = 
eError
;

10538 
p
->
nAlloc
 = 0;

10539 
	}
}

10544 static 
sqlite3_int64
 
	$getIntArg
(
PrintfArguments
 *
p
)

10547 if( 
p
->
nArg
<=p->
nUsed
 ) return 0;

10548 return 
	`sqlite3_value_int64
(
p
->
apArg
[p->
nUsed
++]);

10549 
	}
}

10550 static double 
	$getDoubleArg
(
PrintfArguments
 *
p
)

10553 if( 
p
->
nArg
<=p->
nUsed
 ) return 0.0;

10554 return 
	`sqlite3_value_double
(
p
->
apArg
[p->
nUsed
++]);

10555 
	}
}

10556 static char *
	$getTextArg
(
PrintfArguments
 *
p
)

10559 if( 
p
->
nArg
<=p->
nUsed
 ) return 0;

10560 return (char*)
	`sqlite3_value_text
(
p
->
apArg
[p->
nUsed
++]);

10561 
	}
}

10563 static void 
	$sqlite3VXPrintf
(

10564 
StrAccum
 *
pAccum
,

10565 const char *
fmt
,

10566 
va_list
 
ap


10570 int 
c
;

10571 char *
bufpt
;

10572 int 
precision
;

10573 int 
length
;

10574 int 
idx
;

10575 int 
width
;

10576 
etByte
 
flag_leftjustify
;

10577 
etByte
 
flag_plussign
;

10578 
etByte
 
flag_blanksign
;

10579 
etByte
 
flag_alternateform
;

10580 
etByte
 
flag_altform2
;

10581 
etByte
 
flag_zeropad
;

10582 
etByte
 
flag_long
;

10583 
etByte
 
flag_longlong
;

10584 
etByte
 
done
;

10585 
etByte
 
xtype
 = 0;

10586 
u8
 
bArgList
;

10587 
u8
 
useIntern
;

10588 char 
prefix
;

10589 
sqlite_uint64
 
longvalue
;

10590 long double 
realvalue
;

10591 const 
et_info
 *
infop
;

10592 char *
zOut
;

10593 int 
nOut
;

10594 char *
zExtra
 = 0;

10596 int 
exp
, 
e2
;

10597 int 
nsd
;

10598 double 
rounder
;

10599 
etByte
 
flag_dp
;

10600 
etByte
 
flag_rtz
;

10602 
PrintfArguments
 *
pArgList
 = 0;

10603 char 
buf
[70];

10605 
bufpt
 = 0;

10606 if( 
pAccum
->
printfFlags
 )

10609 if( (
bArgList
 = (
pAccum
->
printfFlags
 & 0x02))!=0 )

10612 
pArgList
 = 
	`__builtin_va_arg
(
ap
,
PrintfArguments
*);

10614 
useIntern
 = 
pAccum
->
printfFlags
 & 0x01;

10616 
bArgList
 = 
useIntern
 = 0;

10618 for(; (
c
=(*
fmt
))!=0; ++fmt)

10621 if( 
c
!='%' )

10624 
bufpt
 = (char *)
fmt
;

10628 do{ 
fmt
++; }while( *fmt && *fmt != '%' );

10630 
	`sqlite3StrAccumAppend
(
pAccum
, 
bufpt
, (int)(
fmt
 - bufpt));

10631 if( *
fmt
==0 ) break;

10633 if( (
c
=(*++
fmt
))==0 )

10636 
	`sqlite3StrAccumAppend
(
pAccum
, "%", 1);

10640 
flag_leftjustify
 = 
flag_plussign
 = 
flag_blanksign
 =

10641 
flag_alternateform
 = 
flag_altform2
 = 
flag_zeropad
 = 0;

10642 
done
 = 0;

10644 switch( 
c
 )

10647 case '-': 
flag_leftjustify
 = 1; break;

10648 case '+': 
flag_plussign
 = 1; break;

10649 case ' ': 
flag_blanksign
 = 1; break;

10650 case '#': 
flag_alternateform
 = 1; break;

10651 case '!': 
flag_altform2
 = 1; break;

10652 case '0': 
flag_zeropad
 = 1; break;

10653 default: 
done
 = 1; break;

10655 }while( !
done
 && (
c
=(*++
fmt
))!=0 );

10657 if( 
c
=='*' )

10660 if( 
bArgList
 )

10663 
width
 = (int)
	`getIntArg
(
pArgList
);

10665 
width
 = 
	`__builtin_va_arg
(
ap
,int);

10667 if( 
width
<0 )

10670 
flag_leftjustify
 = 1;

10671 
width
 = width >= -2147483647 ? -width : 0;

10673 
c
 = *++
fmt
;

10675 unsigned 
wx
 = 0;

10676 while( 
c
>='0' && c<='9' )

10679 
wx
 = wx*10 + 
c
 - '0';

10680 
c
 = *++
fmt
;

10683 
width
 = 
wx
 & 0x7fffffff;

10693 if( 
c
=='.' )

10696 
c
 = *++
fmt
;

10697 if( 
c
=='*' )

10700 if( 
bArgList
 )

10703 
precision
 = (int)
	`getIntArg
(
pArgList
);

10705 
precision
 = 
	`__builtin_va_arg
(
ap
,int);

10707 
c
 = *++
fmt
;

10708 if( 
precision
<0 )

10711 
precision
 = precision >= -2147483647 ? -precision : -1;

10714 unsigned 
px
 = 0;

10715 while( 
c
>='0' && c<='9' )

10718 
px
 = px*10 + 
c
 - '0';

10719 
c
 = *++
fmt
;

10722 
precision
 = 
px
 & 0x7fffffff;

10725 
precision
 = -1;

10729 if( 
c
=='l' )

10732 
flag_long
 = 1;

10733 
c
 = *++
fmt
;

10734 if( 
c
=='l' )

10737 
flag_longlong
 = 1;

10738 
c
 = *++
fmt
;

10740 
flag_longlong
 = 0;

10743 
flag_long
 = 
flag_longlong
 = 0;

10746 
infop
 = &
fmtinfo
[0];

10747 
xtype
 = 0;

10748 for(
idx
=0; idx<((int)(sizeof(
fmtinfo
)/sizeof(fmtinfo[0]))); idx++)

10751 if( 
c
==
fmtinfo
[
idx
].
fmttype
 )

10754 
infop
 = &
fmtinfo
[
idx
];

10755 if( 
useIntern
 || (
infop
->
flags
 & 2)==0 )

10758 
xtype
 = 
infop
->
type
;

10766 switch( 
xtype
 )

10770 
flag_longlong
 = sizeof(char*)==sizeof(
i64
);

10771 
flag_long
 = sizeof(char*)==sizeof(long int);

10775 if( 
infop
->
flags
 & 1 )

10778 
i64
 
v
;

10779 if( 
bArgList
 )

10782 
v
 = 
	`getIntArg
(
pArgList
);

10783 }else if( 
flag_longlong
 )

10786 
v
 = 
	`__builtin_va_arg
(
ap
,
i64
);

10787 }else if( 
flag_long
 )

10790 
v
 = 
	`__builtin_va_arg
(
ap
,long int);

10792 
v
 = 
	`__builtin_va_arg
(
ap
,int);

10794 if( 
v
<0 )

10797 if( 
v
==(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) )

10800 
longvalue
 = ((
u64
)1)<<63;

10802 
longvalue
 = -
v
;

10804 
prefix
 = '-';

10806 
longvalue
 = 
v
;

10807 if( 
flag_plussign
 ) 
prefix
 = '+';

10808 else if( 
flag_blanksign
 ) 
prefix
 = ' ';

10809 else 
prefix
 = 0;

10812 if( 
bArgList
 )

10815 
longvalue
 = (
u64
)
	`getIntArg
(
pArgList
);

10816 }else if( 
flag_longlong
 )

10819 
longvalue
 = 
	`__builtin_va_arg
(
ap
,
u64
);

10820 }else if( 
flag_long
 )

10823 
longvalue
 = 
	`__builtin_va_arg
(
ap
,unsigned long int);

10825 
longvalue
 = 
	`__builtin_va_arg
(
ap
,unsigned int);

10827 
prefix
 = 0;

10829 if( 
longvalue
==0 ) 
flag_alternateform
 = 0;

10830 if( 
flag_zeropad
 && 
precision
<
width
-(
prefix
!=0) )

10833 
precision
 = 
width
-(
prefix
!=0);

10835 if( 
precision
<70 -10 )

10838 
nOut
 = 70;

10839 
zOut
 = 
buf
;

10841 
nOut
 = 
precision
 + 10;

10842 
zOut
 = 
zExtra
 = 
	`sqlite3Malloc
( 
nOut
 );

10843 if( 
zOut
==0 )

10846 
	`setStrAccumError
(
pAccum
, 1);

10850 
bufpt
 = &
zOut
[
nOut
-1];

10851 if( 
xtype
==16 )

10854 static const char 
zOrd
[] = "thstndrd";

10855 int 
x
 = (int)(
longvalue
 % 10);

10856 if( 
x
>=4 || (
longvalue
/10)%10==1 )

10859 
x
 = 0;

10861 *(--
bufpt
) = 
zOrd
[
x
*2+1];

10862 *(--
bufpt
) = 
zOrd
[
x
*2];

10865 const char *
cset
 = &
aDigits
[
infop
->
charset
];

10866 
u8
 
base
 = 
infop
->base;

10868 *(--
bufpt
) = 
cset
[
longvalue
%
base
];

10869 
longvalue
 = longvalue/
base
;

10870 }while( 
longvalue
>0 );

10872 
length
 = (int)(&
zOut
[
nOut
-1]-
bufpt
);

10873 for(
idx
=
precision
-
length
; idx>0; idx--)

10876 *(--
bufpt
) = '0';

10878 if( 
prefix
 ) *(--
bufpt
) = prefix;

10879 if( 
flag_alternateform
 && 
infop
->
prefix
 )

10882 const char *
pre
;

10883 char 
x
;

10884 
pre
 = &
aPrefix
[
infop
->
prefix
];

10885 for(; (
x
=(*
pre
))!=0; pre++) *(--
bufpt
) = x;

10887 
length
 = (int)(&
zOut
[
nOut
-1]-
bufpt
);

10892 if( 
bArgList
 )

10895 
realvalue
 = 
	`getDoubleArg
(
pArgList
);

10897 
realvalue
 = 
	`__builtin_va_arg
(
ap
,double);

10902 if( 
precision
<0 ) precision = 6;

10903 if( 
realvalue
<0.0 )

10906 
realvalue
 = -realvalue;

10907 
prefix
 = '-';

10909 if( 
flag_plussign
 ) 
prefix
 = '+';

10910 else if( 
flag_blanksign
 ) 
prefix
 = ' ';

10911 else 
prefix
 = 0;

10913 if( 
xtype
==4 && 
precision
>0 ) precision--;

10915 for(
idx
=
precision
&0xfff, 
rounder
=0.5; idx>0; idx--, rounder*=0.1)

10918 if( 
xtype
==2 ) 
realvalue
 += 
rounder
;

10920 
exp
 = 0;

10921 if( 
	`sqlite3IsNaN
((double)
realvalue
) )

10924 
bufpt
 = "NaN";

10925 
length
 = 3;

10928 if( 
realvalue
>0.0 )

10931 long double 
scale
 = 1.0;

10932 while( 
realvalue
>=1e100*
scale
 && 
exp
<=350 )

10934 
scale
 *= 1e100;
exp
+=100;}

10935 while( 
realvalue
>=1e10*
scale
 && 
exp
<=350 )

10937 
scale
 *= 1e10; 
exp
+=10; }

10938 while( 
realvalue
>=10.0*
scale
 && 
exp
<=350 )

10940 
scale
 *= 10.0; 
exp
++; }

10941 
realvalue
 /= 
scale
;

10942 while( 
realvalue
<1e-8 )

10944 
realvalue
 *= 1e8; 
exp
-=8; }

10945 while( 
realvalue
<1.0 )

10947 
realvalue
 *= 10.0; 
exp
--; }

10948 if( 
exp
>350 )

10951 
bufpt
 = 
buf
;

10952 
buf
[0] = 
prefix
;

10953 
	`memcpy
(
buf
+(
prefix
!=0),"Inf",4);

10954 
length
 = 3+(
prefix
!=0);

10958 
bufpt
 = 
buf
;

10963 if( 
xtype
!=2 )

10966 
realvalue
 += 
rounder
;

10967 if( 
realvalue
>=10.0 )

10969 
realvalue
 *= 0.1; 
exp
++; }

10971 if( 
xtype
==4 )

10974 
flag_rtz
 = !
flag_alternateform
;

10975 if( 
exp
<-4 || exp>
precision
 )

10978 
xtype
 = 3;

10980 
precision
 = precision - 
exp
;

10981 
xtype
 = 2;

10984 
flag_rtz
 = 
flag_altform2
;

10986 if( 
xtype
==3 )

10989 
e2
 = 0;

10991 
e2
 = 
exp
;

10993 if( ((
e2
)>(0)?(e2):(0))+(
i64
)
precision
+(i64)
width
 > 70 - 15 )

10996 
bufpt
 = 
zExtra


10997 = 
	`sqlite3Malloc
( ((
e2
)>(0)?(e2):(0))+(
i64
)
precision
+(i64)
width
+15 );

10998 if( 
bufpt
==0 )

11001 
	`setStrAccumError
(
pAccum
, 1);

11005 
zOut
 = 
bufpt
;

11006 
nsd
 = 16 + 
flag_altform2
*10;

11007 
flag_dp
 = (
precision
>0 ?1:0) | 
flag_alternateform
 | 
flag_altform2
;

11009 if( 
prefix
 )

11012 *(
bufpt
++) = 
prefix
;

11015 if( 
e2
<0 )

11018 *(
bufpt
++) = '0';

11020 for(; 
e2
>=0; e2--)

11023 *(
bufpt
++) = 
	`et_getdigit
(&
realvalue
,&
nsd
);

11027 if( 
flag_dp
 )

11030 *(
bufpt
++) = '.';

11034 for(
e2
++; e2<0; 
precision
--, e2++)

11038 *(
bufpt
++) = '0';

11041 while( (
precision
--)>0 )

11044 *(
bufpt
++) = 
	`et_getdigit
(&
realvalue
,&
nsd
);

11047 if( 
flag_rtz
 && 
flag_dp
 )

11050 while( 
bufpt
[-1]=='0' ) *(--bufpt) = 0;

11052 if( 
bufpt
[-1]=='.' )

11055 if( 
flag_altform2
 )

11058 *(
bufpt
++) = '0';

11060 *(--
bufpt
) = 0;

11065 if( 
xtype
==3 )

11068 *(
bufpt
++) = 
aDigits
[
infop
->
charset
];

11069 if( 
exp
<0 )

11072 *(
bufpt
++) = '-'; 
exp
 = -exp;

11074 *(
bufpt
++) = '+';

11076 if( 
exp
>=100 )

11079 *(
bufpt
++) = (char)((
exp
/100)+'0');

11080 
exp
 %= 100;

11082 *(
bufpt
++) = (char)(
exp
/10+'0');

11083 *(
bufpt
++) = (char)(
exp
%10+'0');

11085 *
bufpt
 = 0;

11090 
length
 = (int)(
bufpt
-
zOut
);

11091 
bufpt
 = 
zOut
;

11095 if( 
flag_zeropad
 && !
flag_leftjustify
 && 
length
 < 
width
)

11098 int 
i
;

11099 int 
nPad
 = 
width
 - 
length
;

11100 for(
i
=
width
; i>=
nPad
; i--)

11103 
bufpt
[
i
] = bufpt[i-
nPad
];

11105 
i
 = 
prefix
!=0;

11106 while( 
nPad
-- ) 
bufpt
[
i
++] = '0';

11107 
length
 = 
width
;

11112 if( !
bArgList
 )

11115 *(
	`__builtin_va_arg
(
ap
,int*)) = 
pAccum
->
nChar
;

11117 
length
 = 
width
 = 0;

11120 
buf
[0] = '%';

11121 
bufpt
 = 
buf
;

11122 
length
 = 1;

11125 if( 
bArgList
 )

11128 
bufpt
 = 
	`getTextArg
(
pArgList
);

11129 
c
 = 
bufpt
 ? bufpt[0] : 0;

11131 
c
 = 
	`__builtin_va_arg
(
ap
,int);

11133 if( 
precision
>1 )

11136 
width
 -= 
precision
-1;

11137 if( 
width
>1 && !
flag_leftjustify
 )

11140 
	`sqlite3AppendChar
(
pAccum
, 
width
-1, ' ');

11141 
width
 = 0;

11143 
	`sqlite3AppendChar
(
pAccum
, 
precision
-1, 
c
);

11145 
length
 = 1;

11146 
buf
[0] = 
c
;

11147 
bufpt
 = 
buf
;

11151 if( 
bArgList
 )

11154 
bufpt
 = 
	`getTextArg
(
pArgList
);

11155 
xtype
 = 6;

11157 
bufpt
 = 
	`__builtin_va_arg
(
ap
,char*);

11159 if( 
bufpt
==0 )

11162 
bufpt
 = "";

11163 }else if( 
xtype
==7 )

11166 
zExtra
 = 
bufpt
;

11168 if( 
precision
>=0 )

11171 for(
length
=0; length<
precision
 && 
bufpt
[length]; length++)

11175 
length
 = 
	`sqlite3Strlen30
(
bufpt
);

11181 int 
i
, 
j
, 
k
, 
n
, 
isnull
;

11182 int 
needQuote
;

11183 char 
ch
;

11184 char 
q
 = ((
xtype
==15)?'"':'\'');

11185 char *
escarg
;

11187 if( 
bArgList
 )

11190 
escarg
 = 
	`getTextArg
(
pArgList
);

11192 
escarg
 = 
	`__builtin_va_arg
(
ap
,char*);

11194 
isnull
 = 
escarg
==0;

11195 if( 
isnull
 ) 
escarg
 = (
xtype
==11 ? "NULL" : "(NULL)");

11196 
k
 = 
precision
;

11197 for(
i
=
n
=0; 
k
!=0 && (
ch
=
escarg
[i])!=0; i++, k--)

11200 if( 
ch
==
q
 ) 
n
++;

11202 
needQuote
 = !
isnull
 && 
xtype
==11;

11203 
n
 += 
i
 + 3;

11204 if( 
n
>70 )

11207 
bufpt
 = 
zExtra
 = 
	`sqlite3Malloc
( 
n
 );

11208 if( 
bufpt
==0 )

11211 
	`setStrAccumError
(
pAccum
, 1);

11215 
bufpt
 = 
buf
;

11217 
j
 = 0;

11218 if( 
needQuote
 ) 
bufpt
[
j
++] = 
q
;

11219 
k
 = 
i
;

11220 for(
i
=0; i<
k
; i++)

11223 
bufpt
[
j
++] = 
ch
 = 
escarg
[
i
];

11224 if( 
ch
==
q
 ) 
bufpt
[
j
++] = ch;

11226 if( 
needQuote
 ) 
bufpt
[
j
++] = 
q
;

11227 
bufpt
[
j
] = 0;

11228 
length
 = 
j
;

11235 
Token
 *
pToken
 = 
	`__builtin_va_arg
(
ap
,Token*);

11237 if( 
pToken
 && pToken->
n
 )

11240 
	`sqlite3StrAccumAppend
(
pAccum
, (const char*)
pToken
->
z
, pToken->
n
);

11242 
length
 = 
width
 = 0;

11246 
SrcList
 *
pSrc
 = 
	`__builtin_va_arg
(
ap
,SrcList*);

11247 int 
k
 = 
	`__builtin_va_arg
(
ap
,int);

11248 struct 
SrcList_item
 *
pItem
 = &
pSrc
->
a
[
k
];

11251 if( 
pItem
->
zDatabase
 )

11254 
	`sqlite3StrAccumAppendAll
(
pAccum
, 
pItem
->
zDatabase
);

11255 
	`sqlite3StrAccumAppend
(
pAccum
, ".", 1);

11257 
	`sqlite3StrAccumAppendAll
(
pAccum
, 
pItem
->
zName
);

11258 
length
 = 
width
 = 0;

11271 
width
 -= 
length
;

11272 if( 
width
>0 && !
flag_leftjustify
 ) 
	`sqlite3AppendChar
(
pAccum
, width, ' ');

11273 
	`sqlite3StrAccumAppend
(
pAccum
, 
bufpt
, 
length
);

11274 if( 
width
>0 && 
flag_leftjustify
 ) 
	`sqlite3AppendChar
(
pAccum
, width, ' ');

11276 if( 
zExtra
 )

11279 
	`sqlite3DbFree
(
pAccum
->
db
, 
zExtra
);

11280 
zExtra
 = 0;

11283 
	}
}

11285 static int 
	$sqlite3StrAccumEnlarge
(
StrAccum
 *
p
, int 
N
)

11288 char *
zNew
;

11290 if( 
p
->
accError
 )

11297 if( 
p
->
mxAlloc
==0 )

11300 
N
 = 
p
->
nAlloc
 - p->
nChar
 - 1;

11301 
	`setStrAccumError
(
p
, 2);

11302 return 
N
;

11304 char *
zOld
 = (((
p
)->
printfFlags
 & 0x04)!=0) ? p->
zText
 : 0;

11305 
i64
 
szNew
 = 
p
->
nChar
;

11307 
szNew
 += 
N
 + 1;

11308 if( 
szNew
+
p
->
nChar
<=p->
mxAlloc
 )

11313 
szNew
 += 
p
->
nChar
;

11315 if( 
szNew
 > 
p
->
mxAlloc
 )

11318 
	`sqlite3StrAccumReset
(
p
);

11319 
	`setStrAccumError
(
p
, 2);

11322 
p
->
nAlloc
 = (int)
szNew
;

11324 if( 
p
->
db
 )

11327 
zNew
 = 
	`sqlite3DbRealloc
(
p
->
db
, 
zOld
, p->
nAlloc
);

11329 
zNew
 = 
	`sqlite3_realloc64
(
zOld
, 
p
->
nAlloc
);

11331 if( 
zNew
 )

11335 if( !(((
p
)->
printfFlags
 & 0x04)!=0) && p->
nChar
>0 ) 
	`memcpy
(
zNew
, p->
zText
, p->nChar);

11336 
p
->
zText
 = 
zNew
;

11337 
p
->
nAlloc
 = 
	`sqlite3DbMallocSize
(p->
db
, 
zNew
);

11338 
p
->
printfFlags
 |= 0x04;

11340 
	`sqlite3StrAccumReset
(
p
);

11341 
	`setStrAccumError
(
p
, 1);

11345 return 
N
;

11346 
	}
}

11351 static void 
	$sqlite3AppendChar
(
StrAccum
 *
p
, int 
N
, char 
c
)

11355 if( 
p
->
nChar
+(
i64
)
N
 >= p->
nAlloc
 && (N = 
	`sqlite3StrAccumEnlarge
(p, N))<=0 )

11361 while( (
N
--)>0 ) 
p
->
zText
[p->
nChar
++] = 
c
;

11362 
	}
}

11364 static void 
__attribute__
((
noinline
)) 
	$enlargeAndAppend
(
StrAccum
 *
p
, const char *
z
, int 
N
)

11367 
N
 = 
	`sqlite3StrAccumEnlarge
(
p
, N);

11368 if( 
N
>0 )

11371 
	`memcpy
(&
p
->
zText
[p->
nChar
], 
z
, 
N
);

11372 
p
->
nChar
 += 
N
;

11375 
	}
}

11381 static void 
	$sqlite3StrAccumAppend
(
StrAccum
 *
p
, const char *
z
, int 
N
)

11388 if( 
p
->
nChar
+
N
 >= p->
nAlloc
 )

11391 
	`enlargeAndAppend
(
p
,
z
,
N
);

11394 
p
->
nChar
 += 
N
;

11395 
	`memcpy
(&
p
->
zText
[p->
nChar
-
N
], 
z
, N);

11397 
	}
}

11402 static void 
	$sqlite3StrAccumAppendAll
(
StrAccum
 *
p
, const char *
z
)

11405 
	`sqlite3StrAccumAppend
(
p
, 
z
, 
	`sqlite3Strlen30
(z));

11406 
	}
}

11414 static char *
	$sqlite3StrAccumFinish
(
StrAccum
 *
p
)

11417 if( 
p
->
zText
 )

11421 
p
->
zText
[p->
nChar
] = 0;

11422 if( 
p
->
mxAlloc
>0 && !(((p)->
printfFlags
 & 0x04)!=0) )

11425 
p
->
zText
 = 
	`sqlite3DbMallocRaw
(p->
db
, p->
nChar
+1 );

11426 if( 
p
->
zText
 )

11429 
	`memcpy
(
p
->
zText
, p->
zBase
, p->
nChar
+1);

11430 
p
->
printfFlags
 |= 0x04;

11432 
	`setStrAccumError
(
p
, 1);

11436 return 
p
->
zText
;

11437 
	}
}

11442 static void 
	$sqlite3StrAccumReset
(
StrAccum
 *
p
)

11446 if( (((
p
)->
printfFlags
 & 0x04)!=0) )

11449 
	`sqlite3DbFree
(
p
->
db
, p->
zText
);

11450 
p
->
printfFlags
 &= ~0x04;

11452 
p
->
zText
 = 0;

11453 
	}
}

11455 static void 
	$sqlite3StrAccumInit
(
StrAccum
 *
p
, 
sqlite3
 *
db
, char *
zBase
, int 
n
, int 
mx
)

11458 
p
->
zText
 = p->
zBase
 = zBase;

11459 
p
->
db
 = db;

11460 
p
->
nChar
 = 0;

11461 
p
->
nAlloc
 = 
n
;

11462 
p
->
mxAlloc
 = 
mx
;

11463 
p
->
accError
 = 0;

11464 
p
->
printfFlags
 = 0;

11465 
	}
}

11471 static char *
	$sqlite3VMPrintf
(
sqlite3
 *
db
, const char *
zFormat
, 
va_list
 
ap
)

11474 char *
z
;

11475 char 
zBase
[70];

11476 
StrAccum
 
acc
;

11478 
	`sqlite3StrAccumInit
(&
acc
, 
db
, 
zBase
, sizeof(zBase),

11479 
db
->
aLimit
[0]);

11480 
acc
.
printfFlags
 = 0x01;

11481 
	`sqlite3VXPrintf
(&
acc
, 
zFormat
, 
ap
);

11482 
z
 = 
	`sqlite3StrAccumFinish
(&
acc
);

11483 if( 
acc
.
accError
==1 )

11486 
	`sqlite3OomFault
(
db
);

11488 return 
z
;

11489 
	}
}

11495 static char *
	$sqlite3MPrintf
(
sqlite3
 *
db
, const char *
zFormat
, ...)

11498 
va_list
 
ap
;

11499 char *
z
;

11500 
	`__builtin_va_start
(
ap
,
zFormat
);

11501 
z
 = 
	`sqlite3VMPrintf
(
db
, 
zFormat
, 
ap
);

11502 
	`__builtin_va_end
(
ap
);

11503 return 
z
;

11504 
	}
}

11510 char * 
	$sqlite3_vmprintf
(const char *
zFormat
, 
va_list
 
ap
)

11513 char *
z
;

11514 char 
zBase
[70];

11515 
StrAccum
 
acc
;

11517 if( 
	`sqlite3_initialize
() ) return 0;

11519 
	`sqlite3StrAccumInit
(&
acc
, 0, 
zBase
, sizeof(zBase), 1000000000);

11520 
	`sqlite3VXPrintf
(&
acc
, 
zFormat
, 
ap
);

11521 
z
 = 
	`sqlite3StrAccumFinish
(&
acc
);

11522 return 
z
;

11523 
	}
}

11529 char * 
	$sqlite3_mprintf
(const char *
zFormat
, ...)

11532 
va_list
 
ap
;

11533 char *
z
;

11535 if( 
	`sqlite3_initialize
() ) return 0;

11537 
	`__builtin_va_start
(
ap
,
zFormat
);

11538 
z
 = 
	`sqlite3_vmprintf
(
zFormat
, 
ap
);

11539 
	`__builtin_va_end
(
ap
);

11540 return 
z
;

11541 
	}
}

11543 char * 
	$sqlite3_vsnprintf
(int 
n
, char *
zBuf
, const char *
zFormat
, 
va_list
 
ap
)

11546 
StrAccum
 
acc
;

11547 if( 
n
<=0 ) return 
zBuf
;

11555 
	`sqlite3StrAccumInit
(&
acc
, 0, 
zBuf
, 
n
, 0);

11556 
	`sqlite3VXPrintf
(&
acc
, 
zFormat
, 
ap
);

11557 return 
	`sqlite3StrAccumFinish
(&
acc
);

11558 
	}
}

11559 char * 
	$sqlite3_snprintf
(int 
n
, char *
zBuf
, const char *
zFormat
, ...)

11562 char *
z
;

11563 
va_list
 
ap
;

11564 
	`__builtin_va_start
(
ap
,
zFormat
);

11565 
z
 = 
	`sqlite3_vsnprintf
(
n
, 
zBuf
, 
zFormat
, 
ap
);

11566 
	`__builtin_va_end
(
ap
);

11567 return 
z
;

11568 
	}
}

11570 static void 
	$renderLogMsg
(int 
iErrCode
, const char *
zFormat
, 
va_list
 
ap
)

11573 
StrAccum
 
acc
;

11574 char 
zMsg
[70*3];

11576 
	`sqlite3StrAccumInit
(&
acc
, 0, 
zMsg
, sizeof(zMsg), 0);

11577 
	`sqlite3VXPrintf
(&
acc
, 
zFormat
, 
ap
);

11578 
sqlite3Config
.
	`xLog
(sqlite3Config.
pLogArg
, 
iErrCode
,

11579 
	`sqlite3StrAccumFinish
(&
acc
));

11580 
	}
}

11585 void 
	$sqlite3_log
(int 
iErrCode
, const char *
zFormat
, ...)

11588 
va_list
 
ap
;

11589 if( 
sqlite3Config
.
xLog
 )

11592 
	`__builtin_va_start
(
ap
,
zFormat
);

11593 
	`renderLogMsg
(
iErrCode
, 
zFormat
, 
ap
);

11594 
	`__builtin_va_end
(
ap
);

11596 
	}
}

11598 static void 
	$sqlite3XPrintf
(
StrAccum
 *
p
, const char *
zFormat
, ...)

11601 
va_list
 
ap
;

11602 
	`__builtin_va_start
(
ap
,
zFormat
);

11603 
	`sqlite3VXPrintf
(
p
, 
zFormat
, 
ap
);

11604 
	`__builtin_va_end
(
ap
);

11605 
	}
}

11607 static struct 
	ssqlite3PrngType
 {

11608 unsigned char 
	misInit
;

11609 unsigned char 
	mi
, 
	mj
;

11610 unsigned char 
	ms
[256];

11611 } 
	gsqlite3Prng
;

11616 void 
	$sqlite3_randomness
(int 
N
, void *
pBuf
)

11619 unsigned char 
t
;

11620 unsigned char *
zBuf
 = 
pBuf
;

11622 
sqlite3_mutex
 *
mutex
;

11626 if( 
	`sqlite3_initialize
() ) return;

11630 
mutex
 = 
	`sqlite3MutexAlloc
(5);

11633 
	`sqlite3_mutex_enter
(
mutex
);

11634 if( 
N
<=0 || 
pBuf
==0 )

11637 
sqlite3Prng
.
isInit
 = 0;

11638 
	`sqlite3_mutex_leave
(
mutex
);

11642 if( !
sqlite3Prng
.
isInit
 )

11645 int 
i
;

11646 char 
k
[256];

11647 
sqlite3Prng
.
j
 = 0;

11648 
sqlite3Prng
.
i
 = 0;

11649 
	`sqlite3OsRandomness
(
	`sqlite3_vfs_find
(0), 256, 
k
);

11650 for(
i
=0; i<256; i++)

11653 
sqlite3Prng
.
s
[
i
] = (
u8
)i;

11655 for(
i
=0; i<256; i++)

11658 
sqlite3Prng
.
j
 += sqlite3Prng.
s
[
i
] + 
k
[i];

11659 
t
 = 
sqlite3Prng
.
s
[sqlite3Prng.
j
];

11660 
sqlite3Prng
.
s
[sqlite3Prng.
j
] = sqlite3Prng.s[
i
];

11661 
sqlite3Prng
.
s
[
i
] = 
t
;

11663 
sqlite3Prng
.
isInit
 = 1;

11668 
sqlite3Prng
.
i
++;

11669 
t
 = 
sqlite3Prng
.
s
[sqlite3Prng.
i
];

11670 
sqlite3Prng
.
j
 += 
t
;

11671 
sqlite3Prng
.
s
[sqlite3Prng.
i
] = sqlite3Prng.s[sqlite3Prng.
j
];

11672 
sqlite3Prng
.
s
[sqlite3Prng.
j
] = 
t
;

11673 
t
 += 
sqlite3Prng
.
s
[sqlite3Prng.
i
];

11674 *(
zBuf
++) = 
sqlite3Prng
.
s
[
t
];

11675 }while( --
N
 );

11676 
	`sqlite3_mutex_leave
(
mutex
);

11677 
	}
}

11679 static struct 
sqlite3PrngType
 
	gsqlite3SavedPrng
;

11680 static void 
	$sqlite3PrngSaveState
(void)

11683 
	`memcpy
(

11684 &
sqlite3SavedPrng
,

11685 &
sqlite3Prng
,

11686 sizeof(
sqlite3Prng
)

11688 
	}
}

11689 static void 
	$sqlite3PrngRestoreState
(void)

11692 
	`memcpy
(

11693 &
sqlite3Prng
,

11694 &
sqlite3SavedPrng
,

11695 sizeof(
sqlite3Prng
)

11697 
	}
}

11699 struct 
	sSQLiteThread
 {

11700 
pthread_t
 
	mtid
;

11701 int 
	mdone
;

11702 void *
	mpOut
;

11703 void *(*
	mxTask
)(void*);

11704 void *
	mpIn
;

11708 static int 
sqlite3ThreadCreate
(

11709 
SQLiteThread
 **
ppThread
,

11710 void *(*
xTask
)(void*),

11711 void *
pIn


11715 
SQLiteThread
 *
	gp
;

11716 int 
	grc
;

11723 *
	gppThread
 = 0;

11724 
	gp
 = 
sqlite3Malloc
(sizeof(*
p
));

11725 if( 
	gp
==0 ) return 7;

11726 
memset
(
p
, 0, sizeof(*p));

11727 
	gp
->
	gxTask
 = 
xTask
;

11728 
	gp
->
	gpIn
 = 
pIn
;

11733 if( 
sqlite3FaultSim
(200) )

11736 
	grc
 = 1;

11738 
	grc
 = 
pthread_create
(&
p
->
tid
, 0, 
xTask
, 
pIn
);

11740 if( 
	grc
 )

11743 
	gp
->
	gdone
 = 1;

11744 
	gp
->
	gpOut
 = 
xTask
(
pIn
);

11746 *
	gppThread
 = 
p
;

11751 static int 
	$sqlite3ThreadJoin
(
SQLiteThread
 *
p
, void **
ppOut
)

11754 int 
rc
;

11757 if( (
p
==0) ) return 7;

11758 if( 
p
->
done
 )

11761 *
ppOut
 = 
p
->
pOut
;

11762 
rc
 = 0;

11764 
rc
 = 
	`pthread_join
(
p
->
tid
, 
ppOut
) ? 1 : 0;

11766 
	`sqlite3_free
(
p
);

11767 return 
rc
;

11768 
	}
}

11770 static const unsigned char 
	gsqlite3Utf8Trans1
[] = {

11781 static 
u32
 
	$sqlite3Utf8Read
(

11782 const unsigned char **
pz


11786 unsigned int 
c
;

11791 
c
 = *((*
pz
)++);

11792 if( 
c
>=0xc0 )

11795 
c
 = 
sqlite3Utf8Trans1
[c-0xc0];

11796 while( (*(*
pz
) & 0xc0)==0x80 )

11799 
c
 = (c<<6) + (0x3f & *((*
pz
)++));

11801 if( 
c
<0x80

11802 || (
c
&0xFFFFF800)==0xD800

11803 || (
c
&0xFFFFFFFE)==0xFFFE )

11805 
c
 = 0xFFFD; }

11807 return 
c
;

11808 
	}
}

11810 static 
__attribute__
((
noinline
)) int 
	$sqlite3VdbeMemTranslate
(
Mem
 *
pMem
, 
u8
 
desiredEnc
)

11813 int 
len
;

11814 unsigned char *
zOut
;

11815 unsigned char *
zIn
;

11816 unsigned char *
zTerm
;

11817 unsigned char *
z
;

11818 unsigned int 
c
;

11826 if( 
pMem
->
enc
!=1 && 
desiredEnc
!=1 )

11829 
u8
 
temp
;

11830 int 
rc
;

11831 
rc
 = 
	`sqlite3VdbeMemMakeWriteable
(
pMem
);

11832 if( 
rc
!=0 )

11838 
zIn
 = (
u8
*)
pMem
->
z
;

11839 
zTerm
 = &
zIn
[
pMem
->
n
&~1];

11840 while( 
zIn
<
zTerm
 )

11843 
temp
 = *
zIn
;

11844 *
zIn
 = *(zIn+1);

11845 
zIn
++;

11846 *
zIn
++ = 
temp
;

11848 
pMem
->
enc
 = 
desiredEnc
;

11849 goto 
translate_out
;

11853 if( 
desiredEnc
==1 )

11861 
pMem
->
n
 &= ~1;

11862 
len
 = 
pMem
->
n
 * 2 + 1;

11869 
len
 = 
pMem
->
n
 * 2 + 2;

11878 
zIn
 = (
u8
*)
pMem
->
z
;

11879 
zTerm
 = &
zIn
[
pMem
->
n
];

11880 
zOut
 = 
	`sqlite3DbMallocRaw
(
pMem
->
db
, 
len
);

11881 if( !
zOut
 )

11886 
z
 = 
zOut
;

11888 if( 
pMem
->
enc
==1 )

11891 if( 
desiredEnc
==2 )

11895 while( 
zIn
<
zTerm
 )

11898 
c
 = *(
zIn
++); if( c>=0xc0 )

11900 
c
 = 
sqlite3Utf8Trans1
[c-0xc0]; while( 
zIn
!=
zTerm
 && (*zIn & 0xc0)==0x80 )

11902 
c
 = (c<<6) + (0x3f & *(
zIn
++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE )

11904 
c
 = 0xFFFD; } };

11905 { if( 
c
<=0xFFFF )

11907 *
z
++ = (
u8
)(
c
&0x00FF); *z++ = (u8)((c>>8)&0x00FF); }else{ *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(c&0x00FF); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); } };

11912 while( 
zIn
<
zTerm
 )

11915 
c
 = *(
zIn
++); if( c>=0xc0 )

11917 
c
 = 
sqlite3Utf8Trans1
[c-0xc0]; while( 
zIn
!=
zTerm
 && (*zIn & 0xc0)==0x80 )

11919 
c
 = (c<<6) + (0x3f & *(
zIn
++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE )

11921 
c
 = 0xFFFD; } };

11922 { if( 
c
<=0xFFFF )

11924 *
z
++ = (
u8
)((
c
>>8)&0x00FF); *z++ = (u8)(c&0x00FF); }else{ *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); *z++ = (u8)(c&0x00FF); } };

11927 
pMem
->
n
 = (int)(
z
 - 
zOut
);

11928 *
z
++ = 0;

11931 if( 
pMem
->
enc
==2 )

11935 while( 
zIn
<
zTerm
 )

11938 { 
c
 = (*
zIn
++); c += ((*zIn++)<<8); if( c>=0xD800 && c<0xE000 && zIn<
zTerm
 )

11940 int 
c2
 = (*
zIn
++); c2 += ((*zIn++)<<8); 
c
 = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };

11941 { if( 
c
<0x00080 )

11943 *
z
++ = (
u8
)(
c
&0xFF); } else if( c<0x00800 )

11945 *
z
++ = 0xC0 + (
u8
)((
c
>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 )

11947 *
z
++ = 0xE0 + (
u8
)((
c
>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };

11951 while( 
zIn
<
zTerm
 )

11954 { 
c
 = ((*
zIn
++)<<8); c += (*zIn++); if( c>=0xD800 && c<0xE000 && zIn<
zTerm
 )

11956 int 
c2
 = ((*
zIn
++)<<8); c2 += (*zIn++); 
c
 = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };

11957 { if( 
c
<0x00080 )

11959 *
z
++ = (
u8
)(
c
&0xFF); } else if( c<0x00800 )

11961 *
z
++ = 0xC0 + (
u8
)((
c
>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 )

11963 *
z
++ = 0xE0 + (
u8
)((
c
>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };

11966 
pMem
->
n
 = (int)(
z
 - 
zOut
);

11968 *
z
 = 0;

11971 
c
 = 
pMem
->
flags
;

11972 
	`sqlite3VdbeMemRelease
(
pMem
);

11973 
pMem
->
flags
 = 0x0002|0x0200|(
c
&(0x001f|0x8000));

11974 
pMem
->
enc
 = 
desiredEnc
;

11975 
pMem
->
z
 = (char*)
zOut
;

11976 
pMem
->
zMalloc
 = pMem->
z
;

11977 
pMem
->
szMalloc
 = 
	`sqlite3DbMallocSize
(pMem->
db
, pMem->
z
);

11979 
translate_out
:

11988 
	}
}

11990 static int 
	$sqlite3VdbeMemHandleBom
(
Mem
 *
pMem
)

11993 int 
rc
 = 0;

11994 
u8
 
bom
 = 0;

11997 if( 
pMem
->
n
>1 )

12000 
u8
 
b1
 = *(u8 *)
pMem
->
z
;

12001 
u8
 
b2
 = *(((u8 *)
pMem
->
z
) + 1);

12002 if( 
b1
==0xFE && 
b2
==0xFF )

12005 
bom
 = 3;

12007 if( 
b1
==0xFF && 
b2
==0xFE )

12010 
bom
 = 2;

12014 if( 
bom
 )

12017 
rc
 = 
	`sqlite3VdbeMemMakeWriteable
(
pMem
);

12018 if( 
rc
==0 )

12021 
pMem
->
n
 -= 2;

12022 
	`memmove
(
pMem
->
z
, &pMem->z[2], pMem->
n
);

12023 
pMem
->
z
[pMem->
n
] = '\0';

12024 
pMem
->
z
[pMem->
n
+1] = '\0';

12025 
pMem
->
flags
 |= 0x0200;

12026 
pMem
->
enc
 = 
bom
;

12029 return 
rc
;

12030 
	}
}

12032 static int 
	$sqlite3Utf8CharLen
(const char *
zIn
, int 
nByte
)

12035 int 
r
 = 0;

12036 const 
u8
 *
z
 = (const u8*)
zIn
;

12037 const 
u8
 *
zTerm
;

12038 if( 
nByte
>=0 )

12041 
zTerm
 = &
z
[
nByte
];

12043 
zTerm
 = (const 
u8
*)(-1);

12046 while( *
z
!=0 && z<
zTerm
 )

12049 { if( (*(
z
++))>=0xc0 )

12051 while( (*
z
 & 0xc0)==0x80 )

12053 
z
++; } } };

12054 
r
++;

12056 return 
r
;

12057 
	}
}

12059 static char *
	$sqlite3Utf16to8
(
sqlite3
 *
db
, const void *
z
, int 
nByte
, 
u8
 
enc
)

12062 
Mem
 
m
;

12063 
	`memset
(&
m
, 0, sizeof(m));

12064 
m
.
db
 = db;

12065 
	`sqlite3VdbeMemSetStr
(&
m
, 
z
, 
nByte
, 
enc
, ((
sqlite3_destructor_type
)0));

12066 
	`sqlite3VdbeChangeEncoding
(&
m
, 1);

12067 if( 
db
->
mallocFailed
 )

12070 
	`sqlite3VdbeMemRelease
(&
m
);

12071 
m
.
z
 = 0;

12076 return 
m
.
z
;

12077 
	}
}

12084 static int 
	$sqlite3Utf16ByteLen
(const void *
zIn
, int 
nChar
)

12087 int 
c
;

12088 unsigned char const *
z
 = 
zIn
;

12089 int 
n
 = 0;

12094 while( 
n
<
nChar
 )

12097 { 
c
 = ((*
z
++)<<8); c += (*z++); if( c>=0xD800 && c<0xE000 && 1 )

12099 int 
c2
 = ((*
z
++)<<8); c2 += (*z++); 
c
 = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };

12100 
n
++;

12103 while( 
n
<
nChar
 )

12106 { 
c
 = (*
z
++); c += ((*z++)<<8); if( c>=0xD800 && c<0xE000 && 1 )

12108 int 
c2
 = (*
z
++); c2 += ((*z++)<<8); 
c
 = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };

12109 
n
++;

12112 return (int)(
z
-(unsigned char const *)
zIn
);

12113 
	}
}

12115 static int 
	$sqlite3FaultSim
(int 
iTest
)

12118 int (*
xCallback
)(int) = 
sqlite3Config
.
xTestCallback
;

12119 return 
xCallback
 ? 
	`xCallback
(
iTest
) : 0;

12120 
	}
}

12122 static int 
	$sqlite3IsNaN
(double 
x
)

12125 int 
rc
;

12127 volatile double 
y
 = 
x
;

12128 volatile double 
z
 = 
y
;

12129 
rc
 = (
y
!=
z
);

12134 return 
rc
;

12135 
	}
}

12137 static int 
	$sqlite3Strlen30
(const char *
z
)

12140 if( 
z
==0 ) return 0;

12141 return 0x3fffffff & (int)
	`strlen
(
z
);

12142 
	}
}

12144 static char *
	$sqlite3ColumnType
(
Column
 *
pCol
, char *
zDflt
)

12147 if( (
pCol
->
colFlags
 & 0x0004)==0 ) return 
zDflt
;

12148 return 
pCol
->
zName
 + 
	`strlen
(pCol->zName) + 1;

12149 
	}
}

12156 static 
__attribute__
((
noinline
)) void 
	$sqlite3ErrorFinish
(
sqlite3
 *
db
, int 
err_code
)

12159 if( 
db
->
pErr
 ) 
	`sqlite3ValueSetNull
(db->pErr);

12160 
	`sqlite3SystemError
(
db
, 
err_code
);

12161 
	}
}

12168 static void 
	$sqlite3Error
(
sqlite3
 *
db
, int 
err_code
)

12172 
db
->
errCode
 = 
err_code
;

12173 if( 
err_code
 || 
db
->
pErr
 ) 
	`sqlite3ErrorFinish
(db, err_code);

12174 
	}
}

12180 static void 
	$sqlite3SystemError
(
sqlite3
 *
db
, int 
rc
)

12183 if( 
rc
==(10 | (12<<8)) ) return;

12184 
rc
 &= 0xff;

12185 if( 
rc
==14 || rc==10 )

12188 
db
->
iSysErrno
 = 
	`sqlite3OsGetLastError
(db->
pVfs
);

12190 
	}
}

12192 static void 
	$sqlite3ErrorWithMsg
(
sqlite3
 *
db
, int 
err_code
, const char *
zFormat
, ...)

12196 
db
->
errCode
 = 
err_code
;

12197 
	`sqlite3SystemError
(
db
, 
err_code
);

12198 if( 
zFormat
==0 )

12201 
	`sqlite3Error
(
db
, 
err_code
);

12202 }else if( 
db
->
pErr
 || (db->pErr = 
	`sqlite3ValueNew
(db))!=0 )

12205 char *
z
;

12206 
va_list
 
ap
;

12207 
	`__builtin_va_start
(
ap
,
zFormat
);

12208 
z
 = 
	`sqlite3VMPrintf
(
db
, 
zFormat
, 
ap
);

12209 
	`__builtin_va_end
(
ap
);

12210 
	`sqlite3ValueSetStr
(
db
->
pErr
, -1, 
z
, 1, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

12212 
	}
}

12214 static void 
	$sqlite3ErrorMsg
(
Parse
 *
pParse
, const char *
zFormat
, ...)

12217 char *
zMsg
;

12218 
va_list
 
ap
;

12219 
sqlite3
 *
db
 = 
pParse
->db;

12220 
	`__builtin_va_start
(
ap
,
zFormat
);

12221 
zMsg
 = 
	`sqlite3VMPrintf
(
db
, 
zFormat
, 
ap
);

12222 
	`__builtin_va_end
(
ap
);

12223 if( 
db
->
suppressErr
 )

12226 
	`sqlite3DbFree
(
db
, 
zMsg
);

12228 
pParse
->
nErr
++;

12229 
	`sqlite3DbFree
(
db
, 
pParse
->
zErrMsg
);

12230 
pParse
->
zErrMsg
 = 
zMsg
;

12231 
pParse
->
rc
 = 1;

12233 
	}
}

12235 static int 
	$sqlite3Dequote
(char *
z
)

12238 char 
quote
;

12239 int 
i
, 
j
;

12240 if( 
z
==0 ) return -1;

12241 
quote
 = 
z
[0];

12242 switch( 
quote
 )

12248 case '[': 
quote
 = ']'; break;

12251 for(
i
=1, 
j
=0;; i++)

12255 if( 
z
[
i
]==
quote
 )

12258 if( 
z
[
i
+1]==
quote
 )

12261 
z
[
j
++] = 
quote
;

12262 
i
++;

12267 
z
[
j
++] = z[
i
];

12270 
z
[
j
] = 0;

12271 return 
j
;

12272 
	}
}

12277 static void 
	$sqlite3TokenInit
(
Token
 *
p
, char *
z
)

12280 
p
->
z
 = z;

12281 
p
->
n
 = 
	`sqlite3Strlen30
(
z
);

12282 
	}
}

12284 int 
	$sqlite3_stricmp
(const char *
zLeft
, const char *
zRight
)

12287 if( 
zLeft
==0 )

12290 return 
zRight
 ? -1 : 0;

12291 }else if( 
zRight
==0 )

12296 return 
	`sqlite3StrICmp
(
zLeft
, 
zRight
);

12297 
	}
}

12298 static int 
	$sqlite3StrICmp
(const char *
zLeft
, const char *
zRight
)

12301 unsigned char *
a
, *
b
;

12302 int 
c
;

12303 
a
 = (unsigned char *)
zLeft
;

12304 
b
 = (unsigned char *)
zRight
;

12308 
c
 = (int)
sqlite3UpperToLower
[*
a
] - (int)sqlite3UpperToLower[*
b
];

12309 if( 
c
 || *
a
==0 ) break;

12310 
a
++;

12311 
b
++;

12313 return 
c
;

12314 
	}
}

12315 int 
	$sqlite3_strnicmp
(const char *
zLeft
, const char *
zRight
, int 
N
)

12318 register unsigned char *
a
, *
b
;

12319 if( 
zLeft
==0 )

12322 return 
zRight
 ? -1 : 0;

12323 }else if( 
zRight
==0 )

12328 
a
 = (unsigned char *)
zLeft
;

12329 
b
 = (unsigned char *)
zRight
;

12330 while( 
N
-- > 0 && *
a
!=0 && 
sqlite3UpperToLower
[*a]==sqlite3UpperToLower[*
b
])

12332 
a
++; 
b
++; }

12333 return 
N
<0 ? 0 : 
sqlite3UpperToLower
[*
a
] - sqlite3UpperToLower[*
b
];

12334 
	}
}

12336 static int 
	$sqlite3AtoF
(const char *
z
, double *
pResult
, int 
length
, 
u8
 
enc
)

12340 int 
incr
;

12341 const char *
zEnd
 = 
z
 + 
length
;

12343 int 
sign
 = 1;

12344 
i64
 
s
 = 0;

12345 int 
d
 = 0;

12346 int 
esign
 = 1;

12347 int 
e
 = 0;

12348 int 
eValid
 = 1;

12349 double 
result
;

12350 int 
nDigits
 = 0;

12351 int 
nonNum
 = 0;

12354 *
pResult
 = 0.0;

12356 if( 
enc
==1 )

12359 
incr
 = 1;

12361 int 
i
;

12362 
incr
 = 2;

12364 for(
i
=3-
enc
; i<
length
 && 
z
[i]==0; i+=2)

12367 
nonNum
 = 
i
<
length
;

12368 
zEnd
 = 
z
+
i
+
enc
-3;

12369 
z
 += (
enc
&1);

12373 while( 
z
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*z)]&0x01) ) z+=
incr
;

12374 if( 
z
>=
zEnd
 ) return 0;

12377 if( *
z
=='-' )

12380 
sign
 = -1;

12381 
z
+=
incr
;

12382 }else if( *
z
=='+' )

12385 
z
+=
incr
;

12389 while( 
z
<
zEnd
 && z[0]=='0' ) z+=
incr
, 
nDigits
++;

12392 while( 
z
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*z)]&0x04) && 
s
<(((0xffffffff|(((
i64
)0x7fffffff)<<32))-9)/10) )

12395 
s
 = s*10 + (*
z
 - '0');

12396 
z
+=
incr
, 
nDigits
++;

12401 while( 
z
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*z)]&0x04) ) z+=
incr
, 
nDigits
++, 
d
++;

12402 if( 
z
>=
zEnd
 ) goto 
do_atof_calc
;

12405 if( *
z
=='.' )

12408 
z
+=
incr
;

12411 while( 
z
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*z)]&0x04) && 
s
<(((0xffffffff|(((
i64
)0x7fffffff)<<32))-9)/10) )

12414 
s
 = s*10 + (*
z
 - '0');

12415 
z
+=
incr
, 
nDigits
++, 
d
--;

12418 while( 
z
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*z)]&0x04) ) z+=
incr
, 
nDigits
++;

12420 if( 
z
>=
zEnd
 ) goto 
do_atof_calc
;

12423 if( *
z
=='e' || *z=='E' )

12426 
z
+=
incr
;

12427 
eValid
 = 0;

12428 if( 
z
>=
zEnd
 ) goto 
do_atof_calc
;

12430 if( *
z
=='-' )

12433 
esign
 = -1;

12434 
z
+=
incr
;

12435 }else if( *
z
=='+' )

12438 
z
+=
incr
;

12441 while( 
z
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*z)]&0x04) )

12444 
e
 = e<10000 ? (e*10 + (*
z
 - '0')) : 10000;

12445 
z
+=
incr
;

12446 
eValid
 = 1;

12451 if( 
nDigits
 && 
eValid
 )

12454 while( 
z
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*z)]&0x01) ) z+=
incr
;

12457 
do_atof_calc
:

12459 
e
 = (e*
esign
) + 
d
;

12460 if( 
e
<0 ) {

12461 
esign
 = -1;

12462 
e
 *= -1;

12464 
esign
 = 1;

12468 if( !
s
 ) {

12471 
result
 = (
sign
<0 && 
nDigits
) ? -(double)0 : (double)0;

12474 if( 
esign
>0 )

12477 while( 
s
<((0xffffffff|(((
i64
)0x7fffffff)<<32))/10) && 
e
>0 ) e--,s*=10;

12479 while( !(
s
%10) && 
e
>0 ) e--,s/=10;

12483 
s
 = 
sign
<0 ? -s : s;

12487 if( 
e
 )

12490 long double 
scale
 = 1.0;

12492 if( 
e
>307 && e<342 )

12495 while( 
e
%308 ) { 
scale
 *= 1.0e+1; e -= 1; }

12496 if( 
esign
<0 )

12499 
result
 = 
s
 / 
scale
;

12500 
result
 /= 1.0e+308;

12502 
result
 = 
s
 * 
scale
;

12503 
result
 *= 1.0e+308;

12505 }else if( 
e
>=342 )

12508 if( 
esign
<0 )

12511 
result
 = 0.0*
s
;

12513 
result
 = 1e308*1e308*
s
;

12518 while( 
e
%22 ) { 
scale
 *= 1.0e+1; e -= 1; }

12519 while( 
e
>0 ) { 
scale
 *= 1.0e+22; e -= 22; }

12520 if( 
esign
<0 )

12523 
result
 = 
s
 / 
scale
;

12525 
result
 = 
s
 * 
scale
;

12529 
result
 = (double)
s
;

12534 *
pResult
 = 
result
;

12537 return 
z
>=
zEnd
 && 
nDigits
>0 && 
eValid
 && 
nonNum
==0;

12541 
	}
}

12543 static int 
	$compare2pow63
(const char *
zNum
, int 
incr
)

12546 int 
c
 = 0;

12547 int 
i
;

12549 const char *
pow63
 = "922337203685477580";

12550 for(
i
=0; 
c
==0 && i<18; i++)

12553 
c
 = (
zNum
[
i
*
incr
]-
pow63
[i])*10;

12555 if( 
c
==0 )

12558 
c
 = 
zNum
[18*
incr
] - '8';

12563 return 
c
;

12564 
	}
}

12566 static int 
	$sqlite3Atoi64
(const char *
zNum
, 
i64
 *
pNum
, int 
length
, 
u8
 
enc
)

12569 int 
incr
;

12570 
u64
 
u
 = 0;

12571 int 
neg
 = 0;

12572 int 
i
;

12573 int 
c
 = 0;

12574 int 
nonNum
 = 0;

12575 const char *
zStart
;

12576 const char *
zEnd
 = 
zNum
 + 
length
;

12578 if( 
enc
==1 )

12581 
incr
 = 1;

12583 
incr
 = 2;

12585 for(
i
=3-
enc
; i<
length
 && 
zNum
[i]==0; i+=2)

12588 
nonNum
 = 
i
<
length
;

12589 
zEnd
 = 
zNum
+
i
+
enc
-3;

12590 
zNum
 += (
enc
&1);

12592 while( 
zNum
<
zEnd
 && (
sqlite3CtypeMap
[(unsigned char)(*zNum)]&0x01) ) zNum+=
incr
;

12593 if( 
zNum
<
zEnd
 )

12596 if( *
zNum
=='-' )

12599 
neg
 = 1;

12600 
zNum
+=
incr
;

12601 }else if( *
zNum
=='+' )

12604 
zNum
+=
incr
;

12607 
zStart
 = 
zNum
;

12608 while( 
zNum
<
zEnd
 && zNum[0]=='0' )

12610 
zNum
+=
incr
; }

12611 for(
i
=0; &
zNum
[i]<
zEnd
 && (
c
=zNum[i])>='0' && c<='9'; i+=
incr
)

12614 
u
 = u*10 + 
c
 - '0';

12616 if( 
u
>(0xffffffff|(((
i64
)0x7fffffff)<<32)) )

12619 *
pNum
 = 
neg
 ? (((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : (0xffffffff|(((i64)0x7fffffff)<<32));

12620 }else if( 
neg
 )

12623 *
pNum
 = -(
i64
)
u
;

12625 *
pNum
 = (
i64
)
u
;

12630 if( (
c
!=0 && &
zNum
[
i
]<
zEnd
) || (i==0 && 
zStart
==zNum)

12631 || 
i
>19*
incr
 || 
nonNum
 )

12637 }else if( 
i
<19*
incr
 )

12645 
c
 = 
	`compare2pow63
(
zNum
, 
incr
);

12646 if( 
c
<0 )

12652 }else if( 
c
>0 )

12661 return 
neg
 ? 0 : 2;

12664 
	}
}

12666 static int 
	$sqlite3DecOrHexToI64
(const char *
z
, 
i64
 *
pOut
)

12670 if( 
z
[0]=='0'

12671 && (
z
[1]=='x' || z[1]=='X')

12672 && (
sqlite3CtypeMap
[(unsigned char)(
z
[2])]&0x08)

12676 
u64
 
u
 = 0;

12677 int 
i
, 
k
;

12678 for(
i
=2; 
z
[i]=='0'; i++)

12681 for(
k
=
i
; (
sqlite3CtypeMap
[(unsigned char)(
z
[k])]&0x08); k++)

12684 
u
 = u*16 + 
	`sqlite3HexToInt
(
z
[
k
]);

12686 
	`memcpy
(
pOut
, &
u
, 8);

12687 return (
z
[
k
]==0 && k-
i
<=16) ? 0 : 1;

12691 return 
	`sqlite3Atoi64
(
z
, 
pOut
, 
	`sqlite3Strlen30
(z), 1);

12693 
	}
}

12695 static int 
	$sqlite3GetInt32
(const char *
zNum
, int *
pValue
)

12698 
sqlite_int64
 
v
 = 0;

12699 int 
i
, 
c
;

12700 int 
neg
 = 0;

12701 if( 
zNum
[0]=='-' )

12704 
neg
 = 1;

12705 
zNum
++;

12706 }else if( 
zNum
[0]=='+' )

12709 
zNum
++;

12712 else if( 
zNum
[0]=='0'

12713 && (
zNum
[1]=='x' || zNum[1]=='X')

12714 && (
sqlite3CtypeMap
[(unsigned char)(
zNum
[2])]&0x08)

12718 
u32
 
u
 = 0;

12719 
zNum
 += 2;

12720 while( 
zNum
[0]=='0' ) zNum++;

12721 for(
i
=0; (
sqlite3CtypeMap
[(unsigned char)(
zNum
[i])]&0x08) && i<8; i++)

12724 
u
 = u*16 + 
	`sqlite3HexToInt
(
zNum
[
i
]);

12726 if( (
u
&0x80000000)==0 && (
sqlite3CtypeMap
[(unsigned char)(
zNum
[
i
])]&0x08)==0 )

12729 
	`memcpy
(
pValue
, &
u
, 4);

12736 while( 
zNum
[0]=='0' ) zNum++;

12737 for(
i
=0; i<11 && (
c
 = 
zNum
[i] - '0')>=0 && c<=9; i++)

12740 
v
 = v*10 + 
c
;

12749 if( 
i
>10 )

12755 if( 
v
-
neg
>2147483647 )

12760 if( 
neg
 )

12763 
v
 = -v;

12765 *
pValue
 = (int)
v
;

12767 
	}
}

12773 static int 
	$sqlite3Atoi
(const char *
z
)

12776 int 
x
 = 0;

12777 if( 
z
 ) 
	`sqlite3GetInt32
(z, &
x
);

12778 return 
x
;

12779 
	}
}

12781 static int 
__attribute__
((
noinline
)) 
	$putVarint64
(unsigned char *
p
, 
u64
 
v
)

12784 int 
i
, 
j
, 
n
;

12785 
u8
 
buf
[10];

12786 if( 
v
 & (((
u64
)0xff000000)<<32) )

12789 
p
[8] = (
u8
)
v
;

12790 
v
 >>= 8;

12791 for(
i
=7; i>=0; i--)

12794 
p
[
i
] = (
u8
)((
v
 & 0x7f) | 0x80);

12795 
v
 >>= 7;

12799 
n
 = 0;

12801 
buf
[
n
++] = (
u8
)((
v
 & 0x7f) | 0x80);

12802 
v
 >>= 7;

12803 }while( 
v
!=0 );

12804 
buf
[0] &= 0x7f;

12806 for(
i
=0, 
j
=
n
-1; j>=0; j--, i++)

12809 
p
[
i
] = 
buf
[
j
];

12811 return 
n
;

12812 
	}
}

12813 static int 
	$sqlite3PutVarint
(unsigned char *
p
, 
u64
 
v
)

12816 if( 
v
<=0x7f )

12819 
p
[0] = 
v
&0x7f;

12822 if( 
v
<=0x3fff )

12825 
p
[0] = ((
v
>>7)&0x7f)|0x80;

12826 
p
[1] = 
v
&0x7f;

12829 return 
	`putVarint64
(
p
,
v
);

12830 
	}
}

12832 static 
u8
 
	$sqlite3GetVarint
(const unsigned char *
p
, 
u64
 *
v
)

12835 
u32
 
a
,
b
,
s
;

12837 
a
 = *
p
;

12839 if (!(
a
&0x80))

12841 *
v
 = 
a
;

12845 
p
++;

12846 
b
 = *
p
;

12848 if (!(
b
&0x80))

12850 
a
 &= 0x7f;

12851 
a
 = a<<7;

12852 
a
 |= 
b
;

12853 *
v
 = 
a
;

12861 
p
++;

12862 
a
 = a<<14;

12863 
a
 |= *
p
;

12865 if (!(
a
&0x80))

12867 
a
 &= 0x001fc07f;

12868 
b
 &= 0x7f;

12869 
b
 = b<<7;

12870 
a
 |= 
b
;

12871 *
v
 = 
a
;

12876 
a
 &= 0x001fc07f;

12877 
p
++;

12878 
b
 = b<<14;

12879 
b
 |= *
p
;

12881 if (!(
b
&0x80))

12883 
b
 &= 0x001fc07f;

12886 
a
 = a<<7;

12887 
a
 |= 
b
;

12888 *
v
 = 
a
;

12897 
b
 &= 0x001fc07f;

12898 
s
 = 
a
;

12901 
p
++;

12902 
a
 = a<<14;

12903 
a
 |= *
p
;

12905 if (!(
a
&0x80))

12911 
b
 = b<<7;

12912 
a
 |= 
b
;

12913 
s
 = s>>18;

12914 *
v
 = ((
u64
)
s
)<<32 | 
a
;

12919 
s
 = s<<7;

12920 
s
 |= 
b
;

12923 
p
++;

12924 
b
 = b<<14;

12925 
b
 |= *
p
;

12927 if (!(
b
&0x80))

12931 
a
 &= 0x001fc07f;

12932 
a
 = a<<7;

12933 
a
 |= 
b
;

12934 
s
 = s>>18;

12935 *
v
 = ((
u64
)
s
)<<32 | 
a
;

12939 
p
++;

12940 
a
 = a<<14;

12941 
a
 |= *
p
;

12943 if (!(
a
&0x80))

12945 
a
 &= 0xf01fc07f;

12946 
b
 &= 0x001fc07f;

12947 
b
 = b<<7;

12948 
a
 |= 
b
;

12949 
s
 = s>>11;

12950 *
v
 = ((
u64
)
s
)<<32 | 
a
;

12955 
a
 &= 0x001fc07f;

12956 
p
++;

12957 
b
 = b<<14;

12958 
b
 |= *
p
;

12960 if (!(
b
&0x80))

12962 
b
 &= 0xf01fc07f;

12965 
a
 = a<<7;

12966 
a
 |= 
b
;

12967 
s
 = s>>4;

12968 *
v
 = ((
u64
)
s
)<<32 | 
a
;

12972 
p
++;

12973 
a
 = a<<15;

12974 
a
 |= *
p
;

12979 
b
 &= 0x001fc07f;

12980 
b
 = b<<8;

12981 
a
 |= 
b
;

12983 
s
 = s<<4;

12984 
b
 = 
p
[-4];

12985 
b
 &= 0x7f;

12986 
b
 = b>>3;

12987 
s
 |= 
b
;

12989 *
v
 = ((
u64
)
s
)<<32 | 
a
;

12992 
	}
}

12994 static 
u8
 
	$sqlite3GetVarint32
(const unsigned char *
p
, 
u32
 *
v
)

12997 
u32
 
a
,
b
;

13001 
a
 = *
p
;

13003 
p
++;

13004 
b
 = *
p
;

13006 if (!(
b
&0x80))

13009 
a
 &= 0x7f;

13010 
a
 = a<<7;

13011 *
v
 = 
a
 | 
b
;

13016 
p
++;

13017 
a
 = a<<14;

13018 
a
 |= *
p
;

13020 if (!(
a
&0x80))

13023 
a
 &= (0x7f<<14)|(0x7f);

13024 
b
 &= 0x7f;

13025 
b
 = b<<7;

13026 *
v
 = 
a
 | 
b
;

13031 
u64
 
v64
;

13032 
u8
 
n
;

13034 
p
 -= 2;

13035 
n
 = 
	`sqlite3GetVarint
(
p
, &
v64
);

13037 if( (
v64
 & ((((
u64
)1)<<32)-1))!=v64 )

13040 *
v
 = 0xffffffff;

13042 *
v
 = (
u32
)
v64
;

13044 return 
n
;

13047 
	}
}

13053 static int 
	$sqlite3VarintLen
(
u64
 
v
)

13056 int 
i
;

13057 for(
i
=1; (
v
 >>= 7)!=0; i++)

13060 return 
i
;

13061 
	}
}

13067 static 
u32
 
	$sqlite3Get4byte
(const 
u8
 *
p
)

13076 
u32
 
x
;

13077 
	`memcpy
(&
x
,
p
,4);

13078 return 
	`__builtin_bswap32
(
x
);

13080 
	}
}

13081 static void 
	$sqlite3Put4byte
(unsigned char *
p
, 
u32
 
v
)

13088 
u32
 
x
 = 
	`__builtin_bswap32
(
v
);

13089 
	`memcpy
(
p
,&
x
,4);

13091 
	}
}

13093 static 
u8
 
	$sqlite3HexToInt
(int 
h
)

13098 
h
 += 9*(1&(h>>6));

13103 return (
u8
)(
h
 & 0xf);

13104 
	}
}

13106 static void *
	$sqlite3HexToBlob
(
sqlite3
 *
db
, const char *
z
, int 
n
)

13109 char *
zBlob
;

13110 int 
i
;

13112 
zBlob
 = (char *)
	`sqlite3DbMallocRawNN
(
db
, 
n
/2 + 1);

13113 
n
--;

13114 if( 
zBlob
 )

13117 for(
i
=0; i<
n
; i+=2)

13120 
zBlob
[
i
/2] = (
	`sqlite3HexToInt
(
z
[i])<<4) | sqlite3HexToInt(z[i+1]);

13122 
zBlob
[
i
/2] = 0;

13124 return 
zBlob
;

13125 
	}
}

13133 static void 
	$logBadConnection
(const char *
zType
)

13136 
	`sqlite3_log
(21,

13138 
zType


13140 
	}
}

13142 static int 
	$sqlite3SafetyCheckOk
(
sqlite3
 *
db
)

13145 
u32
 
magic
;

13146 if( 
db
==0 )

13149 
	`logBadConnection
("NULL");

13152 
magic
 = 
db
->magic;

13153 if( 
magic
!=0xa029a697 )

13156 if( 
	`sqlite3SafetyCheckSickOrOk
(
db
) )

13160 
	`logBadConnection
("unopened");

13166 
	}
}

13167 static int 
	$sqlite3SafetyCheckSickOrOk
(
sqlite3
 *
db
)

13170 
u32
 
magic
;

13171 
magic
 = 
db
->magic;

13172 if( 
magic
!=0x4b771290 &&

13173 
magic
!=0xa029a697 &&

13174 
magic
!=0xf03b7906 )

13178 
	`logBadConnection
("invalid");

13183 
	}
}

13191 static int 
	$sqlite3AddInt64
(
i64
 *
pA
, i64 
iB
)

13194 
i64
 
iA
 = *
pA
;

13197 if( 
iB
>=0 )

13202 if( 
iA
>0 && (0xffffffff|(((
i64
)0x7fffffff)<<32)) - iA < 
iB
 ) return 1;

13206 if( 
iA
<0 && -(iA + (0xffffffff|(((
i64
)0x7fffffff)<<32))) > 
iB
 + 1 ) return 1;

13208 *
pA
 += 
iB
;

13210 
	}
}

13211 static int 
	$sqlite3SubInt64
(
i64
 *
pA
, i64 
iB
)

13215 if( 
iB
==(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) )

13219 if( (*
pA
)>=0 ) return 1;

13220 *
pA
 -= 
iB
;

13223 return 
	`sqlite3AddInt64
(
pA
, -
iB
);

13225 
	}
}

13228 static int 
	$sqlite3MulInt64
(
i64
 *
pA
, i64 
iB
)

13231 
i64
 
iA
 = *
pA
;

13232 
i64
 
iA1
, 
iA0
, 
iB1
, 
iB0
, 
r
;

13234 
iA1
 = 
iA
/(((
i64
)1)<<32);

13235 
iA0
 = 
iA
 % (((
i64
)1)<<32);

13236 
iB1
 = 
iB
/(((
i64
)1)<<32);

13237 
iB0
 = 
iB
 % (((
i64
)1)<<32);

13238 if( 
iA1
==0 )

13241 if( 
iB1
==0 )

13244 *
pA
 *= 
iB
;

13247 
r
 = 
iA0
*
iB1
;

13248 }else if( 
iB1
==0 )

13251 
r
 = 
iA1
*
iB0
;

13260 if( 
r
<(-(((
i64
)1)<<31)) || r>=(((i64)1)<<31) ) return 1;

13261 
r
 *= (((
i64
)1)<<32);

13262 if( 
	`sqlite3AddInt64
(&
r
, 
iA0
*
iB0
) ) return 1;

13263 *
pA
 = 
r
;

13265 
	}
}

13271 static int 
	$sqlite3AbsInt32
(int 
x
)

13274 if( 
x
>=0 ) return x;

13275 if( 
x
==(int)0x80000000 ) return 0x7fffffff;

13276 return -
x
;

13277 
	}
}

13279 static 
LogEst
 
	$sqlite3LogEstAdd
(
LogEst
 
a
, LogEst 
b
)

13282 static const unsigned char 
x
[] = {

13293 if( 
a
>=
b
 )

13296 if( 
a
>
b
+49 ) return a;

13297 if( 
a
>
b
+31 ) return a+1;

13298 return 
a
+
x
[a-
b
];

13300 if( 
b
>
a
+49 ) return b;

13301 if( 
b
>
a
+31 ) return b+1;

13302 return 
b
+
x
[b-
a
];

13304 
	}
}

13310 static 
LogEst
 
	$sqlite3LogEst
(
u64
 
x
)

13313 static 
LogEst
 
a
[] = { 0, 2, 3, 5, 6, 7, 8, 9 };

13314 
LogEst
 
y
 = 40;

13315 if( 
x
<8 )

13318 if( 
x
<2 ) return 0;

13319 while( 
x
<8 )

13321 
y
 -= 10; 
x
 <<= 1; }

13323 while( 
x
>255 )

13325 
y
 += 40; 
x
 >>= 4; }

13326 while( 
x
>15 )

13328 
y
 += 10; 
x
 >>= 1; }

13330 return 
a
[
x
&7] + 
y
 - 10;

13331 
	}
}

13338 static 
LogEst
 
	$sqlite3LogEstFromDouble
(double 
x
)

13341 
u64
 
a
;

13342 
LogEst
 
e
;

13344 if( 
x
<=1 ) return 0;

13345 if( 
x
<=2000000000 ) return 
	`sqlite3LogEst
((
u64
)x);

13346 
	`memcpy
(&
a
, &
x
, 8);

13347 
e
 = (
a
>>52) - 1022;

13348 return 
e
*10;

13349 
	}
}

13351 static void 
	$sqlite3HashInit
(
Hash
 *
pNew
)

13355 
pNew
->
first
 = 0;

13356 
pNew
->
count
 = 0;

13357 
pNew
->
htsize
 = 0;

13358 
pNew
->
ht
 = 0;

13359 
	}
}

13365 static void 
	$sqlite3HashClear
(
Hash
 *
pH
)

13368 
HashElem
 *
elem
;

13371 
elem
 = 
pH
->
first
;

13372 
pH
->
first
 = 0;

13373 
	`sqlite3_free
(
pH
->
ht
);

13374 
pH
->
ht
 = 0;

13375 
pH
->
htsize
 = 0;

13376 while( 
elem
 )

13379 
HashElem
 *
next_elem
 = 
elem
->
next
;

13380 
	`sqlite3_free
(
elem
);

13381 
elem
 = 
next_elem
;

13383 
pH
->
count
 = 0;

13384 
	}
}

13389 static unsigned int 
	$strHash
(const char *
z
)

13392 unsigned int 
h
 = 0;

13393 unsigned char 
c
;

13394 while( (
c
 = (unsigned char)*
z
++)!=0 )

13397 
h
 = (h<<3) ^ h ^ 
sqlite3UpperToLower
[
c
];

13399 return 
h
;

13400 
	}
}

13406 static void 
	$insertElement
(

13407 
Hash
 *
pH
,

13408 struct 
_ht
 *
pEntry
,

13409 
HashElem
 *
pNew


13413 
HashElem
 *
pHead
;

13414 if( 
pEntry
 )

13417 
pHead
 = 
pEntry
->
count
 ? pEntry->
chain
 : 0;

13418 
pEntry
->
count
++;

13419 
pEntry
->
chain
 = 
pNew
;

13421 
pHead
 = 0;

13423 if( 
pHead
 )

13426 
pNew
->
next
 = 
pHead
;

13427 
pNew
->
prev
 = 
pHead
->prev;

13428 if( 
pHead
->
prev
 )

13430 
pHead
->
prev
->
next
 = 
pNew
; }

13431 else { 
pH
->
first
 = 
pNew
; }

13432 
pHead
->
prev
 = 
pNew
;

13434 
pNew
->
next
 = 
pH
->
first
;

13435 if( 
pH
->
first
 )

13437 
pH
->
first
->
prev
 = 
pNew
; }

13438 
pNew
->
prev
 = 0;

13439 
pH
->
first
 = 
pNew
;

13441 
	}
}

13443 static int 
	$rehash
(
Hash
 *
pH
, unsigned int 
new_size
)

13446 struct 
_ht
 *
new_ht
;

13447 
HashElem
 *
elem
, *
next_elem
;

13450 if( 
new_size
*sizeof(struct 
_ht
)>1024 )

13453 
new_size
 = 1024/sizeof(struct 
_ht
);

13455 if( 
new_size
==
pH
->
htsize
 ) return 0;

13457 
	`sqlite3BeginBenignMalloc
();

13458 
new_ht
 = (struct 
_ht
 *)
	`sqlite3Malloc
( 
new_size
*sizeof(struct _ht) );

13459 
	`sqlite3EndBenignMalloc
();

13461 if( 
new_ht
==0 ) return 0;

13462 
	`sqlite3_free
(
pH
->
ht
);

13463 
pH
->
ht
 = 
new_ht
;

13464 
pH
->
htsize
 = 
new_size
 = 
	`sqlite3MallocSize
(
new_ht
)/sizeof(struct 
_ht
);

13465 
	`memset
(
new_ht
, 0, 
new_size
*sizeof(struct 
_ht
));

13466 for(
elem
=
pH
->
first
, pH->first=0; elem; elem = 
next_elem
)

13469 unsigned int 
h
 = 
	`strHash
(
elem
->
pKey
) % 
new_size
;

13470 
next_elem
 = 
elem
->
next
;

13471 
	`insertElement
(
pH
, &
new_ht
[
h
], 
elem
);

13474 
	}
}

13480 static 
HashElem
 *
	$findElementWithHash
(

13481 const 
Hash
 *
pH
,

13482 const char *
pKey
,

13483 unsigned int *
pHash


13487 
HashElem
 *
elem
;

13488 int 
count
;

13489 unsigned int 
h
;

13491 if( 
pH
->
ht
 )

13494 struct 
_ht
 *
pEntry
;

13495 
h
 = 
	`strHash
(
pKey
) % 
pH
->
htsize
;

13496 
pEntry
 = &
pH
->
ht
[
h
];

13497 
elem
 = 
pEntry
->
chain
;

13498 
count
 = 
pEntry
->count;

13500 
h
 = 0;

13501 
elem
 = 
pH
->
first
;

13502 
count
 = 
pH
->count;

13504 *
pHash
 = 
h
;

13505 while( 
count
-- )

13509 if( 
	`sqlite3StrICmp
(
elem
->
pKey
,pKey)==0 )

13512 return 
elem
;

13514 
elem
 = elem->
next
;

13517 
	}
}

13522 static void 
	$removeElementGivenHash
(

13523 
Hash
 *
pH
,

13524 
HashElem
* 
elem
,

13525 unsigned int 
h


13529 struct 
_ht
 *
pEntry
;

13530 if( 
elem
->
prev
 )

13533 
elem
->
prev
->
next
 = elem->next;

13535 
pH
->
first
 = 
elem
->
next
;

13537 if( 
elem
->
next
 )

13540 
elem
->
next
->
prev
 = elem->prev;

13542 if( 
pH
->
ht
 )

13545 
pEntry
 = &
pH
->
ht
[
h
];

13546 if( 
pEntry
->
chain
==
elem
 )

13549 
pEntry
->
chain
 = 
elem
->
next
;

13551 
pEntry
->
count
--;

13554 
	`sqlite3_free
( 
elem
 );

13555 
pH
->
count
--;

13556 if( 
pH
->
count
==0 )

13561 
	`sqlite3HashClear
(
pH
);

13563 
	}
}

13569 static void *
	$sqlite3HashFind
(const 
Hash
 *
pH
, const char *
pKey
)

13572 
HashElem
 *
elem
;

13573 unsigned int 
h
;

13577 
elem
 = 
	`findElementWithHash
(
pH
, 
pKey
, &
h
);

13578 return 
elem
 ? elem->
data
 : 0;

13579 
	}
}

13581 static void *
	$sqlite3HashInsert
(
Hash
 *
pH
, const char *
pKey
, void *
data
)

13584 unsigned int 
h
;

13585 
HashElem
 *
elem
;

13586 
HashElem
 *
new_elem
;

13590 
elem
 = 
	`findElementWithHash
(
pH
,
pKey
,&
h
);

13591 if( 
elem
 )

13594 void *
old_data
 = 
elem
->
data
;

13595 if( 
data
==0 )

13598 
	`removeElementGivenHash
(
pH
,
elem
,
h
);

13600 
elem
->
data
 = data;

13601 
elem
->
pKey
 = pKey;

13603 return 
old_data
;

13605 if( 
data
==0 ) return 0;

13606 
new_elem
 = (
HashElem
*)
	`sqlite3Malloc
( sizeof(HashElem) );

13607 if( 
new_elem
==0 ) return 
data
;

13608 
new_elem
->
pKey
 = pKey;

13609 
new_elem
->
data
 = data;

13610 
pH
->
count
++;

13611 if( 
pH
->
count
>=10 && pH->count > 2*pH->
htsize
 )

13614 if( 
	`rehash
(
pH
, pH->
count
*2) )

13618 
h
 = 
	`strHash
(
pKey
) % 
pH
->
htsize
;

13621 
	`insertElement
(
pH
, pH->
ht
 ? &pH->ht[
h
] : 0, 
new_elem
);

13623 
	}
}

13625 static const char *
	$sqlite3OpcodeName
(int 
i
)

13628 static const char *const 
azName
[] = {

13792 return 
azName
[
i
];

13793 
	}
}

13801 struct 
	sstat


13803 
__dev_t
 
	mst_dev
;

13808 
__ino_t
 
	mst_ino
;

13816 
__nlink_t
 
	mst_nlink
;

13817 
__mode_t
 
	mst_mode
;

13819 
__uid_t
 
	mst_uid
;

13820 
__gid_t
 
	mst_gid
;

13822 int 
	m__pad0
;

13824 
__dev_t
 
	mst_rdev
;

13829 
__off_t
 
	mst_size
;

13833 
__blksize_t
 
	mst_blksize
;

13835 
__blkcnt_t
 
	mst_blocks
;

13837 struct 
timespec
 
	mst_atim
;

13838 struct 
timespec
 
	mst_mtim
;

13839 struct 
timespec
 
	mst_ctim
;

13841 
__syscall_slong_t
 
	m__glibc_reserved
[3];

13847 struct 
	sstat64


13849 
__dev_t
 
	mst_dev
;

13851 
__ino64_t
 
	mst_ino
;

13852 
__nlink_t
 
	mst_nlink
;

13853 
__mode_t
 
	mst_mode
;

13860 
__uid_t
 
	mst_uid
;

13861 
__gid_t
 
	mst_gid
;

13863 int 
	m__pad0
;

13864 
__dev_t
 
	mst_rdev
;

13865 
__off_t
 
	mst_size
;

13871 
__blksize_t
 
	mst_blksize
;

13872 
__blkcnt64_t
 
	mst_blocks
;

13880 struct 
timespec
 
	mst_atim
;

13881 struct 
timespec
 
	mst_mtim
;

13882 struct 
timespec
 
	mst_ctim
;

13884 
__syscall_slong_t
 
	m__glibc_reserved
[3];

13891 extern int 
	$stat
 (const char *
__restrict
 
__file
, struct 
stat
 *__restrict 
__buf
) 
	`__asm__
 ("" "stat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

13893 
	`__attribute__
 ((
	`__nonnull__
 (1, 2)));

13894 extern int 
	$fstat
 (int 
__fd
, struct 
stat
 *
__buf
) 
	`__asm__
 ("" "fstat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

13895 
	`__attribute__
 ((
	`__nonnull__
 (2)));

13902 extern int 
	$stat64
 (const char *
__restrict
 
__file
,

13903 struct 
stat64
 *
__restrict
 
__buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

13904 extern int 
	$fstat64
 (int 
__fd
, struct 
stat64
 *
__buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

13906 extern int 
	$fstatat
 (int 
__fd
, const char *
__restrict
 
__file
, struct 
stat
 *__restrict 
__buf
, int 
__flag
) 
	`__asm__
 ("" "fstatat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

13909 
	`__attribute__
 ((
	`__nonnull__
 (2, 3)));

13916 extern int 
	$fstatat64
 (int 
__fd
, const char *
__restrict
 
__file
,

13917 struct 
stat64
 *
__restrict
 
__buf
, int 
__flag
)

13918 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

13920 extern int 
	$lstat
 (const char *
__restrict
 
__file
, struct 
stat
 *__restrict 
__buf
) 
	`__asm__
 ("" "lstat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

13923 
	`__attribute__
 ((
	`__nonnull__
 (1, 2)));

13929 extern int 
	$lstat64
 (const char *
__restrict
 
__file
,

13930 struct 
stat64
 *
__restrict
 
__buf
)

13931 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

13937 extern int 
	$chmod
 (const char *
__file
, 
__mode_t
 
__mode
)

13938 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

13944 extern int 
	$lchmod
 (const char *
__file
, 
__mode_t
 
__mode
)

13945 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

13950 extern int 
	$fchmod
 (int 
__fd
, 
__mode_t
 
__mode
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

13956 extern int 
	$fchmodat
 (int 
__fd
, const char *
__file
, 
__mode_t
 
__mode
,

13957 int 
__flag
)

13958 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

13965 extern 
__mode_t
 
	$umask
 (
__mode_t
 
__mask
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

13970 extern 
__mode_t
 
	$getumask
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

13974 extern int 
	$mkdir
 (const char *
__path
, 
__mode_t
 
__mode
)

13975 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

13981 extern int 
	$mkdirat
 (int 
__fd
, const char *
__path
, 
__mode_t
 
__mode
)

13982 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

13989 extern int 
	$mknod
 (const char *
__path
, 
__mode_t
 
__mode
, 
__dev_t
 
__dev
)

13990 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

13996 extern int 
	$mknodat
 (int 
__fd
, const char *
__path
, 
__mode_t
 
__mode
,

13997 
__dev_t
 
__dev
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

14003 extern int 
	$mkfifo
 (const char *
__path
, 
__mode_t
 
__mode
)

14004 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

14010 extern int 
	$mkfifoat
 (int 
__fd
, const char *
__path
, 
__mode_t
 
__mode
)

14011 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

14017 extern int 
	$utimensat
 (int 
__fd
, const char *
__path
,

14018 const struct 
timespec
 
__times
[2],

14019 int 
__flags
)

14020 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

14025 extern int 
	$futimens
 (int 
__fd
, const struct 
timespec
 
__times
[2]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14027 extern int 
	$__fxstat
 (int 
__ver
, int 
__fildes
, struct 
stat
 *
__stat_buf
) 
	`__asm__
 ("" "__fxstat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

14029 
	`__attribute__
 ((
	`__nonnull__
 (3)));

14030 extern int 
	$__xstat
 (int 
__ver
, const char *
__filename
, struct 
stat
 *
__stat_buf
) 
	`__asm__
 ("" "__xstat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

14032 
	`__attribute__
 ((
	`__nonnull__
 (2, 3)));

14033 extern int 
	$__lxstat
 (int 
__ver
, const char *
__filename
, struct 
stat
 *
__stat_buf
) 
	`__asm__
 ("" "__lxstat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

14035 
	`__attribute__
 ((
	`__nonnull__
 (2, 3)));

14036 extern int 
	$__fxstatat
 (int 
__ver
, int 
__fildes
, const char *
__filename
, struct 
stat
 *
__stat_buf
, int 
__flag
) 
	`__asm__
 ("" "__fxstatat64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

14039 
	`__attribute__
 ((
	`__nonnull__
 (3, 4)));

14041 extern int 
	$__fxstat64
 (int 
__ver
, int 
__fildes
, struct 
stat64
 *
__stat_buf
)

14042 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3)));

14043 extern int 
	$__xstat64
 (int 
__ver
, const char *
__filename
,

14044 struct 
stat64
 *
__stat_buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

14045 extern int 
	$__lxstat64
 (int 
__ver
, const char *
__filename
,

14046 struct 
stat64
 *
__stat_buf
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

14047 extern int 
	$__fxstatat64
 (int 
__ver
, int 
__fildes
, const char *
__filename
,

14048 struct 
stat64
 *
__stat_buf
, int 
__flag
)

14049 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 4)));

14051 extern int 
	$__xmknod
 (int 
__ver
, const char *
__path
, 
__mode_t
 
__mode
,

14052 
__dev_t
 *
__dev
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 4)));

14054 extern int 
	$__xmknodat
 (int 
__ver
, int 
__fd
, const char *
__path
,

14055 
__mode_t
 
__mode
, 
__dev_t
 *
__dev
)

14056 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (3, 5)));

14071 struct 
	sflock


14073 short int 
l_type
;

14074 short int 
l_whence
;

14079 
__off64_t
 
l_start
;

14080 
__off64_t
 
l_len
;

14082 
__pid_t
 
l_pid
;

14086 struct 
	sflock64


14088 short int 
l_type
;

14089 short int 
l_whence
;

14090 
__off64_t
 
l_start
;

14091 
__off64_t
 
l_len
;

14092 
__pid_t
 
l_pid
;

14101 struct 
	siovec


14103 void *
iov_base
;

14104 
size_t
 
iov_len
;

14108 enum 
	e__pid_type


14110 
F_OWNER_TID
 = 0,

14111 
F_OWNER_PID
,

14112 
F_OWNER_PGRP
,

14113 
F_OWNER_GID
 = 
F_OWNER_PGRP


14117 struct 
	sf_owner_ex


14119 enum 
__pid_type
 
type
;

14120 
__pid_t
 
pid
;

14123 struct 
	sfile_handle


14125 unsigned int 
handle_bytes
;

14126 int 
handle_type
;

14128 unsigned char 
f_handle
[0];

14140 extern 
ssize_t
 
	$readahead
 (int 
__fd
, 
__off64_t
 
__offset
, 
size_t
 
__count
)

14141 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14148 extern int 
	`sync_file_range
 (int 
__fd
, 
__off64_t
 
__offset
, __off64_t 
__count
,

14149 unsigned int 
__flags
);

14156 extern 
ssize_t
 
	`vmsplice
 (int 
__fdout
, const struct 
iovec
 *
__iov
,

14157 
size_t
 
__count
, unsigned int 
__flags
);

14163 extern 
ssize_t
 
	`splice
 (int 
__fdin
, 
__off64_t
 *
__offin
, int 
__fdout
,

14164 
__off64_t
 *
__offout
, 
size_t
 
__len
,

14165 unsigned int 
__flags
);

14171 extern 
ssize_t
 
	`tee
 (int 
__fdin
, int 
__fdout
, 
size_t
 
__len
,

14172 unsigned int 
__flags
);

14174 extern int 
	$fallocate
 (int 
__fd
, int 
__mode
, 
__off64_t
 
__offset
, __off64_t 
__len
) 
	`__asm__
 ("" "fallocate64")

14182 extern int 
	`fallocate64
 (int 
__fd
, int 
__mode
, 
__off64_t
 
__offset
,

14183 
__off64_t
 
__len
);

14188 extern int 
	$name_to_handle_at
 (int 
__dfd
, const char *
__name
,

14189 struct 
file_handle
 *
__handle
, int *
__mnt_id
,

14190 int 
__flags
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14196 extern int 
	`open_by_handle_at
 (int 
__mountdirfd
, struct 
file_handle
 *
__handle
,

14197 int 
__flags
);

14208 extern int 
	`fcntl
 (int 
__fd
, int 
__cmd
, ...);

14210 extern int 
	$open
 (const char *
__file
, int 
__oflag
, ...) 
	`__asm__
 ("" "open64")

14211 
	`__attribute__
 ((
	`__nonnull__
 (1)));

14217 extern int 
	$open64
 (const char *
__file
, int 
__oflag
, ...) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

14219 extern int 
	$openat
 (int 
__fd
, const char *
__file
, int 
__oflag
, ...) 
	`__asm__
 ("" "openat64")

14220 
	`__attribute__
 ((
	`__nonnull__
 (2)));

14226 extern int 
	$openat64
 (int 
__fd
, const char *
__file
, int 
__oflag
, ...)

14227 
	`__attribute__
 ((
	`__nonnull__
 (2)));

14229 extern int 
	$creat
 (const char *
__file
, 
mode_t
 
__mode
) 
	`__asm__
 ("" "creat64")

14230 
	`__attribute__
 ((
	`__nonnull__
 (1)));

14236 extern int 
	$creat64
 (const char *
__file
, 
mode_t
 
__mode
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

14238 extern int 
	$lockf
 (int 
__fd
, int 
__cmd
, 
__off64_t
 
__len
) 
	`__asm__
 ("" "lockf64");

14244 extern int 
	`lockf64
 (int 
__fd
, int 
__cmd
, 
off64_t
 
__len
);

14246 extern int 
	$posix_fadvise
 (int 
__fd
, 
__off64_t
 
__offset
, __off64_t 
__len
, int 
__advise
) 
	`__asm__
 ("" "posix_fadvise64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

14254 extern int 
	$posix_fadvise64
 (int 
__fd
, 
off64_t
 
__offset
, off64_t 
__len
,

14255 int 
__advise
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14257 extern int 
	$posix_fallocate
 (int 
__fd
, 
__off64_t
 
__offset
, __off64_t 
__len
) 
	`__asm__
 ("" "posix_fallocate64")

14265 extern int 
	`posix_fallocate64
 (int 
__fd
, 
off64_t
 
__offset
, off64_t 
__len
);

14287 typedef 
__intptr_t
 
	tintptr_t
;

14294 typedef 
__socklen_t
 
	tsocklen_t
;

14296 extern int 
	$access
 (const char *
__name
, int 
__type
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

14301 extern int 
	$euidaccess
 (const char *
__name
, int 
__type
)

14302 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

14305 extern int 
	$eaccess
 (const char *
__name
, int 
__type
)

14306 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

14313 extern int 
	$faccessat
 (int 
__fd
, const char *
__file
, int 
__type
, int 
__flag
)

14314 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

14316 extern 
__off64_t
 
	$lseek
 (int 
__fd
, 
__off64_t
 
__offset
, int 
__whence
) 
	`__asm__
 ("" "lseek64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

14324 extern 
__off64_t
 
	$lseek64
 (int 
__fd
, 
__off64_t
 
__offset
, int 
__whence
)

14325 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14332 extern int 
	`close
 (int 
__fd
);

14339 extern 
ssize_t
 
	`read
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
) ;

14345 extern 
ssize_t
 
	`write
 (int 
__fd
, const void *
__buf
, 
size_t
 
__n
) ;

14347 extern 
ssize_t
 
	$pread
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
, 
__off64_t
 
__offset
) 
	`__asm__
 ("" "pread64")

14350 extern 
ssize_t
 
	$pwrite
 (int 
__fd
, const void *
__buf
, 
size_t
 
__nbytes
, 
__off64_t
 
__offset
) 
	`__asm__
 ("" "pwrite64")

14354 extern 
ssize_t
 
	`pread64
 (int 
__fd
, void *
__buf
, 
size_t
 
__nbytes
,

14355 
__off64_t
 
__offset
) ;

14358 extern 
ssize_t
 
	`pwrite64
 (int 
__fd
, const void *
__buf
, 
size_t
 
__n
,

14359 
__off64_t
 
__offset
) ;

14367 extern int 
	$pipe
 (int 
__pipedes
[2]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

14372 extern int 
	$pipe2
 (int 
__pipedes
[2], int 
__flags
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

14374 extern unsigned int 
	$alarm
 (unsigned int 
__seconds
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14376 extern unsigned int 
	`sleep
 (unsigned int 
__seconds
);

14384 extern 
__useconds_t
 
	$ualarm
 (
__useconds_t
 
__value
, __useconds_t 
__interval
)

14385 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14392 extern int 
	`usleep
 (
__useconds_t
 
__useconds
);

14394 extern int 
	`pause
 (void);

14398 extern int 
	$chown
 (const char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

14399 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

14403 extern int 
	$fchown
 (int 
__fd
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

14408 extern int 
	$lchown
 (const char *
__file
, 
__uid_t
 
__owner
, 
__gid_t
 
__group
)

14409 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

14416 extern int 
	$fchownat
 (int 
__fd
, const char *
__file
, 
__uid_t
 
__owner
,

14417 
__gid_t
 
__group
, int 
__flag
)

14418 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

14422 extern int 
	$chdir
 (const char *
__path
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

14426 extern int 
	$fchdir
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

14428 extern char *
	$getcwd
 (char *
__buf
, 
size_t
 
__size
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

14434 extern char *
	$get_current_dir_name
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14442 extern char *
	$getwd
 (char *
__buf
)

14443 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	$__nonnull__
 (1))) 
	`__attribute__
 ((
__deprecated__
)) ;

14448 extern int 
	$dup
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

14451 extern int 
	$dup2
 (int 
__fd
, int 
__fd2
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14456 extern int 
	$dup3
 (int 
__fd
, int 
__fd2
, int 
__flags
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

14460 extern char **
__environ
;

14462 extern char **
environ
;

14468 extern int 
	$execve
 (const char *
__path
, char *const 
__argv
[],

14469 char *const 
__envp
[]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

14474 extern int 
	$fexecve
 (int 
__fd
, char *const 
__argv
[], char *const 
__envp
[])

14475 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

14480 extern int 
	$execv
 (const char *
__path
, char *const 
__argv
[])

14481 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

14485 extern int 
	$execle
 (const char *
__path
, const char *
__arg
, ...)

14486 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

14490 extern int 
	$execl
 (const char *
__path
, const char *
__arg
, ...)

14491 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

14495 extern int 
	$execvp
 (const char *
__file
, char *const 
__argv
[])

14496 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

14501 extern int 
	$execlp
 (const char *
__file
, const char *
__arg
, ...)

14502 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

14507 extern int 
	$execvpe
 (const char *
__file
, char *const 
__argv
[],

14508 char *const 
__envp
[])

14509 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

14515 extern int 
	$nice
 (int 
__inc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

14520 extern void 
	$_exit
 (int 
__status
) 
	`__attribute__
 ((
__noreturn__
));

14530 
_PC_LINK_MAX
,

14532 
_PC_MAX_CANON
,

14534 
_PC_MAX_INPUT
,

14536 
_PC_NAME_MAX
,

14538 
_PC_PATH_MAX
,

14540 
_PC_PIPE_BUF
,

14542 
_PC_CHOWN_RESTRICTED
,

14544 
_PC_NO_TRUNC
,

14546 
_PC_VDISABLE
,

14548 
_PC_SYNC_IO
,

14550 
_PC_ASYNC_IO
,

14552 
_PC_PRIO_IO
,

14554 
_PC_SOCK_MAXBUF
,

14556 
_PC_FILESIZEBITS
,

14558 
_PC_REC_INCR_XFER_SIZE
,

14560 
_PC_REC_MAX_XFER_SIZE
,

14562 
_PC_REC_MIN_XFER_SIZE
,

14564 
_PC_REC_XFER_ALIGN
,

14566 
_PC_ALLOC_SIZE_MIN
,

14568 
_PC_SYMLINK_MAX
,

14570 
_PC_2_SYMLINKS


14577 
_SC_ARG_MAX
,

14579 
_SC_CHILD_MAX
,

14581 
_SC_CLK_TCK
,

14583 
_SC_NGROUPS_MAX
,

14585 
_SC_OPEN_MAX
,

14587 
_SC_STREAM_MAX
,

14589 
_SC_TZNAME_MAX
,

14591 
_SC_JOB_CONTROL
,

14593 
_SC_SAVED_IDS
,

14595 
_SC_REALTIME_SIGNALS
,

14597 
_SC_PRIORITY_SCHEDULING
,

14599 
_SC_TIMERS
,

14601 
_SC_ASYNCHRONOUS_IO
,

14603 
_SC_PRIORITIZED_IO
,

14605 
_SC_SYNCHRONIZED_IO
,

14607 
_SC_FSYNC
,

14609 
_SC_MAPPED_FILES
,

14611 
_SC_MEMLOCK
,

14613 
_SC_MEMLOCK_RANGE
,

14615 
_SC_MEMORY_PROTECTION
,

14617 
_SC_MESSAGE_PASSING
,

14619 
_SC_SEMAPHORES
,

14621 
_SC_SHARED_MEMORY_OBJECTS
,

14623 
_SC_AIO_LISTIO_MAX
,

14625 
_SC_AIO_MAX
,

14627 
_SC_AIO_PRIO_DELTA_MAX
,

14629 
_SC_DELAYTIMER_MAX
,

14631 
_SC_MQ_OPEN_MAX
,

14633 
_SC_MQ_PRIO_MAX
,

14635 
_SC_VERSION
,

14637 
_SC_PAGESIZE
,

14640 
_SC_RTSIG_MAX
,

14642 
_SC_SEM_NSEMS_MAX
,

14644 
_SC_SEM_VALUE_MAX
,

14646 
_SC_SIGQUEUE_MAX
,

14648 
_SC_TIMER_MAX
,

14653 
_SC_BC_BASE_MAX
,

14655 
_SC_BC_DIM_MAX
,

14657 
_SC_BC_SCALE_MAX
,

14659 
_SC_BC_STRING_MAX
,

14661 
_SC_COLL_WEIGHTS_MAX
,

14663 
_SC_EQUIV_CLASS_MAX
,

14665 
_SC_EXPR_NEST_MAX
,

14667 
_SC_LINE_MAX
,

14669 
_SC_RE_DUP_MAX
,

14671 
_SC_CHARCLASS_NAME_MAX
,

14674 
_SC_2_VERSION
,

14676 
_SC_2_C_BIND
,

14678 
_SC_2_C_DEV
,

14680 
_SC_2_FORT_DEV
,

14682 
_SC_2_FORT_RUN
,

14684 
_SC_2_SW_DEV
,

14686 
_SC_2_LOCALEDEF
,

14689 
_SC_PII
,

14691 
_SC_PII_XTI
,

14693 
_SC_PII_SOCKET
,

14695 
_SC_PII_INTERNET
,

14697 
_SC_PII_OSI
,

14699 
_SC_POLL
,

14701 
_SC_SELECT
,

14703 
_SC_UIO_MAXIOV
,

14705 
_SC_IOV_MAX
 = 
_SC_UIO_MAXIOV
,

14707 
_SC_PII_INTERNET_STREAM
,

14709 
_SC_PII_INTERNET_DGRAM
,

14711 
_SC_PII_OSI_COTS
,

14713 
_SC_PII_OSI_CLTS
,

14715 
_SC_PII_OSI_M
,

14717 
_SC_T_IOV_MAX
,

14721 
_SC_THREADS
,

14723 
_SC_THREAD_SAFE_FUNCTIONS
,

14725 
_SC_GETGR_R_SIZE_MAX
,

14727 
_SC_GETPW_R_SIZE_MAX
,

14729 
_SC_LOGIN_NAME_MAX
,

14731 
_SC_TTY_NAME_MAX
,

14733 
_SC_THREAD_DESTRUCTOR_ITERATIONS
,

14735 
_SC_THREAD_KEYS_MAX
,

14737 
_SC_THREAD_STACK_MIN
,

14739 
_SC_THREAD_THREADS_MAX
,

14741 
_SC_THREAD_ATTR_STACKADDR
,

14743 
_SC_THREAD_ATTR_STACKSIZE
,

14745 
_SC_THREAD_PRIORITY_SCHEDULING
,

14747 
_SC_THREAD_PRIO_INHERIT
,

14749 
_SC_THREAD_PRIO_PROTECT
,

14751 
_SC_THREAD_PROCESS_SHARED
,

14754 
_SC_NPROCESSORS_CONF
,

14756 
_SC_NPROCESSORS_ONLN
,

14758 
_SC_PHYS_PAGES
,

14760 
_SC_AVPHYS_PAGES
,

14762 
_SC_ATEXIT_MAX
,

14764 
_SC_PASS_MAX
,

14767 
_SC_XOPEN_VERSION
,

14769 
_SC_XOPEN_XCU_VERSION
,

14771 
_SC_XOPEN_UNIX
,

14773 
_SC_XOPEN_CRYPT
,

14775 
_SC_XOPEN_ENH_I18N
,

14777 
_SC_XOPEN_SHM
,

14780 
_SC_2_CHAR_TERM
,

14782 
_SC_2_C_VERSION
,

14784 
_SC_2_UPE
,

14787 
_SC_XOPEN_XPG2
,

14789 
_SC_XOPEN_XPG3
,

14791 
_SC_XOPEN_XPG4
,

14794 
_SC_CHAR_BIT
,

14796 
_SC_CHAR_MAX
,

14798 
_SC_CHAR_MIN
,

14800 
_SC_INT_MAX
,

14802 
_SC_INT_MIN
,

14804 
_SC_LONG_BIT
,

14806 
_SC_WORD_BIT
,

14808 
_SC_MB_LEN_MAX
,

14810 
_SC_NZERO
,

14812 
_SC_SSIZE_MAX
,

14814 
_SC_SCHAR_MAX
,

14816 
_SC_SCHAR_MIN
,

14818 
_SC_SHRT_MAX
,

14820 
_SC_SHRT_MIN
,

14822 
_SC_UCHAR_MAX
,

14824 
_SC_UINT_MAX
,

14826 
_SC_ULONG_MAX
,

14828 
_SC_USHRT_MAX
,

14831 
_SC_NL_ARGMAX
,

14833 
_SC_NL_LANGMAX
,

14835 
_SC_NL_MSGMAX
,

14837 
_SC_NL_NMAX
,

14839 
_SC_NL_SETMAX
,

14841 
_SC_NL_TEXTMAX
,

14844 
_SC_XBS5_ILP32_OFF32
,

14846 
_SC_XBS5_ILP32_OFFBIG
,

14848 
_SC_XBS5_LP64_OFF64
,

14850 
_SC_XBS5_LPBIG_OFFBIG
,

14853 
_SC_XOPEN_LEGACY
,

14855 
_SC_XOPEN_REALTIME
,

14857 
_SC_XOPEN_REALTIME_THREADS
,

14860 
_SC_ADVISORY_INFO
,

14862 
_SC_BARRIERS
,

14864 
_SC_BASE
,

14866 
_SC_C_LANG_SUPPORT
,

14868 
_SC_C_LANG_SUPPORT_R
,

14870 
_SC_CLOCK_SELECTION
,

14872 
_SC_CPUTIME
,

14874 
_SC_THREAD_CPUTIME
,

14876 
_SC_DEVICE_IO
,

14878 
_SC_DEVICE_SPECIFIC
,

14880 
_SC_DEVICE_SPECIFIC_R
,

14882 
_SC_FD_MGMT
,

14884 
_SC_FIFO
,

14886 
_SC_PIPE
,

14888 
_SC_FILE_ATTRIBUTES
,

14890 
_SC_FILE_LOCKING
,

14892 
_SC_FILE_SYSTEM
,

14894 
_SC_MONOTONIC_CLOCK
,

14896 
_SC_MULTI_PROCESS
,

14898 
_SC_SINGLE_PROCESS
,

14900 
_SC_NETWORKING
,

14902 
_SC_READER_WRITER_LOCKS
,

14904 
_SC_SPIN_LOCKS
,

14906 
_SC_REGEXP
,

14908 
_SC_REGEX_VERSION
,

14910 
_SC_SHELL
,

14912 
_SC_SIGNALS
,

14914 
_SC_SPAWN
,

14916 
_SC_SPORADIC_SERVER
,

14918 
_SC_THREAD_SPORADIC_SERVER
,

14920 
_SC_SYSTEM_DATABASE
,

14922 
_SC_SYSTEM_DATABASE_R
,

14924 
_SC_TIMEOUTS
,

14926 
_SC_TYPED_MEMORY_OBJECTS
,

14928 
_SC_USER_GROUPS
,

14930 
_SC_USER_GROUPS_R
,

14932 
_SC_2_PBS
,

14934 
_SC_2_PBS_ACCOUNTING
,

14936 
_SC_2_PBS_LOCATE
,

14938 
_SC_2_PBS_MESSAGE
,

14940 
_SC_2_PBS_TRACK
,

14942 
_SC_SYMLOOP_MAX
,

14944 
_SC_STREAMS
,

14946 
_SC_2_PBS_CHECKPOINT
,

14949 
_SC_V6_ILP32_OFF32
,

14951 
_SC_V6_ILP32_OFFBIG
,

14953 
_SC_V6_LP64_OFF64
,

14955 
_SC_V6_LPBIG_OFFBIG
,

14958 
_SC_HOST_NAME_MAX
,

14960 
_SC_TRACE
,

14962 
_SC_TRACE_EVENT_FILTER
,

14964 
_SC_TRACE_INHERIT
,

14966 
_SC_TRACE_LOG
,

14969 
_SC_LEVEL1_ICACHE_SIZE
,

14971 
_SC_LEVEL1_ICACHE_ASSOC
,

14973 
_SC_LEVEL1_ICACHE_LINESIZE
,

14975 
_SC_LEVEL1_DCACHE_SIZE
,

14977 
_SC_LEVEL1_DCACHE_ASSOC
,

14979 
_SC_LEVEL1_DCACHE_LINESIZE
,

14981 
_SC_LEVEL2_CACHE_SIZE
,

14983 
_SC_LEVEL2_CACHE_ASSOC
,

14985 
_SC_LEVEL2_CACHE_LINESIZE
,

14987 
_SC_LEVEL3_CACHE_SIZE
,

14989 
_SC_LEVEL3_CACHE_ASSOC
,

14991 
_SC_LEVEL3_CACHE_LINESIZE
,

14993 
_SC_LEVEL4_CACHE_SIZE
,

14995 
_SC_LEVEL4_CACHE_ASSOC
,

14997 
_SC_LEVEL4_CACHE_LINESIZE
,

15001 
_SC_IPV6
 = 
_SC_LEVEL1_ICACHE_SIZE
 + 50,

15003 
_SC_RAW_SOCKETS
,

15006 
_SC_V7_ILP32_OFF32
,

15008 
_SC_V7_ILP32_OFFBIG
,

15010 
_SC_V7_LP64_OFF64
,

15012 
_SC_V7_LPBIG_OFFBIG
,

15015 
_SC_SS_REPL_MAX
,

15018 
_SC_TRACE_EVENT_NAME_MAX
,

15020 
_SC_TRACE_NAME_MAX
,

15022 
_SC_TRACE_SYS_MAX
,

15024 
_SC_TRACE_USER_EVENT_MAX
,

15027 
_SC_XOPEN_STREAMS
,

15030 
_SC_THREAD_ROBUST_PRIO_INHERIT
,

15032 
_SC_THREAD_ROBUST_PRIO_PROTECT


15039 
_CS_PATH
,

15042 
_CS_V6_WIDTH_RESTRICTED_ENVS
,

15046 
_CS_GNU_LIBC_VERSION
,

15048 
_CS_GNU_LIBPTHREAD_VERSION
,

15051 
_CS_V5_WIDTH_RESTRICTED_ENVS
,

15055 
_CS_V7_WIDTH_RESTRICTED_ENVS
,

15059 
_CS_LFS_CFLAGS
 = 1000,

15061 
_CS_LFS_LDFLAGS
,

15063 
_CS_LFS_LIBS
,

15065 
_CS_LFS_LINTFLAGS
,

15067 
_CS_LFS64_CFLAGS
,

15069 
_CS_LFS64_LDFLAGS
,

15071 
_CS_LFS64_LIBS
,

15073 
_CS_LFS64_LINTFLAGS
,

15076 
_CS_XBS5_ILP32_OFF32_CFLAGS
 = 1100,

15078 
_CS_XBS5_ILP32_OFF32_LDFLAGS
,

15080 
_CS_XBS5_ILP32_OFF32_LIBS
,

15082 
_CS_XBS5_ILP32_OFF32_LINTFLAGS
,

15084 
_CS_XBS5_ILP32_OFFBIG_CFLAGS
,

15086 
_CS_XBS5_ILP32_OFFBIG_LDFLAGS
,

15088 
_CS_XBS5_ILP32_OFFBIG_LIBS
,

15090 
_CS_XBS5_ILP32_OFFBIG_LINTFLAGS
,

15092 
_CS_XBS5_LP64_OFF64_CFLAGS
,

15094 
_CS_XBS5_LP64_OFF64_LDFLAGS
,

15096 
_CS_XBS5_LP64_OFF64_LIBS
,

15098 
_CS_XBS5_LP64_OFF64_LINTFLAGS
,

15100 
_CS_XBS5_LPBIG_OFFBIG_CFLAGS
,

15102 
_CS_XBS5_LPBIG_OFFBIG_LDFLAGS
,

15104 
_CS_XBS5_LPBIG_OFFBIG_LIBS
,

15106 
_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS
,

15109 
_CS_POSIX_V6_ILP32_OFF32_CFLAGS
,

15111 
_CS_POSIX_V6_ILP32_OFF32_LDFLAGS
,

15113 
_CS_POSIX_V6_ILP32_OFF32_LIBS
,

15115 
_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS
,

15117 
_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS
,

15119 
_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS
,

15121 
_CS_POSIX_V6_ILP32_OFFBIG_LIBS
,

15123 
_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS
,

15125 
_CS_POSIX_V6_LP64_OFF64_CFLAGS
,

15127 
_CS_POSIX_V6_LP64_OFF64_LDFLAGS
,

15129 
_CS_POSIX_V6_LP64_OFF64_LIBS
,

15131 
_CS_POSIX_V6_LP64_OFF64_LINTFLAGS
,

15133 
_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS
,

15135 
_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS
,

15137 
_CS_POSIX_V6_LPBIG_OFFBIG_LIBS
,

15139 
_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
,

15142 
_CS_POSIX_V7_ILP32_OFF32_CFLAGS
,

15144 
_CS_POSIX_V7_ILP32_OFF32_LDFLAGS
,

15146 
_CS_POSIX_V7_ILP32_OFF32_LIBS
,

15148 
_CS_POSIX_V7_ILP32_OFF32_LINTFLAGS
,

15150 
_CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
,

15152 
_CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
,

15154 
_CS_POSIX_V7_ILP32_OFFBIG_LIBS
,

15156 
_CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS
,

15158 
_CS_POSIX_V7_LP64_OFF64_CFLAGS
,

15160 
_CS_POSIX_V7_LP64_OFF64_LDFLAGS
,

15162 
_CS_POSIX_V7_LP64_OFF64_LIBS
,

15164 
_CS_POSIX_V7_LP64_OFF64_LINTFLAGS
,

15166 
_CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
,

15168 
_CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
,

15170 
_CS_POSIX_V7_LPBIG_OFFBIG_LIBS
,

15172 
_CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS
,

15175 
_CS_V6_ENV
,

15177 
_CS_V7_ENV


15183 extern long int 
	$pathconf
 (const char *
__path
, int 
__name
)

15184 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15187 extern long int 
	$fpathconf
 (int 
__fd
, int 
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15190 extern long int 
	$sysconf
 (int 
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15194 extern 
size_t
 
	$confstr
 (int 
__name
, char *
__buf
, 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15199 extern 
__pid_t
 
	$getpid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15202 extern 
__pid_t
 
	$getppid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15205 extern 
__pid_t
 
	$getpgrp
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15208 extern 
__pid_t
 
	$__getpgid
 (
__pid_t
 
__pid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15210 extern 
__pid_t
 
	$getpgid
 (
__pid_t
 
__pid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15217 extern int 
	$setpgid
 (
__pid_t
 
__pid
, __pid_t 
__pgid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15219 extern int 
	$setpgrp
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15226 extern 
__pid_t
 
	$setsid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15230 extern 
__pid_t
 
	$getsid
 (
__pid_t
 
__pid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15234 extern 
__uid_t
 
	$getuid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15237 extern 
__uid_t
 
	$geteuid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15240 extern 
__gid_t
 
	$getgid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15243 extern 
__gid_t
 
	$getegid
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15248 extern int 
	$getgroups
 (int 
__size
, 
__gid_t
 
__list
[]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15252 extern int 
	$group_member
 (
__gid_t
 
__gid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15259 extern int 
	$setuid
 (
__uid_t
 
__uid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15264 extern int 
	$setreuid
 (
__uid_t
 
__ruid
, __uid_t 
__euid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15269 extern int 
	$seteuid
 (
__uid_t
 
__uid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15276 extern int 
	$setgid
 (
__gid_t
 
__gid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15281 extern int 
	$setregid
 (
__gid_t
 
__rgid
, __gid_t 
__egid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15286 extern int 
	$setegid
 (
__gid_t
 
__gid
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15292 extern int 
	$getresuid
 (
__uid_t
 *
__ruid
, __uid_t *
__euid
, __uid_t *
__suid
)

15293 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15297 extern int 
	$getresgid
 (
__gid_t
 *
__rgid
, __gid_t *
__egid
, __gid_t *
__sgid
)

15298 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15302 extern int 
	$setresuid
 (
__uid_t
 
__ruid
, __uid_t 
__euid
, __uid_t 
__suid
)

15303 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15307 extern int 
	$setresgid
 (
__gid_t
 
__rgid
, __gid_t 
__egid
, __gid_t 
__sgid
)

15308 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15315 extern 
__pid_t
 
	$fork
 (void) 
	`__attribute__
 ((
__nothrow__
));

15323 extern 
__pid_t
 
	$vfork
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15329 extern char *
	$ttyname
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15333 extern int 
	$ttyname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

15334 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2))) ;

15338 extern int 
	$isatty
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15344 extern int 
	$ttyslot
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15349 extern int 
	$link
 (const char *
__from
, const char *
__to
)

15350 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2))) ;

15355 extern int 
	$linkat
 (int 
__fromfd
, const char *
__from
, int 
__tofd
,

15356 const char *
__to
, int 
__flags
)

15357 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 4))) ;

15362 extern int 
	$symlink
 (const char *
__from
, const char *
__to
)

15363 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2))) ;

15368 extern 
ssize_t
 
	$readlink
 (const char *
__restrict
 
__path
,

15369 char *
__restrict
 
__buf
, 
size_t
 
__len
)

15370 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2))) ;

15375 extern int 
	$symlinkat
 (const char *
__from
, int 
__tofd
,

15376 const char *
__to
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3))) ;

15379 extern 
ssize_t
 
	$readlinkat
 (int 
__fd
, const char *
__restrict
 
__path
,

15380 char *
__restrict
 
__buf
, 
size_t
 
__len
)

15381 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3))) ;

15385 extern int 
	$unlink
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15389 extern int 
	$unlinkat
 (int 
__fd
, const char *
__name
, int 
__flag
)

15390 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

15394 extern int 
	$rmdir
 (const char *
__path
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15398 extern 
__pid_t
 
	$tcgetpgrp
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15401 extern int 
	$tcsetpgrp
 (int 
__fd
, 
__pid_t
 
__pgrp_id
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15408 extern char *
	`getlogin
 (void);

15416 extern int 
	$getlogin_r
 (char *
__name
, 
size_t
 
__name_len
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

15421 extern int 
	$setlogin
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15425 extern char *
optarg
;

15427 extern int 
optind
;

15432 extern int 
opterr
;

15436 extern int 
optopt
;

15438 extern int 
	$getopt
 (int 
___argc
, char *const *
___argv
, const char *
__shortopts
)

15439 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15448 extern int 
	$gethostname
 (char *
__name
, 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15455 extern int 
	$sethostname
 (const char *
__name
, 
size_t
 
__len
)

15456 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

15460 extern int 
	$sethostid
 (long int 
__id
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15466 extern int 
	$getdomainname
 (char *
__name
, 
size_t
 
__len
)

15467 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

15468 extern int 
	$setdomainname
 (const char *
__name
, 
size_t
 
__len
)

15469 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

15475 extern int 
	$vhangup
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15478 extern int 
	$revoke
 (const char *
__file
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

15486 extern int 
	$profil
 (unsigned short int *
__sample_buffer
, 
size_t
 
__size
,

15487 
size_t
 
__offset
, unsigned int 
__scale
)

15488 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15494 extern int 
	$acct
 (const char *
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15498 extern char *
	$getusershell
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15499 extern void 
	$endusershell
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15500 extern void 
	$setusershell
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15506 extern int 
	$daemon
 (int 
__nochdir
, int 
__noclose
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15513 extern int 
	$chroot
 (const char *
__path
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

15517 extern char *
	$getpass
 (const char *
__prompt
) 
	`__attribute__
 ((
	`__nonnull__
 (1)));

15525 extern int 
	`fsync
 (int 
__fd
);

15531 extern int 
	$syncfs
 (int 
__fd
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15538 extern long int 
	`gethostid
 (void);

15541 extern void 
	$sync
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15547 extern int 
	$getpagesize
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

15552 extern int 
	$getdtablesize
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15554 extern int 
	$truncate
 (const char *
__file
, 
__off64_t
 
__length
) 
	`__asm__
 ("" "truncate64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

15556 
	`__attribute__
 ((
	`__nonnull__
 (1))) ;

15562 extern int 
	$truncate64
 (const char *
__file
, 
__off64_t
 
__length
)

15563 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1))) ;

15565 extern int 
	$ftruncate
 (int 
__fd
, 
__off64_t
 
__length
) 
	`__asm__
 ("" "ftruncate64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

15572 extern int 
	$ftruncate64
 (int 
__fd
, 
__off64_t
 
__length
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15574 extern int 
	$brk
 (void *
__addr
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) ;

15580 extern void *
	$sbrk
 (
intptr_t
 
__delta
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15582 extern long int 
	$syscall
 (long int 
__sysno
, ...) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15584 extern int 
	`fdatasync
 (int 
__fildes
);

15592 extern char *
	$crypt
 (const char *
__key
, const char *
__salt
)

15593 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

15597 extern void 
	$encrypt
 (char *
__glibc_block
, int 
__edflag
)

15598 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15605 extern void 
	$swab
 (const void *
__restrict
 
__from
, void *__restrict 
__to
,

15606 
ssize_t
 
__n
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 2)));

15618 struct 
	stimezone


15620 int 
tz_minuteswest
;

15621 int 
tz_dsttime
;

15624 typedef struct 
timezone
 *
	t__restrict
 
	t__timezone_ptr_t
;

15626 extern int 
	$gettimeofday
 (struct 
timeval
 *
__restrict
 
__tv
,

15627 
__timezone_ptr_t
 
__tz
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15632 extern int 
	$settimeofday
 (const struct 
timeval
 *
__tv
,

15633 const struct 
timezone
 *
__tz
)

15634 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15640 extern int 
	$adjtime
 (const struct 
timeval
 *
__delta
,

15641 struct 
timeval
 *
__olddelta
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15646 enum 
	e__itimer_which


15649 
ITIMER_REAL
 = 0,

15652 
ITIMER_VIRTUAL
 = 1,

15656 
ITIMER_PROF
 = 2

15662 struct 
	sitimerval


15665 struct 
timeval
 
it_interval
;

15667 struct 
timeval
 
it_value
;

15673 typedef enum 
__itimer_which
 
	t__itimer_which_t
;

15680 extern int 
	$getitimer
 (
__itimer_which_t
 
__which
,

15681 struct 
itimerval
 *
__value
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15686 extern int 
	$setitimer
 (
__itimer_which_t
 
__which
,

15687 const struct 
itimerval
 *
__restrict
 
__new
,

15688 struct 
itimerval
 *
__restrict
 
__old
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15693 extern int 
	$utimes
 (const char *
__file
, const struct 
timeval
 
__tvp
[2])

15694 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15698 extern int 
	$lutimes
 (const char *
__file
, const struct 
timeval
 
__tvp
[2])

15699 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1)));

15702 extern int 
	$futimes
 (int 
__fd
, const struct 
timeval
 
__tvp
[2]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15709 extern int 
	$futimesat
 (int 
__fd
, const char *
__file
,

15710 const struct 
timeval
 
__tvp
[2]) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15734 extern int *
	$__errno_location
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
__const__
));

15737 extern char *
program_invocation_name
, *
program_invocation_short_name
;

15743 typedef int 
	terror_t
;

15762 extern void * 
	$mmap
 (void *
__addr
, 
size_t
 
__len
, int 
__prot
, int 
__flags
, int 
__fd
, 
__off64_t
 
__offset
) 
	`__asm__
 ("" "mmap64") 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
))

15771 extern void *
	$mmap64
 (void *
__addr
, 
size_t
 
__len
, int 
__prot
,

15772 int 
__flags
, int 
__fd
, 
__off64_t
 
__offset
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15777 extern int 
	$munmap
 (void *
__addr
, 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15782 extern int 
	$mprotect
 (void *
__addr
, 
size_t
 
__len
, int 
__prot
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15790 extern int 
	`msync
 (void *
__addr
, 
size_t
 
__len
, int 
__flags
);

15795 extern int 
	$madvise
 (void *
__addr
, 
size_t
 
__len
, int 
__advice
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15799 extern int 
	$posix_madvise
 (void *
__addr
, 
size_t
 
__len
, int 
__advice
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15804 extern int 
	$mlock
 (const void *
__addr
, 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15807 extern int 
	$munlock
 (const void *
__addr
, 
size_t
 
__len
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15812 extern int 
	$mlockall
 (int 
__flags
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15816 extern int 
	$munlockall
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15824 extern int 
	$mincore
 (void *
__start
, 
size_t
 
__len
, unsigned char *
__vec
)

15825 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15827 extern void *
	$mremap
 (void *
__addr
, 
size_t
 
__old_len
, size_t 
__new_len
,

15828 int 
__flags
, ...) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15832 extern int 
	$remap_file_pages
 (void *
__start
, 
size_t
 
__size
, int 
__prot
,

15833 
size_t
 
__pgoff
, int 
__flags
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

15838 extern int 
	`shm_open
 (const char *
__name
, int 
__oflag
, 
mode_t
 
__mode
);

15841 extern int 
	`shm_unlink
 (const char *
__name
);

15846 typedef struct 
unixShm
 
	tunixShm
;

15847 typedef struct 
unixShmNode
 
	tunixShmNode
;

15848 typedef struct 
unixInodeInfo
 
	tunixInodeInfo
;

15849 typedef struct 
UnixUnusedFd
 
	tUnixUnusedFd
;

15857 struct 
	sUnixUnusedFd
 {

15858 int 
fd
;

15859 int 
flags
;

15860 
UnixUnusedFd
 *
pNext
;

15867 typedef struct 
unixFile
 
	tunixFile
;

15868 struct 
	sunixFile
 {

15869 
sqlite3_io_methods
 const *
pMethod
;

15870 
sqlite3_vfs
 *
pVfs
;

15871 
unixInodeInfo
 *
pInode
;

15872 int 
h
;

15873 unsigned char 
eFileLock
;

15874 unsigned short int 
ctrlFlags
;

15875 int 
lastErrno
;

15876 void *
lockingContext
;

15877 
UnixUnusedFd
 *
pUnused
;

15878 const char *
zPath
;

15879 
unixShm
 *
pShm
;

15880 int 
szChunk
;

15882 int 
nFetchOut
;

15883 
sqlite3_int64
 
mmapSize
;

15884 
sqlite3_int64
 
mmapSizeActual
;

15885 
sqlite3_int64
 
mmapSizeMax
;

15886 void *
pMapRegion
;

15894 static 
pid_t
 
randomnessPid
 = 0;

15896 static int 
	$posixOpen
(const char *
zFile
, int 
flags
, int 
mode
)

15899 return 
	`open
(
zFile
, 
flags
, 
mode
);

15900 
	}
}

15903 static int 
openDirectory
(const char*, int*);

15904 static int 
unixGetpagesize
(void);

15912 static struct 
	sunix_syscall
 {

15913 const char *
	mzName
;

15914 
sqlite3_syscall_ptr
 
	mpCurrent
;

15915 
sqlite3_syscall_ptr
 
	mpDefault
;

15916 } 
	gaSyscall
[] = {

15917 { "open", (
sqlite3_syscall_ptr
)
posixOpen
, 0 },

15920 { "close", (
sqlite3_syscall_ptr
)
close
, 0 },

15923 { "access", (
sqlite3_syscall_ptr
)
access
, 0 },

15926 { "getcwd", (
sqlite3_syscall_ptr
)
getcwd
, 0 },

15929 { "stat", (
sqlite3_syscall_ptr
)
stat
, 0 },

15931 { "fstat", (
sqlite3_syscall_ptr
)
fstat
, 0 },

15935 { "ftruncate", (
sqlite3_syscall_ptr
)
ftruncate
, 0 },

15938 { "fcntl", (
sqlite3_syscall_ptr
)
fcntl
, 0 },

15941 { "read", (
sqlite3_syscall_ptr
)
read
, 0 },

15947 { "pread", (
sqlite3_syscall_ptr
)0, 0 },

15954 { "pread64", (
sqlite3_syscall_ptr
)0, 0 },

15958 { "write", (
sqlite3_syscall_ptr
)
write
, 0 },

15964 { "pwrite", (
sqlite3_syscall_ptr
)0, 0 },

15972 { "pwrite64", (
sqlite3_syscall_ptr
)0, 0 },

15977 { "fchmod", (
sqlite3_syscall_ptr
)
fchmod
, 0 },

15983 { "fallocate", (
sqlite3_syscall_ptr
)0, 0 },

15987 { "unlink", (
sqlite3_syscall_ptr
)
unlink
, 0 },

15990 { "openDirectory", (
sqlite3_syscall_ptr
)
openDirectory
, 0 },

15993 { "mkdir", (
sqlite3_syscall_ptr
)
mkdir
, 0 },

15996 { "rmdir", (
sqlite3_syscall_ptr
)
rmdir
, 0 },

16000 { "fchown", (
sqlite3_syscall_ptr
)
fchown
, 0 },

16006 { "geteuid", (
sqlite3_syscall_ptr
)
geteuid
, 0 },

16010 { "mmap", (
sqlite3_syscall_ptr
)
mmap
, 0 },

16017 { "munmap", (
sqlite3_syscall_ptr
)
munmap
, 0 },

16024 { "mremap", (
sqlite3_syscall_ptr
)
mremap
, 0 },

16031 { "getpagesize", (
sqlite3_syscall_ptr
)
unixGetpagesize
, 0 },

16038 { "readlink", (
sqlite3_syscall_ptr
)
readlink
, 0 },

16045 { "lstat", (
sqlite3_syscall_ptr
)
lstat
, 0 },

16059 static int 
	$robustFchown
(int 
fd
, 
uid_t
 
uid
, 
gid_t
 
gid
)

16063 return ((
	`uid_t
(*)(void))
aSyscall
[21].
pCurrent
)() ? 0 : ((int(*)(int,
uid_t
,
gid_t
))aSyscall[20].pCurrent)(
fd
,
uid
,
gid
);

16067 
	}
}

16075 static int 
	$unixSetSystemCall
(

16076 
sqlite3_vfs
 *
pNotUsed
,

16077 const char *
zName
,

16078 
sqlite3_syscall_ptr
 
pNewFunc


16082 unsigned int 
i
;

16083 int 
rc
 = 12;

16085 (void)(
pNotUsed
);

16086 if( 
zName
==0 )

16092 
rc
 = 0;

16093 for(
i
=0; i<sizeof(
aSyscall
)/sizeof(aSyscall[0]); i++)

16096 if( 
aSyscall
[
i
].
pDefault
 )

16099 
aSyscall
[
i
].
pCurrent
 = aSyscall[i].
pDefault
;

16106 for(
i
=0; i<sizeof(
aSyscall
)/sizeof(aSyscall[0]); i++)

16109 if( 
	`strcmp
(
zName
, 
aSyscall
[
i
].zName)==0 )

16112 if( 
aSyscall
[
i
].
pDefault
==0 )

16115 
aSyscall
[
i
].
pDefault
 = aSyscall[i].
pCurrent
;

16117 
rc
 = 0;

16118 if( 
pNewFunc
==0 ) pNewFunc = 
aSyscall
[
i
].
pDefault
;

16119 
aSyscall
[
i
].
pCurrent
 = 
pNewFunc
;

16124 return 
rc
;

16125 
	}
}

16132 static 
sqlite3_syscall_ptr
 
	$unixGetSystemCall
(

16133 
sqlite3_vfs
 *
pNotUsed
,

16134 const char *
zName


16138 unsigned int 
i
;

16140 (void)(
pNotUsed
);

16141 for(
i
=0; i<sizeof(
aSyscall
)/sizeof(aSyscall[0]); i++)

16144 if( 
	`strcmp
(
zName
, 
aSyscall
[
i
].zName)==0 ) return aSyscall[i].
pCurrent
;

16147 
	}
}

16155 static const char *
	$unixNextSystemCall
(
sqlite3_vfs
 *
p
, const char *
zName
)

16158 int 
i
 = -1;

16160 (void)(
p
);

16161 if( 
zName
 )

16164 for(
i
=0; i<((int)(sizeof(
aSyscall
)/sizeof(aSyscall[0])))-1; i++)

16167 if( 
	`strcmp
(
zName
, 
aSyscall
[
i
].zName)==0 ) break;

16170 for(
i
++; i<((int)(sizeof(
aSyscall
)/sizeof(aSyscall[0]))); i++)

16173 if( 
aSyscall
[
i
].
pCurrent
!=0 ) return aSyscall[i].
zName
;

16176 
	}
}

16178 static int 
	$robust_open
(const char *
z
, int 
f
, 
mode_t
 
m
)

16181 int 
fd
;

16182 
mode_t
 
m2
 = 
m
 ? m : 0644;

16187 
fd
 = ((int(*)(const char*,int,int))
aSyscall
[0].
pCurrent
)(
z
,
f
|02000000,
m2
);

16191 if( 
fd
<0 )

16194 if( (*
	`__errno_location
 ())==4 ) continue;

16197 if( 
fd
>=3 ) break;

16198 ((int(*)(int))
aSyscall
[1].
pCurrent
)(
fd
);

16199 
	`sqlite3_log
(28,

16200 "attempt to open \"%s\" as file descriptor %d", 
z
, 
fd
);

16201 
fd
 = -1;

16202 if( ((int(*)(const char*,int,int))
aSyscall
[0].
pCurrent
)("/dev/null", 
f
, 
m
)<0 ) break;

16204 if( 
fd
>=0 )

16207 if( 
m
!=0 )

16210 struct 
stat
 
statbuf
;

16211 if( ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(
fd
, &
statbuf
)==0

16212 && 
statbuf
.
st_size
==0

16213 && (
statbuf
.
st_mode
&0777)!=
m


16217 ((int(*)(int,
mode_t
))
aSyscall
[14].
pCurrent
)(
fd
, 
m
);

16224 return 
fd
;

16225 
	}
}

16227 static void 
	$unixEnterMutex
(void)

16230 
	`sqlite3_mutex_enter
(
	`sqlite3MutexAlloc
(11));

16231 
	}
}

16232 static void 
	$unixLeaveMutex
(void)

16235 
	`sqlite3_mutex_leave
(
	`sqlite3MutexAlloc
(11));

16236 
	}
}

16238 static int 
	$robust_ftruncate
(int 
h
, 
sqlite3_int64
 
sz
)

16241 int 
rc
;

16243 do{ 
rc
 = ((int(*)(int,
off_t
))
aSyscall
[6].
pCurrent
)(
h
,
sz
); }while( rc<0 && (*
	`__errno_location
 ())==4 );

16244 return 
rc
;

16245 
	}
}

16247 static int 
	$sqliteErrorFromPosixError
(int 
posixError
, int 
sqliteIOErr
) {

16252 switch (
posixError
) {

16267 return 
sqliteIOErr
;

16269 
	}
}

16271 struct 
	svxworksFileId
 {

16272 struct 
vxworksFileId
 *
	mpNext
;

16273 int 
	mnRef
;

16274 int 
	mnName
;

16275 char *
	mzCanonicalName
;

16278 struct 
	sunixFileId
 {

16279 
dev_t
 
	mdev
;

16283 
ino_t
 
	mino
;

16287 struct 
	sunixInodeInfo
 {

16288 struct 
unixFileId
 
	mfileId
;

16289 int 
	mnShared
;

16290 unsigned char 
	meFileLock
;

16291 unsigned char 
	mbProcessLock
;

16292 int 
	mnRef
;

16293 
unixShmNode
 *
	mpShmNode
;

16294 int 
	mnLock
;

16295 
UnixUnusedFd
 *
	mpUnused
;

16296 
unixInodeInfo
 *
	mpNext
;

16297 
unixInodeInfo
 *
	mpPrev
;

16310 static 
unixInodeInfo
 *
	ginodeList
 = 0;

16312 static int 
	$unixLogErrorAtLine
(

16313 int 
errcode
,

16314 const char *
zFunc
,

16315 const char *
zPath
,

16316 int 
iLine


16320 char *
zErr
;

16321 int 
iErrno
 = (*
	`__errno_location
 ());

16323 
zErr
 = "";

16329 if( 
zPath
==0 ) zPath = "";

16330 
	`sqlite3_log
(
errcode
,

16332 
iLine
, 
iErrno
, 
zFunc
, 
zPath
, 
zErr


16335 return 
errcode
;

16336 
	}
}

16338 static void 
	$robust_close
(
unixFile
 *
pFile
, int 
h
, int 
lineno
)

16341 if( ((int(*)(int))
aSyscall
[1].
pCurrent
)(
h
) )

16344 
	`unixLogErrorAtLine
((10 | (16<<8)), "close",

16345 
pFile
 ? pFile->
zPath
 : 0, 
lineno
);

16347 
	}
}

16353 static void 
	$storeLastErrno
(
unixFile
 *
pFile
, int 
error
)

16356 
pFile
->
lastErrno
 = 
error
;

16357 
	}
}

16362 static void 
	$closePendingFds
(
unixFile
 *
pFile
)

16365 
unixInodeInfo
 *
pInode
 = 
pFile
->pInode;

16366 
UnixUnusedFd
 *
p
;

16367 
UnixUnusedFd
 *
pNext
;

16368 for(
p
=
pInode
->
pUnused
; p; p=
pNext
)

16371 
pNext
 = 
p
->pNext;

16372 
	`robust_close
(
pFile
, 
p
->
fd
, 28716);

16373 
	`sqlite3_free
(
p
);

16375 
pInode
->
pUnused
 = 0;

16376 
	}
}

16384 static void 
	$releaseInodeInfo
(
unixFile
 *
pFile
)

16387 
unixInodeInfo
 *
pInode
 = 
pFile
->pInode;

16389 if( (
pInode
) )

16392 
pInode
->
nRef
--;

16393 if( 
pInode
->
nRef
==0 )

16397 
	`closePendingFds
(
pFile
);

16398 if( 
pInode
->
pPrev
 )

16402 
pInode
->
pPrev
->
pNext
 = pInode->pNext;

16405 
inodeList
 = 
pInode
->
pNext
;

16407 if( 
pInode
->
pNext
 )

16411 
pInode
->
pNext
->
pPrev
 = pInode->pPrev;

16413 
	`sqlite3_free
(
pInode
);

16416 
	}
}

16418 static int 
	$findInodeInfo
(

16419 
unixFile
 *
pFile
,

16420 
unixInodeInfo
 **
ppInode


16424 int 
rc
;

16425 int 
fd
;

16426 struct 
unixFileId
 
fileId
;

16427 struct 
stat
 
statbuf
;

16428 
unixInodeInfo
 *
pInode
 = 0;

16435 
fd
 = 
pFile
->
h
;

16436 
rc
 = ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(
fd
, &
statbuf
);

16437 if( 
rc
!=0 )

16440 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

16447 
	`memset
(&
fileId
, 0, sizeof(fileId));

16448 
fileId
.
dev
 = 
statbuf
.
st_dev
;

16452 
fileId
.
ino
 = 
statbuf
.
st_ino
;

16454 
pInode
 = 
inodeList
;

16455 while( 
pInode
 && 
	`memcmp
(&
fileId
, &pInode->fileId, sizeof(fileId)) )

16458 
pInode
 = pInode->
pNext
;

16460 if( 
pInode
==0 )

16463 
pInode
 = 
	`sqlite3_malloc64
( sizeof(*pInode) );

16464 if( 
pInode
==0 )

16469 
	`memset
(
pInode
, 0, sizeof(*pInode));

16470 
	`memcpy
(&
pInode
->
fileId
, &fileId, sizeof(fileId));

16471 
pInode
->
nRef
 = 1;

16472 
pInode
->
pNext
 = 
inodeList
;

16473 
pInode
->
pPrev
 = 0;

16474 if( 
inodeList
 ) inodeList->
pPrev
 = 
pInode
;

16475 
inodeList
 = 
pInode
;

16477 
pInode
->
nRef
++;

16479 *
ppInode
 = 
pInode
;

16481 
	}
}

16486 static int 
	$fileHasMoved
(
unixFile
 *
pFile
)

16492 struct 
stat
 
buf
;

16493 return 
pFile
->
pInode
!=0 &&

16494 (((int(*)(const char*,struct 
stat
*))
aSyscall
[4].
pCurrent
)(
pFile
->
zPath
, &
buf
)!=0 || buf.
st_ino
!=pFile->
pInode
->
fileId
.
ino
);

16496 
	}
}

16498 static void 
	$verifyDbFile
(
unixFile
 *
pFile
)

16501 struct 
stat
 
buf
;

16502 int 
rc
;

16505 if( 
pFile
->
ctrlFlags
 & 0x80 ) return;

16507 
rc
 = ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(
pFile
->
h
, &
buf
);

16508 if( 
rc
!=0 )

16511 
	`sqlite3_log
(28, "cannot fstat db file %s", 
pFile
->
zPath
);

16514 if( 
buf
.
st_nlink
==0 )

16517 
	`sqlite3_log
(28, "file unlinked while open: %s", 
pFile
->
zPath
);

16520 if( 
buf
.
st_nlink
>1 )

16523 
	`sqlite3_log
(28, "multiple links to file: %s", 
pFile
->
zPath
);

16526 if( 
	`fileHasMoved
(
pFile
) )

16529 
	`sqlite3_log
(28, "file renamed while open: %s", 
pFile
->
zPath
);

16532 
	}
}

16534 static int 
	$unixCheckReservedLock
(
sqlite3_file
 *
id
, int *
pResOut
)

16537 int 
rc
 = 0;

16538 int 
reserved
 = 0;

16539 
unixFile
 *
pFile
 = (unixFile*)
id
;

16545 
	`unixEnterMutex
();

16548 if( 
pFile
->
pInode
->
eFileLock
>1 )

16551 
reserved
 = 1;

16557 if( !
reserved
 && !
pFile
->
pInode
->
bProcessLock
 )

16560 struct 
flock
 
lock
;

16561 
lock
.
l_whence
 = 0;

16562 
lock
.
l_start
 = (
sqlite3PendingByte
+1);

16563 
lock
.
l_len
 = 1;

16564 
lock
.
l_type
 = 1;

16565 if( ((int(*)(int,int,...))
aSyscall
[7].
pCurrent
)(
pFile
->
h
, 5, &
lock
) )

16568 
rc
 = (10 | (14<<8));

16569 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

16570 } else if( 
lock
.
l_type
!=2 )

16573 
reserved
 = 1;

16578 
	`unixLeaveMutex
();

16581 *
pResOut
 = 
reserved
;

16582 return 
rc
;

16583 
	}
}

16585 static int 
	$unixFileLock
(
unixFile
 *
pFile
, struct 
flock
 *
pLock
)

16588 int 
rc
;

16589 
unixInodeInfo
 *
pInode
 = 
pFile
->pInode;

16592 if( (
pFile
->
ctrlFlags
 & (0x01|0x02))==0x01 )

16595 if( 
pInode
->
bProcessLock
==0 )

16598 struct 
flock
 
lock
;

16600 
lock
.
l_whence
 = 0;

16601 
lock
.
l_start
 = (
sqlite3PendingByte
+2);

16602 
lock
.
l_len
 = 510;

16603 
lock
.
l_type
 = 1;

16604 
rc
 = ((int(*)(int,int,...))
aSyscall
[7].
pCurrent
)(
pFile
->
h
, 6, &
lock
);

16605 if( 
rc
<0 ) return rc;

16606 
pInode
->
bProcessLock
 = 1;

16607 
pInode
->
nLock
++;

16609 
rc
 = 0;

16612 
rc
 = ((int(*)(int,int,...))
aSyscall
[7].
pCurrent
)(
pFile
->
h
, 6, 
pLock
);

16614 return 
rc
;

16615 
	}
}

16617 static int 
	$unixLock
(
sqlite3_file
 *
id
, int 
eFileLock
)

16621 int 
rc
 = 0;

16622 
unixFile
 *
pFile
 = (unixFile*)
id
;

16623 
unixInodeInfo
 *
pInode
;

16624 struct 
flock
 
lock
;

16625 int 
tErrno
 = 0;

16637 if( 
pFile
->
eFileLock
>=eFileLock )

16656 
	`unixEnterMutex
();

16657 
pInode
 = 
pFile
->pInode;

16662 if( (
pFile
->
eFileLock
!=
pInode
->eFileLock &&

16663 (
pInode
->
eFileLock
>=3 || eFileLock>1))

16667 
rc
 = 5;

16668 goto 
end_lock
;

16675 if( 
eFileLock
==1 &&

16676 (
pInode
->
eFileLock
==1 || pInode->eFileLock==2) )

16682 
pFile
->
eFileLock
 = 1;

16683 
pInode
->
nShared
++;

16684 
pInode
->
nLock
++;

16685 goto 
end_lock
;

16693 
lock
.
l_len
 = 1L;

16694 
lock
.
l_whence
 = 0;

16695 if( 
eFileLock
==1

16696 || (
eFileLock
==4 && 
pFile
->eFileLock<3)

16700 
lock
.
l_type
 = (
eFileLock
==1?0:1);

16701 
lock
.
l_start
 = 
sqlite3PendingByte
;

16702 if( 
	`unixFileLock
(
pFile
, &
lock
) )

16705 
tErrno
 = (*
	`__errno_location
 ());

16706 
rc
 = 
	`sqliteErrorFromPosixError
(
tErrno
, (10 | (15<<8)));

16707 if( 
rc
!=5 )

16710 
	`storeLastErrno
(
pFile
, 
tErrno
);

16712 goto 
end_lock
;

16720 if( 
eFileLock
==1 )

16728 
lock
.
l_start
 = (
sqlite3PendingByte
+2);

16729 
lock
.
l_len
 = 510;

16730 if( 
	`unixFileLock
(
pFile
, &
lock
) )

16733 
tErrno
 = (*
	`__errno_location
 ());

16734 
rc
 = 
	`sqliteErrorFromPosixError
(
tErrno
, (10 | (15<<8)));

16738 
lock
.
l_start
 = 
sqlite3PendingByte
;

16739 
lock
.
l_len
 = 1L;

16740 
lock
.
l_type
 = 2;

16741 if( 
	`unixFileLock
(
pFile
, &
lock
) && 
rc
==0 )

16745 
tErrno
 = (*
	`__errno_location
 ());

16746 
rc
 = (10 | (8<<8));

16749 if( 
rc
 )

16752 if( 
rc
!=5 )

16755 
	`storeLastErrno
(
pFile
, 
tErrno
);

16757 goto 
end_lock
;

16759 
pFile
->
eFileLock
 = 1;

16760 
pInode
->
nLock
++;

16761 
pInode
->
nShared
 = 1;

16763 }else if( 
eFileLock
==4 && 
pInode
->
nShared
>1 )

16768 
rc
 = 5;

16775 
lock
.
l_type
 = 1;

16778 if( 
eFileLock
==2 )

16781 
lock
.
l_start
 = (
sqlite3PendingByte
+1);

16782 
lock
.
l_len
 = 1L;

16784 
lock
.
l_start
 = (
sqlite3PendingByte
+2);

16785 
lock
.
l_len
 = 510;

16788 if( 
	`unixFileLock
(
pFile
, &
lock
) )

16791 
tErrno
 = (*
	`__errno_location
 ());

16792 
rc
 = 
	`sqliteErrorFromPosixError
(
tErrno
, (10 | (15<<8)));

16793 if( 
rc
!=5 )

16796 
	`storeLastErrno
(
pFile
, 
tErrno
);

16801 if( 
rc
==0 )

16804 
pFile
->
eFileLock
 = eFileLock;

16805 
pInode
->
eFileLock
 = eFileLock;

16806 }else if( 
eFileLock
==4 )

16809 
pFile
->
eFileLock
 = 3;

16810 
pInode
->
eFileLock
 = 3;

16813 
end_lock
:

16814 
	`unixLeaveMutex
();

16817 return 
rc
;

16818 
	}
}

16824 static void 
	$setPendingFd
(
unixFile
 *
pFile
)

16827 
unixInodeInfo
 *
pInode
 = 
pFile
->pInode;

16828 
UnixUnusedFd
 *
p
 = 
pFile
->
pUnused
;

16829 
p
->
pNext
 = 
pInode
->
pUnused
;

16830 
pInode
->
pUnused
 = 
p
;

16831 
pFile
->
h
 = -1;

16832 
pFile
->
pUnused
 = 0;

16833 
	}
}

16835 static int 
	$posixUnlock
(
sqlite3_file
 *
id
, int 
eFileLock
, int 
handleNFSUnlock
)

16838 
unixFile
 *
pFile
 = (unixFile*)
id
;

16839 
unixInodeInfo
 *
pInode
;

16840 struct 
flock
 
lock
;

16841 int 
rc
 = 0;

16849 if( 
pFile
->
eFileLock
<=eFileLock )

16854 
	`unixEnterMutex
();

16855 
pInode
 = 
pFile
->pInode;

16857 if( 
pFile
->
eFileLock
>1 )

16862 if( 
eFileLock
==1 )

16866 (void)
handleNFSUnlock
;

16870 
lock
.
l_type
 = 0;

16871 
lock
.
l_whence
 = 0;

16872 
lock
.
l_start
 = (
sqlite3PendingByte
+2);

16873 
lock
.
l_len
 = 510;

16874 if( 
	`unixFileLock
(
pFile
, &
lock
) )

16883 
rc
 = (10 | (9<<8));

16884 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

16885 goto 
end_unlock
;

16889 
lock
.
l_type
 = 2;

16890 
lock
.
l_whence
 = 0;

16891 
lock
.
l_start
 = 
sqlite3PendingByte
;

16892 
lock
.
l_len
 = 2L; ((void) (0));

16893 if( 
	`unixFileLock
(
pFile
, &
lock
)==0 )

16896 
pInode
->
eFileLock
 = 1;

16898 
rc
 = (10 | (8<<8));

16899 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

16900 goto 
end_unlock
;

16903 if( 
eFileLock
==0 )

16910 
pInode
->
nShared
--;

16911 if( 
pInode
->
nShared
==0 )

16914 
lock
.
l_type
 = 2;

16915 
lock
.
l_whence
 = 0;

16916 
lock
.
l_start
 = lock.
l_len
 = 0L;

16917 if( 
	`unixFileLock
(
pFile
, &
lock
)==0 )

16920 
pInode
->
eFileLock
 = 0;

16922 
rc
 = (10 | (8<<8));

16923 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

16924 
pInode
->
eFileLock
 = 0;

16925 
pFile
->
eFileLock
 = 0;

16933 
pInode
->
nLock
--;

16935 if( 
pInode
->
nLock
==0 )

16938 
	`closePendingFds
(
pFile
);

16942 
end_unlock
:

16943 
	`unixLeaveMutex
();

16944 if( 
rc
==0 ) 
pFile
->
eFileLock
 = eFileLock;

16945 return 
rc
;

16946 
	}
}

16948 static int 
	$unixUnlock
(
sqlite3_file
 *
id
, int 
eFileLock
)

16954 return 
	`posixUnlock
(
id
, 
eFileLock
, 0);

16955 
	}
}

16958 static int 
unixMapfile
(
unixFile
 *
pFd
, 
i64
 
nByte
);

16959 static void 
unixUnmapfile
(
unixFile
 *
pFd
);

16961 static int 
	$closeUnixFile
(
sqlite3_file
 *
id
)

16964 
unixFile
 *
pFile
 = (unixFile*)
id
;

16966 
	`unixUnmapfile
(
pFile
);

16968 if( 
pFile
->
h
>=0 )

16971 
	`robust_close
(
pFile
, pFile->
h
, 29444);

16972 
pFile
->
h
 = -1;

16977 
	`sqlite3_free
(
pFile
->
pUnused
);

16978 
	`memset
(
pFile
, 0, sizeof(
unixFile
));

16980 
	}
}

16985 static int 
	$unixClose
(
sqlite3_file
 *
id
)

16988 int 
rc
 = 0;

16989 
unixFile
 *
pFile
 = (unixFile *)
id
;

16990 
	`verifyDbFile
(
pFile
);

16991 
	`unixUnlock
(
id
, 0);

16992 
	`unixEnterMutex
();

16998 if( (
pFile
->
pInode
) && pFile->pInode->
nLock
 )

17006 
	`setPendingFd
(
pFile
);

17008 
	`releaseInodeInfo
(
pFile
);

17009 
rc
 = 
	`closeUnixFile
(
id
);

17010 
	`unixLeaveMutex
();

17011 return 
rc
;

17012 
	}
}

17014 static int 
	$nolockCheckReservedLock
(
sqlite3_file
 *
NotUsed
, int *
pResOut
)

17017 (void)(
NotUsed
);

17018 *
pResOut
 = 0;

17020 
	}
}

17021 static int 
	$nolockLock
(
sqlite3_file
 *
NotUsed
, int 
NotUsed2
)

17024 (void)(
NotUsed
),(void)(
NotUsed2
);

17026 
	}
}

17027 static int 
	$nolockUnlock
(
sqlite3_file
 *
NotUsed
, int 
NotUsed2
)

17030 (void)(
NotUsed
),(void)(
NotUsed2
);

17032 
	}
}

17037 static int 
	$nolockClose
(
sqlite3_file
 *
id
) {

17038 return 
	`closeUnixFile
(
id
);

17039 
	}
}

17041 static int 
	$dotlockCheckReservedLock
(
sqlite3_file
 *
id
, int *
pResOut
) {

17042 int 
rc
 = 0;

17043 int 
reserved
 = 0;

17044 
unixFile
 *
pFile
 = (unixFile*)
id
;

17049 
reserved
 = ((int(*)(const char*,int))
aSyscall
[2].
pCurrent
)((const char*)
pFile
->
lockingContext
, 0)==0;

17051 *
pResOut
 = 
reserved
;

17052 return 
rc
;

17053 
	}
}

17055 static int 
	$dotlockLock
(
sqlite3_file
 *
id
, int 
eFileLock
) {

17056 
unixFile
 *
pFile
 = (unixFile*)
id
;

17057 char *
zLockFile
 = (char *)
pFile
->
lockingContext
;

17058 int 
rc
 = 0;

17064 if( 
pFile
->
eFileLock
 > 0 )

17067 
pFile
->
eFileLock
 = eFileLock;

17072 
	`utimes
(
zLockFile
, ((void *)0));

17078 
rc
 = ((int(*)(const char*,
mode_t
))
aSyscall
[18].
pCurrent
)(
zLockFile
, 0777);

17079 if( 
rc
<0 )

17083 int 
tErrno
 = (*
	`__errno_location
 ());

17084 if( 17 == 
tErrno
 )

17087 
rc
 = 5;

17089 
rc
 = 
	`sqliteErrorFromPosixError
(
tErrno
, (10 | (15<<8)));

17090 if( 
rc
!=5 )

17093 
	`storeLastErrno
(
pFile
, 
tErrno
);

17096 return 
rc
;

17100 
pFile
->
eFileLock
 = eFileLock;

17101 return 
rc
;

17102 
	}
}

17104 static int 
	$dotlockUnlock
(
sqlite3_file
 *
id
, int 
eFileLock
) {

17105 
unixFile
 *
pFile
 = (unixFile*)
id
;

17106 char *
zLockFile
 = (char *)
pFile
->
lockingContext
;

17107 int 
rc
;

17115 if( 
pFile
->
eFileLock
==eFileLock )

17124 if( 
eFileLock
==1 )

17127 
pFile
->
eFileLock
 = 1;

17133 
rc
 = ((int(*)(const char*))
aSyscall
[19].
pCurrent
)(
zLockFile
);

17134 if( 
rc
<0 )

17137 int 
tErrno
 = (*
	`__errno_location
 ());

17138 if( 
tErrno
==2 )

17141 
rc
 = 0;

17143 
rc
 = (10 | (8<<8));

17144 
	`storeLastErrno
(
pFile
, 
tErrno
);

17146 return 
rc
;

17148 
pFile
->
eFileLock
 = 0;

17150 
	}
}

17155 static int 
	$dotlockClose
(
sqlite3_file
 *
id
) {

17156 
unixFile
 *
pFile
 = (unixFile*)
id
;

17158 
	`dotlockUnlock
(
id
, 0);

17159 
	`sqlite3_free
(
pFile
->
lockingContext
);

17160 return 
	`closeUnixFile
(
id
);

17161 
	}
}

17163 static int 
	$seekAndRead
(
unixFile
 *
id
, 
sqlite3_int64
 
offset
, void *
pBuf
, int 
cnt
)

17166 int 
got
;

17167 int 
prior
 = 0;

17169 
i64
 
newOffset
;

17182 
newOffset
 = 
	`lseek
(
id
->
h
, 
offset
, 0);

17184 if( 
newOffset
<0 )

17187 
	`storeLastErrno
((
unixFile
*)
id
, (*
	`__errno_location
 ()));

17190 
got
 = ((
	`ssize_t
(*)(int,void*,
size_t
))
aSyscall
[8].
pCurrent
)(
id
->
h
, 
pBuf
, 
cnt
);

17192 if( 
got
==
cnt
 ) break;

17193 if( 
got
<0 )

17196 if( (*
	`__errno_location
 ())==4 )

17198 
got
 = 1; continue; }

17199 
prior
 = 0;

17200 
	`storeLastErrno
((
unixFile
*)
id
, (*
	`__errno_location
 ()));

17202 }else if( 
got
>0 )

17205 
cnt
 -= 
got
;

17206 
offset
 += 
got
;

17207 
prior
 += 
got
;

17208 
pBuf
 = (void*)(
got
 + (char*)pBuf);

17210 }while( 
got
>0 );

17214 return 
got
+
prior
;

17215 
	}
}

17222 static int 
	$unixRead
(

17223 
sqlite3_file
 *
id
,

17224 void *
pBuf
,

17225 int 
amt
,

17226 
sqlite3_int64
 
offset


17230 
unixFile
 *
pFile
 = (unixFile *)
id
;

17231 int 
got
;

17236 if( 
offset
<
pFile
->
mmapSize
 )

17239 if( 
offset
+
amt
 <= 
pFile
->
mmapSize
 )

17242 
	`memcpy
(
pBuf
, &((
u8
 *)(
pFile
->
pMapRegion
))[
offset
], 
amt
);

17245 int 
nCopy
 = 
pFile
->
mmapSize
 - 
offset
;

17246 
	`memcpy
(
pBuf
, &((
u8
 *)(
pFile
->
pMapRegion
))[
offset
], 
nCopy
);

17247 
pBuf
 = &((
u8
 *)pBuf)[
nCopy
];

17248 
amt
 -= 
nCopy
;

17249 
offset
 += 
nCopy
;

17254 
got
 = 
	`seekAndRead
(
pFile
, 
offset
, 
pBuf
, 
amt
);

17255 if( 
got
==
amt
 )

17259 }else if( 
got
<0 )

17265 
	`storeLastErrno
(
pFile
, 0);

17267 
	`memset
(&((char*)
pBuf
)[
got
], 0, 
amt
-got);

17270 
	}
}

17272 static int 
	$seekAndWriteFd
(

17273 int 
fd
,

17274 
i64
 
iOff
,

17275 const void *
pBuf
,

17276 int 
nBuf
,

17277 int *
piErrno


17281 int 
rc
 = 0;

17286 
nBuf
 &= 0x1ffff;

17295 
i64
 
iSeek
 = 
	`lseek
(
fd
, 
iOff
, 0);

17297 if( 
iSeek
<0 )

17300 
rc
 = -1;

17303 
rc
 = ((
	`ssize_t
(*)(int,const void*,
size_t
))
aSyscall
[11].
pCurrent
)(
fd
, 
pBuf
, 
nBuf
);

17304 }while( 
rc
<0 && (*
	`__errno_location
 ())==4 );

17310 if( 
rc
<0 ) *
piErrno
 = (*
	`__errno_location
 ());

17311 return 
rc
;

17312 
	}
}

17314 static int 
	$seekAndWrite
(
unixFile
 *
id
, 
i64
 
offset
, const void *
pBuf
, int 
cnt
)

17317 return 
	`seekAndWriteFd
(
id
->
h
, 
offset
, 
pBuf
, 
cnt
, &id->
lastErrno
);

17318 
	}
}

17325 static int 
	$unixWrite
(

17326 
sqlite3_file
 *
id
,

17327 const void *
pBuf
,

17328 int 
amt
,

17329 
sqlite3_int64
 
offset


17333 
unixFile
 *
pFile
 = (unixFile*)
id
;

17334 int 
wrote
 = 0;

17338 while( (
wrote
 = 
	`seekAndWrite
(
pFile
, 
offset
, 
pBuf
, 
amt
))<amt && wrote>0 )

17341 
amt
 -= 
wrote
;

17342 
offset
 += 
wrote
;

17343 
pBuf
 = &((char*)pBuf)[
wrote
];

17348 if( 
amt
>
wrote
 )

17351 if( 
wrote
<0 && 
pFile
->
lastErrno
!=28 )

17357 
	`storeLastErrno
(
pFile
, 0);

17363 
	}
}

17365 static int 
	$full_fsync
(int 
fd
, int 
fullSync
, int 
dataOnly
)

17368 int 
rc
;

17370 (void)(
fullSync
);

17371 (void)(
dataOnly
);

17373 
rc
 = 
	`fsync
(
fd
);

17381 if( 0 && 
rc
!= -1 )

17384 
rc
 = 0;

17386 return 
rc
;

17387 
	}
}

17389 static int 
	$openDirectory
(const char *
zFilename
, int *
pFd
)

17392 int 
ii
;

17393 int 
fd
 = -1;

17394 char 
zDirname
[512 +1];

17396 
	`sqlite3_snprintf
(512, 
zDirname
, "%s", 
zFilename
);

17397 for(
ii
=(int)
	`strlen
(
zDirname
); ii>0 && zDirname[ii]!='/'; ii--);

17398 if( 
ii
>0 )

17401 
zDirname
[
ii
] = '\0';

17403 if( 
zDirname
[0]!='/' ) zDirname[0] = '.';

17404 
zDirname
[1] = 0;

17406 
fd
 = 
	`robust_open
(
zDirname
, 00|0, 0);

17407 if( 
fd
>=0 )

17412 *
pFd
 = 
fd
;

17413 if( 
fd
>=0 ) return 0;

17414 return 
	`unixLogErrorAtLine
(
	`sqlite3CantopenError
(31035),"openDirectory",
zDirname
,31035);

17415 
	}
}

17417 static int 
	$unixSync
(
sqlite3_file
 *
id
, int 
flags
)

17420 int 
rc
;

17421 
unixFile
 *
pFile
 = (unixFile*)
id
;

17423 int 
isDataOnly
 = (
flags
&0x00010);

17424 int 
isFullsync
 = (
flags
&0x0F)==0x00003;

17438 
rc
 = 
	`full_fsync
(
pFile
->
h
, 
isFullsync
, 
isDataOnly
);

17440 if( 
rc
 )

17443 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

17444 return 
	`unixLogErrorAtLine
((10 | (4<<8)),"full_fsync",
pFile
->
zPath
,31076);

17451 if( 
pFile
->
ctrlFlags
 & 0x08 )

17454 int 
dirfd
;

17457 
rc
 = ((int(*)(const char*,int*))
aSyscall
[17].
pCurrent
)(
pFile
->
zPath
, &
dirfd
);

17458 if( 
rc
==0 )

17461 
	`full_fsync
(
dirfd
, 0, 0);

17462 
	`robust_close
(
pFile
, 
dirfd
, 31090);

17465 
rc
 = 0;

17467 
pFile
->
ctrlFlags
 &= ~0x08;

17469 return 
rc
;

17470 
	}
}

17475 static int 
	$unixTruncate
(
sqlite3_file
 *
id
, 
i64
 
nByte
)

17478 
unixFile
 *
pFile
 = (unixFile *)
id
;

17479 int 
rc
;

17488 if( 
pFile
->
szChunk
>0 )

17491 
nByte
 = ((nByte + 
pFile
->
szChunk
 - 1)/pFile->szChunk) * pFile->szChunk;

17494 
rc
 = 
	`robust_ftruncate
(
pFile
->
h
, 
nByte
);

17495 if( 
rc
 )

17498 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

17499 return 
	`unixLogErrorAtLine
((10 | (6<<8)),"ftruncate",
pFile
->
zPath
,31121);

17502 if( 
nByte
<
pFile
->
mmapSize
 )

17505 
pFile
->
mmapSize
 = 
nByte
;

17511 
	}
}

17516 static int 
	$unixFileSize
(
sqlite3_file
 *
id
, 
i64
 *
pSize
)

17519 int 
rc
;

17520 struct 
stat
 
buf
;

17522 
rc
 = ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(((
unixFile
*)
id
)->
h
, &
buf
);

17524 if( 
rc
!=0 )

17527 
	`storeLastErrno
((
unixFile
*)
id
, (*
	`__errno_location
 ()));

17530 *
pSize
 = 
buf
.
st_size
;

17538 if( *
pSize
==1 ) *pSize = 0;

17542 
	}
}

17544 static int 
	$fcntlSizeHint
(
unixFile
 *
pFile
, 
i64
 
nByte
)

17547 if( 
pFile
->
szChunk
>0 )

17550 
i64
 
nSize
;

17551 struct 
stat
 
buf
;

17553 if( ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(
pFile
->
h
, &
buf
) )

17559 
nSize
 = ((
nByte
+
pFile
->
szChunk
-1) / pFile->szChunk) * pFile->szChunk;

17560 if( 
nSize
>(
i64
)
buf
.
st_size
 )

17564 int 
nBlk
 = 
buf
.
st_blksize
;

17565 int 
nWrite
 = 0;

17566 
i64
 
iWrite
;

17568 
iWrite
 = (
buf
.
st_size
/
nBlk
)*nBlk + nBlk - 1;

17571 for( ; 
iWrite
<
nSize
+
nBlk
-1; iWrite+=nBlk )

17574 if( 
iWrite
>=
nSize
 ) iWrite = nSize - 1;

17575 
nWrite
 = 
	`seekAndWrite
(
pFile
, 
iWrite
, "", 1);

17576 if( 
nWrite
!=1 ) return (10 | (3<<8));

17583 if( 
pFile
->
mmapSizeMax
>0 && 
nByte
>pFile->
mmapSize
 )

17586 int 
rc
;

17587 if( 
pFile
->
szChunk
<=0 )

17590 if( 
	`robust_ftruncate
(
pFile
->
h
, 
nByte
) )

17593 
	`storeLastErrno
(
pFile
, (*
	`__errno_location
 ()));

17594 return 
	`unixLogErrorAtLine
((10 | (6<<8)),"ftruncate",
pFile
->
zPath
,31242);

17598 
rc
 = 
	`unixMapfile
(
pFile
, 
nByte
);

17599 return 
rc
;

17604 
	}
}

17612 static void 
	$unixModeBit
(
unixFile
 *
pFile
, unsigned char 
mask
, int *
pArg
)

17615 if( *
pArg
<0 )

17618 *
pArg
 = (
pFile
->
ctrlFlags
 & 
mask
)!=0;

17619 }else if( (*
pArg
)==0 )

17622 
pFile
->
ctrlFlags
 &= ~
mask
;

17624 
pFile
->
ctrlFlags
 |= 
mask
;

17626 
	}
}

17629 static int 
unixGetTempname
(int 
nBuf
, char *
zBuf
);

17634 static int 
	$unixFileControl
(
sqlite3_file
 *
id
, int 
op
, void *
pArg
)

17637 
unixFile
 *
pFile
 = (unixFile*)
id
;

17638 switch( 
op
 )

17642 *(int*)
pArg
 = 
pFile
->
eFileLock
;

17646 *(int*)
pArg
 = 
pFile
->
lastErrno
;

17650 
pFile
->
szChunk
 = *(int *)
pArg
;

17654 int 
rc
;

17656 
rc
 = 
	`fcntlSizeHint
(
pFile
, *(
i64
 *)
pArg
);

17658 return 
rc
;

17661 
	`unixModeBit
(
pFile
, 0x04, (int*)
pArg
);

17665 
	`unixModeBit
(
pFile
, 0x10, (int*)
pArg
);

17669 *(char**)
pArg
 = 
	`sqlite3_mprintf
("%s", 
pFile
->
pVfs
->
zName
);

17673 char *
zTFile
 = 
	`sqlite3_malloc64
( 
pFile
->
pVfs
->
mxPathname
 );

17674 if( 
zTFile
 )

17677 
	`unixGetTempname
(
pFile
->
pVfs
->
mxPathname
, 
zTFile
);

17678 *(char**)
pArg
 = 
zTFile
;

17683 *(int*)
pArg
 = 
	`fileHasMoved
(
pFile
);

17688 
i64
 
newLimit
 = *(i64*)
pArg
;

17689 int 
rc
 = 0;

17690 if( 
newLimit
>
sqlite3Config
.
mxMmap
 )

17693 
newLimit
 = 
sqlite3Config
.
mxMmap
;

17695 *(
i64
*)
pArg
 = 
pFile
->
mmapSizeMax
;

17696 if( 
newLimit
>=0 && newLimit!=
pFile
->
mmapSizeMax
 && pFile->
nFetchOut
==0 )

17699 
pFile
->
mmapSizeMax
 = 
newLimit
;

17700 if( 
pFile
->
mmapSize
>0 )

17703 
	`unixUnmapfile
(
pFile
);

17704 
rc
 = 
	`unixMapfile
(
pFile
, -1);

17707 return 
rc
;

17712 
	}
}

17714 static int 
	$unixSectorSize
(
sqlite3_file
 *
NotUsed
)

17717 (void)(
NotUsed
);

17719 
	}
}

17721 static int 
	$unixDeviceCharacteristics
(
sqlite3_file
 *
id
)

17724 
unixFile
 *
p
 = (unixFile*)
id
;

17725 int 
rc
 = 0;

17730 if( 
p
->
ctrlFlags
 & 0x10 )

17733 
rc
 |= 0x00001000;

17735 return 
rc
;

17736 
	}
}

17738 static int 
	$unixGetpagesize
(void)

17746 return (int)
	`sysconf
(
_SC_PAGESIZE
);

17748 
	}
}

17750 struct 
	sunixShmNode
 {

17751 
unixInodeInfo
 *
	mpInode
;

17752 
sqlite3_mutex
 *
	mmutex
;

17753 char *
	mzFilename
;

17754 int 
	mh
;

17755 int 
	mszRegion
;

17756 
u16
 
	mnRegion
;

17757 
u8
 
	misReadonly
;

17758 char **
	mapRegion
;

17759 int 
	mnRef
;

17760 
unixShm
 *
	mpFirst
;

17768 struct 
	sunixShm
 {

17769 
unixShmNode
 *
	mpShmNode
;

17770 
unixShm
 *
	mpNext
;

17771 
u8
 
	mhasMutex
;

17772 
u8
 
	mid
;

17773 
u16
 
	msharedMask
;

17774 
u16
 
	mexclMask
;

17777 static int 
	$unixShmSystemLock
(

17778 
unixFile
 *
pFile
,

17779 int 
lockType
,

17780 int 
ofst
,

17781 int 
n


17785 
unixShmNode
 *
pShmNode
;

17786 struct 
flock
 
f
;

17787 int 
rc
 = 0;

17790 
pShmNode
 = 
pFile
->
pInode
->pShmNode;

17799 if( 
pShmNode
->
h
>=0 )

17803 
	`memset
(&
f
, 0, sizeof(f));

17804 
f
.
l_type
 = 
lockType
;

17805 
f
.
l_whence
 = 0;

17806 
f
.
l_start
 = 
ofst
;

17807 
f
.
l_len
 = 
n
;

17809 
rc
 = ((int(*)(int,int,...))
aSyscall
[7].
pCurrent
)(
pShmNode
->
h
, 6, &
f
);

17810 
rc
 = (rc!=(-1)) ? 0 : 5;

17813 return 
rc
;

17814 
	}
}

17816 static int 
	$unixShmRegionPerMap
(void)

17819 int 
shmsz
 = 32*1024;

17820 int 
pgsz
 = ((int(*)(void))
aSyscall
[25].
pCurrent
)();

17822 if( 
pgsz
<
shmsz
 ) return 1;

17823 return 
pgsz
/
shmsz
;

17824 
	}
}

17832 static void 
	$unixShmPurge
(
unixFile
 *
pFd
)

17835 
unixShmNode
 *
p
 = 
pFd
->
pInode
->
pShmNode
;

17837 if( 
p
 && (p->
nRef
==0) )

17840 int 
nShmPerMap
 = 
	`unixShmRegionPerMap
();

17841 int 
i
;

17843 
	`sqlite3_mutex_free
(
p
->
mutex
);

17844 for(
i
=0; i<
p
->
nRegion
; i+=
nShmPerMap
)

17847 if( 
p
->
h
>=0 )

17850 ((void*(*)(void*,
size_t
))
aSyscall
[23].
pCurrent
)(
p
->
apRegion
[
i
], p->
szRegion
);

17852 
	`sqlite3_free
(
p
->
apRegion
[
i
]);

17855 
	`sqlite3_free
(
p
->
apRegion
);

17856 if( 
p
->
h
>=0 )

17859 
	`robust_close
(
pFd
, 
p
->
h
, 31697);

17860 
p
->
h
 = -1;

17862 
p
->
pInode
->
pShmNode
 = 0;

17863 
	`sqlite3_free
(
p
);

17865 
	}
}

17867 static int 
	$unixOpenSharedMemory
(
unixFile
 *
pDbFd
)

17870 struct 
unixShm
 *
p
 = 0;

17871 struct 
unixShmNode
 *
pShmNode
;

17872 int 
rc
;

17873 
unixInodeInfo
 *
pInode
;

17874 char *
zShmFilename
;

17875 int 
nShmFilename
;

17878 
p
 = 
	`sqlite3_malloc64
( sizeof(*p) );

17879 if( 
p
==0 ) return 7;

17880 
	`memset
(
p
, 0, sizeof(*p));

17886 
	`unixEnterMutex
();

17887 
pInode
 = 
pDbFd
->pInode;

17888 
pShmNode
 = 
pInode
->pShmNode;

17889 if( 
pShmNode
==0 )

17892 struct 
stat
 
sStat
;

17894 const char *
zBasePath
 = 
pDbFd
->
zPath
;

17901 if( ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(
pDbFd
->
h
, &
sStat
) )

17904 
rc
 = (10 | (7<<8));

17905 goto 
shm_open_err
;

17911 
nShmFilename
 = 6 + (int)
	`strlen
(
zBasePath
);

17913 
pShmNode
 = 
	`sqlite3_malloc64
( sizeof(*pShmNode) + 
nShmFilename
 );

17914 if( 
pShmNode
==0 )

17917 
rc
 = 7;

17918 goto 
shm_open_err
;

17920 
	`memset
(
pShmNode
, 0, sizeof(*pShmNode)+
nShmFilename
);

17921 
zShmFilename
 = 
pShmNode
->
zFilename
 = (char*)&pShmNode[1];

17927 
	`sqlite3_snprintf
(
nShmFilename
, 
zShmFilename
, "%s-shm", 
zBasePath
);

17930 
pShmNode
->
h
 = -1;

17931 
pDbFd
->
pInode
->
pShmNode
 = pShmNode;

17932 
pShmNode
->
pInode
 = 
pDbFd
->pInode;

17933 
pShmNode
->
mutex
 = 
	`sqlite3_mutex_alloc
(0);

17934 if( 
pShmNode
->
mutex
==0 )

17937 
rc
 = 7;

17938 goto 
shm_open_err
;

17941 if( 
pInode
->
bProcessLock
==0 )

17944 int 
openFlags
 = 02 | 0100;

17945 if( 
	`sqlite3_uri_boolean
(
pDbFd
->
zPath
, "readonly_shm", 0) )

17948 
openFlags
 = 00;

17949 
pShmNode
->
isReadonly
 = 1;

17951 
pShmNode
->
h
 = 
	`robust_open
(
zShmFilename
, 
openFlags
, (
sStat
.
st_mode
&0777));

17952 if( 
pShmNode
->
h
<0 )

17955 
rc
 = 
	`unixLogErrorAtLine
(
	`sqlite3CantopenError
(31812),"open",
zShmFilename
,31812);

17956 goto 
shm_open_err
;

17963 
	`robustFchown
(
pShmNode
->
h
, 
sStat
.
st_uid
, sStat.
st_gid
);

17968 
rc
 = 0;

17969 if( 
	`unixShmSystemLock
(
pDbFd
, 1, (((22+8)*4)+8), 1)==0 )

17972 if( 
	`robust_ftruncate
(
pShmNode
->
h
, 0) )

17975 
rc
 = 
	`unixLogErrorAtLine
((10 | (18<<8)),"ftruncate",
zShmFilename
,31828);

17978 if( 
rc
==0 )

17981 
rc
 = 
	`unixShmSystemLock
(
pDbFd
, 0, (((22+8)*4)+8), 1);

17983 if( 
rc
 ) goto 
shm_open_err
;

17988 
p
->
pShmNode
 = pShmNode;

17992 
pShmNode
->
nRef
++;

17993 
pDbFd
->
pShm
 = 
p
;

17994 
	`unixLeaveMutex
();

17996 
	`sqlite3_mutex_enter
(
pShmNode
->
mutex
);

17997 
p
->
pNext
 = 
pShmNode
->
pFirst
;

17998 
pShmNode
->
pFirst
 = 
p
;

17999 
	`sqlite3_mutex_leave
(
pShmNode
->
mutex
);

18003 
shm_open_err
:

18004 
	`unixShmPurge
(
pDbFd
);

18005 
	`sqlite3_free
(
p
);

18006 
	`unixLeaveMutex
();

18007 return 
rc
;

18008 
	}
}

18010 static int 
	$unixShmMap
(

18011 
sqlite3_file
 *
fd
,

18012 int 
iRegion
,

18013 int 
szRegion
,

18014 int 
bExtend
,

18015 void volatile **
pp


18019 
unixFile
 *
pDbFd
 = (unixFile*)
fd
;

18020 
unixShm
 *
p
;

18021 
unixShmNode
 *
pShmNode
;

18022 int 
rc
 = 0;

18023 int 
nShmPerMap
 = 
	`unixShmRegionPerMap
();

18024 int 
nReqRegion
;

18027 if( 
pDbFd
->
pShm
==0 )

18030 
rc
 = 
	`unixOpenSharedMemory
(
pDbFd
);

18031 if( 
rc
!=0 ) return rc;

18034 
p
 = 
pDbFd
->
pShm
;

18035 
pShmNode
 = 
p
->pShmNode;

18036 
	`sqlite3_mutex_enter
(
pShmNode
->
mutex
);

18043 
nReqRegion
 = ((
iRegion
+
nShmPerMap
) / nShmPerMap) * nShmPerMap;

18045 if( 
pShmNode
->
nRegion
<
nReqRegion
 )

18048 char **
apNew
;

18049 int 
nByte
 = 
nReqRegion
*
szRegion
;

18050 struct 
stat
 
sStat
;

18052 
pShmNode
->
szRegion
 = szRegion;

18054 if( 
pShmNode
->
h
>=0 )

18061 if( ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(
pShmNode
->
h
, &
sStat
) )

18064 
rc
 = (10 | (19<<8));

18065 goto 
shmpage_out
;

18068 if( 
sStat
.
st_size
<
nByte
 )

18074 if( !
bExtend
 )

18077 goto 
shmpage_out
;

18081 static const int 
pgsz
 = 4096;

18082 int 
iPg
;

18086 for(
iPg
=(
sStat
.
st_size
/
pgsz
); iPg<(
nByte
/pgsz); iPg++)

18089 int 
x
 = 0;

18090 if( 
	`seekAndWriteFd
(
pShmNode
->
h
, 
iPg
*
pgsz
 + pgsz-1, "", 1, &
x
)!=1 )

18093 const char *
zFile
 = 
pShmNode
->
zFilename
;

18094 
rc
 = 
	`unixLogErrorAtLine
((10 | (19<<8)),"write",
zFile
,31960);

18095 goto 
shmpage_out
;

18103 
apNew
 = (char **)
	`sqlite3_realloc
(

18104 
pShmNode
->
apRegion
, 
nReqRegion
*sizeof(char *)

18106 if( !
apNew
 )

18109 
rc
 = (10 | (12<<8));

18110 goto 
shmpage_out
;

18112 
pShmNode
->
apRegion
 = 
apNew
;

18113 while( 
pShmNode
->
nRegion
<
nReqRegion
 )

18116 int 
nMap
 = 
szRegion
*
nShmPerMap
;

18117 int 
i
;

18118 void *
pMem
;

18119 if( 
pShmNode
->
h
>=0 )

18122 
pMem
 = ((void*(*)(void*,
size_t
,int,int,int,
off_t
))
aSyscall
[22].
pCurrent
)(0, 
nMap
,

18123 
pShmNode
->
isReadonly
 ? 0x1 : 0x1|0x2,

18124 0x01, 
pShmNode
->
h
, 
szRegion
*(
i64
)pShmNode->
nRegion


18126 if( 
pMem
==((void *) -1) )

18129 
rc
 = 
	`unixLogErrorAtLine
((10 | (21<<8)),"mmap",
pShmNode
->
zFilename
,31987);

18130 goto 
shmpage_out
;

18133 
pMem
 = 
	`sqlite3_malloc64
(
szRegion
);

18134 if( 
pMem
==0 )

18137 
rc
 = 7;

18138 goto 
shmpage_out
;

18140 
	`memset
(
pMem
, 0, 
szRegion
);

18143 for(
i
=0; i<
nShmPerMap
; i++)

18146 
pShmNode
->
apRegion
[pShmNode->
nRegion
+
i
] = &((char*)
pMem
)[
szRegion
*i];

18148 
pShmNode
->
nRegion
 += 
nShmPerMap
;

18152 
shmpage_out
:

18153 if( 
pShmNode
->
nRegion
>
iRegion
 )

18156 *
pp
 = 
pShmNode
->
apRegion
[
iRegion
];

18158 *
pp
 = 0;

18160 if( 
pShmNode
->
isReadonly
 && 
rc
==0 ) rc = 8;

18161 
	`sqlite3_mutex_leave
(
pShmNode
->
mutex
);

18162 return 
rc
;

18163 
	}
}

18165 static int 
	$unixShmLock
(

18166 
sqlite3_file
 *
fd
,

18167 int 
ofst
,

18168 int 
n
,

18169 int 
flags


18173 
unixFile
 *
pDbFd
 = (unixFile*)
fd
;

18174 
unixShm
 *
p
 = 
pDbFd
->
pShm
;

18175 
unixShm
 *
pX
;

18176 
unixShmNode
 *
pShmNode
 = 
p
->pShmNode;

18177 int 
rc
 = 0;

18178 
u16
 
mask
;

18192 
mask
 = (1<<(
ofst
+
n
)) - (1<<ofst);

18194 
	`sqlite3_mutex_enter
(
pShmNode
->
mutex
);

18195 if( 
flags
 & 1 )

18198 
u16
 
allMask
 = 0;

18201 for(
pX
=
pShmNode
->
pFirst
; pX; pX=pX->
pNext
)

18204 if( 
pX
==
p
 ) continue;

18206 
allMask
 |= 
pX
->
sharedMask
;

18210 if( (
mask
 & 
allMask
)==0 )

18213 
rc
 = 
	`unixShmSystemLock
(
pDbFd
, 2, 
ofst
+((22+8)*4), 
n
);

18215 
rc
 = 0;

18219 if( 
rc
==0 )

18222 
p
->
exclMask
 &= ~
mask
;

18223 
p
->
sharedMask
 &= ~
mask
;

18225 }else if( 
flags
 & 4 )

18228 
u16
 
allShared
 = 0;

18234 for(
pX
=
pShmNode
->
pFirst
; pX; pX=pX->
pNext
)

18237 if( (
pX
->
exclMask
 & 
mask
)!=0 )

18240 
rc
 = 5;

18243 
allShared
 |= 
pX
->
sharedMask
;

18247 if( 
rc
==0 )

18250 if( (
allShared
 & 
mask
)==0 )

18253 
rc
 = 
	`unixShmSystemLock
(
pDbFd
, 0, 
ofst
+((22+8)*4), 
n
);

18255 
rc
 = 0;

18260 if( 
rc
==0 )

18263 
p
->
sharedMask
 |= 
mask
;

18269 for(
pX
=
pShmNode
->
pFirst
; pX; pX=pX->
pNext
)

18272 if( (
pX
->
exclMask
 & 
mask
)!=0 || (pX->
sharedMask
 & mask)!=0 )

18275 
rc
 = 5;

18283 if( 
rc
==0 )

18286 
rc
 = 
	`unixShmSystemLock
(
pDbFd
, 1, 
ofst
+((22+8)*4), 
n
);

18287 if( 
rc
==0 )

18291 
p
->
exclMask
 |= 
mask
;

18295 
	`sqlite3_mutex_leave
(
pShmNode
->
mutex
);

18298 return 
rc
;

18299 
	}
}

18307 static void 
	$unixShmBarrier
(

18308 
sqlite3_file
 *
fd


18312 (void)(
fd
);

18313 
	`sqlite3MemoryBarrier
();

18314 
	`unixEnterMutex
();

18315 
	`unixLeaveMutex
();

18316 
	}
}

18318 static int 
	$unixShmUnmap
(

18319 
sqlite3_file
 *
fd
,

18320 int 
deleteFlag


18324 
unixShm
 *
p
;

18325 
unixShmNode
 *
pShmNode
;

18326 
unixShm
 **
pp
;

18327 
unixFile
 *
pDbFd
;

18329 
pDbFd
 = (
unixFile
*)
fd
;

18330 
p
 = 
pDbFd
->
pShm
;

18331 if( 
p
==0 ) return 0;

18332 
pShmNode
 = 
p
->pShmNode;

18339 
	`sqlite3_mutex_enter
(
pShmNode
->
mutex
);

18340 for(
pp
=&
pShmNode
->
pFirst
; (*pp)!=
p
; pp = &(*pp)->
pNext
)

18343 *
pp
 = 
p
->
pNext
;

18346 
	`sqlite3_free
(
p
);

18347 
pDbFd
->
pShm
 = 0;

18348 
	`sqlite3_mutex_leave
(
pShmNode
->
mutex
);

18352 
	`unixEnterMutex
();

18354 
pShmNode
->
nRef
--;

18355 if( 
pShmNode
->
nRef
==0 )

18358 if( 
deleteFlag
 && 
pShmNode
->
h
>=0 )

18361 ((int(*)(const char*))
aSyscall
[16].
pCurrent
)(
pShmNode
->
zFilename
);

18363 
	`unixShmPurge
(
pDbFd
);

18365 
	`unixLeaveMutex
();

18368 
	}
}

18370 static void 
	$unixUnmapfile
(
unixFile
 *
pFd
)

18374 if( 
pFd
->
pMapRegion
 )

18377 ((void*(*)(void*,
size_t
))
aSyscall
[23].
pCurrent
)(
pFd
->
pMapRegion
, pFd->
mmapSizeActual
);

18378 
pFd
->
pMapRegion
 = 0;

18379 
pFd
->
mmapSize
 = 0;

18380 
pFd
->
mmapSizeActual
 = 0;

18382 
	}
}

18384 static void 
	$unixRemapfile
(

18385 
unixFile
 *
pFd
,

18386 
i64
 
nNew


18390 const char *
zErr
 = "mmap";

18391 int 
h
 = 
pFd
->h;

18392 
u8
 *
pOrig
 = (u8 *)
pFd
->
pMapRegion
;

18393 
i64
 
nOrig
 = 
pFd
->
mmapSizeActual
;

18394 
u8
 *
pNew
 = 0;

18395 int 
flags
 = 0x1;

18408 if( 
pOrig
 )

18412 
i64
 
nReuse
 = 
pFd
->
mmapSize
;

18417 
u8
 *
pReq
 = &
pOrig
[
nReuse
];

18420 if( 
nReuse
!=
nOrig
 )

18423 ((void*(*)(void*,
size_t
))
aSyscall
[23].
pCurrent
)(
pReq
, 
nOrig
-
nReuse
);

18427 
pNew
 = ((void*(*)(void*,
size_t
,size_t,int,...))
aSyscall
[24].
pCurrent
)(
pOrig
, 
nReuse
, 
nNew
, 1);

18428 
zErr
 = "mremap";

18430 if( 
pNew
==((void *) -1) || pNew==0 )

18433 ((void*(*)(void*,
size_t
))
aSyscall
[23].
pCurrent
)(
pOrig
, 
nReuse
);

18438 if( 
pNew
==0 )

18441 
pNew
 = ((void*(*)(void*,
size_t
,int,int,int,
off_t
))
aSyscall
[22].
pCurrent
)(0, 
nNew
, 
flags
, 0x01, 
h
, 0);

18444 if( 
pNew
==((void *) -1) )

18447 
pNew
 = 0;

18448 
nNew
 = 0;

18449 
	`unixLogErrorAtLine
(0,
zErr
,
pFd
->
zPath
,32299);

18454 
pFd
->
mmapSizeMax
 = 0;

18456 
pFd
->
pMapRegion
 = (void *)
pNew
;

18457 
pFd
->
mmapSize
 = pFd->
mmapSizeActual
 = 
nNew
;

18458 
	}
}

18460 static int 
	$unixMapfile
(
unixFile
 *
pFd
, 
i64
 
nMap
)

18465 if( 
pFd
->
nFetchOut
>0 ) return 0;

18467 if( 
nMap
<0 )

18470 struct 
stat
 
statbuf
;

18471 if( ((int(*)(int,struct 
stat
*))
aSyscall
[5].
pCurrent
)(
pFd
->
h
, &
statbuf
) )

18476 
nMap
 = 
statbuf
.
st_size
;

18478 if( 
nMap
>
pFd
->
mmapSizeMax
 )

18481 
nMap
 = 
pFd
->
mmapSizeMax
;

18485 if( 
nMap
!=
pFd
->
mmapSize
 )

18488 
	`unixRemapfile
(
pFd
, 
nMap
);

18492 
	}
}

18494 static int 
	$unixFetch
(
sqlite3_file
 *
fd
, 
i64
 
iOff
, int 
nAmt
, void **
pp
)

18498 
unixFile
 *
pFd
 = (unixFile *)
fd
;

18500 *
pp
 = 0;

18503 if( 
pFd
->
mmapSizeMax
>0 )

18506 if( 
pFd
->
pMapRegion
==0 )

18509 int 
rc
 = 
	`unixMapfile
(
pFd
, -1);

18510 if( 
rc
!=0 ) return rc;

18512 if( 
pFd
->
mmapSize
 >= 
iOff
+
nAmt
 )

18515 *
pp
 = &((
u8
 *)
pFd
->
pMapRegion
)[
iOff
];

18516 
pFd
->
nFetchOut
++;

18521 
	}
}

18523 static int 
	$unixUnfetch
(
sqlite3_file
 *
fd
, 
i64
 
iOff
, void *
p
)

18527 
unixFile
 *
pFd
 = (unixFile *)
fd
;

18528 (void)(
iOff
);

18538 if( 
p
 )

18541 
pFd
->
nFetchOut
--;

18543 
	`unixUnmapfile
(
pFd
);

18553 
	}
}

18555 static const 
sqlite3_io_methods
 
	gposixIoMethods
 = { 3, 
unixClose
, 
unixRead
, 
unixWrite
, 
unixTruncate
, 
unixSync
, 
unixFileSize
, 
unixLock
, 
unixUnlock
, 
unixCheckReservedLock
, 
unixFileControl
, 
unixSectorSize
, 
unixDeviceCharacteristics
, 
unixShmMap
, 
unixShmLock
, 
unixShmBarrier
, 
unixShmUnmap
, 
unixFetch
, 
unixUnfetch
, }; static const sqlite3_io_methods *
	$posixIoFinderImpl
(const char *
z
, 
unixFile
 *
p
)

18557 (void)(
z
); (void)(
p
); return &
posixIoMethods
; 
	}
} static const 
	gsqlite3_io_methods
 *(*const 
	gposixIoFinder
)(const char*,
unixFile
 *
	gp
) = 
posixIoFinderImpl
;

18559 static const 
sqlite3_io_methods
 
	gnolockIoMethods
 = { 3, 
nolockClose
, 
unixRead
, 
unixWrite
, 
unixTruncate
, 
unixSync
, 
unixFileSize
, 
nolockLock
, 
nolockUnlock
, 
nolockCheckReservedLock
, 
unixFileControl
, 
unixSectorSize
, 
unixDeviceCharacteristics
, 0, 
unixShmLock
, 
unixShmBarrier
, 
unixShmUnmap
, 
unixFetch
, 
unixUnfetch
, }; static const sqlite3_io_methods *
	$nolockIoFinderImpl
(const char *
z
, 
unixFile
 *
p
)

18561 (void)(
z
); (void)(
p
); return &
nolockIoMethods
; 
	}
} static const 
	gsqlite3_io_methods
 *(*const 
	gnolockIoFinder
)(const char*,
unixFile
 *
	gp
) = 
nolockIoFinderImpl
;

18563 static const 
sqlite3_io_methods
 
	gdotlockIoMethods
 = { 1, 
dotlockClose
, 
unixRead
, 
unixWrite
, 
unixTruncate
, 
unixSync
, 
unixFileSize
, 
dotlockLock
, 
dotlockUnlock
, 
dotlockCheckReservedLock
, 
unixFileControl
, 
unixSectorSize
, 
unixDeviceCharacteristics
, 0, 
unixShmLock
, 
unixShmBarrier
, 
unixShmUnmap
, 
unixFetch
, 
unixUnfetch
, }; static const sqlite3_io_methods *
	$dotlockIoFinderImpl
(const char *
z
, 
unixFile
 *
p
)

18565 (void)(
z
); (void)(
p
); return &
dotlockIoMethods
; 
	}
} static const 
	gsqlite3_io_methods
 *(*const 
	gdotlockIoFinder
)(const char*,
unixFile
 *
	gp
) = 
dotlockIoFinderImpl
;

18567 typedef const 
	tsqlite3_io_methods
 *(*
	tfinder_type
)(const char*,
	tunixFile
*);

18569 static int 
	$fillInUnixFile
(

18570 
sqlite3_vfs
 *
pVfs
,

18571 int 
h
,

18572 
sqlite3_file
 *
pId
,

18573 const char *
zFilename
,

18574 int 
ctrlFlags


18578 const 
sqlite3_io_methods
 *
pLockingStyle
;

18579 
unixFile
 *
pNew
 = (unixFile *)
pId
;

18580 int 
rc
 = 0;

18591 
pNew
->
h
 = h;

18592 
pNew
->
pVfs
 = pVfs;

18593 
pNew
->
zPath
 = 
zFilename
;

18594 
pNew
->
ctrlFlags
 = (
u8
)ctrlFlags;

18596 
pNew
->
mmapSizeMax
 = 
sqlite3Config
.
szMmap
;

18598 if( 
	`sqlite3_uri_boolean
(((
ctrlFlags
 & 0x40) ? 
zFilename
 : 0),

18602 
pNew
->
ctrlFlags
 |= 0x10;

18604 if( 
	`strcmp
(
pVfs
->
zName
,"unix-excl")==0 )

18607 
pNew
->
ctrlFlags
 |= 0x01;

18610 if( 
ctrlFlags
 & 0x80 )

18613 
pLockingStyle
 = &
nolockIoMethods
;

18615 
pLockingStyle
 = (**(
finder_type
*)
pVfs
->
pAppData
)(
zFilename
, 
pNew
);

18624 if( 
pLockingStyle
 == &
posixIoMethods


18631 
	`unixEnterMutex
();

18632 
rc
 = 
	`findInodeInfo
(
pNew
, &pNew->
pInode
);

18633 if( 
rc
!=0 )

18637 
	`robust_close
(
pNew
, 
h
, 32813);

18638 
h
 = -1;

18640 
	`unixLeaveMutex
();

18643 else if( 
pLockingStyle
 == &
dotlockIoMethods
 )

18649 char *
zLockFile
;

18650 int 
nFilename
;

18652 
nFilename
 = (int)
	`strlen
(
zFilename
) + 6;

18653 
zLockFile
 = (char *)
	`sqlite3_malloc64
(
nFilename
);

18654 if( 
zLockFile
==0 )

18657 
rc
 = 7;

18659 
	`sqlite3_snprintf
(
nFilename
, 
zLockFile
, "%s" ".lock", 
zFilename
);

18661 
pNew
->
lockingContext
 = 
zLockFile
;

18664 
	`storeLastErrno
(
pNew
, 0);

18666 if( 
rc
!=0 )

18669 if( 
h
>=0 ) 
	`robust_close
(
pNew
, h, 32898);

18671 
pNew
->
pMethod
 = 
pLockingStyle
;

18673 
	`verifyDbFile
(
pNew
);

18675 return 
rc
;

18676 
	}
}

18682 static const char *
	$unixTempFileDir
(void)

18685 static const char *
azDirs
[] = {

18693 unsigned int 
i
;

18694 struct 
stat
 
buf
;

18695 const char *
zDir
 = 
sqlite3_temp_directory
;

18697 if( !
azDirs
[0] ) azDirs[0] = 
	`getenv
("SQLITE_TMPDIR");

18698 if( !
azDirs
[1] ) azDirs[1] = 
	`getenv
("TMPDIR");

18699 for(
i
=0; i<sizeof(
azDirs
)/sizeof(azDirs[0]); 
zDir
=azDirs[i++])

18702 if( 
zDir
==0 ) continue;

18703 if( ((int(*)(const char*,struct 
stat
*))
aSyscall
[4].
pCurrent
)(
zDir
, &
buf
) ) continue;

18704 if( !((((
buf
.
st_mode
)) & 0170000) == (0040000)) ) continue;

18705 if( ((int(*)(const char*,int))
aSyscall
[2].
pCurrent
)(
zDir
, 07) ) continue;

18708 return 
zDir
;

18709 
	}
}

18716 static int 
	$unixGetTempname
(int 
nBuf
, char *
zBuf
)

18719 const char *
zDir
;

18720 int 
iLimit
 = 0;

18728 
zDir
 = 
	`unixTempFileDir
();

18730 
u64
 
r
;

18731 
	`sqlite3_randomness
(sizeof(
r
), &r);

18733 
zBuf
[
nBuf
-2] = 0;

18734 
	`sqlite3_snprintf
(
nBuf
, 
zBuf
, "%s/""etilqs_""%llx%c",

18735 
zDir
, 
r
, 0);

18736 if( 
zBuf
[
nBuf
-2]!=0 || (
iLimit
++)>10 ) return 1;

18737 }while( ((int(*)(const char*,int))
aSyscall
[2].
pCurrent
)(
zBuf
,0)==0 );

18739 
	}
}

18741 static 
UnixUnusedFd
 *
	$findReusableFd
(const char *
zPath
, int 
flags
)

18744 
UnixUnusedFd
 *
pUnused
 = 0;

18752 struct 
stat
 
sStat
;

18754 if( 0==((int(*)(const char*,struct 
stat
*))
aSyscall
[4].
pCurrent
)(
zPath
, &
sStat
) )

18757 
unixInodeInfo
 *
pInode
;

18759 
	`unixEnterMutex
();

18760 
pInode
 = 
inodeList
;

18761 while( 
pInode
 && (pInode->
fileId
.
dev
!=
sStat
.
st_dev


18762 || 
pInode
->
fileId
.
ino
!=
sStat
.
st_ino
) )

18765 
pInode
 = pInode->
pNext
;

18767 if( 
pInode
 )

18770 
UnixUnusedFd
 **
pp
;

18771 for(
pp
=&
pInode
->
pUnused
; *pp && (*pp)->
flags
!=flags; pp=&((*pp)->
pNext
));

18772 
pUnused
 = *
pp
;

18773 if( 
pUnused
 )

18776 *
pp
 = 
pUnused
->
pNext
;

18779 
	`unixLeaveMutex
();

18782 return 
pUnused
;

18783 
	}
}

18785 static int 
	$findCreateFileMode
(

18786 const char *
zPath
,

18787 int 
flags
,

18788 
mode_t
 *
pMode
,

18789 
uid_t
 *
pUid
,

18790 
gid_t
 *
pGid


18794 int 
rc
 = 0;

18795 *
pMode
 = 0;

18796 *
pUid
 = 0;

18797 *
pGid
 = 0;

18798 if( 
flags
 & (0x00080000|0x00000800) )

18801 char 
zDb
[512 +1];

18802 int 
nDb
;

18803 struct 
stat
 
sStat
;

18805 
nDb
 = 
	`sqlite3Strlen30
(
zPath
) - 1;

18806 while( 
zPath
[
nDb
]!='-' )

18819 
nDb
--;

18821 
	`memcpy
(
zDb
, 
zPath
, 
nDb
);

18822 
zDb
[
nDb
] = '\0';

18824 if( 0==((int(*)(const char*,struct 
stat
*))
aSyscall
[4].
pCurrent
)(
zDb
, &
sStat
) )

18827 *
pMode
 = 
sStat
.
st_mode
 & 0777;

18828 *
pUid
 = 
sStat
.
st_uid
;

18829 *
pGid
 = 
sStat
.
st_gid
;

18831 
rc
 = (10 | (7<<8));

18833 }else if( 
flags
 & 0x00000008 )

18836 *
pMode
 = 0600;

18838 return 
rc
;

18839 
	}
}

18841 static int 
	$unixOpen
(

18842 
sqlite3_vfs
 *
pVfs
,

18843 const char *
zPath
,

18844 
sqlite3_file
 *
pFile
,

18845 int 
flags
,

18846 int *
pOutFlags


18850 
unixFile
 *
p
 = (unixFile *)
pFile
;

18851 int 
fd
 = -1;

18852 int 
openFlags
 = 0;

18853 int 
eType
 = 
flags
&0xFFFFFF00;

18854 int 
noLock
;

18855 int 
rc
 = 0;

18856 int 
ctrlFlags
 = 0;

18858 int 
isExclusive
 = (
flags
 & 0x00000010);

18859 int 
isDelete
 = (
flags
 & 0x00000008);

18860 int 
isCreate
 = (
flags
 & 0x00000004);

18861 int 
isReadonly
 = (
flags
 & 0x00000001);

18862 int 
isReadWrite
 = (
flags
 & 0x00000002);

18864 int 
syncDir
 = (
isCreate
 && (

18865 
eType
==0x00004000

18866 || 
eType
==0x00000800

18867 || 
eType
==0x00080000

18873 char 
zTmpname
[512 +2];

18874 const char *
zName
 = 
zPath
;

18900 if( 
randomnessPid
!=(
pid_t
)
	`getpid
() )

18903 
randomnessPid
 = (
pid_t
)
	`getpid
();

18904 
	`sqlite3_randomness
(0,0);

18907 
	`memset
(
p
, 0, sizeof(
unixFile
));

18909 if( 
eType
==0x00000100 )

18912 
UnixUnusedFd
 *
pUnused
;

18913 
pUnused
 = 
	`findReusableFd
(
zName
, 
flags
);

18914 if( 
pUnused
 )

18917 
fd
 = 
pUnused
->fd;

18919 
pUnused
 = 
	`sqlite3_malloc64
(sizeof(*pUnused));

18920 if( !
pUnused
 )

18926 
p
->
pUnused
 = pUnused;

18933 }else if( !
zName
 )

18938 
rc
 = 
	`unixGetTempname
(
pVfs
->
mxPathname
, 
zTmpname
);

18939 if( 
rc
!=0 )

18942 return 
rc
;

18944 
zName
 = 
zTmpname
;

18955 if( 
isReadonly
 ) 
openFlags
 |= 00;

18956 if( 
isReadWrite
 ) 
openFlags
 |= 02;

18957 if( 
isCreate
 ) 
openFlags
 |= 0100;

18958 if( 
isExclusive
 ) 
openFlags
 |= (0200|0400000);

18959 
openFlags
 |= (0|0);

18961 if( 
fd
<0 )

18964 
mode_t
 
openMode
;

18965 
uid_t
 
uid
;

18966 
gid_t
 
gid
;

18967 
rc
 = 
	`findCreateFileMode
(
zName
, 
flags
, &
openMode
, &
uid
, &
gid
);

18968 if( 
rc
!=0 )

18973 return 
rc
;

18975 
fd
 = 
	`robust_open
(
zName
, 
openFlags
, 
openMode
);

18978 if( 
fd
<0 && (*
	`__errno_location
 ())!=21 && 
isReadWrite
 )

18982 
flags
 &= ~(0x00000002|0x00000004);

18983 
openFlags
 &= ~(02|0100);

18984 
flags
 |= 0x00000001;

18985 
openFlags
 |= 00;

18986 
isReadonly
 = 1;

18987 
fd
 = 
	`robust_open
(
zName
, 
openFlags
, 
openMode
);

18989 if( 
fd
<0 )

18992 
rc
 = 
	`unixLogErrorAtLine
(
	`sqlite3CantopenError
(33278),"open",
zName
,33278);

18993 goto 
open_finished
;

19000 if( 
flags
 & (0x00080000|0x00000800) )

19003 
	`robustFchown
(
fd
, 
uid
, 
gid
);

19007 if( 
pOutFlags
 )

19010 *
pOutFlags
 = 
flags
;

19013 if( 
p
->
pUnused
 )

19016 
p
->
pUnused
->
fd
 = fd;

19017 
p
->
pUnused
->
flags
 = flags;

19020 if( 
isDelete
 )

19024 ((int(*)(const char*))
aSyscall
[16].
pCurrent
)(
zName
);

19028 if( 
isDelete
 ) 
ctrlFlags
 |= 0x20;

19029 if( 
isReadonly
 ) 
ctrlFlags
 |= 0x02;

19030 
noLock
 = 
eType
!=0x00000100;

19031 if( 
noLock
 ) 
ctrlFlags
 |= 0x80;

19032 if( 
syncDir
 ) 
ctrlFlags
 |= 0x08;

19033 if( 
flags
 & 0x00000040 ) 
ctrlFlags
 |= 0x40;

19035 
rc
 = 
	`fillInUnixFile
(
pVfs
, 
fd
, 
pFile
, 
zPath
, 
ctrlFlags
);

19037 
open_finished
:

19038 if( 
rc
!=0 )

19041 
	`sqlite3_free
(
p
->
pUnused
);

19043 return 
rc
;

19044 
	}
}

19051 static int 
	$unixDelete
(

19052 
sqlite3_vfs
 *
NotUsed
,

19053 const char *
zPath
,

19054 int 
dirSync


19058 int 
rc
 = 0;

19059 (void)(
NotUsed
);

19061 if( ((int(*)(const char*))
aSyscall
[16].
pCurrent
)(
zPath
)==(-1) )

19064 if( (*
	`__errno_location
 ())==2

19071 
rc
 = (10 | (23<<8));

19073 
rc
 = 
	`unixLogErrorAtLine
((10 | (10<<8)),"unlink",
zPath
,33404);

19075 return 
rc
;

19078 if( (
dirSync
 & 1)!=0 )

19081 int 
fd
;

19082 
rc
 = ((int(*)(const char*,int*))
aSyscall
[17].
pCurrent
)(
zPath
, &
fd
);

19083 if( 
rc
==0 )

19086 if( 
	`full_fsync
(
fd
,0,0) )

19089 
rc
 = 
	`unixLogErrorAtLine
((10 | (5<<8)),"fsync",
zPath
,33414);

19091 
	`robust_close
(0, 
fd
, 33416);

19094 
rc
 = 0;

19098 return 
rc
;

19099 
	}
}

19101 static int 
	$unixAccess
(

19102 
sqlite3_vfs
 *
NotUsed
,

19103 const char *
zPath
,

19104 int 
flags
,

19105 int *
pResOut


19109 (void)(
NotUsed
);

19117 if( 
flags
==0 )

19120 struct 
stat
 
buf
;

19121 *
pResOut
 = (0==((int(*)(const char*,struct 
stat
*))
aSyscall
[4].
pCurrent
)(
zPath
, &
buf
) && buf.
st_size
>0);

19123 *
pResOut
 = ((int(*)(const char*,int))
aSyscall
[2].
pCurrent
)(
zPath
, 2|4)==0;

19126 
	}
}

19131 static int 
	$mkFullPathname
(

19132 const char *
zPath
,

19133 char *
zOut
,

19134 int 
nOut


19138 int 
nPath
 = 
	`sqlite3Strlen30
(
zPath
);

19139 int 
iOff
 = 0;

19140 if( 
zPath
[0]!='/' )

19143 if( ((char*(*)(char*,
size_t
))
aSyscall
[3].
pCurrent
)(
zOut
, 
nOut
-2)==0 )

19146 return 
	`unixLogErrorAtLine
(
	`sqlite3CantopenError
(33471),"getcwd",
zPath
,33471);

19148 
iOff
 = 
	`sqlite3Strlen30
(
zOut
);

19149 
zOut
[
iOff
++] = '/';

19151 if( (
iOff
+
nPath
+1)>
nOut
 )

19156 
zOut
[
iOff
] = '\0';

19157 return 
	`sqlite3CantopenError
(33480);

19159 
	`sqlite3_snprintf
(
nOut
-
iOff
, &
zOut
[iOff], "%s", 
zPath
);

19161 
	}
}

19163 static int 
	$unixFullPathname
(

19164 
sqlite3_vfs
 *
pVfs
,

19165 const char *
zPath
,

19166 int 
nOut
,

19167 char *
zOut


19174 int 
rc
 = 0;

19175 int 
nByte
;

19176 int 
nLink
 = 1;

19177 const char *
zIn
 = 
zPath
;

19178 char *
zDel
 = 0;

19181 (void)(
pVfs
);

19194 int 
bLink
 = 0;

19195 struct 
stat
 
buf
;

19196 if( ((int(*)(const char*,struct 
stat
*))
aSyscall
[27].
pCurrent
)(
zIn
, &
buf
)!=0 )

19199 if( (*
	`__errno_location
 ())!=2 )

19202 
rc
 = 
	`unixLogErrorAtLine
(
	`sqlite3CantopenError
(33528),"lstat",
zIn
,33528);

19205 
bLink
 = ((((
buf
.
st_mode
)) & 0170000) == (0120000));

19208 if( 
bLink
 )

19211 if( 
zDel
==0 )

19214 
zDel
 = 
	`sqlite3_malloc
(
nOut
);

19215 if( 
zDel
==0 ) 
rc
 = 7;

19216 }else if( ++
nLink
>100 )

19219 
rc
 = 
	`sqlite3CantopenError
(33539);

19222 if( 
rc
==0 )

19225 
nByte
 = ((
	`ssize_t
(*)(const char*,char*,
size_t
))
aSyscall
[26].
pCurrent
)(
zIn
, 
zDel
, 
nOut
-1);

19226 if( 
nByte
<0 )

19229 
rc
 = 
	`unixLogErrorAtLine
(
	`sqlite3CantopenError
(33545),"readlink",
zIn
,33545);

19231 if( 
zDel
[0]!='/' )

19234 int 
n
;

19235 for(
n
 = 
	`sqlite3Strlen30
(
zIn
); n>0 && zIn[n-1]!='/'; n--);

19236 if( 
nByte
+
n
+1>
nOut
 )

19239 
rc
 = 
	`sqlite3CantopenError
(33551);

19241 
	`memmove
(&
zDel
[
n
], zDel, 
nByte
+1);

19242 
	`memcpy
(
zDel
, 
zIn
, 
n
);

19243 
nByte
 += 
n
;

19246 
zDel
[
nByte
] = '\0';

19250 
zIn
 = 
zDel
;

19254 if( 
rc
==0 && 
zIn
!=
zOut
 )

19257 
rc
 = 
	`mkFullPathname
(
zIn
, 
zOut
, 
nOut
);

19259 if( 
bLink
==0 ) break;

19260 
zIn
 = 
zOut
;

19261 }while( 
rc
==0 );

19263 
	`sqlite3_free
(
zDel
);

19264 return 
rc
;

19266 
	}
}

19285 extern void 
	$_dl_mcount_wrapper_check
 (void *
__selfpc
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

19290 typedef long int 
	tLmid_t
;

19302 extern void *
	$dlopen
 (const char *
__file
, int 
__mode
) 
	`__attribute__
 ((
__nothrow__
));

19306 extern int 
	$dlclose
 (void *
__handle
) 
	`__attribute__
 ((
__nothrow__
)) __attribute__ ((
	`__nonnull__
 (1)));

19310 extern void *
	$dlsym
 (void *
__restrict
 
__handle
,

19311 const char *
__restrict
 
__name
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

19315 extern void *
	$dlmopen
 (
Lmid_t
 
__nsid
, const char *
__file
, int 
__mode
) 
	`__attribute__
 ((
__nothrow__
));

19319 extern void *
	$dlvsym
 (void *
__restrict
 
__handle
,

19320 const char *
__restrict
 
__name
,

19321 const char *
__restrict
 
__version
)

19322 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2, 3)));

19328 extern char *
	$dlerror
 (void) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
));

19336 const char *
dli_fname
;

19337 void *
dli_fbase
;

19338 const char *
dli_sname
;

19339 void *
dli_saddr
;

19340 } 
	tDl_info
;

19344 extern int 
	$dladdr
 (const void *
__address
, 
Dl_info
 *
__info
)

19345 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

19348 extern int 
	$dladdr1
 (const void *
__address
, 
Dl_info
 *
__info
,

19349 void **
__extra_info
, int 
__flags
) 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (2)));

19357 
RTLD_DL_SYMENT
 = 1,

19360 
RTLD_DL_LINKMAP
 = 2

19369 extern int 
	$dlinfo
 (void *
__restrict
 
__handle
,

19370 int 
__request
, void *
__restrict
 
__arg
)

19371 
	`__attribute__
 ((
__nothrow__
 , 
__leaf__
)) __attribute__ ((
	`__nonnull__
 (1, 3)));

19377 
RTLD_DI_LMID
 = 1,

19381 
RTLD_DI_LINKMAP
 = 2,

19383 
RTLD_DI_CONFIGADDR
 = 3,

19390 
RTLD_DI_SERINFO
 = 4,

19391 
RTLD_DI_SERINFOSIZE
 = 5,

19395 
RTLD_DI_ORIGIN
 = 6,

19397 
RTLD_DI_PROFILENAME
 = 7,

19398 
RTLD_DI_PROFILEOUT
 = 8,

19403 
RTLD_DI_TLS_MODID
 = 9,

19409 
RTLD_DI_TLS_DATA
 = 10,

19411 
RTLD_DI_MAX
 = 10

19419 char *
dls_name
;

19420 unsigned int 
dls_flags
;

19421 } 
	tDl_serpath
;

19427 
size_t
 
dls_size
;

19428 unsigned int 
dls_cnt
;

19429 
Dl_serpath
 
dls_serpath
[1];

19430 } 
	tDl_serinfo
;

19436 static void *
	$unixDlOpen
(
sqlite3_vfs
 *
NotUsed
, const char *
zFilename
)

19439 (void)(
NotUsed
);

19440 return 
	`dlopen
(
zFilename
, 0x00002 | 0x00100);

19441 
	}
}

19443 static void 
	$unixDlError
(
sqlite3_vfs
 *
NotUsed
, int 
nBuf
, char *
zBufOut
)

19446 const char *
zErr
;

19447 (void)(
NotUsed
);

19448 
	`unixEnterMutex
();

19449 
zErr
 = 
	`dlerror
();

19450 if( 
zErr
 )

19453 
	`sqlite3_snprintf
(
nBuf
, 
zBufOut
, "%s", 
zErr
);

19455 
	`unixLeaveMutex
();

19456 
	}
}

19457 static void (*
	$unixDlSym
(
sqlite3_vfs
 *
NotUsed
, void *
p
, const char*
zSym
))(void)

19461 void (*(*
x
)(void*,const char*))(void);

19462 (void)(
NotUsed
);

19463 
x
 = (void(*(*)(void*,const char*))(void))
dlsym
;

19464 return (*
x
)(
p
, 
zSym
);

19465 
	}
}

19466 static void 
	$unixDlClose
(
sqlite3_vfs
 *
NotUsed
, void *
pHandle
)

19469 (void)(
NotUsed
);

19470 
	`dlclose
(
pHandle
);

19471 
	}
}

19473 static int 
	$unixRandomness
(
sqlite3_vfs
 *
NotUsed
, int 
nBuf
, char *
zBuf
)

19476 (void)(
NotUsed
);

19479 
	`memset
(
zBuf
, 0, 
nBuf
);

19480 
randomnessPid
 = (
pid_t
)
	`getpid
();

19483 int 
fd
, 
got
;

19484 
fd
 = 
	`robust_open
("/dev/urandom", 00, 0);

19485 if( 
fd
<0 )

19488 
time_t
 
t
;

19489 
	`time
(&
t
);

19490 
	`memcpy
(
zBuf
, &
t
, sizeof(t));

19491 
	`memcpy
(&
zBuf
[sizeof(
t
)], &
randomnessPid
, sizeof(randomnessPid));

19493 
nBuf
 = sizeof(
t
) + sizeof(
randomnessPid
);

19495 do{ 
got
 = ((
	`ssize_t
(*)(int,void*,
size_t
))
aSyscall
[8].
pCurrent
)(
fd
, 
zBuf
, 
nBuf
); }while( got<0 && (*
	`__errno_location
 ())==4 );

19496 
	`robust_close
(0, 
fd
, 33675);

19500 return 
nBuf
;

19501 
	}
}

19503 static int 
	$unixSleep
(
sqlite3_vfs
 *
NotUsed
, int 
microseconds
)

19507 int 
seconds
 = (
microseconds
+999999)/1000000;

19508 
	`sleep
(
seconds
);

19509 (void)(
NotUsed
);

19510 return 
seconds
*1000000;

19512 
	}
}

19514 static int 
	$unixCurrentTimeInt64
(
sqlite3_vfs
 *
NotUsed
, 
sqlite3_int64
 *
piNow
)

19517 static const 
sqlite3_int64
 
unixEpoch
 = 24405875*(sqlite3_int64)8640000;

19518 int 
rc
 = 0;

19520 struct 
timeval
 
sNow
;

19521 (void)
	`gettimeofday
(&
sNow
, 0);

19522 *
piNow
 = 
unixEpoch
 + 1000*(
sqlite3_int64
)
sNow
.
tv_sec
 + sNow.
tv_usec
/1000;

19530 (void)(
NotUsed
);

19531 return 
rc
;

19532 
	}
}

19540 static int 
	$unixCurrentTime
(
sqlite3_vfs
 *
NotUsed
, double *
prNow
)

19543 
sqlite3_int64
 
i
 = 0;

19544 int 
rc
;

19545 (void)(
NotUsed
);

19546 
rc
 = 
	`unixCurrentTimeInt64
(0, &
i
);

19547 *
prNow
 = 
i
/86400000.0;

19548 return 
rc
;

19549 
	}
}

19551 static int 
	$unixGetLastError
(
sqlite3_vfs
 *
NotUsed
, int 
NotUsed2
, char *
NotUsed3
)

19554 (void)(
NotUsed
);

19555 (void)(
NotUsed2
);

19556 (void)(
NotUsed3
);

19557 return (*
	`__errno_location
 ());

19558 
	}
}

19560 int 
	$sqlite3_os_init
(void)

19564 static 
sqlite3_vfs
 
aVfs
[] = {

19570 { 3, sizeof(
unixFile
), 512, 0, "unix", (void*)&
posixIoFinder
, 
unixOpen
, 
unixDelete
, 
unixAccess
, 
unixFullPathname
, 
unixDlOpen
, 
unixDlError
, 
unixDlSym
, 
unixDlClose
, 
unixRandomness
, 
unixSleep
, 
unixCurrentTime
, 
unixGetLastError
, 
unixCurrentTimeInt64
, 
unixSetSystemCall
, 
unixGetSystemCall
, 
unixNextSystemCall
, },

19572 { 3, sizeof(
unixFile
), 512, 0, "unix-none", (void*)&
nolockIoFinder
, 
unixOpen
, 
unixDelete
, 
unixAccess
, 
unixFullPathname
, 
unixDlOpen
, 
unixDlError
, 
unixDlSym
, 
unixDlClose
, 
unixRandomness
, 
unixSleep
, 
unixCurrentTime
, 
unixGetLastError
, 
unixCurrentTimeInt64
, 
unixSetSystemCall
, 
unixGetSystemCall
, 
unixNextSystemCall
, },

19573 { 3, sizeof(
unixFile
), 512, 0, "unix-dotfile", (void*)&
dotlockIoFinder
, 
unixOpen
, 
unixDelete
, 
unixAccess
, 
unixFullPathname
, 
unixDlOpen
, 
unixDlError
, 
unixDlSym
, 
unixDlClose
, 
unixRandomness
, 
unixSleep
, 
unixCurrentTime
, 
unixGetLastError
, 
unixCurrentTimeInt64
, 
unixSetSystemCall
, 
unixGetSystemCall
, 
unixNextSystemCall
, },

19574 { 3, sizeof(
unixFile
), 512, 0, "unix-excl", (void*)&
posixIoFinder
, 
unixOpen
, 
unixDelete
, 
unixAccess
, 
unixFullPathname
, 
unixDlOpen
, 
unixDlError
, 
unixDlSym
, 
unixDlClose
, 
unixRandomness
, 
unixSleep
, 
unixCurrentTime
, 
unixGetLastError
, 
unixCurrentTimeInt64
, 
unixSetSystemCall
, 
unixGetSystemCall
, 
unixNextSystemCall
, },

19577 unsigned int 
i
;

19584 for(
i
=0; i<(sizeof(
aVfs
)/sizeof(
sqlite3_vfs
)); i++)

19587 
	`sqlite3_vfs_register
(&
aVfs
[
i
], i==0);

19590 
	}
}

19592 int 
	$sqlite3_os_end
(void)

19596 
	}
}

19598 struct 
	sBitvec
 {

19599 
u32
 
	miSize
;

19600 
u32
 
	mnSet
;

19603 
u32
 
	miDivisor
;

19608 
u8
 
	maBitmap
[((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u8))];

19609 
u32
 
	maHash
[((((512 -(3*sizeof(u32)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32))];

19610 
Bitvec
 *
	mapSub
[((((512 -(3*sizeof(
u32
)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *))];

19611 } 
	mu
;

19619 static 
Bitvec
 *
	$sqlite3BitvecCreate
(
u32
 
iSize
)

19622 
Bitvec
 *
p
;

19624 
p
 = 
	`sqlite3MallocZero
( sizeof(*p) );

19625 if( 
p
 )

19628 
p
->
iSize
 = iSize;

19630 return 
p
;

19631 
	}
}

19638 static int 
	$sqlite3BitvecTestNotNull
(
Bitvec
 *
p
, 
u32
 
i
)

19642 
i
--;

19643 if( 
i
>=
p
->
iSize
 ) return 0;

19644 while( 
p
->
iDivisor
 )

19647 
u32
 
bin
 = 
i
/
p
->
iDivisor
;

19648 
i
 = i%
p
->
iDivisor
;

19649 
p
 = p->
u
.
apSub
[
bin
];

19650 if (!
p
) {

19654 if( 
p
->
iSize
<=(((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(
u8
))*8) )

19657 return (
p
->
u
.
aBitmap
[
i
/8] & (1<<(i&(8 -1))))!=0;

19659 
u32
 
h
 = (((
i
++)*1)%((((512 -(3*sizeof(u32)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32)));

19660 while( 
p
->
u
.
aHash
[
h
] )

19663 if( 
p
->
u
.
aHash
[
h
]==
i
 ) return 1;

19664 
h
 = (h+1) % ((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32));

19668 
	}
}

19669 static int 
	$sqlite3BitvecTest
(
Bitvec
 *
p
, 
u32
 
i
)

19672 return 
p
!=0 && 
	`sqlite3BitvecTestNotNull
(p,
i
);

19673 
	}
}

19675 static int 
	$sqlite3BitvecSet
(
Bitvec
 *
p
, 
u32
 
i
)

19678 
u32
 
h
;

19679 if( 
p
==0 ) return 0;

19682 
i
--;

19683 while((
p
->
iSize
 > (((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(
u8
))*8)) && p->
iDivisor
) {

19684 
u32
 
bin
 = 
i
/
p
->
iDivisor
;

19685 
i
 = i%
p
->
iDivisor
;

19686 if( 
p
->
u
.
apSub
[
bin
]==0 )

19689 
p
->
u
.
apSub
[
bin
] = 
	`sqlite3BitvecCreate
( p->
iDivisor
 );

19690 if( 
p
->
u
.
apSub
[
bin
]==0 ) return 7;

19692 
p
 = p->
u
.
apSub
[
bin
];

19694 if( 
p
->
iSize
<=(((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(
u8
))*8) )

19697 
p
->
u
.
aBitmap
[
i
/8] |= 1 << (i&(8 -1));

19700 
h
 = (((
i
++)*1)%((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32)));

19704 if( !
p
->
u
.
aHash
[
h
] )

19707 if (
p
->
nSet
<(((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32))-1)) {

19708 goto 
bitvec_set_end
;

19710 goto 
bitvec_set_rehash
;

19716 if( 
p
->
u
.
aHash
[
h
]==
i
 ) return 0;

19717 
h
++;

19718 if( 
h
>=((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;

19719 } while( 
p
->
u
.
aHash
[
h
] );

19723 
bitvec_set_rehash
:

19724 if( 
p
->
nSet
>=(((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32))/2) )

19727 unsigned int 
j
;

19728 int 
rc
;

19729 
u32
 *
aiValues
 = 
	`sqlite3DbMallocRaw
(0,sizeof(
p
->
u
.
aHash
));

19730 if( 
aiValues
==0 )

19735 
	`memcpy
(
aiValues
, 
p
->
u
.
aHash
, sizeof(p->u.aHash));

19736 
	`memset
(
p
->
u
.
apSub
, 0, sizeof(p->u.apSub));

19737 
p
->
iDivisor
 = (p->
iSize
 + ((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(Bitvec *)) - 1)/((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *));

19738 
rc
 = 
	`sqlite3BitvecSet
(
p
, 
i
);

19739 for(
j
=0; j<((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32)); j++)

19742 if( 
aiValues
[
j
] ) 
rc
 |= 
	`sqlite3BitvecSet
(
p
, aiValues[j]);

19744 
	`sqlite3DbFree
(0,
aiValues
);

19745 return 
rc
;

19748 
bitvec_set_end
:

19749 
p
->
nSet
++;

19750 
p
->
u
.
aHash
[
h
] = 
i
;

19752 
	}
}

19760 static void 
	$sqlite3BitvecClear
(
Bitvec
 *
p
, 
u32
 
i
, void *
pBuf
)

19763 if( 
p
==0 ) return;

19765 
i
--;

19766 while( 
p
->
iDivisor
 )

19769 
u32
 
bin
 = 
i
/
p
->
iDivisor
;

19770 
i
 = i%
p
->
iDivisor
;

19771 
p
 = p->
u
.
apSub
[
bin
];

19772 if (!
p
) {

19776 if( 
p
->
iSize
<=(((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(
u8
))*8) )

19779 
p
->
u
.
aBitmap
[
i
/8] &= ~(1 << (i&(8 -1)));

19781 unsigned int 
j
;

19782 
u32
 *
aiValues
 = 
pBuf
;

19783 
	`memcpy
(
aiValues
, 
p
->
u
.
aHash
, sizeof(p->u.aHash));

19784 
	`memset
(
p
->
u
.
aHash
, 0, sizeof(p->u.aHash));

19785 
p
->
nSet
 = 0;

19786 for(
j
=0; j<((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32)); j++)

19789 if( 
aiValues
[
j
] && aiValues[j]!=(
i
+1) )

19792 
u32
 
h
 = (((
aiValues
[
j
]-1)*1)%((((512 -(3*sizeof(u32)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32)));

19793 
p
->
nSet
++;

19794 while( 
p
->
u
.
aHash
[
h
] )

19797 
h
++;

19798 if( 
h
>=((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;

19800 
p
->
u
.
aHash
[
h
] = 
aiValues
[
j
];

19804 
	}
}

19809 static void 
	$sqlite3BitvecDestroy
(
Bitvec
 *
p
)

19812 if( 
p
==0 ) return;

19813 if( 
p
->
iDivisor
 )

19816 unsigned int 
i
;

19817 for(
i
=0; i<((((512 -(3*sizeof(
u32
)))/sizeof(
Bitvec
*))*sizeof(Bitvec*))/sizeof(Bitvec *)); i++)

19820 
	`sqlite3BitvecDestroy
(
p
->
u
.
apSub
[
i
]);

19823 
	`sqlite3_free
(
p
);

19824 
	}
}

19830 static 
u32
 
	$sqlite3BitvecSize
(
Bitvec
 *
p
)

19833 return 
p
->
iSize
;

19834 
	}
}

19836 static int 
	$sqlite3BitvecBuiltinTest
(int 
sz
, int *
aOp
)

19839 
Bitvec
 *
pBitvec
 = 0;

19840 unsigned char *
pV
 = 0;

19841 int 
rc
 = -1;

19842 int 
i
, 
nx
, 
pc
, 
op
;

19843 void *
pTmpSpace
;

19847 
pBitvec
 = 
	`sqlite3BitvecCreate
( 
sz
 );

19848 
pV
 = 
	`sqlite3MallocZero
( (
sz
+7)/8 + 1 );

19849 
pTmpSpace
 = 
	`sqlite3_malloc64
(512);

19850 if( 
pBitvec
==0 || 
pV
==0 || 
pTmpSpace
==0 ) goto 
bitvec_end
;

19853 
	`sqlite3BitvecSet
(0, 1);

19854 
	`sqlite3BitvecClear
(0, 1, 
pTmpSpace
);

19857 
pc
 = 0;

19858 while( (
op
 = 
aOp
[
pc
])!=0 )

19861 switch( 
op
 )

19867 
nx
 = 4;

19868 
i
 = 
aOp
[
pc
+2] - 1;

19869 
aOp
[
pc
+2] += aOp[pc+3];

19875 
nx
 = 2;

19876 
	`sqlite3_randomness
(sizeof(
i
), &i);

19880 if( (--
aOp
[
pc
+1]) > 0 ) 
nx
 = 0;

19881 
pc
 += 
nx
;

19882 
i
 = (i & 0x7fffffff)%
sz
;

19883 if( (
op
 & 1)!=0 )

19886 
pV
[(
i
+1)>>3] |= (1<<((i+1)&7));

19887 if( 
op
!=5 )

19890 if( 
	`sqlite3BitvecSet
(
pBitvec
, 
i
+1) ) goto 
bitvec_end
;

19893 
pV
[(
i
+1)>>3] &= ~(1<<((i+1)&7));

19894 
	`sqlite3BitvecClear
(
pBitvec
, 
i
+1, 
pTmpSpace
);

19903 
rc
 = 
	`sqlite3BitvecTest
(0,0) + sqlite3BitvecTest(
pBitvec
, 
sz
+1)

19904 + 
	`sqlite3BitvecTest
(
pBitvec
, 0)

19905 + (
	`sqlite3BitvecSize
(
pBitvec
) - 
sz
);

19906 for(
i
=1; i<=
sz
; i++)

19909 if( ((
pV
[
i
>>3]&(1<<(i&7)))!=0)!=
	`sqlite3BitvecTest
(
pBitvec
,i) )

19912 
rc
 = 
i
;

19918 
bitvec_end
:

19919 
	`sqlite3_free
(
pTmpSpace
);

19920 
	`sqlite3_free
(
pV
);

19921 
	`sqlite3BitvecDestroy
(
pBitvec
);

19922 return 
rc
;

19923 
	}
}

19925 struct 
	sPCache
 {

19926 
PgHdr
 *
	mpDirty
, *
	mpDirtyTail
;

19927 
PgHdr
 *
	mpSynced
;

19928 int 
	mnRefSum
;

19929 int 
	mszCache
;

19930 int 
	mszSpill
;

19931 int 
	mszPage
;

19932 int 
	mszExtra
;

19933 
u8
 
	mbPurgeable
;

19934 
u8
 
	meCreate
;

19935 int (*
	mxStress
)(void*,
	mPgHdr
*);

19936 void *
	mpStress
;

19937 
sqlite3_pcache
 *
	mpCache
;

19940 static void 
	$pcacheManageDirtyList
(
PgHdr
 *
pPage
, 
u8
 
addRemove
)

19943 
PCache
 *
p
 = 
pPage
->
pCache
;

19945 if( 
addRemove
 & 1 )

19952 if( 
p
->
pSynced
==
pPage
 )

19955 
PgHdr
 *
pSynced
 = 
pPage
->
pDirtyPrev
;

19956 while( 
pSynced
 && (pSynced->
flags
&0x008) )

19959 
pSynced
 = pSynced->
pDirtyPrev
;

19961 
p
->
pSynced
 = pSynced;

19964 if( 
pPage
->
pDirtyNext
 )

19967 
pPage
->
pDirtyNext
->
pDirtyPrev
 = pPage->pDirtyPrev;

19970 
p
->
pDirtyTail
 = 
pPage
->
pDirtyPrev
;

19972 if( 
pPage
->
pDirtyPrev
 )

19975 
pPage
->
pDirtyPrev
->
pDirtyNext
 = pPage->pDirtyNext;

19978 
p
->
pDirty
 = 
pPage
->
pDirtyNext
;

19979 if( 
p
->
pDirty
==0 && p->
bPurgeable
 )

19983 
p
->
eCreate
 = 2;

19986 
pPage
->
pDirtyNext
 = 0;

19987 
pPage
->
pDirtyPrev
 = 0;

19989 if( 
addRemove
 & 2 )

19994 
pPage
->
pDirtyNext
 = 
p
->
pDirty
;

19995 if( 
pPage
->
pDirtyNext
 )

19999 
pPage
->
pDirtyNext
->
pDirtyPrev
 = pPage;

20001 
p
->
pDirtyTail
 = 
pPage
;

20002 if( 
p
->
bPurgeable
 )

20006 
p
->
eCreate
 = 1;

20009 
p
->
pDirty
 = 
pPage
;

20010 if( !
p
->
pSynced
 && 0==(
pPage
->
flags
&0x008) )

20013 
p
->
pSynced
 = 
pPage
;

20016 
	}
}

20022 static void 
	$pcacheUnpin
(
PgHdr
 *
p
)

20025 if( 
p
->
pCache
->
bPurgeable
 )

20028 
sqlite3Config
.
pcache2
.
	`xUnpin
(
p
->
pCache
->pCache, p->
pPage
, 0);

20030 
	}
}

20036 static int 
	$numberOfCachePages
(
PCache
 *
p
)

20039 if( 
p
->
szCache
>=0 )

20044 return 
p
->
szCache
;

20049 return (int)((-1024*(
i64
)
p
->
szCache
)/(p->
szPage
+p->
szExtra
));

20051 
	}
}

20058 static int 
	$sqlite3PcacheInitialize
(void)

20061 if( 
sqlite3Config
.
pcache2
.
xInit
==0 )

20067 
	`sqlite3PCacheSetDefault
();

20069 return 
sqlite3Config
.
pcache2
.
	`xInit
(sqlite3Config.pcache2.
pArg
);

20070 
	}
}

20071 static void 
	$sqlite3PcacheShutdown
(void)

20074 if( 
sqlite3Config
.
pcache2
.
xShutdown
 )

20078 
sqlite3Config
.
pcache2
.
	`xShutdown
(sqlite3Config.pcache2.
pArg
);

20080 
	}
}

20085 static int 
	$sqlite3PcacheSize
(void)

20087 return sizeof(
PCache
); 
	}
}

20095 static int 
sqlite3PcacheOpen
(

20096 int 
szPage
,

20097 int 
szExtra
,

20098 int 
bPurgeable
,

20099 int (*
xStress
)(void*,
PgHdr
*),

20100 void *
pStress
,

20101 
PCache
 *
p


20105 
	`memset
(
p
, 0, sizeof(
PCache
));

20106 
p
->
szPage
 = 1;

20107 
p
->
szExtra
 = szExtra;

20108 
p
->
bPurgeable
 = bPurgeable;

20109 
p
->
eCreate
 = 2;

20110 
p
->
xStress
 = xStress;

20111 
p
->
pStress
 = pStress;

20112 
p
->
szCache
 = 100;

20113 
p
->
szSpill
 = 1;

20114 return 
	`sqlite3PcacheSetPageSize
(
p
, 
szPage
);

20115 
	}
}

20121 static int 
	$sqlite3PcacheSetPageSize
(
PCache
 *
pCache
, int 
szPage
)

20125 if( 
pCache
->
szPage
 )

20128 
sqlite3_pcache
 *
pNew
;

20129 
pNew
 = 
sqlite3Config
.
pcache2
.
	`xCreate
(

20130 
szPage
, 
pCache
->
szExtra
 + (((sizeof(
PgHdr
))+7)&~7),

20131 
pCache
->
bPurgeable


20133 if( 
pNew
==0 ) return 7;

20134 
sqlite3Config
.
pcache2
.
	`xCachesize
(
pNew
, 
	`numberOfCachePages
(
pCache
));

20135 if( 
pCache
->pCache )

20138 
sqlite3Config
.
pcache2
.
	`xDestroy
(
pCache
->pCache);

20140 
pCache
->pCache = 
pNew
;

20141 
pCache
->
szPage
 = szPage;

20144 
	}
}

20146 static 
sqlite3_pcache_page
 *
	$sqlite3PcacheFetch
(

20147 
PCache
 *
pCache
,

20148 
Pgno
 
pgno
,

20149 int 
createFlag


20153 int 
eCreate
;

20160 
eCreate
 = 
createFlag
 & 
pCache
->eCreate;

20164 return 
sqlite3Config
.
pcache2
.
	`xFetch
(
pCache
->pCache, 
pgno
, 
eCreate
);

20165 
	}
}

20167 static int 
	$sqlite3PcacheFetchStress
(

20168 
PCache
 *
pCache
,

20169 
Pgno
 
pgno
,

20170 
sqlite3_pcache_page
 **
ppPage


20174 
PgHdr
 *
pPg
;

20175 if( 
pCache
->
eCreate
==2 ) return 0;

20177 if( 
	`sqlite3PcachePagecount
(
pCache
)>pCache->
szSpill
 )

20185 for(
pPg
=
pCache
->
pSynced
;

20186 
pPg
 && (pPg->
nRef
 || (pPg->
flags
&0x008));

20187 
pPg
=pPg->
pDirtyPrev


20189 
pCache
->
pSynced
 = 
pPg
;

20190 if( !
pPg
 )

20193 for(
pPg
=
pCache
->
pDirtyTail
; pPg && pPg->
nRef
; pPg=pPg->
pDirtyPrev
);

20195 if( 
pPg
 )

20198 int 
rc
;

20206 
rc
 = 
pCache
->
	`xStress
(pCache->
pStress
, 
pPg
);

20207 if( 
rc
!=0 && rc!=5 )

20210 return 
rc
;

20214 *
ppPage
 = 
sqlite3Config
.
pcache2
.
	`xFetch
(
pCache
->pCache, 
pgno
, 2);

20215 return *
ppPage
==0 ? 7 : 0;

20216 
	}
}

20218 static 
__attribute__
((
noinline
)) 
PgHdr
 *
	$pcacheFetchFinishWithInit
(

20219 
PCache
 *
pCache
,

20220 
Pgno
 
pgno
,

20221 
sqlite3_pcache_page
 *
pPage


20225 
PgHdr
 *
pPgHdr
;

20227 
pPgHdr
 = (
PgHdr
*)
pPage
->
pExtra
;

20229 
	`memset
(
pPgHdr
, 0, sizeof(
PgHdr
));

20230 
pPgHdr
->
pPage
 = pPage;

20231 
pPgHdr
->
pData
 = 
pPage
->
pBuf
;

20232 
pPgHdr
->
pExtra
 = (void *)&pPgHdr[1];

20233 
	`memset
(
pPgHdr
->
pExtra
, 0, 
pCache
->
szExtra
);

20234 
pPgHdr
->
pCache
 = pCache;

20235 
pPgHdr
->
pgno
 = pgno;

20236 
pPgHdr
->
flags
 = 0x001;

20237 return 
	`sqlite3PcacheFetchFinish
(
pCache
,
pgno
,
pPage
);

20238 
	}
}

20246 static 
PgHdr
 *
	$sqlite3PcacheFetchFinish
(

20247 
PCache
 *
pCache
,

20248 
Pgno
 
pgno
,

20249 
sqlite3_pcache_page
 *
pPage


20253 
PgHdr
 *
pPgHdr
;

20256 
pPgHdr
 = (
PgHdr
 *)
pPage
->
pExtra
;

20258 if( !
pPgHdr
->
pPage
 )

20261 return 
	`pcacheFetchFinishWithInit
(
pCache
, 
pgno
, 
pPage
);

20263 
pCache
->
nRefSum
++;

20264 
pPgHdr
->
nRef
++;

20265 return 
pPgHdr
;

20266 
	}
}

20272 static void 
__attribute__
((
noinline
)) 
	$sqlite3PcacheRelease
(
PgHdr
 *
p
)

20276 
p
->
pCache
->
nRefSum
--;

20277 if( (--
p
->
nRef
)==0 )

20280 if( 
p
->
flags
&0x001 )

20283 
	`pcacheUnpin
(
p
);

20284 }else if( 
p
->
pDirtyPrev
!=0 )

20288 
	`pcacheManageDirtyList
(
p
, 3);

20291 
	}
}

20296 static void 
	$sqlite3PcacheRef
(
PgHdr
 *
p
)

20300 
p
->
nRef
++;

20301 
p
->
pCache
->
nRefSum
++;

20302 
	}
}

20309 static void 
	$sqlite3PcacheDrop
(
PgHdr
 *
p
)

20313 if( 
p
->
flags
&0x002 )

20316 
	`pcacheManageDirtyList
(
p
, 1);

20318 
p
->
pCache
->
nRefSum
--;

20319 
sqlite3Config
.
pcache2
.
	`xUnpin
(
p
->
pCache
->pCache, p->
pPage
, 1);

20320 
	}
}

20326 static void 
	$sqlite3PcacheMakeDirty
(
PgHdr
 *
p
)

20330 if( 
p
->
flags
 & (0x001|0x020) )

20333 
p
->
flags
 &= ~0x020;

20334 if( 
p
->
flags
 & 0x001 )

20337 
p
->
flags
 ^= (0x002|0x001);

20339 
	`pcacheManageDirtyList
(
p
, 2);

20342 
	}
}

20348 static void 
	$sqlite3PcacheMakeClean
(
PgHdr
 *
p
)

20351 if( (
p
->
flags
 & 0x002) )

20355 
	`pcacheManageDirtyList
(
p
, 1);

20356 
p
->
flags
 &= ~(0x002|0x008|0x004);

20357 
p
->
flags
 |= 0x001;

20358 if( 
p
->
nRef
==0 )

20361 
	`pcacheUnpin
(
p
);

20364 
	}
}

20369 static void 
	$sqlite3PcacheCleanAll
(
PCache
 *
pCache
)

20372 
PgHdr
 *
p
;

20373 while( (
p
 = 
pCache
->
pDirty
)!=0 )

20376 
	`sqlite3PcacheMakeClean
(
p
);

20378 
	}
}

20383 static void 
	$sqlite3PcacheClearSyncFlags
(
PCache
 *
pCache
)

20386 
PgHdr
 *
p
;

20387 for(
p
=
pCache
->
pDirty
; p; p=p->
pDirtyNext
)

20390 
p
->
flags
 &= ~0x008;

20392 
pCache
->
pSynced
 = pCache->
pDirtyTail
;

20393 
	}
}

20398 static void 
	$sqlite3PcacheMove
(
PgHdr
 *
p
, 
Pgno
 
newPgno
)

20401 
PCache
 *
pCache
 = 
p
->pCache;

20404 
sqlite3Config
.
pcache2
.
	`xRekey
(
pCache
->pCache, 
p
->
pPage
, p->
pgno
,
newPgno
);

20405 
p
->
pgno
 = 
newPgno
;

20406 if( (
p
->
flags
&0x002) && (p->flags&0x008) )

20409 
	`pcacheManageDirtyList
(
p
, 3);

20411 
	}
}

20413 static void 
	$sqlite3PcacheTruncate
(
PCache
 *
pCache
, 
Pgno
 
pgno
)

20416 if( 
pCache
->pCache )

20419 
PgHdr
 *
p
;

20420 
PgHdr
 *
pNext
;

20421 for(
p
=
pCache
->
pDirty
; p; p=
pNext
)

20424 
pNext
 = 
p
->
pDirtyNext
;

20430 if( (
p
->
pgno
>pgno) )

20434 
	`sqlite3PcacheMakeClean
(
p
);

20437 if( 
pgno
==0 && 
pCache
->
nRefSum
 )

20440 
sqlite3_pcache_page
 *
pPage1
;

20441 
pPage1
 = 
sqlite3Config
.
pcache2
.
	`xFetch
(
pCache
->pCache,1,0);

20442 if( (
pPage1
) )

20446 
	`memset
(
pPage1
->
pBuf
, 0, 
pCache
->
szPage
);

20447 
pgno
 = 1;

20450 
sqlite3Config
.
pcache2
.
	`xTruncate
(
pCache
->pCache, 
pgno
+1);

20452 
	}
}

20457 static void 
	$sqlite3PcacheClose
(
PCache
 *
pCache
)

20461 
sqlite3Config
.
pcache2
.
	`xDestroy
(
pCache
->pCache);

20462 
	}
}

20467 static void 
	$sqlite3PcacheClear
(
PCache
 *
pCache
)

20470 
	`sqlite3PcacheTruncate
(
pCache
, 0);

20471 
	}
}

20477 static 
PgHdr
 *
	$pcacheMergeDirtyList
(
PgHdr
 *
pA
, PgHdr *
pB
)

20480 
PgHdr
 
result
, *
pTail
;

20481 
pTail
 = &
result
;

20482 while( 
pA
 && 
pB
 )

20485 if( 
pA
->
pgno
<
pB
->pgno )

20488 
pTail
->
pDirty
 = 
pA
;

20489 
pTail
 = 
pA
;

20490 
pA
 = pA->
pDirty
;

20492 
pTail
->
pDirty
 = 
pB
;

20493 
pTail
 = 
pB
;

20494 
pB
 = pB->
pDirty
;

20497 if( 
pA
 )

20500 
pTail
->
pDirty
 = 
pA
;

20501 }else if( 
pB
 )

20504 
pTail
->
pDirty
 = 
pB
;

20506 
pTail
->
pDirty
 = 0;

20508 return 
result
.
pDirty
;

20509 
	}
}

20511 static 
PgHdr
 *
	$pcacheSortDirtyList
(
PgHdr
 *
pIn
)

20514 
PgHdr
 *
a
[32], *
p
;

20515 int 
i
;

20516 
	`memset
(
a
, 0, sizeof(a));

20517 while( 
pIn
 )

20520 
p
 = 
pIn
;

20521 
pIn
 = 
p
->
pDirty
;

20522 
p
->
pDirty
 = 0;

20523 for(
i
=0; (i<32 -1); i++)

20526 if( 
a
[
i
]==0 )

20529 
a
[
i
] = 
p
;

20532 
p
 = 
	`pcacheMergeDirtyList
(
a
[
i
], p);

20533 
a
[
i
] = 0;

20536 if( (
i
==32 -1) )

20542 
a
[
i
] = 
	`pcacheMergeDirtyList
(a[i], 
p
);

20545 
p
 = 
a
[0];

20546 for(
i
=1; i<32; i++)

20549 
p
 = 
	`pcacheMergeDirtyList
(p, 
a
[
i
]);

20551 return 
p
;

20552 
	}
}

20557 static 
PgHdr
 *
	$sqlite3PcacheDirtyList
(
PCache
 *
pCache
)

20560 
PgHdr
 *
p
;

20561 for(
p
=
pCache
->
pDirty
; p; p=p->
pDirtyNext
)

20564 
p
->
pDirty
 = p->
pDirtyNext
;

20566 return 
	`pcacheSortDirtyList
(
pCache
->
pDirty
);

20567 
	}
}

20575 static int 
	$sqlite3PcacheRefCount
(
PCache
 *
pCache
)

20578 return 
pCache
->
nRefSum
;

20579 
	}
}

20584 static int 
	$sqlite3PcachePageRefcount
(
PgHdr
 *
p
)

20587 return 
p
->
nRef
;

20588 
	}
}

20593 static int 
	$sqlite3PcachePagecount
(
PCache
 *
pCache
)

20597 return 
sqlite3Config
.
pcache2
.
	`xPagecount
(
pCache
->pCache);

20598 
	}
}

20600 static void 
	$sqlite3PcacheSetCachesize
(
PCache
 *
pCache
, int 
mxPage
)

20604 
pCache
->
szCache
 = 
mxPage
;

20605 
sqlite3Config
.
pcache2
.
	`xCachesize
(
pCache
->pCache,

20606 
	`numberOfCachePages
(
pCache
));

20607 
	}
}

20614 static int 
	$sqlite3PcacheSetSpillsize
(
PCache
 *
p
, int 
mxPage
)

20617 int 
res
;

20619 if( 
mxPage
 )

20622 if( 
mxPage
<0 )

20625 
mxPage
 = (int)((-1024*(
i64
)mxPage)/(
p
->
szPage
+p->
szExtra
));

20627 
p
->
szSpill
 = 
mxPage
;

20629 
res
 = 
	`numberOfCachePages
(
p
);

20630 if( 
res
<
p
->
szSpill
 ) res = p->szSpill;

20631 return 
res
;

20632 
	}
}

20637 static void 
	$sqlite3PcacheShrink
(
PCache
 *
pCache
)

20641 
sqlite3Config
.
pcache2
.
	`xShrink
(
pCache
->pCache);

20642 
	}
}

20648 static int 
	$sqlite3HeaderSizePcache
(void)

20650 return (((sizeof(
PgHdr
))+7)&~7); 
	}
}

20652 typedef struct 
PCache1
 
	tPCache1
;

20653 typedef struct 
PgHdr1
 
	tPgHdr1
;

20654 typedef struct 
PgFreeslot
 
	tPgFreeslot
;

20655 typedef struct 
PGroup
 
	tPGroup
;

20663 struct 
	sPgHdr1
 {

20664 
sqlite3_pcache_page
 
	mpage
;

20665 unsigned int 
	miKey
;

20666 
u8
 
	misPinned
;

20667 
u8
 
	misBulkLocal
;

20668 
u8
 
	misAnchor
;

20669 
PgHdr1
 *
	mpNext
;

20670 
PCache1
 *
	mpCache
;

20671 
PgHdr1
 *
	mpLruNext
;

20672 
PgHdr1
 *
	mpLruPrev
;

20675 struct 
	sPGroup
 {

20676 
sqlite3_mutex
 *
	mmutex
;

20677 unsigned int 
	mnMaxPage
;

20678 unsigned int 
	mnMinPage
;

20679 unsigned int 
	mmxPinned
;

20680 unsigned int 
	mnCurrentPage
;

20681 
PgHdr1
 
	mlru
;

20684 struct 
	sPCache1
 {

20690 
PGroup
 *
	mpGroup
;

20691 int 
	mszPage
;

20692 int 
	mszExtra
;

20693 int 
	mszAlloc
;

20694 int 
	mbPurgeable
;

20695 unsigned int 
	mnMin
;

20696 unsigned int 
	mnMax
;

20697 unsigned int 
	mn90pct
;

20698 unsigned int 
	miMaxKey
;

20703 unsigned int 
	mnRecyclable
;

20704 unsigned int 
	mnPage
;

20705 unsigned int 
	mnHash
;

20706 
PgHdr1
 **
	mapHash
;

20707 
PgHdr1
 *
	mpFree
;

20708 void *
	mpBulk
;

20715 struct 
	sPgFreeslot
 {

20716 
PgFreeslot
 *
	mpNext
;

20722 static struct 
	sPCacheGlobal
 {

20723 
PGroup
 
	mgrp
;

20730 int 
	misInit
;

20731 int 
	mseparateCache
;

20732 int 
	mnInitPage
;

20733 int 
	mszSlot
;

20734 int 
	mnSlot
;

20735 int 
	mnReserve
;

20736 void *
	mpStart
, *
	mpEnd
;

20738 
sqlite3_mutex
 *
	mmutex
;

20739 
PgFreeslot
 *
	mpFree
;

20740 int 
	mnFreeSlot
;

20745 int 
	mbUnderPressure
;

20746 } 
	gpcache1_g
;

20748 static void 
	$sqlite3PCacheBufferSetup
(void *
pBuf
, int 
sz
, int 
n
)

20751 if( (
pcache1_g
).
isInit
 )

20754 
PgFreeslot
 *
p
;

20755 if( 
pBuf
==0 ) 
sz
 = 
n
 = 0;

20756 
sz
 = ((sz)&~7);

20757 (
pcache1_g
).
szSlot
 = 
sz
;

20758 (
pcache1_g
).
nSlot
 = (pcache1_g).
nFreeSlot
 = 
n
;

20759 (
pcache1_g
).
nReserve
 = 
n
>90 ? 10 : (n/10 + 1);

20760 (
pcache1_g
).
pStart
 = 
pBuf
;

20761 (
pcache1_g
).
pFree
 = 0;

20762 (
pcache1_g
).
bUnderPressure
 = 0;

20763 while( 
n
-- )

20766 
p
 = (
PgFreeslot
*)
pBuf
;

20767 
p
->
pNext
 = (
pcache1_g
).
pFree
;

20768 (
pcache1_g
).
pFree
 = 
p
;

20769 
pBuf
 = (void*)&((char*)pBuf)[
sz
];

20771 (
pcache1_g
).
pEnd
 = 
pBuf
;

20773 
	}
}

20779 static int 
	$pcache1InitBulk
(
PCache1
 *
pCache
)

20782 
i64
 
szBulk
;

20783 char *
zBulk
;

20784 if( (
pcache1_g
).
nInitPage
==0 ) return 0;

20786 if( 
pCache
->
nMax
<3 ) return 0;

20787 
	`sqlite3BeginBenignMalloc
();

20788 if( (
pcache1_g
).
nInitPage
>0 )

20791 
szBulk
 = 
pCache
->
szAlloc
 * (
i64
)(
pcache1_g
).
nInitPage
;

20793 
szBulk
 = -1024 * (
i64
)(
pcache1_g
).
nInitPage
;

20795 if( 
szBulk
 > 
pCache
->
szAlloc
*(
i64
)pCache->
nMax
 )

20798 
szBulk
 = 
pCache
->
szAlloc
*pCache->
nMax
;

20800 
zBulk
 = 
pCache
->
pBulk
 = 
	`sqlite3Malloc
( 
szBulk
 );

20801 
	`sqlite3EndBenignMalloc
();

20802 if( 
zBulk
 )

20805 int 
nBulk
 = 
	`sqlite3MallocSize
(
zBulk
)/
pCache
->
szAlloc
;

20806 int 
i
;

20807 for(
i
=0; i<
nBulk
; i++)

20810 
PgHdr1
 *
pX
 = (PgHdr1*)&
zBulk
[
pCache
->
szPage
];

20811 
pX
->
page
.
pBuf
 = 
zBulk
;

20812 
pX
->
page
.
pExtra
 = &pX[1];

20813 
pX
->
isBulkLocal
 = 1;

20814 
pX
->
isAnchor
 = 0;

20815 
pX
->
pNext
 = 
pCache
->
pFree
;

20816 
pCache
->
pFree
 = 
pX
;

20817 
zBulk
 += 
pCache
->
szAlloc
;

20820 return 
pCache
->
pFree
!=0;

20821 
	}
}

20823 static void *
	$pcache1Alloc
(int 
nByte
)

20826 void *
p
 = 0;

20828 if( 
nByte
<=(
pcache1_g
).
szSlot
 )

20831 
	`sqlite3_mutex_enter
((
pcache1_g
).
mutex
);

20832 
p
 = (
PgHdr1
 *)(
pcache1_g
).
pFree
;

20833 if( 
p
 )

20836 (
pcache1_g
).
pFree
 = (pcache1_g).pFree->
pNext
;

20837 (
pcache1_g
).
nFreeSlot
--;

20838 (
pcache1_g
).
bUnderPressure
 = (pcache1_g).
nFreeSlot
<(pcache1_g).
nReserve
;

20840 
	`sqlite3StatusHighwater
(7, 
nByte
);

20841 
	`sqlite3StatusUp
(1, 1);

20843 
	`sqlite3_mutex_leave
((
pcache1_g
).
mutex
);

20845 if( 
p
==0 )

20851 
p
 = 
	`sqlite3Malloc
(
nByte
);

20853 if( 
p
 )

20856 int 
sz
 = 
	`sqlite3MallocSize
(
p
);

20857 
	`sqlite3_mutex_enter
((
pcache1_g
).
mutex
);

20858 
	`sqlite3StatusHighwater
(7, 
nByte
);

20859 
	`sqlite3StatusUp
(2, 
sz
);

20860 
	`sqlite3_mutex_leave
((
pcache1_g
).
mutex
);

20865 return 
p
;

20866 
	}
}

20871 static void 
	$pcache1Free
(void *
p
)

20874 if( 
p
==0 ) return;

20875 if( (((
uptr
)(
p
)>=(uptr)((
pcache1_g
).
pStart
))&&((uptr)(p)<(uptr)((pcache1_g).
pEnd
))) )

20878 
PgFreeslot
 *
pSlot
;

20879 
	`sqlite3_mutex_enter
((
pcache1_g
).
mutex
);

20880 
	`sqlite3StatusDown
(1, 1);

20881 
pSlot
 = (
PgFreeslot
*)
p
;

20882 
pSlot
->
pNext
 = (
pcache1_g
).
pFree
;

20883 (
pcache1_g
).
pFree
 = 
pSlot
;

20884 (
pcache1_g
).
nFreeSlot
++;

20885 (
pcache1_g
).
bUnderPressure
 = (pcache1_g).
nFreeSlot
<(pcache1_g).
nReserve
;

20887 
	`sqlite3_mutex_leave
((
pcache1_g
).
mutex
);

20893 int 
nFreed
 = 0;

20894 
nFreed
 = 
	`sqlite3MallocSize
(
p
);

20895 
	`sqlite3_mutex_enter
((
pcache1_g
).
mutex
);

20896 
	`sqlite3StatusDown
(2, 
nFreed
);

20897 
	`sqlite3_mutex_leave
((
pcache1_g
).
mutex
);

20900 
	`sqlite3_free
(
p
);

20902 
	}
}

20904 static 
PgHdr1
 *
	$pcache1AllocPage
(
PCache1
 *
pCache
, int 
benignMalloc
)

20907 
PgHdr1
 *
p
 = 0;

20908 void *
pPg
;

20911 if( 
pCache
->
pFree
 || (pCache->
nPage
==0 && 
	`pcache1InitBulk
(pCache)) )

20914 
p
 = 
pCache
->
pFree
;

20915 
pCache
->
pFree
 = 
p
->
pNext
;

20916 
p
->
pNext
 = 0;

20919 if( 
benignMalloc
 )

20921 
	`sqlite3BeginBenignMalloc
(); }

20923 
pPg
 = 
	`pcache1Alloc
(
pCache
->
szAlloc
);

20924 
p
 = (
PgHdr1
 *)&((
u8
 *)
pPg
)[
pCache
->
szPage
];

20926 if( 
benignMalloc
 )

20928 
	`sqlite3EndBenignMalloc
(); }

20932 if( 
pPg
==0 ) return 0;

20933 
p
->
page
.
pBuf
 = 
pPg
;

20934 
p
->
page
.
pExtra
 = &p[1];

20935 
p
->
isBulkLocal
 = 0;

20936 
p
->
isAnchor
 = 0;

20938 if( 
pCache
->
bPurgeable
 )

20941 
pCache
->
pGroup
->
nCurrentPage
++;

20943 return 
p
;

20944 
	}
}

20949 static void 
	$pcache1FreePage
(
PgHdr1
 *
p
)

20952 
PCache1
 *
pCache
;

20954 
pCache
 = 
p
->pCache;

20956 if( 
p
->
isBulkLocal
 )

20959 
p
->
pNext
 = 
pCache
->
pFree
;

20960 
pCache
->
pFree
 = 
p
;

20962 
	`pcache1Free
(
p
->
page
.
pBuf
);

20967 if( 
pCache
->
bPurgeable
 )

20970 
pCache
->
pGroup
->
nCurrentPage
--;

20972 
	}
}

20979 static void *
	$sqlite3PageMalloc
(int 
sz
)

20982 return 
	`pcache1Alloc
(
sz
);

20983 
	}
}

20988 static void 
	$sqlite3PageFree
(void *
p
)

20991 
	`pcache1Free
(
p
);

20992 
	}
}

20994 static int 
	$pcache1UnderMemoryPressure
(
PCache1
 *
pCache
)

20997 if( (
pcache1_g
).
nSlot
 && (
pCache
->
szPage
+pCache->
szExtra
)<=(pcache1_g).
szSlot
 )

21000 return (
pcache1_g
).
bUnderPressure
;

21002 return 
	`sqlite3HeapNearlyFull
();

21004 
	}
}

21006 static void 
	$pcache1ResizeHash
(
PCache1
 *
p
)

21009 
PgHdr1
 **
apNew
;

21010 unsigned int 
nNew
;

21011 unsigned int 
i
;

21015 
nNew
 = 
p
->
nHash
*2;

21016 if( 
nNew
<256 )

21019 
nNew
 = 256;

21023 if( 
p
->
nHash
 )

21025 
	`sqlite3BeginBenignMalloc
(); }

21026 
apNew
 = (
PgHdr1
 **)
	`sqlite3MallocZero
(sizeof(PgHdr1 *)*
nNew
);

21027 if( 
p
->
nHash
 )

21029 
	`sqlite3EndBenignMalloc
(); }

21031 if( 
apNew
 )

21034 for(
i
=0; i<
p
->
nHash
; i++)

21037 
PgHdr1
 *
pPage
;

21038 
PgHdr1
 *
pNext
 = 
p
->
apHash
[
i
];

21039 while( (
pPage
 = 
pNext
)!=0 )

21042 unsigned int 
h
 = 
pPage
->
iKey
 % 
nNew
;

21043 
pNext
 = 
pPage
->pNext;

21044 
pPage
->
pNext
 = 
apNew
[
h
];

21045 
apNew
[
h
] = 
pPage
;

21048 
	`sqlite3_free
(
p
->
apHash
);

21049 
p
->
apHash
 = 
apNew
;

21050 
p
->
nHash
 = 
nNew
;

21052 
	}
}

21054 static 
PgHdr1
 *
	$pcache1PinPage
(
PgHdr1
 *
pPage
)

21057 
PCache1
 *
pCache
;

21061 
pCache
 = 
pPage
->pCache;

21065 
pPage
->
pLruPrev
->
pLruNext
 = pPage->pLruNext;

21066 
pPage
->
pLruNext
->
pLruPrev
 = pPage->pLruPrev;

21067 
pPage
->
pLruNext
 = 0;

21068 
pPage
->
pLruPrev
 = 0;

21069 
pPage
->
isPinned
 = 1;

21072 
pCache
->
nRecyclable
--;

21073 return 
pPage
;

21074 
	}
}

21076 static void 
	$pcache1RemoveFromHash
(
PgHdr1
 *
pPage
, int 
freeFlag
)

21079 unsigned int 
h
;

21080 
PCache1
 *
pCache
 = 
pPage
->pCache;

21081 
PgHdr1
 **
pp
;

21084 
h
 = 
pPage
->
iKey
 % 
pCache
->
nHash
;

21085 for(
pp
=&
pCache
->
apHash
[
h
]; (*pp)!=
pPage
; pp=&(*pp)->
pNext
);

21086 *
pp
 = (*pp)->
pNext
;

21088 
pCache
->
nPage
--;

21089 if( 
freeFlag
 ) 
	`pcache1FreePage
(
pPage
);

21090 
	}
}

21096 static void 
	$pcache1EnforceMaxPage
(
PCache1
 *
pCache
)

21099 
PGroup
 *
pGroup
 = 
pCache
->pGroup;

21100 
PgHdr1
 *
p
;

21102 while( 
pGroup
->
nCurrentPage
>pGroup->
nMaxPage


21103 && (
p
=
pGroup
->
lru
.
pLruPrev
)->
isAnchor
==0

21109 
	`pcache1PinPage
(
p
);

21110 
	`pcache1RemoveFromHash
(
p
, 1);

21112 if( 
pCache
->
nPage
==0 && pCache->
pBulk
 )

21115 
	`sqlite3_free
(
pCache
->
pBulk
);

21116 
pCache
->
pBulk
 = pCache->
pFree
 = 0;

21118 
	}
}

21120 static void 
	$pcache1TruncateUnsafe
(

21121 
PCache1
 *
pCache
,

21122 unsigned int 
iLimit


21127 unsigned int 
h
;

21129 for(
h
=0; h<
pCache
->
nHash
; h++)

21132 
PgHdr1
 **
pp
 = &
pCache
->
apHash
[
h
];

21133 
PgHdr1
 *
pPage
;

21134 while( (
pPage
 = *
pp
)!=0 )

21137 if( 
pPage
->
iKey
>=
iLimit
 )

21140 
pCache
->
nPage
--;

21141 *
pp
 = 
pPage
->
pNext
;

21142 if( !
pPage
->
isPinned
 ) 
	`pcache1PinPage
(pPage);

21143 
	`pcache1FreePage
(
pPage
);

21145 
pp
 = &
pPage
->
pNext
;

21151 
	}
}

21159 static int 
	$pcache1Init
(void *
NotUsed
)

21162 (void)(
NotUsed
);

21164 
	`memset
(&(
pcache1_g
), 0, sizeof((pcache1_g)));

21166 (
pcache1_g
).
separateCache
 = 
sqlite3Config
.
pPage
==0

21167 || 
sqlite3Config
.
bCoreMutex
>0;

21173 if( 
sqlite3Config
.
bCoreMutex
 )

21176 (
pcache1_g
).
grp
.
mutex
 = 
	`sqlite3_mutex_alloc
(6);

21177 (
pcache1_g
).
mutex
 = 
	`sqlite3_mutex_alloc
(7);

21180 if( (
pcache1_g
).
separateCache


21181 && 
sqlite3Config
.
nPage
!=0

21182 && 
sqlite3Config
.
pPage
==0

21186 (
pcache1_g
).
nInitPage
 = 
sqlite3Config
.
nPage
;

21188 (
pcache1_g
).
nInitPage
 = 0;

21190 (
pcache1_g
).
grp
.
mxPinned
 = 10;

21191 (
pcache1_g
).
isInit
 = 1;

21193 
	}
}

21200 static void 
	$pcache1Shutdown
(void *
NotUsed
)

21203 (void)(
NotUsed
);

21205 
	`memset
(&(
pcache1_g
), 0, sizeof((pcache1_g)));

21206 
	}
}

21209 static void 
pcache1Destroy
(
sqlite3_pcache
 *
p
);

21216 static 
sqlite3_pcache
 *
	$pcache1Create
(int 
szPage
, int 
szExtra
, int 
bPurgeable
)

21219 
PCache1
 *
pCache
;

21220 
PGroup
 *
pGroup
;

21221 int 
sz
;

21226 
sz
 = sizeof(
PCache1
) + sizeof(
PGroup
)*(
pcache1_g
).
separateCache
;

21227 
pCache
 = (
PCache1
 *)
	`sqlite3MallocZero
(
sz
);

21228 if( 
pCache
 )

21231 if( (
pcache1_g
).
separateCache
 )

21234 
pGroup
 = (
PGroup
*)&
pCache
[1];

21235 
pGroup
->
mxPinned
 = 10;

21237 
pGroup
 = &(
pcache1_g
).
grp
;

21239 if( 
pGroup
->
lru
.
isAnchor
==0 )

21242 
pGroup
->
lru
.
isAnchor
 = 1;

21243 
pGroup
->
lru
.
pLruPrev
 = pGroup->lru.
pLruNext
 = &pGroup->lru;

21245 
pCache
->
pGroup
 = pGroup;

21246 
pCache
->
szPage
 = szPage;

21247 
pCache
->
szExtra
 = szExtra;

21248 
pCache
->
szAlloc
 = 
szPage
 + 
szExtra
 + (((sizeof(
PgHdr1
))+7)&~7);

21249 
pCache
->
bPurgeable
 = (bPurgeable ? 1 : 0);

21251 
	`pcache1ResizeHash
(
pCache
);

21252 if( 
bPurgeable
 )

21255 
pCache
->
nMin
 = 10;

21256 
pGroup
->
nMinPage
 += 
pCache
->
nMin
;

21257 
pGroup
->
mxPinned
 = pGroup->
nMaxPage
 + 10 - pGroup->
nMinPage
;

21260 if( 
pCache
->
nHash
==0 )

21263 
	`pcache1Destroy
((
sqlite3_pcache
*)
pCache
);

21264 
pCache
 = 0;

21267 return (
sqlite3_pcache
 *)
pCache
;

21268 
	}
}

21275 static void 
	$pcache1Cachesize
(
sqlite3_pcache
 *
p
, int 
nMax
)

21278 
PCache1
 *
pCache
 = (PCache1 *)
p
;

21279 if( 
pCache
->
bPurgeable
 )

21282 
PGroup
 *
pGroup
 = 
pCache
->pGroup;

21284 
pGroup
->
nMaxPage
 += (
nMax
 - 
pCache
->nMax);

21285 
pGroup
->
mxPinned
 = pGroup->
nMaxPage
 + 10 - pGroup->
nMinPage
;

21286 
pCache
->
nMax
 = nMax;

21287 
pCache
->
n90pct
 = pCache->
nMax
*9/10;

21288 
	`pcache1EnforceMaxPage
(
pCache
);

21291 
	}
}

21298 static void 
	$pcache1Shrink
(
sqlite3_pcache
 *
p
)

21301 
PCache1
 *
pCache
 = (PCache1*)
p
;

21302 if( 
pCache
->
bPurgeable
 )

21305 
PGroup
 *
pGroup
 = 
pCache
->pGroup;

21306 int 
savedMaxPage
;

21308 
savedMaxPage
 = 
pGroup
->
nMaxPage
;

21309 
pGroup
->
nMaxPage
 = 0;

21310 
	`pcache1EnforceMaxPage
(
pCache
);

21311 
pGroup
->
nMaxPage
 = 
savedMaxPage
;

21314 
	}
}

21319 static int 
	$pcache1Pagecount
(
sqlite3_pcache
 *
p
)

21322 int 
n
;

21323 
PCache1
 *
pCache
 = (PCache1*)
p
;

21325 
n
 = 
pCache
->
nPage
;

21327 return 
n
;

21328 
	}
}

21330 static 
__attribute__
((
noinline
)) 
PgHdr1
 *
	$pcache1FetchStage2
(

21331 
PCache1
 *
pCache
,

21332 unsigned int 
iKey
,

21333 int 
createFlag


21337 unsigned int 
nPinned
;

21338 
PGroup
 *
pGroup
 = 
pCache
->pGroup;

21339 
PgHdr1
 *
pPage
 = 0;

21343 
nPinned
 = 
pCache
->
nPage
 - pCache->
nRecyclable
;

21346 if( 
createFlag
==1 && (

21347 
nPinned
>=
pGroup
->
mxPinned


21348 || 
nPinned
>=
pCache
->
n90pct


21349 || (
	`pcache1UnderMemoryPressure
(
pCache
) && pCache->
nRecyclable
<
nPinned
)

21356 if( 
pCache
->
nPage
>=pCache->
nHash
 ) 
	`pcache1ResizeHash
(pCache);

21360 if( 
pCache
->
bPurgeable


21361 && !
pGroup
->
lru
.
pLruPrev
->
isAnchor


21362 && ((
pCache
->
nPage
+1>=pCache->
nMax
) || 
	`pcache1UnderMemoryPressure
(pCache))

21366 
PCache1
 *
pOther
;

21367 
pPage
 = 
pGroup
->
lru
.
pLruPrev
;

21369 
	`pcache1RemoveFromHash
(
pPage
, 0);

21370 
	`pcache1PinPage
(
pPage
);

21371 
pOther
 = 
pPage
->
pCache
;

21372 if( 
pOther
->
szAlloc
 != 
pCache
->szAlloc )

21375 
	`pcache1FreePage
(
pPage
);

21376 
pPage
 = 0;

21378 
pGroup
->
nCurrentPage
 -= (
pOther
->
bPurgeable
 - 
pCache
->bPurgeable);

21385 if( !
pPage
 )

21388 
pPage
 = 
	`pcache1AllocPage
(
pCache
, 
createFlag
==1);

21391 if( 
pPage
 )

21394 unsigned int 
h
 = 
iKey
 % 
pCache
->
nHash
;

21395 
pCache
->
nPage
++;

21396 
pPage
->
iKey
 = iKey;

21397 
pPage
->
pNext
 = 
pCache
->
apHash
[
h
];

21398 
pPage
->
pCache
 = pCache;

21399 
pPage
->
pLruPrev
 = 0;

21400 
pPage
->
pLruNext
 = 0;

21401 
pPage
->
isPinned
 = 1;

21402 *(void **)
pPage
->
page
.
pExtra
 = 0;

21403 
pCache
->
apHash
[
h
] = 
pPage
;

21404 if( 
iKey
>
pCache
->
iMaxKey
 )

21407 
pCache
->
iMaxKey
 = 
iKey
;

21410 return 
pPage
;

21411 
	}
}

21413 static 
PgHdr1
 *
	$pcache1FetchNoMutex
(

21414 
sqlite3_pcache
 *
p
,

21415 unsigned int 
iKey
,

21416 int 
createFlag


21420 
PCache1
 *
pCache
 = (PCache1 *)
p
;

21421 
PgHdr1
 *
pPage
 = 0;

21424 
pPage
 = 
pCache
->
apHash
[
iKey
 % pCache->
nHash
];

21425 while( 
pPage
 && pPage->
iKey
!=iKey )

21427 
pPage
 = pPage->
pNext
; }

21433 if( 
pPage
 )

21436 if( !
pPage
->
isPinned
 )

21439 return 
	`pcache1PinPage
(
pPage
);

21441 return 
pPage
;

21443 }else if( 
createFlag
 )

21447 return 
	`pcache1FetchStage2
(
pCache
, 
iKey
, 
createFlag
);

21451 
	}
}

21453 static 
sqlite3_pcache_page
 *
	$pcache1Fetch
(

21454 
sqlite3_pcache
 *
p
,

21455 unsigned int 
iKey
,

21456 int 
createFlag


21476 return (
sqlite3_pcache_page
*)
	`pcache1FetchNoMutex
(
p
, 
iKey
, 
createFlag
);

21478 
	}
}

21486 static void 
	$pcache1Unpin
(

21487 
sqlite3_pcache
 *
p
,

21488 
sqlite3_pcache_page
 *
pPg
,

21489 int 
reuseUnlikely


21493 
PCache1
 *
pCache
 = (PCache1 *)
p
;

21494 
PgHdr1
 *
pPage
 = (PgHdr1 *)
pPg
;

21495 
PGroup
 *
pGroup
 = 
pCache
->pGroup;

21506 if( 
reuseUnlikely
 || 
pGroup
->
nCurrentPage
>pGroup->
nMaxPage
 )

21509 
	`pcache1RemoveFromHash
(
pPage
, 1);

21512 
PgHdr1
 **
ppFirst
 = &
pGroup
->
lru
.
pLruNext
;

21513 
pPage
->
pLruPrev
 = &
pGroup
->
lru
;

21514 (
pPage
->
pLruNext
 = *
ppFirst
)->
pLruPrev
 = pPage;

21515 *
ppFirst
 = 
pPage
;

21516 
pCache
->
nRecyclable
++;

21517 
pPage
->
isPinned
 = 0;

21521 
	}
}

21526 static void 
	$pcache1Rekey
(

21527 
sqlite3_pcache
 *
p
,

21528 
sqlite3_pcache_page
 *
pPg
,

21529 unsigned int 
iOld
,

21530 unsigned int 
iNew


21534 
PCache1
 *
pCache
 = (PCache1 *)
p
;

21535 
PgHdr1
 *
pPage
 = (PgHdr1 *)
pPg
;

21536 
PgHdr1
 **
pp
;

21537 unsigned int 
h
;

21543 
h
 = 
iOld
%
pCache
->
nHash
;

21544 
pp
 = &
pCache
->
apHash
[
h
];

21545 while( (*
pp
)!=
pPage
 )

21548 
pp
 = &(*pp)->
pNext
;

21550 *
pp
 = 
pPage
->
pNext
;

21552 
h
 = 
iNew
%
pCache
->
nHash
;

21553 
pPage
->
iKey
 = 
iNew
;

21554 
pPage
->
pNext
 = 
pCache
->
apHash
[
h
];

21555 
pCache
->
apHash
[
h
] = 
pPage
;

21556 if( 
iNew
>
pCache
->
iMaxKey
 )

21559 
pCache
->
iMaxKey
 = 
iNew
;

21563 
	}
}

21565 static void 
	$pcache1Truncate
(
sqlite3_pcache
 *
p
, unsigned int 
iLimit
)

21568 
PCache1
 *
pCache
 = (PCache1 *)
p
;

21570 if( 
iLimit
<=
pCache
->
iMaxKey
 )

21573 
	`pcache1TruncateUnsafe
(
pCache
, 
iLimit
);

21574 
pCache
->
iMaxKey
 = 
iLimit
-1;

21577 
	}
}

21584 static void 
	$pcache1Destroy
(
sqlite3_pcache
 *
p
)

21587 
PCache1
 *
pCache
 = (PCache1 *)
p
;

21588 
PGroup
 *
pGroup
 = 
pCache
->pGroup;

21591 
	`pcache1TruncateUnsafe
(
pCache
, 0);

21593 
pGroup
->
nMaxPage
 -= 
pCache
->
nMax
;

21595 
pGroup
->
nMinPage
 -= 
pCache
->
nMin
;

21596 
pGroup
->
mxPinned
 = pGroup->
nMaxPage
 + 10 - pGroup->
nMinPage
;

21597 
	`pcache1EnforceMaxPage
(
pCache
);

21599 
	`sqlite3_free
(
pCache
->
pBulk
);

21600 
	`sqlite3_free
(
pCache
->
apHash
);

21601 
	`sqlite3_free
(
pCache
);

21602 
	}
}

21609 static void 
	$sqlite3PCacheSetDefault
(void)

21612 static const 
sqlite3_pcache_methods2
 
defaultMethods
 = {

21615 
pcache1Init
,

21616 
pcache1Shutdown
,

21617 
pcache1Create
,

21618 
pcache1Cachesize
,

21619 
pcache1Pagecount
,

21620 
pcache1Fetch
,

21621 
pcache1Unpin
,

21622 
pcache1Rekey
,

21623 
pcache1Truncate
,

21624 
pcache1Destroy
,

21625 
pcache1Shrink


21627 
	`sqlite3_config
(18, &
defaultMethods
);

21628 
	}
}

21633 static int 
	$sqlite3HeaderSizePcache1
(void)

21635 return (((sizeof(
PgHdr1
))+7)&~7); 
	}
}

21641 static 
sqlite3_mutex
 *
	$sqlite3Pcache1Mutex
(void)

21644 return (
pcache1_g
).
mutex
;

21645 
	}
}

21647 struct 
	sRowSetEntry
 {

21648 
i64
 
	mv
;

21649 struct 
RowSetEntry
 *
	mpRight
;

21650 struct 
RowSetEntry
 *
	mpLeft
;

21659 struct 
	sRowSetChunk
 {

21660 struct 
RowSetChunk
 *
	mpNextChunk
;

21661 struct 
RowSetEntry
 
	maEntry
[((1024 -8)/sizeof(struct RowSetEntry))];

21669 struct 
	sRowSet
 {

21670 struct 
RowSetChunk
 *
	mpChunk
;

21671 
sqlite3
 *
	mdb
;

21672 struct 
RowSetEntry
 *
	mpEntry
;

21673 struct 
RowSetEntry
 *
	mpLast
;

21674 struct 
RowSetEntry
 *
	mpFresh
;

21675 struct 
RowSetEntry
 *
	mpForest
;

21676 
u16
 
	mnFresh
;

21677 
u16
 
	mrsFlags
;

21678 int 
	miBatch
;

21681 static 
RowSet
 *
	$sqlite3RowSetInit
(
sqlite3
 *
db
, void *
pSpace
, unsigned int 
N
)

21684 
RowSet
 *
p
;

21686 
p
 = 
pSpace
;

21687 
p
->
pChunk
 = 0;

21688 
p
->
db
 = db;

21689 
p
->
pEntry
 = 0;

21690 
p
->
pLast
 = 0;

21691 
p
->
pForest
 = 0;

21692 
p
->
pFresh
 = (struct 
RowSetEntry
*)((((sizeof(*p))+7)&~7) + (char*)p);

21693 
p
->
nFresh
 = (
u16
)((
N
 - (((sizeof(*p))+7)&~7))/sizeof(struct 
RowSetEntry
));

21694 
p
->
rsFlags
 = 0x01;

21695 
p
->
iBatch
 = 0;

21696 return 
p
;

21697 
	}
}

21704 static void 
	$sqlite3RowSetClear
(
RowSet
 *
p
)

21707 struct 
RowSetChunk
 *
pChunk
, *
pNextChunk
;

21708 for(
pChunk
=
p
->pChunk; pChunk; pChunk = 
pNextChunk
)

21711 
pNextChunk
 = 
pChunk
->pNextChunk;

21712 
	`sqlite3DbFree
(
p
->
db
, 
pChunk
);

21714 
p
->
pChunk
 = 0;

21715 
p
->
nFresh
 = 0;

21716 
p
->
pEntry
 = 0;

21717 
p
->
pLast
 = 0;

21718 
p
->
pForest
 = 0;

21719 
p
->
rsFlags
 = 0x01;

21720 
	}
}

21722 static struct 
RowSetEntry
 *
	$rowSetEntryAlloc
(
RowSet
 *
p
)

21726 if( 
p
->
nFresh
==0 )

21729 struct 
RowSetChunk
 *
pNew
;

21730 
pNew
 = 
	`sqlite3DbMallocRawNN
(
p
->
db
, sizeof(*pNew));

21731 if( 
pNew
==0 )

21736 
pNew
->
pNextChunk
 = 
p
->
pChunk
;

21737 
p
->
pChunk
 = 
pNew
;

21738 
p
->
pFresh
 = 
pNew
->
aEntry
;

21739 
p
->
nFresh
 = ((1024 -8)/sizeof(struct 
RowSetEntry
));

21741 
p
->
nFresh
--;

21742 return 
p
->
pFresh
++;

21743 
	}
}

21751 static void 
	$sqlite3RowSetInsert
(
RowSet
 *
p
, 
i64
 
rowid
)

21754 struct 
RowSetEntry
 *
pEntry
;

21755 struct 
RowSetEntry
 *
pLast
;

21760 
pEntry
 = 
	`rowSetEntryAlloc
(
p
);

21761 if( 
pEntry
==0 ) return;

21762 
pEntry
->
v
 = 
rowid
;

21763 
pEntry
->
pRight
 = 0;

21764 
pLast
 = 
p
->pLast;

21765 if( 
pLast
 )

21768 if( (
p
->
rsFlags
 & 0x01)!=0 && 
rowid
<=
pLast
->
v
 )

21771 
p
->
rsFlags
 &= ~0x01;

21773 
pLast
->
pRight
 = 
pEntry
;

21775 
p
->
pEntry
 = pEntry;

21777 
p
->
pLast
 = 
pEntry
;

21778 
	}
}

21786 static struct 
RowSetEntry
 *
	$rowSetEntryMerge
(

21787 struct 
RowSetEntry
 *
pA
,

21788 struct 
RowSetEntry
 *
pB


21792 struct 
RowSetEntry
 
head
;

21793 struct 
RowSetEntry
 *
pTail
;

21795 
pTail
 = &
head
;

21796 while( 
pA
 && 
pB
 )

21801 if( 
pA
->
v
<
pB
->v )

21804 
pTail
->
pRight
 = 
pA
;

21805 
pA
 = pA->
pRight
;

21806 
pTail
 = pTail->
pRight
;

21807 }else if( 
pB
->
v
<
pA
->v )

21810 
pTail
->
pRight
 = 
pB
;

21811 
pB
 = pB->
pRight
;

21812 
pTail
 = pTail->
pRight
;

21814 
pA
 = pA->
pRight
;

21817 if( 
pA
 )

21821 
pTail
->
pRight
 = 
pA
;

21824 
pTail
->
pRight
 = 
pB
;

21826 return 
head
.
pRight
;

21827 
	}
}

21833 static struct 
RowSetEntry
 *
	$rowSetEntrySort
(struct 
RowSetEntry
 *
pIn
)

21836 unsigned int 
i
;

21837 struct 
RowSetEntry
 *
pNext
, *
aBucket
[40];

21839 
	`memset
(
aBucket
, 0, sizeof(aBucket));

21840 while( 
pIn
 )

21843 
pNext
 = 
pIn
->
pRight
;

21844 
pIn
->
pRight
 = 0;

21845 for(
i
=0; 
aBucket
[i]; i++)

21848 
pIn
 = 
	`rowSetEntryMerge
(
aBucket
[
i
], pIn);

21849 
aBucket
[
i
] = 0;

21851 
aBucket
[
i
] = 
pIn
;

21852 
pIn
 = 
pNext
;

21854 
pIn
 = 0;

21855 for(
i
=0; i<sizeof(
aBucket
)/sizeof(aBucket[0]); i++)

21858 
pIn
 = 
	`rowSetEntryMerge
(pIn, 
aBucket
[
i
]);

21860 return 
pIn
;

21861 
	}
}

21869 static void 
	$rowSetTreeToList
(

21870 struct 
RowSetEntry
 *
pIn
,

21871 struct 
RowSetEntry
 **
ppFirst
,

21872 struct 
RowSetEntry
 **
ppLast


21877 if( 
pIn
->
pLeft
 )

21880 struct 
RowSetEntry
 *
p
;

21881 
	`rowSetTreeToList
(
pIn
->
pLeft
, 
ppFirst
, &
p
);

21882 
p
->
pRight
 = 
pIn
;

21884 *
ppFirst
 = 
pIn
;

21886 if( 
pIn
->
pRight
 )

21889 
	`rowSetTreeToList
(
pIn
->
pRight
, &pIn->pRight, 
ppLast
);

21891 *
ppLast
 = 
pIn
;

21894 
	}
}

21896 static struct 
RowSetEntry
 *
	$rowSetNDeepTree
(

21897 struct 
RowSetEntry
 **
ppList
,

21898 int 
iDepth


21902 struct 
RowSetEntry
 *
p
;

21903 struct 
RowSetEntry
 *
pLeft
;

21904 if( *
ppList
==0 )

21909 if( 
iDepth
==1 )

21912 
p
 = *
ppList
;

21913 *
ppList
 = 
p
->
pRight
;

21914 
p
->
pLeft
 = p->
pRight
 = 0;

21915 return 
p
;

21917 
pLeft
 = 
	`rowSetNDeepTree
(
ppList
, 
iDepth
-1);

21918 
p
 = *
ppList
;

21919 if( 
p
==0 )

21922 return 
pLeft
;

21924 
p
->
pLeft
 = pLeft;

21925 *
ppList
 = 
p
->
pRight
;

21926 
p
->
pRight
 = 
	`rowSetNDeepTree
(
ppList
, 
iDepth
-1);

21927 return 
p
;

21928 
	}
}

21934 static struct 
RowSetEntry
 *
	$rowSetListToTree
(struct 
RowSetEntry
 *
pList
)

21937 int 
iDepth
;

21938 struct 
RowSetEntry
 *
p
;

21939 struct 
RowSetEntry
 *
pLeft
;

21942 
p
 = 
pList
;

21943 
pList
 = 
p
->
pRight
;

21944 
p
->
pLeft
 = p->
pRight
 = 0;

21945 for(
iDepth
=1; 
pList
; iDepth++)

21948 
pLeft
 = 
p
;

21949 
p
 = 
pList
;

21950 
pList
 = 
p
->
pRight
;

21951 
p
->
pLeft
 = pLeft;

21952 
p
->
pRight
 = 
	`rowSetNDeepTree
(&
pList
, 
iDepth
);

21954 return 
p
;

21955 
	}
}

21963 static void 
	$rowSetToList
(
RowSet
 *
p
)

21970 if( (
p
->
rsFlags
 & 0x01)==0 )

21973 
p
->
pEntry
 = 
	`rowSetEntrySort
(p->pEntry);

21982 
p
->
rsFlags
 |= 0x02;

21983 
	}
}

21985 static int 
	$sqlite3RowSetNext
(
RowSet
 *
p
, 
i64
 *
pRowid
)

21991 if( (
p
->
rsFlags
 & 0x02)==0 ) 
	`rowSetToList
(p);

21994 if( 
p
->
pEntry
 )

21997 *
pRowid
 = 
p
->
pEntry
->
v
;

21998 
p
->
pEntry
 = p->pEntry->
pRight
;

21999 if( 
p
->
pEntry
==0 )

22002 
	`sqlite3RowSetClear
(
p
);

22008 
	}
}

22010 static int 
	$sqlite3RowSetTest
(
RowSet
 *
pRowSet
, int 
iBatch
, 
sqlite3_int64
 
iRowid
)

22013 struct 
RowSetEntry
 *
p
, *
pTree
;

22020 if( 
iBatch
!=
pRowSet
->iBatch )

22023 
p
 = 
pRowSet
->
pEntry
;

22024 if( 
p
 )

22027 struct 
RowSetEntry
 **
ppPrevTree
 = &
pRowSet
->
pForest
;

22028 if( (
pRowSet
->
rsFlags
 & 0x01)==0 )

22031 
p
 = 
	`rowSetEntrySort
(p);

22033 for(
pTree
 = 
pRowSet
->
pForest
; pTree; pTree=pTree->
pRight
)

22036 
ppPrevTree
 = &
pTree
->
pRight
;

22037 if( 
pTree
->
pLeft
==0 )

22040 
pTree
->
pLeft
 = 
	`rowSetListToTree
(
p
);

22043 struct 
RowSetEntry
 *
pAux
, *
pTail
;

22044 
	`rowSetTreeToList
(
pTree
->
pLeft
, &
pAux
, &
pTail
);

22045 
pTree
->
pLeft
 = 0;

22046 
p
 = 
	`rowSetEntryMerge
(
pAux
, p);

22049 if( 
pTree
==0 )

22052 *
ppPrevTree
 = 
pTree
 = 
	`rowSetEntryAlloc
(
pRowSet
);

22053 if( 
pTree
 )

22056 
pTree
->
v
 = 0;

22057 
pTree
->
pRight
 = 0;

22058 
pTree
->
pLeft
 = 
	`rowSetListToTree
(
p
);

22061 
pRowSet
->
pEntry
 = 0;

22062 
pRowSet
->
pLast
 = 0;

22063 
pRowSet
->
rsFlags
 |= 0x01;

22065 
pRowSet
->
iBatch
 = iBatch;

22071 for(
pTree
 = 
pRowSet
->
pForest
; pTree; pTree=pTree->
pRight
)

22074 
p
 = 
pTree
->
pLeft
;

22075 while( 
p
 )

22078 if( 
p
->
v
<
iRowid
 )

22081 
p
 = p->
pRight
;

22082 }else if( 
p
->
v
>
iRowid
 )

22085 
p
 = p->
pLeft
;

22092 
	}
}

22094 typedef struct 
Wal
 
	tWal
;

22097 static int 
sqlite3WalOpen
(
sqlite3_vfs
*, 
sqlite3_file
*, const char *, int, 
i64
, 
Wal
**);

22098 static int 
sqlite3WalClose
(
Wal
 *
pWal
, int 
sync_flags
, int, 
u8
 *);

22101 static void 
sqlite3WalLimit
(
Wal
*, 
i64
);

22103 static int 
sqlite3WalBeginReadTransaction
(
Wal
 *
pWal
, int *);

22104 static void 
sqlite3WalEndReadTransaction
(
Wal
 *
pWal
);

22107 static int 
sqlite3WalFindFrame
(
Wal
 *, 
Pgno
, 
u32
 *);

22108 static int 
sqlite3WalReadFrame
(
Wal
 *, 
u32
, int, 
u8
 *);

22111 static 
Pgno
 
sqlite3WalDbsize
(
Wal
 *
pWal
);

22114 static int 
sqlite3WalBeginWriteTransaction
(
Wal
 *
pWal
);

22115 static int 
sqlite3WalEndWriteTransaction
(
Wal
 *
pWal
);

22118 static int 
sqlite3WalUndo
(
Wal
 *
pWal
, int (*
xUndo
)(void *, 
Pgno
), void *
pUndoCtx
);

22122 static void 
	`sqlite3WalSavepoint
(
Wal
 *
pWal
, 
u32
 *
aWalData
);

22126 static int 
	`sqlite3WalSavepointUndo
(
Wal
 *
pWal
, 
u32
 *
aWalData
);

22129 static int 
	`sqlite3WalFrames
(
Wal
 *
pWal
, int, 
PgHdr
 *, 
Pgno
, int, int);

22132 static int 
	`sqlite3WalCheckpoint
(

22133 
Wal
 *
pWal
,

22134 int 
eMode
,

22135 int (*
xBusy
)(void*),

22136 void *
pBusyArg
,

22137 int 
sync_flags
,

22138 int 
nBuf
,

22139 
u8
 *
zBuf
,

22140 int *
pnLog
,

22141 int *
pnCkpt


22149 static int 
	`sqlite3WalCallback
(
Wal
 *
pWal
);

22154 static int 
	`sqlite3WalExclusiveMode
(
Wal
 *
pWal
, int 
op
);

22160 static int 
	`sqlite3WalHeapMemory
(
Wal
 *
pWal
);

22162 static 
sqlite3_file
 *
	`sqlite3WalFile
(
Wal
 *
pWal
);

22164 typedef struct 
PagerSavepoint
 
	tPagerSavepoint
;

22165 struct 
	sPagerSavepoint
 {

22166 
i64
 
iOffset
;

22167 
i64
 
iHdrOffset
;

22168 
Bitvec
 *
pInSavepoint
;

22169 
Pgno
 
nOrig
;

22170 
Pgno
 
iSubRec
;

22172 
u32
 
aWalData
[4];

22176 struct 
	sPager
 {

22177 
sqlite3_vfs
 *
pVfs
;

22178 
u8
 
exclusiveMode
;

22179 
u8
 
journalMode
;

22180 
u8
 
useJournal
;

22181 
u8
 
noSync
;

22182 
u8
 
fullSync
;

22183 
u8
 
extraSync
;

22184 
u8
 
ckptSyncFlags
;

22185 
u8
 
walSyncFlags
;

22186 
u8
 
syncFlags
;

22187 
u8
 
tempFile
;

22188 
u8
 
noLock
;

22189 
u8
 
readOnly
;

22190 
u8
 
memDb
;

22192 
u8
 
eState
;

22193 
u8
 
eLock
;

22194 
u8
 
changeCountDone
;

22195 
u8
 
setMaster
;

22196 
u8
 
doNotSpill
;

22197 
u8
 
subjInMemory
;

22198 
u8
 
bUseFetch
;

22199 
u8
 
hasHeldSharedLock
;

22200 
Pgno
 
dbSize
;

22201 
Pgno
 
dbOrigSize
;

22202 
Pgno
 
dbFileSize
;

22203 
Pgno
 
dbHintSize
;

22204 int 
errCode
;

22205 int 
nRec
;

22206 
u32
 
cksumInit
;

22207 
u32
 
nSubRec
;

22208 
Bitvec
 *
pInJournal
;

22209 
sqlite3_file
 *
fd
;

22210 
sqlite3_file
 *
jfd
;

22211 
sqlite3_file
 *
sjfd
;

22212 
i64
 
journalOff
;

22213 
i64
 
journalHdr
;

22214 
sqlite3_backup
 *
pBackup
;

22215 
PagerSavepoint
 *
aSavepoint
;

22216 int 
nSavepoint
;

22217 
u32
 
iDataVersion
;

22218 char 
dbFileVers
[16];

22220 int 
nMmapOut
;

22221 
sqlite3_int64
 
szMmap
;

22222 
PgHdr
 *
pMmapFreelist
;

22227 
u16
 
nExtra
;

22228 
i16
 
nReserve
;

22229 
u32
 
vfsFlags
;

22230 
u32
 
sectorSize
;

22231 int 
pageSize
;

22232 
Pgno
 
mxPgno
;

22233 
i64
 
journalSizeLimit
;

22234 char *
zFilename
;

22235 char *
zJournal
;

22236 int (*
xBusyHandler
)(void*);

22237 void *
pBusyHandlerArg
;

22238 int 
aStat
[3];

22242 void (*
xReiniter
)(
DbPage
*);

22249 char *
pTmpSpace
;

22250 
PCache
 *
pPCache
;

22252 
Wal
 *
pWal
;

22253 char *
zWal
;

22257 static const unsigned char 
aJournalMagic
[] = {

22259 
	}
};

22261 static int 
	$pagerUseWal
(
Pager
 *
pPager
)

22264 return (
pPager
->
pWal
!=0);

22265 
	}
}

22267 static int 
	$subjRequiresPage
(
PgHdr
 *
pPg
)

22270 
Pager
 *
pPager
 = 
pPg
->pPager;

22271 
PagerSavepoint
 *
p
;

22272 
Pgno
 
pgno
 = 
pPg
->pgno;

22273 int 
i
;

22274 for(
i
=0; i<
pPager
->
nSavepoint
; i++)

22277 
p
 = &
pPager
->
aSavepoint
[
i
];

22278 if( 
p
->
nOrig
>=
pgno
 && 0==
	`sqlite3BitvecTestNotNull
(p->
pInSavepoint
, pgno) )

22285 
	}
}

22287 static int 
	$read32bits
(
sqlite3_file
 *
fd
, 
i64
 
offset
, 
u32
 *
pRes
)

22290 unsigned char 
ac
[4];

22291 int 
rc
 = 
	`sqlite3OsRead
(
fd
, 
ac
, sizeof(ac), 
offset
);

22292 if( 
rc
==0 )

22295 *
pRes
 = 
	`sqlite3Get4byte
(
ac
);

22297 return 
rc
;

22298 
	}
}

22300 static int 
	$write32bits
(
sqlite3_file
 *
fd
, 
i64
 
offset
, 
u32
 
val
)

22303 char 
ac
[4];

22304 
	`sqlite3Put4byte
((
u8
*)
ac
,
val
);

22305 return 
	`sqlite3OsWrite
(
fd
, 
ac
, 4, 
offset
);

22306 
	}
}

22308 static int 
	$pagerUnlockDb
(
Pager
 *
pPager
, int 
eLock
)

22311 int 
rc
 = 0;

22316 if( ((
pPager
->
fd
)->
pMethods
!=0) )

22320 
rc
 = 
pPager
->
noLock
 ? 0 : 
	`sqlite3OsUnlock
(pPager->
fd
, 
eLock
);

22321 if( 
pPager
->
eLock
!=(4 +1) )

22324 
pPager
->
eLock
 = (
u8
)eLock;

22328 return 
rc
;

22329 
	}
}

22331 static int 
	$pagerLockDb
(
Pager
 *
pPager
, int 
eLock
)

22334 int 
rc
 = 0;

22337 if( 
pPager
->
eLock
<eLock || pPager->eLock==(4 +1) )

22340 
rc
 = 
pPager
->
noLock
 ? 0 : 
	`sqlite3OsLock
(pPager->
fd
, 
eLock
);

22341 if( 
rc
==0 && (
pPager
->
eLock
!=(4 +1)||eLock==4) )

22344 
pPager
->
eLock
 = (
u8
)eLock;

22348 return 
rc
;

22349 
	}
}

22351 static int 
	$readMasterJournal
(
sqlite3_file
 *
pJrnl
, char *
zMaster
, 
u32
 
nMaster
)

22354 int 
rc
;

22355 
u32
 
len
;

22356 
i64
 
szJ
;

22357 
u32
 
cksum
;

22358 
u32
 
u
;

22359 unsigned char 
aMagic
[8];

22360 
zMaster
[0] = '\0';

22362 if( 0!=(
rc
 = 
	`sqlite3OsFileSize
(
pJrnl
, &
szJ
))

22363 || 
szJ
<16

22364 || 0!=(
rc
 = 
	`read32bits
(
pJrnl
, 
szJ
-16, &
len
))

22365 || 
len
>=
nMaster


22366 || 
len
==0

22367 || 0!=(
rc
 = 
	`read32bits
(
pJrnl
, 
szJ
-12, &
cksum
))

22368 || 0!=(
rc
 = 
	`sqlite3OsRead
(
pJrnl
, 
aMagic
, 8, 
szJ
-8))

22369 || 
	`memcmp
(
aMagic
, 
aJournalMagic
, 8)

22370 || 0!=(
rc
 = 
	`sqlite3OsRead
(
pJrnl
, 
zMaster
, 
len
, 
szJ
-16-len))

22374 return 
rc
;

22378 for(
u
=0; u<
len
; u++)

22381 
cksum
 -= 
zMaster
[
u
];

22383 if( 
cksum
 )

22391 
len
 = 0;

22393 
zMaster
[
len
] = '\0';

22396 
	}
}

22398 static 
i64
 
	$journalHdrOffset
(
Pager
 *
pPager
)

22401 
i64
 
offset
 = 0;

22402 
i64
 
c
 = 
pPager
->
journalOff
;

22403 if( 
c
 )

22406 
offset
 = ((
c
-1)/(
pPager
->
sectorSize
) + 1) * (pPager->sectorSize);

22411 return 
offset
;

22412 
	}
}

22414 static int 
	$zeroJournalHdr
(
Pager
 *
pPager
, int 
doTruncate
)

22417 int 
rc
 = 0;

22420 if( 
pPager
->
journalOff
 )

22423 const 
i64
 
iLimit
 = 
pPager
->
journalSizeLimit
;

22426 if( 
doTruncate
 || 
iLimit
==0 )

22429 
rc
 = 
	`sqlite3OsTruncate
(
pPager
->
jfd
, 0);

22431 static const char 
zeroHdr
[28] = {0};

22432 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
jfd
, 
zeroHdr
, sizeof(zeroHdr), 0);

22434 if( 
rc
==0 && !
pPager
->
noSync
 )

22437 
rc
 = 
	`sqlite3OsSync
(
pPager
->
jfd
, 0x00010|pPager->
syncFlags
);

22446 if( 
rc
==0 && 
iLimit
>0 )

22449 
i64
 
sz
;

22450 
rc
 = 
	`sqlite3OsFileSize
(
pPager
->
jfd
, &
sz
);

22451 if( 
rc
==0 && 
sz
>
iLimit
 )

22454 
rc
 = 
	`sqlite3OsTruncate
(
pPager
->
jfd
, 
iLimit
);

22458 return 
rc
;

22459 
	}
}

22461 static int 
	$writeJournalHdr
(
Pager
 *
pPager
)

22464 int 
rc
 = 0;

22465 char *
zHeader
 = 
pPager
->
pTmpSpace
;

22466 
u32
 
nHeader
 = (u32)
pPager
->
pageSize
;

22467 
u32
 
nWrite
;

22468 int 
ii
;

22472 if( 
nHeader
>(
pPager
->
sectorSize
) )

22475 
nHeader
 = (
pPager
->
sectorSize
);

22482 for(
ii
=0; ii<
pPager
->
nSavepoint
; ii++)

22485 if( 
pPager
->
aSavepoint
[
ii
].
iHdrOffset
==0 )

22488 
pPager
->
aSavepoint
[
ii
].
iHdrOffset
 = pPager->
journalOff
;

22492 
pPager
->
journalHdr
 = pPager->
journalOff
 = 
	`journalHdrOffset
(pPager);

22495 if( 
pPager
->
noSync
 || (pPager->
journalMode
==4)

22496 || (
	`sqlite3OsDeviceCharacteristics
(
pPager
->
fd
)&0x00000200)

22500 
	`memcpy
(
zHeader
, 
aJournalMagic
, sizeof(aJournalMagic));

22501 
	`sqlite3Put4byte
((
u8
*)&
zHeader
[sizeof(
aJournalMagic
)],0xffffffff);

22503 
	`memset
(
zHeader
, 0, sizeof(
aJournalMagic
)+4);

22507 
	`sqlite3_randomness
(sizeof(
pPager
->
cksumInit
), &pPager->cksumInit);

22508 
	`sqlite3Put4byte
((
u8
*)&
zHeader
[sizeof(
aJournalMagic
)+4],
pPager
->
cksumInit
);

22510 
	`sqlite3Put4byte
((
u8
*)&
zHeader
[sizeof(
aJournalMagic
)+8],
pPager
->
dbOrigSize
);

22512 
	`sqlite3Put4byte
((
u8
*)&
zHeader
[sizeof(
aJournalMagic
)+12],
pPager
->
sectorSize
);

22515 
	`sqlite3Put4byte
((
u8
*)&
zHeader
[sizeof(
aJournalMagic
)+16],
pPager
->
pageSize
);

22522 
	`memset
(&
zHeader
[sizeof(
aJournalMagic
)+20], 0,

22523 
nHeader
-(sizeof(
aJournalMagic
)+20));

22525 for(
nWrite
=0; 
rc
==0&&nWrite<(
pPager
->
sectorSize
); nWrite+=
nHeader
)

22529 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
jfd
, 
zHeader
, 
nHeader
, pPager->
journalOff
);

22531 
pPager
->
journalOff
 += 
nHeader
;

22534 return 
rc
;

22535 
	}
}

22537 static int 
	$readJournalHdr
(

22538 
Pager
 *
pPager
,

22539 int 
isHot
,

22540 
i64
 
journalSize
,

22541 
u32
 *
pNRec
,

22542 
u32
 *
pDbSize


22546 int 
rc
;

22547 unsigned char 
aMagic
[8];

22548 
i64
 
iHdrOff
;

22556 
pPager
->
journalOff
 = 
	`journalHdrOffset
(pPager);

22557 if( 
pPager
->
journalOff
+(pPager->
sectorSize
) > 
journalSize
 )

22562 
iHdrOff
 = 
pPager
->
journalOff
;

22569 if( 
isHot
 || 
iHdrOff
!=
pPager
->
journalHdr
 )

22572 
rc
 = 
	`sqlite3OsRead
(
pPager
->
jfd
, 
aMagic
, sizeof(aMagic), 
iHdrOff
);

22573 if( 
rc
 )

22576 return 
rc
;

22578 if( 
	`memcmp
(
aMagic
, 
aJournalMagic
, sizeof(aMagic))!=0 )

22589 if( 0!=(
rc
 = 
	`read32bits
(
pPager
->
jfd
, 
iHdrOff
+8, 
pNRec
))

22590 || 0!=(
rc
 = 
	`read32bits
(
pPager
->
jfd
, 
iHdrOff
+12, &pPager->
cksumInit
))

22591 || 0!=(
rc
 = 
	`read32bits
(
pPager
->
jfd
, 
iHdrOff
+16, 
pDbSize
))

22595 return 
rc
;

22598 if( 
pPager
->
journalOff
==0 )

22601 
u32
 
iPageSize
;

22602 
u32
 
iSectorSize
;

22605 if( 0!=(
rc
 = 
	`read32bits
(
pPager
->
jfd
, 
iHdrOff
+20, &
iSectorSize
))

22606 || 0!=(
rc
 = 
	`read32bits
(
pPager
->
jfd
, 
iHdrOff
+24, &
iPageSize
))

22610 return 
rc
;

22617 if( 
iPageSize
==0 )

22620 
iPageSize
 = 
pPager
->
pageSize
;

22628 if( 
iPageSize
<512 || 
iSectorSize
<32

22629 || 
iPageSize
>65536 || 
iSectorSize
>0x10000

22630 || ((
iPageSize
-1)&iPageSize)!=0 || ((
iSectorSize
-1)&iSectorSize)!=0

22646 
rc
 = 
	`sqlite3PagerSetPagesize
(
pPager
, &
iPageSize
, -1);

22655 
pPager
->
sectorSize
 = 
iSectorSize
;

22658 
pPager
->
journalOff
 += (pPager->
sectorSize
);

22659 return 
rc
;

22660 
	}
}

22662 static int 
	$writeMasterJournal
(
Pager
 *
pPager
, const char *
zMaster
)

22665 int 
rc
;

22666 int 
nMaster
;

22667 
i64
 
iHdrOff
;

22668 
i64
 
jrnlSize
;

22669 
u32
 
cksum
 = 0;

22674 if( !
zMaster


22675 || 
pPager
->
journalMode
==4

22676 || !((
pPager
->
jfd
)->
pMethods
!=0)

22682 
pPager
->
setMaster
 = 1;

22686 for(
nMaster
=0; 
zMaster
[nMaster]; nMaster++)

22689 
cksum
 += 
zMaster
[
nMaster
];

22696 if( 
pPager
->
fullSync
 )

22699 
pPager
->
journalOff
 = 
	`journalHdrOffset
(pPager);

22701 
iHdrOff
 = 
pPager
->
journalOff
;

22706 if( (0 != (
rc
 = 
	`write32bits
(
pPager
->
jfd
, 
iHdrOff
, ((
Pgno
)((
sqlite3PendingByte
/((pPager)->
pageSize
))+1)))))

22707 || (0 != (
rc
 = 
	`sqlite3OsWrite
(
pPager
->
jfd
, 
zMaster
, 
nMaster
, 
iHdrOff
+4)))

22708 || (0 != (
rc
 = 
	`write32bits
(
pPager
->
jfd
, 
iHdrOff
+4+
nMaster
, nMaster)))

22709 || (0 != (
rc
 = 
	`write32bits
(
pPager
->
jfd
, 
iHdrOff
+4+
nMaster
+4, 
cksum
)))

22710 || (0 != (
rc
 = 
	`sqlite3OsWrite
(
pPager
->
jfd
, 
aJournalMagic
, 8,

22711 
iHdrOff
+4+
nMaster
+8)))

22715 return 
rc
;

22717 
pPager
->
journalOff
 += (
nMaster
+20);

22719 if( 0==(
rc
 = 
	`sqlite3OsFileSize
(
pPager
->
jfd
, &
jrnlSize
))

22720 && 
jrnlSize
>
pPager
->
journalOff


22724 
rc
 = 
	`sqlite3OsTruncate
(
pPager
->
jfd
, pPager->
journalOff
);

22726 return 
rc
;

22727 
	}
}

22732 static void 
	$pager_reset
(
Pager
 *
pPager
)

22735 
pPager
->
iDataVersion
++;

22736 
	`sqlite3BackupRestart
(
pPager
->
pBackup
);

22737 
	`sqlite3PcacheClear
(
pPager
->
pPCache
);

22738 
	}
}

22743 static 
u32
 
	$sqlite3PagerDataVersion
(
Pager
 *
pPager
)

22747 return 
pPager
->
iDataVersion
;

22748 
	}
}

22755 static void 
	$releaseAllSavepoints
(
Pager
 *
pPager
)

22758 int 
ii
;

22759 for(
ii
=0; ii<
pPager
->
nSavepoint
; ii++)

22762 
	`sqlite3BitvecDestroy
(
pPager
->
aSavepoint
[
ii
].
pInSavepoint
);

22764 if( !
pPager
->
exclusiveMode
 || 
	`sqlite3JournalIsInMemory
(pPager->
sjfd
) )

22767 
	`sqlite3OsClose
(
pPager
->
sjfd
);

22769 
	`sqlite3_free
(
pPager
->
aSavepoint
);

22770 
pPager
->
aSavepoint
 = 0;

22771 
pPager
->
nSavepoint
 = 0;

22772 
pPager
->
nSubRec
 = 0;

22773 
	}
}

22780 static int 
	$addToSavepointBitvecs
(
Pager
 *
pPager
, 
Pgno
 
pgno
)

22783 int 
ii
;

22784 int 
rc
 = 0;

22786 for(
ii
=0; ii<
pPager
->
nSavepoint
; ii++)

22789 
PagerSavepoint
 *
p
 = &
pPager
->
aSavepoint
[
ii
];

22790 if( 
pgno
<=
p
->
nOrig
 )

22793 
rc
 |= 
	`sqlite3BitvecSet
(
p
->
pInSavepoint
, 
pgno
);

22798 return 
rc
;

22799 
	}
}

22801 static void 
	$pager_unlock
(
Pager
 *
pPager
)

22810 
	`sqlite3BitvecDestroy
(
pPager
->
pInJournal
);

22811 
pPager
->
pInJournal
 = 0;

22812 
	`releaseAllSavepoints
(
pPager
);

22814 if( 
	`pagerUseWal
(
pPager
) )

22818 
	`sqlite3WalEndReadTransaction
(
pPager
->
pWal
);

22819 
pPager
->
eState
 = 0;

22820 }else if( !
pPager
->
exclusiveMode
 )

22823 int 
rc
;

22824 int 
iDc
 = ((
pPager
->
fd
)->
pMethods
!=0)?
	`sqlite3OsDeviceCharacteristics
(pPager->fd):0;

22837 if( 0==(
iDc
 & 0x00000800)

22838 || 1!=(
pPager
->
journalMode
 & 5)

22842 
	`sqlite3OsClose
(
pPager
->
jfd
);

22850 
rc
 = 
	`pagerUnlockDb
(
pPager
, 0);

22851 if( 
rc
!=0 && 
pPager
->
eState
==6 )

22854 
pPager
->
eLock
 = (4 +1);

22862 
pPager
->
changeCountDone
 = 0;

22863 
pPager
->
eState
 = 0;

22871 if( 
pPager
->
errCode
 )

22875 
	`pager_reset
(
pPager
);

22876 
pPager
->
changeCountDone
 = pPager->
tempFile
;

22877 
pPager
->
eState
 = 0;

22878 
pPager
->
errCode
 = 0;

22879 if( ((
pPager
)->
bUseFetch
) ) 
	`sqlite3OsUnfetch
(pPager->
fd
, 0, 0);

22882 
pPager
->
journalOff
 = 0;

22883 
pPager
->
journalHdr
 = 0;

22884 
pPager
->
setMaster
 = 0;

22885 
	}
}

22887 static int 
	$pager_error
(
Pager
 *
pPager
, int 
rc
)

22890 int 
rc2
 = 
rc
 & 0xff;

22897 if( 
rc2
==13 || rc2==10 )

22900 
pPager
->
errCode
 = 
rc
;

22901 
pPager
->
eState
 = 6;

22903 return 
rc
;

22904 
	}
}

22906 static int 
pager_truncate
(
Pager
 *
pPager
, 
Pgno
 
nPage
);

22908 static int 
	$pager_end_transaction
(
Pager
 *
pPager
, int 
hasMaster
, int 
bCommit
)

22911 int 
rc
 = 0;

22912 int 
rc2
 = 0;

22916 if( 
pPager
->
eState
<2 && pPager->
eLock
<2 )

22922 
	`releaseAllSavepoints
(
pPager
);

22924 if( ((
pPager
->
jfd
)->
pMethods
!=0) )

22930 if( 
	`sqlite3JournalIsInMemory
(
pPager
->
jfd
) )

22934 
	`sqlite3OsClose
(
pPager
->
jfd
);

22935 }else if( 
pPager
->
journalMode
==3 )

22938 if( 
pPager
->
journalOff
==0 )

22941 
rc
 = 0;

22943 
rc
 = 
	`sqlite3OsTruncate
(
pPager
->
jfd
, 0);

22944 if( 
rc
==0 && 
pPager
->
fullSync
 )

22952 
rc
 = 
	`sqlite3OsSync
(
pPager
->
jfd
, pPager->
syncFlags
);

22955 
pPager
->
journalOff
 = 0;

22956 }else if( 
pPager
->
journalMode
==1

22957 || (
pPager
->
exclusiveMode
 && pPager->
journalMode
!=5)

22961 
rc
 = 
	`zeroJournalHdr
(
pPager
, 
hasMaster
);

22962 
pPager
->
journalOff
 = 0;

22969 int 
bDelete
 = !
pPager
->
tempFile
;

22975 
	`sqlite3OsClose
(
pPager
->
jfd
);

22976 if( 
bDelete
 )

22979 
rc
 = 
	`sqlite3OsDelete
(
pPager
->
pVfs
, pPager->
zJournal
, pPager->
extraSync
);

22984 
	`sqlite3BitvecDestroy
(
pPager
->
pInJournal
);

22985 
pPager
->
pInJournal
 = 0;

22986 
pPager
->
nRec
 = 0;

22987 
	`sqlite3PcacheCleanAll
(
pPager
->
pPCache
);

22988 
	`sqlite3PcacheTruncate
(
pPager
->
pPCache
, pPager->
dbSize
);

22990 if( 
	`pagerUseWal
(
pPager
) )

22997 
rc2
 = 
	`sqlite3WalEndWriteTransaction
(
pPager
->
pWal
);

22999 }else if( 
rc
==0 && 
bCommit
 && 
pPager
->
dbFileSize
>pPager->
dbSize
 )

23009 
rc
 = 
	`pager_truncate
(
pPager
, pPager->
dbSize
);

23012 if( 
rc
==0 && 
bCommit
 && ((
pPager
->
fd
)->
pMethods
!=0) )

23015 
rc
 = 
	`sqlite3OsFileControl
(
pPager
->
fd
, 22, 0);

23016 if( 
rc
==12 ) rc = 0;

23019 if( !
pPager
->
exclusiveMode


23020 && (!
	`pagerUseWal
(
pPager
) || 
	`sqlite3WalExclusiveMode
(pPager->
pWal
, 0))

23024 
rc2
 = 
	`pagerUnlockDb
(
pPager
, 1);

23025 
pPager
->
changeCountDone
 = 0;

23027 
pPager
->
eState
 = 1;

23028 
pPager
->
setMaster
 = 0;

23030 return (
rc
==0?
rc2
:rc);

23031 
	}
}

23033 static void 
	$pagerUnlockAndRollback
(
Pager
 *
pPager
)

23036 if( 
pPager
->
eState
!=6 && pPager->eState!=0 )

23040 if( 
pPager
->
eState
>=2 )

23043 
	`sqlite3BeginBenignMalloc
();

23044 
	`sqlite3PagerRollback
(
pPager
);

23045 
	`sqlite3EndBenignMalloc
();

23046 }else if( !
pPager
->
exclusiveMode
 )

23050 
	`pager_end_transaction
(
pPager
, 0, 0);

23053 
	`pager_unlock
(
pPager
);

23054 
	}
}

23056 static 
u32
 
	$pager_cksum
(
Pager
 *
pPager
, const 
u8
 *
aData
)

23059 
u32
 
cksum
 = 
pPager
->
cksumInit
;

23060 int 
i
 = 
pPager
->
pageSize
-200;

23061 while( 
i
>0 )

23064 
cksum
 += 
aData
[
i
];

23065 
i
 -= 200;

23067 return 
cksum
;

23068 
	}
}

23070 static int 
	$pager_playback_one_page
(

23071 
Pager
 *
pPager
,

23072 
i64
 *
pOffset
,

23073 
Bitvec
 *
pDone
,

23074 int 
isMainJrnl
,

23075 int 
isSavepnt


23079 int 
rc
;

23080 
PgHdr
 *
pPg
;

23081 
Pgno
 
pgno
;

23082 
u32
 
cksum
;

23083 char *
aData
;

23084 
sqlite3_file
 *
jfd
;

23085 int 
isSynced
;

23092 
aData
 = 
pPager
->
pTmpSpace
;

23110 
jfd
 = 
isMainJrnl
 ? 
pPager
->jfd : pPager->
sjfd
;

23111 
rc
 = 
	`read32bits
(
jfd
, *
pOffset
, &
pgno
);

23112 if( 
rc
!=0 ) return rc;

23113 
rc
 = 
	`sqlite3OsRead
(
jfd
, (
u8
*)
aData
, 
pPager
->
pageSize
, (*
pOffset
)+4);

23114 if( 
rc
!=0 ) return rc;

23115 *
pOffset
 += 
pPager
->
pageSize
 + 4 + 
isMainJrnl
*4;

23122 if( 
pgno
==0 || pgno==((
Pgno
)((
sqlite3PendingByte
/((
pPager
)->
pageSize
))+1)) )

23128 if( 
pgno
>(
Pgno
)
pPager
->
dbSize
 || 
	`sqlite3BitvecTest
(
pDone
, pgno) )

23133 if( 
isMainJrnl
 )

23136 
rc
 = 
	`read32bits
(
jfd
, (*
pOffset
)-4, &
cksum
);

23137 if( 
rc
 ) return rc;

23138 if( !
isSavepnt
 && 
	`pager_cksum
(
pPager
, (
u8
*)
aData
)!=
cksum
 )

23148 if( 
pDone
 && (
rc
 = 
	`sqlite3BitvecSet
(pDone, 
pgno
))!=0 )

23151 return 
rc
;

23156 if( 
pgno
==1 && 
pPager
->
nReserve
!=((
u8
*)
aData
)[20] )

23159 
pPager
->
nReserve
 = ((
u8
*)
aData
)[20];

23163 if( 
	`pagerUseWal
(
pPager
) )

23166 
pPg
 = 0;

23168 
pPg
 = 
	`sqlite3PagerLookup
(
pPager
, 
pgno
);

23176 if( 
isMainJrnl
 )

23179 
isSynced
 = 
pPager
->
noSync
 || (*
pOffset
 <= pPager->
journalHdr
);

23181 
isSynced
 = (
pPg
==0 || 0==(pPg->
flags
 & 0x008));

23183 if( ((
pPager
->
fd
)->
pMethods
!=0)

23184 && (
pPager
->
eState
>=4 || pPager->eState==0)

23185 && 
isSynced


23189 
i64
 
ofst
 = (
pgno
-1)*(i64)
pPager
->
pageSize
;

23192 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
fd
, (
u8
 *)
aData
, pPager->
pageSize
, 
ofst
);

23193 if( 
pgno
>
pPager
->
dbFileSize
 )

23196 
pPager
->
dbFileSize
 = 
pgno
;

23198 if( 
pPager
->
pBackup
 )

23202 
	`sqlite3BackupUpdate
(
pPager
->
pBackup
, 
pgno
, (
u8
*)
aData
);

23203 
aData
=(char*)aData;

23205 }else if( !
isMainJrnl
 && 
pPg
==0 )

23211 
pPager
->
doNotSpill
 |= 0x02;

23212 
rc
 = 
	`sqlite3PagerGet
(
pPager
, 
pgno
, &
pPg
, 1);

23214 
pPager
->
doNotSpill
 &= ~0x02;

23215 if( 
rc
!=0 ) return rc;

23216 
pPg
->
flags
 &= ~0x010;

23217 
	`sqlite3PcacheMakeDirty
(
pPg
);

23219 if( 
pPg
 )

23228 void *
pData
;

23229 
pData
 = 
pPg
->pData;

23230 
	`memcpy
(
pData
, (
u8
*)
aData
, 
pPager
->
pageSize
);

23231 
pPager
->
	`xReiniter
(
pPg
);

23232 if( 
isMainJrnl
 && (!
isSavepnt
 || *
pOffset
<=
pPager
->
journalHdr
) )

23237 
	`sqlite3PcacheMakeClean
(
pPg
);

23243 if( 
pgno
==1 )

23246 
	`memcpy
(&
pPager
->
dbFileVers
, &((
u8
*)
pData
)[24],sizeof(pPager->dbFileVers));

23251 
	`sqlite3PcacheRelease
(
pPg
);

23253 return 
rc
;

23254 
	}
}

23256 static int 
	$pager_delmaster
(
Pager
 *
pPager
, const char *
zMaster
)

23259 
sqlite3_vfs
 *
pVfs
 = 
pPager
->pVfs;

23260 int 
rc
;

23261 
sqlite3_file
 *
pMaster
;

23262 
sqlite3_file
 *
pJournal
;

23263 char *
zMasterJournal
 = 0;

23264 
i64
 
nMasterJournal
;

23265 char *
zJournal
;

23266 char *
zMasterPtr
;

23267 int 
nMasterPtr
;

23272 
pMaster
 = (
sqlite3_file
 *)
	`sqlite3MallocZero
(
pVfs
->
szOsFile
 * 2);

23273 
pJournal
 = (
sqlite3_file
 *)(((
u8
 *)
pMaster
) + 
pVfs
->
szOsFile
);

23274 if( !
pMaster
 )

23277 
rc
 = 7;

23279 const int 
flags
 = (0x00000001|0x00004000);

23280 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
zMaster
, 
pMaster
, 
flags
, 0);

23282 if( 
rc
!=0 ) goto 
delmaster_out
;

23289 
rc
 = 
	`sqlite3OsFileSize
(
pMaster
, &
nMasterJournal
);

23290 if( 
rc
!=0 ) goto 
delmaster_out
;

23291 
nMasterPtr
 = 
pVfs
->
mxPathname
+1;

23292 
zMasterJournal
 = 
	`sqlite3Malloc
(
nMasterJournal
 + 
nMasterPtr
 + 1);

23293 if( !
zMasterJournal
 )

23296 
rc
 = 7;

23297 goto 
delmaster_out
;

23299 
zMasterPtr
 = &
zMasterJournal
[
nMasterJournal
+1];

23300 
rc
 = 
	`sqlite3OsRead
(
pMaster
, 
zMasterJournal
, (int)
nMasterJournal
, 0);

23301 if( 
rc
!=0 ) goto 
delmaster_out
;

23302 
zMasterJournal
[
nMasterJournal
] = 0;

23304 
zJournal
 = 
zMasterJournal
;

23305 while( (
zJournal
-
zMasterJournal
)<
nMasterJournal
 )

23308 int 
exists
;

23309 
rc
 = 
	`sqlite3OsAccess
(
pVfs
, 
zJournal
, 0, &
exists
);

23310 if( 
rc
!=0 )

23313 goto 
delmaster_out
;

23315 if( 
exists
 )

23322 int 
c
;

23323 int 
flags
 = (0x00000001|0x00000800);

23324 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
zJournal
, 
pJournal
, 
flags
, 0);

23325 if( 
rc
!=0 )

23328 goto 
delmaster_out
;

23331 
rc
 = 
	`readMasterJournal
(
pJournal
, 
zMasterPtr
, 
nMasterPtr
);

23332 
	`sqlite3OsClose
(
pJournal
);

23333 if( 
rc
!=0 )

23336 goto 
delmaster_out
;

23339 
c
 = 
zMasterPtr
[0]!=0 && 
	`strcmp
(zMasterPtr, 
zMaster
)==0;

23340 if( 
c
 )

23344 goto 
delmaster_out
;

23347 
zJournal
 += (
	`sqlite3Strlen30
(zJournal)+1);

23350 
	`sqlite3OsClose
(
pMaster
);

23351 
rc
 = 
	`sqlite3OsDelete
(
pVfs
, 
zMaster
, 0);

23353 
delmaster_out
:

23354 
	`sqlite3_free
(
zMasterJournal
);

23355 if( 
pMaster
 )

23358 
	`sqlite3OsClose
(
pMaster
);

23360 
	`sqlite3_free
(
pMaster
);

23362 return 
rc
;

23363 
	}
}

23365 static int 
	$pager_truncate
(
Pager
 *
pPager
, 
Pgno
 
nPage
)

23368 int 
rc
 = 0;

23372 if( ((
pPager
->
fd
)->
pMethods
!=0)

23373 && (
pPager
->
eState
>=4 || pPager->eState==0)

23377 
i64
 
currentSize
, 
newSize
;

23378 int 
szPage
 = 
pPager
->
pageSize
;

23381 
rc
 = 
	`sqlite3OsFileSize
(
pPager
->
fd
, &
currentSize
);

23382 
newSize
 = 
szPage
*(
i64
)
nPage
;

23383 if( 
rc
==0 && 
currentSize
!=
newSize
 )

23386 if( 
currentSize
>
newSize
 )

23389 
rc
 = 
	`sqlite3OsTruncate
(
pPager
->
fd
, 
newSize
);

23390 }else if( (
currentSize
+
szPage
)<=
newSize
 )

23393 char *
pTmp
 = 
pPager
->
pTmpSpace
;

23394 
	`memset
(
pTmp
, 0, 
szPage
);

23397 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
fd
, 
pTmp
, 
szPage
, 
newSize
-szPage);

23399 if( 
rc
==0 )

23402 
pPager
->
dbFileSize
 = 
nPage
;

23406 return 
rc
;

23407 
	}
}

23413 static int 
	$sqlite3SectorSize
(
sqlite3_file
 *
pFile
)

23416 int 
iRet
 = 
	`sqlite3OsSectorSize
(
pFile
);

23417 if( 
iRet
<32 )

23420 
iRet
 = 512;

23421 }else if( 
iRet
>0x10000 )

23425 
iRet
 = 0x10000;

23427 return 
iRet
;

23428 
	}
}

23430 static void 
	$setSectorSize
(
Pager
 *
pPager
)

23435 if( 
pPager
->
tempFile


23436 || (
	`sqlite3OsDeviceCharacteristics
(
pPager
->
fd
) &

23444 
pPager
->
sectorSize
 = 512;

23446 
pPager
->
sectorSize
 = 
	`sqlite3SectorSize
(pPager->
fd
);

23448 
	}
}

23450 static int 
	$pager_playback
(
Pager
 *
pPager
, int 
isHot
)

23453 
sqlite3_vfs
 *
pVfs
 = 
pPager
->pVfs;

23454 
i64
 
szJ
;

23455 
u32
 
nRec
;

23456 
u32
 
u
;

23457 
Pgno
 
mxPg
 = 0;

23458 int 
rc
;

23459 int 
res
 = 1;

23460 char *
zMaster
 = 0;

23461 int 
needPagerReset
;

23462 int 
nPlayback
 = 0;

23468 
rc
 = 
	`sqlite3OsFileSize
(
pPager
->
jfd
, &
szJ
);

23469 if( 
rc
!=0 )

23472 goto 
end_playback
;

23475 
zMaster
 = 
pPager
->
pTmpSpace
;

23476 
rc
 = 
	`readMasterJournal
(
pPager
->
jfd
, 
zMaster
, pPager->
pVfs
->
mxPathname
+1);

23477 if( 
rc
==0 && 
zMaster
[0] )

23480 
rc
 = 
	`sqlite3OsAccess
(
pVfs
, 
zMaster
, 0, &
res
);

23482 
zMaster
 = 0;

23483 if( 
rc
!=0 || !
res
 )

23486 goto 
end_playback
;

23488 
pPager
->
journalOff
 = 0;

23489 
needPagerReset
 = 
isHot
;

23503 
rc
 = 
	`readJournalHdr
(
pPager
, 
isHot
, 
szJ
, &
nRec
, &
mxPg
);

23504 if( 
rc
!=0 )

23507 if( 
rc
==101 )

23510 
rc
 = 0;

23512 goto 
end_playback
;

23520 if( 
nRec
==0xffffffff )

23524 
nRec
 = (int)((
szJ
 - (
pPager
->
sectorSize
))/((pPager->
pageSize
) + 8));

23527 if( 
nRec
==0 && !
isHot
 &&

23528 
pPager
->
journalHdr
+(pPager->
sectorSize
)==pPager->
journalOff
 )

23531 
nRec
 = (int)((
szJ
 - 
pPager
->
journalOff
) / ((pPager->
pageSize
) + 8));

23537 if( 
pPager
->
journalOff
==(pPager->
sectorSize
) )

23540 
rc
 = 
	`pager_truncate
(
pPager
, 
mxPg
);

23541 if( 
rc
!=0 )

23544 goto 
end_playback
;

23546 
pPager
->
dbSize
 = 
mxPg
;

23552 for(
u
=0; u<
nRec
; u++)

23555 if( 
needPagerReset
 )

23558 
	`pager_reset
(
pPager
);

23559 
needPagerReset
 = 0;

23561 
rc
 = 
	`pager_playback_one_page
(
pPager
,&pPager->
journalOff
,0,1,0);

23562 if( 
rc
==0 )

23565 
nPlayback
++;

23567 if( 
rc
==101 )

23570 
pPager
->
journalOff
 = 
szJ
;

23572 }else if( 
rc
==(10 | (2<<8)) )

23580 
rc
 = 0;

23581 goto 
end_playback
;

23588 goto 
end_playback
;

23596 
end_playback
:

23598 
pPager
->
changeCountDone
 = pPager->
tempFile
;

23600 if( 
rc
==0 )

23603 
zMaster
 = 
pPager
->
pTmpSpace
;

23604 
rc
 = 
	`readMasterJournal
(
pPager
->
jfd
, 
zMaster
, pPager->
pVfs
->
mxPathname
+1);

23607 if( 
rc
==0

23608 && (
pPager
->
eState
>=4 || pPager->eState==0)

23612 
rc
 = 
	`sqlite3PagerSync
(
pPager
, 0);

23614 if( 
rc
==0 )

23617 
rc
 = 
	`pager_end_transaction
(
pPager
, 
zMaster
[0]!='\0', 0);

23620 if( 
rc
==0 && 
zMaster
[0] && 
res
 )

23626 
rc
 = 
	`pager_delmaster
(
pPager
, 
zMaster
);

23629 if( 
isHot
 && 
nPlayback
 )

23632 
	`sqlite3_log
((27 | (2<<8)), "recovered %d pages from %s",

23633 
nPlayback
, 
pPager
->
zJournal
);

23640 
	`setSectorSize
(
pPager
);

23641 return 
rc
;

23642 
	}
}

23644 static int 
	$readDbPage
(
PgHdr
 *
pPg
, 
u32
 
iFrame
)

23647 
Pager
 *
pPager
 = 
pPg
->pPager;

23648 
Pgno
 
pgno
 = 
pPg
->pgno;

23649 int 
rc
 = 0;

23650 int 
pgsz
 = 
pPager
->
pageSize
;

23656 if( 
iFrame
 )

23660 
rc
 = 
	`sqlite3WalReadFrame
(
pPager
->
pWal
, 
iFrame
, 
pgsz
, 
pPg
->
pData
);

23664 
i64
 
iOffset
 = (
pgno
-1)*(i64)
pPager
->
pageSize
;

23665 
rc
 = 
	`sqlite3OsRead
(
pPager
->
fd
, 
pPg
->
pData
, 
pgsz
, 
iOffset
);

23666 if( 
rc
==(10 | (2<<8)) )

23669 
rc
 = 0;

23673 if( 
pgno
==1 )

23676 if( 
rc
 )

23680 
	`memset
(
pPager
->
dbFileVers
, 0xff, sizeof(pPager->dbFileVers));

23682 
u8
 *
dbFileVers
 = &((u8*)
pPg
->
pData
)[24];

23683 
	`memcpy
(&
pPager
->
dbFileVers
, dbFileVers, sizeof(pPager->dbFileVers));

23694 return 
rc
;

23695 
	}
}

23697 static void 
	$pager_write_changecounter
(
PgHdr
 *
pPg
)

23700 
u32
 
change_counter
;

23703 
change_counter
 = 
	`sqlite3Get4byte
((
u8
*)
pPg
->
pPager
->
dbFileVers
)+1;

23704 
	`sqlite3Put4byte
((
u8
*)((char*)
pPg
->
pData
)+24,
change_counter
);

23709 
	`sqlite3Put4byte
((
u8
*)((char*)
pPg
->
pData
)+92,
change_counter
);

23710 
	`sqlite3Put4byte
((
u8
*)((char*)
pPg
->
pData
)+96,3012000);

23711 
	}
}

23713 static int 
	$pagerUndoCallback
(void *
pCtx
, 
Pgno
 
iPg
)

23716 int 
rc
 = 0;

23717 
Pager
 *
pPager
 = (Pager *)
pCtx
;

23718 
PgHdr
 *
pPg
;

23721 
pPg
 = 
	`sqlite3PagerLookup
(
pPager
, 
iPg
);

23722 if( 
pPg
 )

23725 if( 
	`sqlite3PcachePageRefcount
(
pPg
)==1 )

23728 
	`sqlite3PcacheDrop
(
pPg
);

23730 
u32
 
iFrame
 = 0;

23731 
rc
 = 
	`sqlite3WalFindFrame
(
pPager
->
pWal
, 
pPg
->
pgno
, &
iFrame
);

23732 if( 
rc
==0 )

23735 
rc
 = 
	`readDbPage
(
pPg
, 
iFrame
);

23737 if( 
rc
==0 )

23740 
pPager
->
	`xReiniter
(
pPg
);

23742 
	`sqlite3PagerUnrefNotNull
(
pPg
);

23746 
	`sqlite3BackupRestart
(
pPager
->
pBackup
);

23748 return 
rc
;

23749 
	}
}

23754 static int 
	$pagerRollbackWal
(
Pager
 *
pPager
)

23757 int 
rc
;

23758 
PgHdr
 *
pList
;

23760 
pPager
->
dbSize
 = pPager->
dbOrigSize
;

23761 
rc
 = 
	`sqlite3WalUndo
(
pPager
->
pWal
, 
pagerUndoCallback
, (void *)pPager);

23762 
pList
 = 
	`sqlite3PcacheDirtyList
(
pPager
->
pPCache
);

23763 while( 
pList
 && 
rc
==0 )

23766 
PgHdr
 *
pNext
 = 
pList
->
pDirty
;

23767 
rc
 = 
	`pagerUndoCallback
((void *)
pPager
, 
pList
->
pgno
);

23768 
pList
 = 
pNext
;

23771 return 
rc
;

23772 
	}
}

23774 static int 
	$pagerWalFrames
(

23775 
Pager
 *
pPager
,

23776 
PgHdr
 *
pList
,

23777 
Pgno
 
nTruncate
,

23778 int 
isCommit


23782 int 
rc
;

23783 int 
nList
;

23784 
PgHdr
 *
p
;

23796 if( 
isCommit
 )

23803 
PgHdr
 **
ppNext
 = &
pList
;

23804 
nList
 = 0;

23805 for(
p
=
pList
; (*
ppNext
 = p)!=0; p=p->
pDirty
)

23808 if( 
p
->
pgno
<=
nTruncate
 )

23811 
ppNext
 = &
p
->
pDirty
;

23812 
nList
++;

23817 
nList
 = 1;

23819 
pPager
->
aStat
[2] += 
nList
;

23821 if( 
pList
->
pgno
==1 ) 
	`pager_write_changecounter
(pList);

23822 
rc
 = 
	`sqlite3WalFrames
(
pPager
->
pWal
,

23823 
pPager
->
pageSize
, 
pList
, 
nTruncate
, 
isCommit
, pPager->
walSyncFlags


23825 if( 
rc
==0 && 
pPager
->
pBackup
 )

23828 for(
p
=
pList
; p; p=p->
pDirty
)

23831 
	`sqlite3BackupUpdate
(
pPager
->
pBackup
, 
p
->
pgno
, (
u8
 *)p->
pData
);

23835 return 
rc
;

23836 
	}
}

23838 static int 
	$pagerBeginReadTransaction
(
Pager
 *
pPager
)

23841 int 
rc
;

23842 int 
changed
 = 0;

23852 
	`sqlite3WalEndReadTransaction
(
pPager
->
pWal
);

23854 
rc
 = 
	`sqlite3WalBeginReadTransaction
(
pPager
->
pWal
, &
changed
);

23855 if( 
rc
!=0 || 
changed
 )

23858 
	`pager_reset
(
pPager
);

23859 if( ((
pPager
)->
bUseFetch
) ) 
	`sqlite3OsUnfetch
(pPager->
fd
, 0, 0);

23862 return 
rc
;

23863 
	}
}

23865 static int 
	$pagerPagecount
(
Pager
 *
pPager
, 
Pgno
 *
pnPage
)

23868 
Pgno
 
nPage
;

23878 
nPage
 = 
	`sqlite3WalDbsize
(
pPager
->
pWal
);

23885 if( 
nPage
==0 )

23888 
i64
 
n
 = 0;

23890 if( ((
pPager
->
fd
)->
pMethods
!=0) )

23893 int 
rc
 = 
	`sqlite3OsFileSize
(
pPager
->
fd
, &
n
);

23894 if( 
rc
!=0 )

23897 return 
rc
;

23900 
nPage
 = (
Pgno
)((
n
+
pPager
->
pageSize
-1) / pPager->pageSize);

23907 if( 
nPage
>
pPager
->
mxPgno
 )

23910 
pPager
->
mxPgno
 = (
Pgno
)
nPage
;

23913 *
pnPage
 = 
nPage
;

23915 
	}
}

23917 static int 
	$pagerOpenWalIfPresent
(
Pager
 *
pPager
)

23920 int 
rc
 = 0;

23924 if( !
pPager
->
tempFile
 )

23927 int 
isWal
;

23928 
Pgno
 
nPage
;

23930 
rc
 = 
	`pagerPagecount
(
pPager
, &
nPage
);

23931 if( 
rc
 ) return rc;

23932 if( 
nPage
==0 )

23935 
rc
 = 
	`sqlite3OsDelete
(
pPager
->
pVfs
, pPager->
zWal
, 0);

23936 if( 
rc
==(10 | (23<<8)) ) rc = 0;

23937 
isWal
 = 0;

23939 
rc
 = 
	`sqlite3OsAccess
(

23940 
pPager
->
pVfs
, pPager->
zWal
, 0, &
isWal


23943 if( 
rc
==0 )

23946 if( 
isWal
 )

23950 
rc
 = 
	`sqlite3PagerOpenWal
(
pPager
, 0);

23951 }else if( 
pPager
->
journalMode
==5 )

23954 
pPager
->
journalMode
 = 0;

23958 return 
rc
;

23959 
	}
}

23961 static int 
	$pagerPlaybackSavepoint
(
Pager
 *
pPager
, 
PagerSavepoint
 *
pSavepoint
)

23964 
i64
 
szJ
;

23965 
i64
 
iHdrOff
;

23966 int 
rc
 = 0;

23967 
Bitvec
 *
pDone
 = 0;

23973 if( 
pSavepoint
 )

23976 
pDone
 = 
	`sqlite3BitvecCreate
(
pSavepoint
->
nOrig
);

23977 if( !
pDone
 )

23987 
pPager
->
dbSize
 = 
pSavepoint
 ? pSavepoint->
nOrig
 : pPager->
dbOrigSize
;

23988 
pPager
->
changeCountDone
 = pPager->
tempFile
;

23990 if( !
pSavepoint
 && 
	`pagerUseWal
(
pPager
) )

23993 return 
	`pagerRollbackWal
(
pPager
);

24001 
szJ
 = 
pPager
->
journalOff
;

24004 if( 
pSavepoint
 && !
	`pagerUseWal
(
pPager
) )

24007 
iHdrOff
 = 
pSavepoint
->
iHdrOffset
 ? pSavepoint->iHdrOffset : 
szJ
;

24008 
pPager
->
journalOff
 = 
pSavepoint
->
iOffset
;

24009 while( 
rc
==0 && 
pPager
->
journalOff
<
iHdrOff
 )

24012 
rc
 = 
	`pager_playback_one_page
(
pPager
, &pPager->
journalOff
, 
pDone
, 1, 1);

24016 
pPager
->
journalOff
 = 0;

24024 while( 
rc
==0 && 
pPager
->
journalOff
<
szJ
 )

24027 
u32
 
ii
;

24028 
u32
 
nJRec
 = 0;

24029 
u32
 
dummy
;

24030 
rc
 = 
	`readJournalHdr
(
pPager
, 0, 
szJ
, &
nJRec
, &
dummy
);

24038 if( 
nJRec
==0

24039 && 
pPager
->
journalHdr
+(pPager->
sectorSize
)==pPager->
journalOff


24043 
nJRec
 = (
u32
)((
szJ
 - 
pPager
->
journalOff
)/((pPager->
pageSize
) + 8));

24045 for(
ii
=0; 
rc
==0 && ii<
nJRec
 && 
pPager
->
journalOff
<
szJ
; ii++)

24048 
rc
 = 
	`pager_playback_one_page
(
pPager
, &pPager->
journalOff
, 
pDone
, 1, 1);

24058 if( 
pSavepoint
 )

24061 
u32
 
ii
;

24062 
i64
 
offset
 = (i64)
pSavepoint
->
iSubRec
*(4+
pPager
->
pageSize
);

24064 if( 
	`pagerUseWal
(
pPager
) )

24067 
rc
 = 
	`sqlite3WalSavepointUndo
(
pPager
->
pWal
, 
pSavepoint
->
aWalData
);

24069 for(
ii
=
pSavepoint
->
iSubRec
; 
rc
==0 && ii<
pPager
->
nSubRec
; ii++)

24073 
rc
 = 
	`pager_playback_one_page
(
pPager
, &
offset
, 
pDone
, 0, 1);

24078 
	`sqlite3BitvecDestroy
(
pDone
);

24079 if( 
rc
==0 )

24082 
pPager
->
journalOff
 = 
szJ
;

24085 return 
rc
;

24086 
	}
}

24092 static void 
	$sqlite3PagerSetCachesize
(
Pager
 *
pPager
, int 
mxPage
)

24095 
	`sqlite3PcacheSetCachesize
(
pPager
->
pPCache
, 
mxPage
);

24096 
	}
}

24102 static int 
	$sqlite3PagerSetSpillsize
(
Pager
 *
pPager
, int 
mxPage
)

24105 return 
	`sqlite3PcacheSetSpillsize
(
pPager
->
pPCache
, 
mxPage
);

24106 
	}
}

24111 static void 
	$pagerFixMaplimit
(
Pager
 *
pPager
)

24115 
sqlite3_file
 *
fd
 = 
pPager
->fd;

24116 if( ((
fd
)->
pMethods
!=0) && fd->pMethods->
iVersion
>=3 )

24119 
sqlite3_int64
 
sz
;

24120 
sz
 = 
pPager
->
szMmap
;

24121 
pPager
->
bUseFetch
 = (
sz
>0);

24122 
	`sqlite3OsFileControlHint
(
pPager
->
fd
, 18, &
sz
);

24125 
	}
}

24130 static void 
	$sqlite3PagerSetMmapLimit
(
Pager
 *
pPager
, 
sqlite3_int64
 
szMmap
)

24133 
pPager
->
szMmap
 = szMmap;

24134 
	`pagerFixMaplimit
(
pPager
);

24135 
	}
}

24140 static void 
	$sqlite3PagerShrink
(
Pager
 *
pPager
)

24143 
	`sqlite3PcacheShrink
(
pPager
->
pPCache
);

24144 
	}
}

24146 static void 
	$sqlite3PagerSetFlags
(

24147 
Pager
 *
pPager
,

24148 unsigned 
pgFlags


24152 unsigned 
level
 = 
pgFlags
 & 0x07;

24153 if( 
pPager
->
tempFile
 )

24156 
pPager
->
noSync
 = 1;

24157 
pPager
->
fullSync
 = 0;

24158 
pPager
->
extraSync
 = 0;

24160 
pPager
->
noSync
 = 
level
==0x01 ?1:0;

24161 
pPager
->
fullSync
 = 
level
>=0x03 ?1:0;

24162 
pPager
->
extraSync
 = 
level
==0x04 ?1:0;

24164 if( 
pPager
->
noSync
 )

24167 
pPager
->
syncFlags
 = 0;

24168 
pPager
->
ckptSyncFlags
 = 0;

24169 }else if( 
pgFlags
 & 0x08 )

24172 
pPager
->
syncFlags
 = 0x00003;

24173 
pPager
->
ckptSyncFlags
 = 0x00003;

24174 }else if( 
pgFlags
 & 0x10 )

24177 
pPager
->
syncFlags
 = 0x00002;

24178 
pPager
->
ckptSyncFlags
 = 0x00003;

24180 
pPager
->
syncFlags
 = 0x00002;

24181 
pPager
->
ckptSyncFlags
 = 0x00002;

24183 
pPager
->
walSyncFlags
 = pPager->
syncFlags
;

24184 if( 
pPager
->
fullSync
 )

24187 
pPager
->
walSyncFlags
 |= 0x20;

24189 if( 
pgFlags
 & 0x20 )

24192 
pPager
->
doNotSpill
 &= ~0x01;

24194 
pPager
->
doNotSpill
 |= 0x01;

24196 
	}
}

24198 static int 
	$pagerOpentemp
(

24199 
Pager
 *
pPager
,

24200 
sqlite3_file
 *
pFile
,

24201 int 
vfsFlags


24205 int 
rc
;

24211 
vfsFlags
 |= 0x00000002 | 0x00000004 |

24213 
rc
 = 
	`sqlite3OsOpen
(
pPager
->
pVfs
, 0, 
pFile
, 
vfsFlags
, 0);

24215 return 
rc
;

24216 
	}
}

24218 static void 
sqlite3PagerSetBusyhandler
(

24219 
Pager
 *
pPager
,

24220 int (*
xBusyHandler
)(void *),

24221 void *
pBusyHandlerArg


24225 
pPager
->
xBusyHandler
 = xBusyHandler;

24226 
pPager
->
pBusyHandlerArg
 = pBusyHandlerArg;

24228 if( ((
pPager
->
fd
)->
pMethods
!=0) )

24231 void **
ap
 = (void **)&
pPager
->
xBusyHandler
;

24234 
	`sqlite3OsFileControlHint
(
pPager
->
fd
, 15, (void *)
ap
);

24236 
	}
}

24238 static int 
	$sqlite3PagerSetPagesize
(
Pager
 *
pPager
, 
u32
 *
pPageSize
, int 
nReserve
)

24241 int 
rc
 = 0;

24243 
u32
 
pageSize
 = *
pPageSize
;

24245 if( (
pPager
->
memDb
==0 || pPager->
dbSize
==0)

24246 && 
	`sqlite3PcacheRefCount
(
pPager
->
pPCache
)==0

24247 && 
pageSize
 && pageSize!=(
u32
)
pPager
->pageSize

24251 char *
pNew
 = ((void *)0);

24252 
i64
 
nByte
 = 0;

24254 if( 
pPager
->
eState
>0 && ((pPager->
fd
)->
pMethods
!=0) )

24257 
rc
 = 
	`sqlite3OsFileSize
(
pPager
->
fd
, &
nByte
);

24259 if( 
rc
==0 )

24262 
pNew
 = (char *)
	`sqlite3PageMalloc
(
pageSize
);

24263 if( !
pNew
 ) 
rc
 = 7;

24266 if( 
rc
==0 )

24269 
	`pager_reset
(
pPager
);

24270 
rc
 = 
	`sqlite3PcacheSetPageSize
(
pPager
->
pPCache
, 
pageSize
);

24272 if( 
rc
==0 )

24275 
	`sqlite3PageFree
(
pPager
->
pTmpSpace
);

24276 
pPager
->
pTmpSpace
 = 
pNew
;

24277 
pPager
->
dbSize
 = (
Pgno
)((
nByte
+
pageSize
-1)/pageSize);

24278 
pPager
->
pageSize
 = pageSize;

24280 
	`sqlite3PageFree
(
pNew
);

24284 *
pPageSize
 = 
pPager
->
pageSize
;

24285 if( 
rc
==0 )

24288 if( 
nReserve
<0 ) nReserve = 
pPager
->nReserve;

24290 
pPager
->
nReserve
 = (
i16
)nReserve;

24292 
	`pagerFixMaplimit
(
pPager
);

24294 return 
rc
;

24295 
	}
}

24297 static void *
	$sqlite3PagerTempSpace
(
Pager
 *
pPager
)

24300 return 
pPager
->
pTmpSpace
;

24301 
	}
}

24303 static int 
	$sqlite3PagerMaxPageCount
(
Pager
 *
pPager
, int 
mxPage
)

24306 if( 
mxPage
>0 )

24309 
pPager
->
mxPgno
 = 
mxPage
;

24313 return 
pPager
->
mxPgno
;

24314 
	}
}

24316 static int 
	$sqlite3PagerReadFileheader
(
Pager
 *
pPager
, int 
N
, unsigned char *
pDest
)

24319 int 
rc
 = 0;

24320 
	`memset
(
pDest
, 0, 
N
);

24329 if( ((
pPager
->
fd
)->
pMethods
!=0) )

24333 
rc
 = 
	`sqlite3OsRead
(
pPager
->
fd
, 
pDest
, 
N
, 0);

24334 if( 
rc
==(10 | (2<<8)) )

24337 
rc
 = 0;

24340 return 
rc
;

24341 
	}
}

24343 static void 
	$sqlite3PagerPagecount
(
Pager
 *
pPager
, int *
pnPage
)

24348 *
pnPage
 = (int)
pPager
->
dbSize
;

24349 
	}
}

24351 static int 
	$pager_wait_on_lock
(
Pager
 *
pPager
, int 
locktype
)

24354 int 
rc
;

24367 
rc
 = 
	`pagerLockDb
(
pPager
, 
locktype
);

24368 }while( 
rc
==5 && 
pPager
->
	`xBusyHandler
(pPager->
pBusyHandlerArg
) );

24369 return 
rc
;

24370 
	}
}

24372 static void 
	$sqlite3PagerTruncateImage
(
Pager
 *
pPager
, 
Pgno
 
nPage
)

24377 
pPager
->
dbSize
 = 
nPage
;

24379 
	}
}

24381 static int 
	$pagerSyncHotJournal
(
Pager
 *
pPager
)

24384 int 
rc
 = 0;

24385 if( !
pPager
->
noSync
 )

24388 
rc
 = 
	`sqlite3OsSync
(
pPager
->
jfd
, 0x00002);

24390 if( 
rc
==0 )

24393 
rc
 = 
	`sqlite3OsFileSize
(
pPager
->
jfd
, &pPager->
journalHdr
);

24395 return 
rc
;

24396 
	}
}

24398 static int 
	$pagerAcquireMapPage
(

24399 
Pager
 *
pPager
,

24400 
Pgno
 
pgno
,

24401 void *
pData
,

24402 
PgHdr
 **
ppPage


24406 
PgHdr
 *
p
;

24408 if( 
pPager
->
pMmapFreelist
 )

24411 *
ppPage
 = 
p
 = 
pPager
->
pMmapFreelist
;

24412 
pPager
->
pMmapFreelist
 = 
p
->
pDirty
;

24413 
p
->
pDirty
 = 0;

24414 
	`memset
(
p
->
pExtra
, 0, 
pPager
->
nExtra
);

24416 *
ppPage
 = 
p
 = (
PgHdr
 *)
	`sqlite3MallocZero
(sizeof(PgHdr) + 
pPager
->
nExtra
);

24417 if( 
p
==0 )

24420 
	`sqlite3OsUnfetch
(
pPager
->
fd
, (
i64
)(
pgno
-1) * pPager->
pageSize
, 
pData
);

24423 
p
->
pExtra
 = (void *)&p[1];

24424 
p
->
flags
 = 0x040;

24425 
p
->
nRef
 = 1;

24426 
p
->
pPager
 = pPager;

24435 
p
->
pgno
 = pgno;

24436 
p
->
pData
 = pData;

24437 
pPager
->
nMmapOut
++;

24440 
	}
}

24446 static void 
	$pagerReleaseMapPage
(
PgHdr
 *
pPg
)

24449 
Pager
 *
pPager
 = 
pPg
->pPager;

24450 
pPager
->
nMmapOut
--;

24451 
pPg
->
pDirty
 = 
pPager
->
pMmapFreelist
;

24452 
pPager
->
pMmapFreelist
 = 
pPg
;

24455 
	`sqlite3OsUnfetch
(
pPager
->
fd
, (
i64
)(
pPg
->
pgno
-1)*pPager->
pageSize
, pPg->
pData
);

24456 
	}
}

24461 static void 
	$pagerFreeMapHdrs
(
Pager
 *
pPager
)

24464 
PgHdr
 *
p
;

24465 
PgHdr
 *
pNext
;

24466 for(
p
=
pPager
->
pMmapFreelist
; p; p=
pNext
)

24469 
pNext
 = 
p
->
pDirty
;

24470 
	`sqlite3_free
(
p
);

24472 
	}
}

24474 static int 
	$sqlite3PagerClose
(
Pager
 *
pPager
)

24477 
u8
 *
pTmp
 = (u8 *)
pPager
->
pTmpSpace
;

24481 
	`sqlite3BeginBenignMalloc
();

24482 
	`pagerFreeMapHdrs
(
pPager
);

24484 
pPager
->
exclusiveMode
 = 0;

24486 
	`sqlite3WalClose
(
pPager
->
pWal
, pPager->
ckptSyncFlags
, pPager->
pageSize
, 
pTmp
);

24487 
pPager
->
pWal
 = 0;

24489 
	`pager_reset
(
pPager
);

24490 if( 
pPager
->
memDb
 )

24493 
	`pager_unlock
(
pPager
);

24496 if( ((
pPager
->
jfd
)->
pMethods
!=0) )

24499 
	`pager_error
(
pPager
, 
	`pagerSyncHotJournal
(pPager));

24501 
	`pagerUnlockAndRollback
(
pPager
);

24503 
	`sqlite3EndBenignMalloc
();

24507 
	`sqlite3OsClose
(
pPager
->
jfd
);

24508 
	`sqlite3OsClose
(
pPager
->
fd
);

24509 
	`sqlite3PageFree
(
pTmp
);

24510 
	`sqlite3PcacheClose
(
pPager
->
pPCache
);

24519 
	`sqlite3_free
(
pPager
);

24521 
	}
}

24523 static void 
	$sqlite3PagerRef
(
DbPage
 *
pPg
)

24526 
	`sqlite3PcacheRef
(
pPg
);

24527 
	}
}

24529 static int 
	$syncJournal
(
Pager
 *
pPager
, int 
newHdr
)

24532 int 
rc
;

24540 
rc
 = 
	`sqlite3PagerExclusiveLock
(
pPager
);

24541 if( 
rc
!=0 ) return rc;

24543 if( !
pPager
->
noSync
 )

24547 if( ((
pPager
->
jfd
)->
pMethods
!=0) && pPager->
journalMode
!=4 )

24550 const int 
iDc
 = 
	`sqlite3OsDeviceCharacteristics
(
pPager
->
fd
);

24553 if( 0==(
iDc
&0x00000200) )

24557 
i64
 
iNextHdrOffset
;

24558 
u8
 
aMagic
[8];

24559 
u8
 
zHeader
[sizeof(
aJournalMagic
)+4];

24561 
	`memcpy
(
zHeader
, 
aJournalMagic
, sizeof(aJournalMagic));

24562 
	`sqlite3Put4byte
((
u8
*)&
zHeader
[sizeof(
aJournalMagic
)],
pPager
->
nRec
);

24564 
iNextHdrOffset
 = 
	`journalHdrOffset
(
pPager
);

24565 
rc
 = 
	`sqlite3OsRead
(
pPager
->
jfd
, 
aMagic
, 8, 
iNextHdrOffset
);

24566 if( 
rc
==0 && 0==
	`memcmp
(
aMagic
, 
aJournalMagic
, 8) )

24569 static const 
u8
 
zerobyte
 = 0;

24570 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
jfd
, &
zerobyte
, 1, 
iNextHdrOffset
);

24572 if( 
rc
!=0 && rc!=(10 | (2<<8)) )

24575 return 
rc
;

24578 if( 
pPager
->
fullSync
 && 0==(
iDc
&0x00000400) )

24583 
rc
 = 
	`sqlite3OsSync
(
pPager
->
jfd
, pPager->
syncFlags
);

24584 if( 
rc
!=0 ) return rc;

24587 
rc
 = 
	`sqlite3OsWrite
(

24588 
pPager
->
jfd
, 
zHeader
, sizeof(zHeader), pPager->
journalHdr


24590 if( 
rc
!=0 ) return rc;

24592 if( 0==(
iDc
&0x00000400) )

24597 
rc
 = 
	`sqlite3OsSync
(
pPager
->
jfd
, pPager->
syncFlags
|

24598 (
pPager
->
syncFlags
==0x00003?0x00010:0)

24600 if( 
rc
!=0 ) return rc;

24603 
pPager
->
journalHdr
 = pPager->
journalOff
;

24604 if( 
newHdr
 && 0==(
iDc
&0x00000200) )

24607 
pPager
->
nRec
 = 0;

24608 
rc
 = 
	`writeJournalHdr
(
pPager
);

24609 if( 
rc
!=0 ) return rc;

24612 
pPager
->
journalHdr
 = pPager->
journalOff
;

24620 
	`sqlite3PcacheClearSyncFlags
(
pPager
->
pPCache
);

24621 
pPager
->
eState
 = 4;

24624 
	}
}

24626 static int 
	$pager_write_pagelist
(
Pager
 *
pPager
, 
PgHdr
 *
pList
)

24629 int 
rc
 = 0;

24640 if( !((
pPager
->
fd
)->
pMethods
!=0) )

24644 
rc
 = 
	`pagerOpentemp
(
pPager
, pPager->
fd
, pPager->
vfsFlags
);

24651 if( 
rc
==0

24652 && 
pPager
->
dbHintSize
<pPager->
dbSize


24653 && (
pList
->
pDirty
 || pList->
pgno
>
pPager
->
dbHintSize
)

24657 
sqlite3_int64
 
szFile
 = 
pPager
->
pageSize
 * (sqlite3_int64)pPager->
dbSize
;

24658 
	`sqlite3OsFileControlHint
(
pPager
->
fd
, 5, &
szFile
);

24659 
pPager
->
dbHintSize
 = pPager->
dbSize
;

24662 while( 
rc
==0 && 
pList
 )

24665 
Pgno
 
pgno
 = 
pList
->pgno;

24667 if( 
pgno
<=
pPager
->
dbSize
 && 0==(
pList
->
flags
&0x020) )

24670 
i64
 
offset
 = (
pgno
-1)*(i64)
pPager
->
pageSize
;

24671 char *
pData
;

24674 if( 
pList
->
pgno
==1 ) 
	`pager_write_changecounter
(pList);

24677 
pData
=(char*)
pList
->pData;

24680 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
fd
, 
pData
, pPager->
pageSize
, 
offset
);

24686 if( 
pgno
==1 )

24689 
	`memcpy
(&
pPager
->
dbFileVers
, &
pData
[24], sizeof(pPager->dbFileVers));

24691 if( 
pgno
>
pPager
->
dbFileSize
 )

24694 
pPager
->
dbFileSize
 = 
pgno
;

24696 
pPager
->
aStat
[2]++;

24699 
	`sqlite3BackupUpdate
(
pPager
->
pBackup
, 
pgno
, (
u8
*)
pList
->
pData
);

24709 
pList
 = pList->
pDirty
;

24712 return 
rc
;

24713 
	}
}

24715 static int 
	$openSubJournal
(
Pager
 *
pPager
)

24718 int 
rc
 = 0;

24719 if( !((
pPager
->
sjfd
)->
pMethods
!=0) )

24722 const int 
flags
 = 0x00002000 | 0x00000002

24725 int 
nStmtSpill
 = 
sqlite3Config
.nStmtSpill;

24726 if( 
pPager
->
journalMode
==4 || pPager->
subjInMemory
 )

24729 
nStmtSpill
 = -1;

24731 
rc
 = 
	`sqlite3JournalOpen
(
pPager
->
pVfs
, 0, pPager->
sjfd
, 
flags
, 
nStmtSpill
);

24733 return 
rc
;

24734 
	}
}

24736 static int 
	$subjournalPage
(
PgHdr
 *
pPg
)

24739 int 
rc
 = 0;

24740 
Pager
 *
pPager
 = 
pPg
->pPager;

24741 if( 
pPager
->
journalMode
!=2 )

24753 
rc
 = 
	`openSubJournal
(
pPager
);

24757 if( 
rc
==0 )

24760 void *
pData
 = 
pPg
->pData;

24761 
i64
 
offset
 = (i64)
pPager
->
nSubRec
*(4+pPager->
pageSize
);

24762 char *
pData2
;

24764 
pData2
=(char*)
pData
;

24766 
rc
 = 
	`write32bits
(
pPager
->
sjfd
, 
offset
, 
pPg
->
pgno
);

24767 if( 
rc
==0 )

24770 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
sjfd
, 
pData2
, pPager->
pageSize
, 
offset
+4);

24774 if( 
rc
==0 )

24777 
pPager
->
nSubRec
++;

24779 
rc
 = 
	`addToSavepointBitvecs
(
pPager
, 
pPg
->
pgno
);

24781 return 
rc
;

24782 
	}
}

24783 static int 
	$subjournalPageIfRequired
(
PgHdr
 *
pPg
)

24786 if( 
	`subjRequiresPage
(
pPg
) )

24789 return 
	`subjournalPage
(
pPg
);

24793 
	}
}

24795 static int 
	$pagerStress
(void *
p
, 
PgHdr
 *
pPg
)

24798 
Pager
 *
pPager
 = (Pager *)
p
;

24799 int 
rc
 = 0;

24804 if( (
pPager
->
errCode
) ) return 0;

24808 if( 
pPager
->
doNotSpill


24809 && ((
pPager
->
doNotSpill
 & (0x02|0x01))!=0

24810 || (
pPg
->
flags
 & 0x008)!=0)

24817 
pPg
->
pDirty
 = 0;

24818 if( 
	`pagerUseWal
(
pPager
) )

24822 
rc
 = 
	`subjournalPageIfRequired
(
pPg
);

24823 if( 
rc
==0 )

24826 
rc
 = 
	`pagerWalFrames
(
pPager
, 
pPg
, 0, 0);

24831 if( 
pPg
->
flags
&0x008

24832 || 
pPager
->
eState
==3

24836 
rc
 = 
	`syncJournal
(
pPager
, 1);

24840 if( 
rc
==0 )

24844 
rc
 = 
	`pager_write_pagelist
(
pPager
, 
pPg
);

24849 if( 
rc
==0 )

24853 
	`sqlite3PcacheMakeClean
(
pPg
);

24856 return 
	`pager_error
(
pPager
, 
rc
);

24857 
	}
}

24862 static int 
	$sqlite3PagerFlush
(
Pager
 *
pPager
)

24865 int 
rc
 = 
pPager
->
errCode
;

24866 if( !
pPager
->
memDb
 )

24869 
PgHdr
 *
pList
 = 
	`sqlite3PcacheDirtyList
(
pPager
->
pPCache
);

24871 while( 
rc
==0 && 
pList
 )

24874 
PgHdr
 *
pNext
 = 
pList
->
pDirty
;

24875 if( 
pList
->
nRef
==0 )

24878 
rc
 = 
	`pagerStress
((void*)
pPager
, 
pList
);

24880 
pList
 = 
pNext
;

24884 return 
rc
;

24885 
	}
}

24887 static int 
sqlite3PagerOpen
(

24888 
sqlite3_vfs
 *
pVfs
,

24889 
Pager
 **
ppPager
,

24890 const char *
zFilename
,

24891 int 
nExtra
,

24892 int 
flags
,

24893 int 
vfsFlags
,

24894 void (*
xReinit
)(
DbPage
*)

24898 
u8
 *
pPtr
;

24899 
Pager
 *
pPager
 = 0;

24900 int 
rc
 = 0;

24901 int 
tempFile
 = 0;

24902 int 
memDb
 = 0;

24903 int 
readOnly
 = 0;

24904 int 
journalFileSize
;

24905 char *
zPathname
 = 0;

24906 int 
nPathname
 = 0;

24907 int 
useJournal
 = (
flags
 & 0x0001)==0;

24908 int 
pcacheSize
 = 
	`sqlite3PcacheSize
();

24909 
u32
 
szPageDflt
 = 4096;

24910 const char *
zUri
 = 0;

24911 int 
nUri
 = 0;

24915 
journalFileSize
 = (((
	`sqlite3JournalSize
(
pVfs
))+7)&~7);

24918 *
ppPager
 = 0;

24921 if( 
flags
 & 0x0002 )

24924 
memDb
 = 1;

24925 if( 
zFilename
 && zFilename[0] )

24928 
zPathname
 = 
	`sqlite3DbStrDup
(0, 
zFilename
);

24929 if( 
zPathname
==0 ) return 7;

24930 
nPathname
 = 
	`sqlite3Strlen30
(
zPathname
);

24931 
zFilename
 = 0;

24940 if( 
zFilename
 && zFilename[0] )

24943 const char *
z
;

24944 
nPathname
 = 
pVfs
->
mxPathname
+1;

24945 
zPathname
 = 
	`sqlite3DbMallocRaw
(0, 
nPathname
*2);

24946 if( 
zPathname
==0 )

24951 
zPathname
[0] = 0;

24952 
rc
 = 
	`sqlite3OsFullPathname
(
pVfs
, 
zFilename
, 
nPathname
, 
zPathname
);

24953 
nPathname
 = 
	`sqlite3Strlen30
(
zPathname
);

24954 
z
 = 
zUri
 = &
zFilename
[
	`sqlite3Strlen30
(zFilename)+1];

24955 while( *
z
 )

24958 
z
 += 
	`sqlite3Strlen30
(z)+1;

24959 
z
 += 
	`sqlite3Strlen30
(z)+1;

24961 
nUri
 = (int)(&
z
[1] - 
zUri
);

24963 if( 
rc
==0 && 
nPathname
+8>
pVfs
->
mxPathname
 )

24972 
rc
 = 
	`sqlite3CantopenError
(48619);

24974 if( 
rc
!=0 )

24977 
	`sqlite3DbFree
(0, 
zPathname
);

24978 return 
rc
;

24982 
pPtr
 = (
u8
 *)
	`sqlite3MallocZero
(

24983 (((sizeof(*
pPager
))+7)&~7) +

24984 (((
pcacheSize
)+7)&~7) +

24985 (((
pVfs
->
szOsFile
)+7)&~7) +

24986 
journalFileSize
 * 2 +

24987 
nPathname
 + 1 + 
nUri
 +

24988 
nPathname
 + 8 + 2

24990 + 
nPathname
 + 4 + 2

24994 if( !
pPtr
 )

24997 
	`sqlite3DbFree
(0, 
zPathname
);

25000 
pPager
 = (
Pager
*)(
pPtr
);

25001 
pPager
->
pPCache
 = (
PCache
*)(
pPtr
 += (((sizeof(*pPager))+7)&~7));

25002 
pPager
->
fd
 = (
sqlite3_file
*)(
pPtr
 += (((
pcacheSize
)+7)&~7));

25003 
pPager
->
sjfd
 = (
sqlite3_file
*)(
pPtr
 += (((
pVfs
->
szOsFile
)+7)&~7));

25004 
pPager
->
jfd
 = (
sqlite3_file
*)(
pPtr
 += 
journalFileSize
);

25005 
pPager
->
zFilename
 = (char*)(
pPtr
 += 
journalFileSize
);

25009 if( 
zPathname
 )

25013 
pPager
->
zJournal
 = (char*)(
pPtr
 += 
nPathname
 + 1 + 
nUri
);

25014 
	`memcpy
(
pPager
->
zFilename
, 
zPathname
, 
nPathname
);

25015 if( 
nUri
 ) 
	`memcpy
(&
pPager
->
zFilename
[
nPathname
+1], 
zUri
, nUri);

25016 
	`memcpy
(
pPager
->
zJournal
, 
zPathname
, 
nPathname
);

25017 
	`memcpy
(&
pPager
->
zJournal
[
nPathname
], "-journal\000", 8+2);

25020 
pPager
->
zWal
 = &pPager->
zJournal
[
nPathname
+8+1];

25021 
	`memcpy
(
pPager
->
zWal
, 
zPathname
, 
nPathname
);

25022 
	`memcpy
(&
pPager
->
zWal
[
nPathname
], "-wal\000", 4+1);

25025 
	`sqlite3DbFree
(0, 
zPathname
);

25027 
pPager
->
pVfs
 = pVfs;

25028 
pPager
->
vfsFlags
 = vfsFlags;

25032 if( 
zFilename
 && zFilename[0] )

25035 int 
fout
 = 0;

25036 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
pPager
->
zFilename
, pPager->
fd
, 
vfsFlags
, &
fout
);

25038 
readOnly
 = (
fout
&0x00000001);

25040 if( 
rc
==0 )

25043 int 
iDc
 = 
	`sqlite3OsDeviceCharacteristics
(
pPager
->
fd
);

25044 if( !
readOnly
 )

25047 
	`setSectorSize
(
pPager
);

25049 if( 
szPageDflt
<
pPager
->
sectorSize
 )

25052 if( 
pPager
->
sectorSize
>8192 )

25055 
szPageDflt
 = 8192;

25057 
szPageDflt
 = (
u32
)
pPager
->
sectorSize
;

25062 
pPager
->
noLock
 = 
	`sqlite3_uri_boolean
(
zFilename
, "nolock", 0);

25063 if( (
iDc
 & 0x00002000)!=0

25064 || 
	`sqlite3_uri_boolean
(
zFilename
, "immutable", 0) )

25067 
vfsFlags
 |= 0x00000001;

25068 goto 
act_like_temp_file
;

25073 
act_like_temp_file
:

25074 
tempFile
 = 1;

25075 
pPager
->
eState
 = 1;

25076 
pPager
->
eLock
 = 4;

25077 
pPager
->
noLock
 = 1;

25078 
readOnly
 = (
vfsFlags
&0x00000001);

25084 if( 
rc
==0 )

25088 
rc
 = 
	`sqlite3PagerSetPagesize
(
pPager
, &
szPageDflt
, -1);

25093 if( 
rc
==0 )

25097 
nExtra
 = (((nExtra)+7)&~7);

25098 
rc
 = 
	`sqlite3PcacheOpen
(
szPageDflt
, 
nExtra
, !
memDb
,

25099 !
memDb
?
pagerStress
:0, (void *)
pPager
, pPager->
pPCache
);

25104 if( 
rc
!=0 )

25107 
	`sqlite3OsClose
(
pPager
->
fd
);

25108 
	`sqlite3PageFree
(
pPager
->
pTmpSpace
);

25109 
	`sqlite3_free
(
pPager
);

25110 return 
rc
;

25116 
pPager
->
useJournal
 = (
u8
)useJournal;

25123 
pPager
->
mxPgno
 = 1073741823;

25126 
pPager
->
tempFile
 = (
u8
)tempFile;

25130 
pPager
->
exclusiveMode
 = (
u8
)
tempFile
;

25131 
pPager
->
changeCountDone
 = pPager->
tempFile
;

25132 
pPager
->
memDb
 = (
u8
)memDb;

25133 
pPager
->
readOnly
 = (
u8
)readOnly;

25135 
pPager
->
noSync
 = pPager->
tempFile
;

25136 if( 
pPager
->
noSync
 )

25145 
pPager
->
fullSync
 = 1;

25146 
pPager
->
extraSync
 = 0;

25147 
pPager
->
syncFlags
 = 0x00002;

25148 
pPager
->
walSyncFlags
 = 0x00002 | 0x20;

25149 
pPager
->
ckptSyncFlags
 = 0x00002;

25154 
pPager
->
nExtra
 = (
u16
)nExtra;

25155 
pPager
->
journalSizeLimit
 = -1;

25157 
	`setSectorSize
(
pPager
);

25158 if( !
useJournal
 )

25161 
pPager
->
journalMode
 = 2;

25162 }else if( 
memDb
 )

25165 
pPager
->
journalMode
 = 4;

25169 
pPager
->
xReiniter
 = 
xReinit
;

25173 *
ppPager
 = 
pPager
;

25175 
	}
}

25183 static int 
	$databaseIsUnmoved
(
Pager
 *
pPager
)

25186 int 
bHasMoved
 = 0;

25187 int 
rc
;

25189 if( 
pPager
->
tempFile
 ) return 0;

25190 if( 
pPager
->
dbSize
==0 ) return 0;

25192 
rc
 = 
	`sqlite3OsFileControl
(
pPager
->
fd
, 20, &
bHasMoved
);

25193 if( 
rc
==12 )

25199 
rc
 = 0;

25200 }else if( 
rc
==0 && 
bHasMoved
 )

25203 
rc
 = (8 | (4<<8));

25205 return 
rc
;

25206 
	}
}

25208 static int 
	$hasHotJournal
(
Pager
 *
pPager
, int *
pExists
)

25211 
sqlite3_vfs
 * const 
pVfs
 = 
pPager
->pVfs;

25212 int 
rc
 = 0;

25213 int 
exists
 = 1;

25214 int 
jrnlOpen
 = !!((
pPager
->
jfd
)->
pMethods
!=0);

25224 *
pExists
 = 0;

25225 if( !
jrnlOpen
 )

25228 
rc
 = 
	`sqlite3OsAccess
(
pVfs
, 
pPager
->
zJournal
, 0, &
exists
);

25230 if( 
rc
==0 && 
exists
 )

25233 int 
locked
 = 0;

25235 
rc
 = 
	`sqlite3OsCheckReservedLock
(
pPager
->
fd
, &
locked
);

25236 if( 
rc
==0 && !
locked
 )

25239 
Pgno
 
nPage
;

25241 
rc
 = 
	`pagerPagecount
(
pPager
, &
nPage
);

25242 if( 
rc
==0 )

25246 if( 
nPage
==0 && !
jrnlOpen
 )

25249 
	`sqlite3BeginBenignMalloc
();

25250 if( 
	`pagerLockDb
(
pPager
, 2)==0 )

25253 
	`sqlite3OsDelete
(
pVfs
, 
pPager
->
zJournal
, 0);

25254 if( !
pPager
->
exclusiveMode
 ) 
	`pagerUnlockDb
(pPager, 1);

25256 
	`sqlite3EndBenignMalloc
();

25264 if( !
jrnlOpen
 )

25267 int 
f
 = 0x00000001|0x00000800;

25268 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
pPager
->
zJournal
, pPager->
jfd
, 
f
, &f);

25270 if( 
rc
==0 )

25273 
u8
 
first
 = 0;

25274 
rc
 = 
	`sqlite3OsRead
(
pPager
->
jfd
, (void *)&
first
, 1, 0);

25275 if( 
rc
==(10 | (2<<8)) )

25278 
rc
 = 0;

25280 if( !
jrnlOpen
 )

25283 
	`sqlite3OsClose
(
pPager
->
jfd
);

25285 *
pExists
 = (
first
!=0);

25286 }else if( 
rc
==14 )

25290 *
pExists
 = 1;

25291 
rc
 = 0;

25298 return 
rc
;

25299 
	}
}

25301 static int 
	$sqlite3PagerSharedLock
(
Pager
 *
pPager
)

25304 int 
rc
 = 0;

25314 if( (
pPager
->
memDb
 && pPager->
errCode
) )

25316 return 
pPager
->
errCode
; }

25318 if( !
	`pagerUseWal
(
pPager
) && pPager->
eState
==0 )

25321 int 
bHotJournal
 = 1;

25325 
rc
 = 
	`pager_wait_on_lock
(
pPager
, 1);

25326 if( 
rc
!=0 )

25330 goto 
failed
;

25336 if( 
pPager
->
eLock
<=1 )

25339 
rc
 = 
	`hasHotJournal
(
pPager
, &
bHotJournal
);

25341 if( 
rc
!=0 )

25344 goto 
failed
;

25346 if( 
bHotJournal
 )

25349 if( 
pPager
->
readOnly
 )

25352 
rc
 = (8 | (3<<8));

25353 goto 
failed
;

25356 
rc
 = 
	`pagerLockDb
(
pPager
, 4);

25357 if( 
rc
!=0 )

25360 goto 
failed
;

25363 if( !((
pPager
->
jfd
)->
pMethods
!=0) )

25366 
sqlite3_vfs
 * const 
pVfs
 = 
pPager
->pVfs;

25367 int 
bExists
;

25368 
rc
 = 
	`sqlite3OsAccess
(

25369 
pVfs
, 
pPager
->
zJournal
, 0, &
bExists
);

25370 if( 
rc
==0 && 
bExists
 )

25373 int 
fout
 = 0;

25374 int 
f
 = 0x00000002|0x00000800;

25376 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
pPager
->
zJournal
, pPager->
jfd
, 
f
, &
fout
);

25378 if( 
rc
==0 && 
fout
&0x00000001 )

25381 
rc
 = 
	`sqlite3CantopenError
(49095);

25382 
	`sqlite3OsClose
(
pPager
->
jfd
);

25387 if( ((
pPager
->
jfd
)->
pMethods
!=0) )

25391 
rc
 = 
	`pagerSyncHotJournal
(
pPager
);

25392 if( 
rc
==0 )

25395 
rc
 = 
	`pager_playback
(
pPager
, 1);

25396 
pPager
->
eState
 = 0;

25398 }else if( !
pPager
->
exclusiveMode
 )

25401 
	`pagerUnlockDb
(
pPager
, 1);

25404 if( 
rc
!=0 )

25408 
	`pager_error
(
pPager
, 
rc
);

25409 goto 
failed
;

25418 if( !
pPager
->
tempFile
 && pPager->
hasHeldSharedLock
 )

25422 
Pgno
 
nPage
 = 0;

25423 char 
dbFileVers
[sizeof(
pPager
->dbFileVers)];

25425 
rc
 = 
	`pagerPagecount
(
pPager
, &
nPage
);

25426 if( 
rc
 ) goto 
failed
;

25428 if( 
nPage
>0 )

25432 
rc
 = 
	`sqlite3OsRead
(
pPager
->
fd
, &
dbFileVers
, sizeof(dbFileVers), 24);

25433 if( 
rc
!=0 && rc!=(10 | (2<<8)) )

25436 goto 
failed
;

25439 
	`memset
(
dbFileVers
, 0, sizeof(dbFileVers));

25442 if( 
	`memcmp
(
pPager
->
dbFileVers
, dbFileVers, sizeof(dbFileVers))!=0 )

25445 
	`pager_reset
(
pPager
);

25453 if( ((
pPager
)->
bUseFetch
) )

25456 
	`sqlite3OsUnfetch
(
pPager
->
fd
, 0, 0);

25464 
rc
 = 
	`pagerOpenWalIfPresent
(
pPager
);

25470 if( 
	`pagerUseWal
(
pPager
) )

25474 
rc
 = 
	`pagerBeginReadTransaction
(
pPager
);

25477 if( 
pPager
->
eState
==0 && 
rc
==0 )

25480 
rc
 = 
	`pagerPagecount
(
pPager
, &pPager->
dbSize
);

25483 
failed
:

25484 if( 
rc
!=0 )

25488 
	`pager_unlock
(
pPager
);

25491 
pPager
->
eState
 = 1;

25492 
pPager
->
hasHeldSharedLock
 = 1;

25494 return 
rc
;

25495 
	}
}

25497 static void 
	$pagerUnlockIfUnused
(
Pager
 *
pPager
)

25500 if( 
pPager
->
nMmapOut
==0 && (
	`sqlite3PcacheRefCount
(pPager->
pPCache
)==0) )

25503 
	`pagerUnlockAndRollback
(
pPager
);

25505 
	}
}

25507 static int 
	$sqlite3PagerGet
(

25508 
Pager
 *
pPager
,

25509 
Pgno
 
pgno
,

25510 
DbPage
 **
ppPage
,

25511 int 
flags


25515 int 
rc
 = 0;

25516 
PgHdr
 *
pPg
 = 0;

25517 
u32
 
iFrame
 = 0;

25518 const int 
noContent
 = (
flags
 & 0x01);

25524 const int 
bMmapOk
 = (
pgno
>1 && ((
pPager
)->
bUseFetch
)

25525 && (
pPager
->
eState
==1 || (
flags
 & 0x02))

25535 if( 
pgno
<=1 && pgno==0 )

25538 return 
	`sqlite3CorruptError
(49316);

25548 if( 
pPager
->
errCode
!=0 )

25551 
rc
 = 
pPager
->
errCode
;

25553 if( 
bMmapOk
 && 
	`pagerUseWal
(
pPager
) )

25556 
rc
 = 
	`sqlite3WalFindFrame
(
pPager
->
pWal
, 
pgno
, &
iFrame
);

25557 if( 
rc
!=0 ) goto 
pager_acquire_err
;

25560 if( 
bMmapOk
 && 
iFrame
==0 )

25563 void *
pData
 = 0;

25565 
rc
 = 
	`sqlite3OsFetch
(
pPager
->
fd
,

25566 (
i64
)(
pgno
-1) * 
pPager
->
pageSize
, pPager->pageSize, &
pData


25569 if( 
rc
==0 && 
pData
 )

25572 if( 
pPager
->
eState
>1 )

25575 
pPg
 = 
	`sqlite3PagerLookup
(
pPager
, 
pgno
);

25577 if( 
pPg
==0 )

25580 
rc
 = 
	`pagerAcquireMapPage
(
pPager
, 
pgno
, 
pData
, &
pPg
);

25582 
	`sqlite3OsUnfetch
(
pPager
->
fd
, (
i64
)(
pgno
-1)*pPager->
pageSize
, 
pData
);

25584 if( 
pPg
 )

25588 *
ppPage
 = 
pPg
;

25592 if( 
rc
!=0 )

25595 goto 
pager_acquire_err
;

25600 
sqlite3_pcache_page
 *
pBase
;

25601 
pBase
 = 
	`sqlite3PcacheFetch
(
pPager
->
pPCache
, 
pgno
, 3);

25602 if( 
pBase
==0 )

25605 
rc
 = 
	`sqlite3PcacheFetchStress
(
pPager
->
pPCache
, 
pgno
, &
pBase
);

25606 if( 
rc
!=0 ) goto 
pager_acquire_err
;

25607 if( 
pBase
==0 )

25610 
pPg
 = *
ppPage
 = 0;

25611 
rc
 = 7;

25612 goto 
pager_acquire_err
;

25615 
pPg
 = *
ppPage
 = 
	`sqlite3PcacheFetchFinish
(
pPager
->
pPCache
, 
pgno
, 
pBase
);

25620 if( 
rc
!=0 )

25626 
pPg
 = 0;

25627 goto 
pager_acquire_err
;

25633 if( 
pPg
->
pPager
 && !
noContent
 )

25639 
pPager
->
aStat
[0]++;

25646 
pPg
->
pPager
 = pPager;

25650 if( 
pgno
>2147483647 || pgno==((
Pgno
)((
sqlite3PendingByte
/((
pPager
)->
pageSize
))+1)) )

25653 
rc
 = 
	`sqlite3CorruptError
(49405);

25654 goto 
pager_acquire_err
;

25657 if( 
pPager
->
memDb
 || pPager->
dbSize
<
pgno
 || 
noContent
 || !((pPager->
fd
)->
pMethods
!=0) )

25660 if( 
pgno
>
pPager
->
mxPgno
 )

25663 
rc
 = 13;

25664 goto 
pager_acquire_err
;

25666 if( 
noContent
 )

25675 
	`sqlite3BeginBenignMalloc
();

25676 if( 
pgno
<=
pPager
->
dbOrigSize
 )

25679 
	`sqlite3BitvecSet
(
pPager
->
pInJournal
, 
pgno
);

25682 
	`addToSavepointBitvecs
(
pPager
, 
pgno
);

25684 
	`sqlite3EndBenignMalloc
();

25686 
	`memset
(
pPg
->
pData
, 0, 
pPager
->
pageSize
);

25689 if( 
	`pagerUseWal
(
pPager
) && 
bMmapOk
==0 )

25692 
rc
 = 
	`sqlite3WalFindFrame
(
pPager
->
pWal
, 
pgno
, &
iFrame
);

25693 if( 
rc
!=0 ) goto 
pager_acquire_err
;

25696 
pPager
->
aStat
[1]++;

25697 
rc
 = 
	`readDbPage
(
pPg
, 
iFrame
);

25698 if( 
rc
!=0 )

25701 goto 
pager_acquire_err
;

25709 
pager_acquire_err
:

25711 if( 
pPg
 )

25714 
	`sqlite3PcacheDrop
(
pPg
);

25716 
	`pagerUnlockIfUnused
(
pPager
);

25718 *
ppPage
 = 0;

25719 return 
rc
;

25720 
	}
}

25722 static 
DbPage
 *
	$sqlite3PagerLookup
(
Pager
 *
pPager
, 
Pgno
 
pgno
)

25725 
sqlite3_pcache_page
 *
pPage
;

25729 
pPage
 = 
	`sqlite3PcacheFetch
(
pPager
->
pPCache
, 
pgno
, 0);

25731 if( 
pPage
==0 ) return 0;

25732 return 
	`sqlite3PcacheFetchFinish
(
pPager
->
pPCache
, 
pgno
, 
pPage
);

25733 
	}
}

25735 static void 
	$sqlite3PagerUnrefNotNull
(
DbPage
 *
pPg
)

25738 
Pager
 *
pPager
;

25740 
pPager
 = 
pPg
->pPager;

25741 if( 
pPg
->
flags
 & 0x040 )

25744 
	`pagerReleaseMapPage
(
pPg
);

25746 
	`sqlite3PcacheRelease
(
pPg
);

25748 
	`pagerUnlockIfUnused
(
pPager
);

25749 
	}
}

25750 static void 
	$sqlite3PagerUnref
(
DbPage
 *
pPg
)

25753 if( 
pPg
 ) 
	`sqlite3PagerUnrefNotNull
(pPg);

25754 
	}
}

25756 static int 
	$pager_open_journal
(
Pager
 *
pPager
)

25759 int 
rc
 = 0;

25760 
sqlite3_vfs
 * const 
pVfs
 = 
pPager
->pVfs;

25769 if( (
pPager
->
errCode
) ) return pPager->errCode;

25771 if( !
	`pagerUseWal
(
pPager
) && pPager->
journalMode
!=2 )

25774 
pPager
->
pInJournal
 = 
	`sqlite3BitvecCreate
(pPager->
dbSize
);

25775 if( 
pPager
->
pInJournal
==0 )

25782 if( !((
pPager
->
jfd
)->
pMethods
!=0) )

25785 if( 
pPager
->
journalMode
==4 )

25788 
	`sqlite3MemJournalOpen
(
pPager
->
jfd
);

25790 const int 
flags
 =

25792 (
pPager
->
tempFile
 ?

25799 
rc
 = 
	`databaseIsUnmoved
(
pPager
);

25800 if( 
rc
==0 )

25808 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
pPager
->
zJournal
, pPager->
jfd
, 
flags
, 0);

25819 if( 
rc
==0 )

25823 
pPager
->
nRec
 = 0;

25824 
pPager
->
journalOff
 = 0;

25825 
pPager
->
setMaster
 = 0;

25826 
pPager
->
journalHdr
 = 0;

25827 
rc
 = 
	`writeJournalHdr
(
pPager
);

25831 if( 
rc
!=0 )

25834 
	`sqlite3BitvecDestroy
(
pPager
->
pInJournal
);

25835 
pPager
->
pInJournal
 = 0;

25838 
pPager
->
eState
 = 3;

25841 return 
rc
;

25842 
	}
}

25844 static int 
	$sqlite3PagerBegin
(
Pager
 *
pPager
, int 
exFlag
, int 
subjInMemory
)

25847 int 
rc
 = 0;

25849 if( 
pPager
->
errCode
 ) return pPager->errCode;

25851 
pPager
->
subjInMemory
 = (
u8
)subjInMemory;

25853 if( (
pPager
->
eState
==1) )

25858 if( 
	`pagerUseWal
(
pPager
) )

25864 if( 
pPager
->
exclusiveMode
 && 
	`sqlite3WalExclusiveMode
(pPager->
pWal
, -1) )

25867 
rc
 = 
	`pagerLockDb
(
pPager
, 4);

25868 if( 
rc
!=0 )

25871 return 
rc
;

25873 (void)
	`sqlite3WalExclusiveMode
(
pPager
->
pWal
, 1);

25881 
rc
 = 
	`sqlite3WalBeginWriteTransaction
(
pPager
->
pWal
);

25888 
rc
 = 
	`pagerLockDb
(
pPager
, 2);

25889 if( 
rc
==0 && 
exFlag
 )

25892 
rc
 = 
	`pager_wait_on_lock
(
pPager
, 4);

25896 if( 
rc
==0 )

25900 
pPager
->
eState
 = 2;

25901 
pPager
->
dbHintSize
 = pPager->
dbSize
;

25902 
pPager
->
dbFileSize
 = pPager->
dbSize
;

25903 
pPager
->
dbOrigSize
 = pPager->
dbSize
;

25904 
pPager
->
journalOff
 = 0;

25913 return 
rc
;

25914 
	}
}

25919 static 
__attribute__
((
noinline
)) int 
	$pagerAddPageToRollbackJournal
(
PgHdr
 *
pPg
)

25922 
Pager
 *
pPager
 = 
pPg
->pPager;

25923 int 
rc
;

25924 
u32
 
cksum
;

25925 char *
pData2
;

25926 
i64
 
iOff
 = 
pPager
->
journalOff
;

25934 
pData2
=(char*)
pPg
->
pData
;

25935 
cksum
 = 
	`pager_cksum
(
pPager
, (
u8
*)
pData2
);

25937 
pPg
->
flags
 |= 0x008;

25939 
rc
 = 
	`write32bits
(
pPager
->
jfd
, 
iOff
, 
pPg
->
pgno
);

25940 if( 
rc
!=0 ) return rc;

25941 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
jfd
, 
pData2
, pPager->
pageSize
, 
iOff
+4);

25942 if( 
rc
!=0 ) return rc;

25943 
rc
 = 
	`write32bits
(
pPager
->
jfd
, 
iOff
+pPager->
pageSize
+4, 
cksum
);

25944 if( 
rc
!=0 ) return rc;

25953 
pPager
->
journalOff
 += 8 + pPager->
pageSize
;

25954 
pPager
->
nRec
++;

25956 
rc
 = 
	`sqlite3BitvecSet
(
pPager
->
pInJournal
, 
pPg
->
pgno
);

25959 
rc
 |= 
	`addToSavepointBitvecs
(
pPager
, 
pPg
->
pgno
);

25961 return 
rc
;

25962 
	}
}

25964 static int 
	$pager_write
(
PgHdr
 *
pPg
)

25967 
Pager
 *
pPager
 = 
pPg
->pPager;

25968 int 
rc
 = 0;

25983 if( 
pPager
->
eState
==2 )

25986 
rc
 = 
	`pager_open_journal
(
pPager
);

25987 if( 
rc
!=0 ) return rc;

25993 
	`sqlite3PcacheMakeDirty
(
pPg
);

26000 if( 
pPager
->
pInJournal
!=0

26001 && 
	`sqlite3BitvecTestNotNull
(
pPager
->
pInJournal
, 
pPg
->
pgno
)==0

26006 if( 
pPg
->
pgno
<=
pPager
->
dbOrigSize
 )

26009 
rc
 = 
	`pagerAddPageToRollbackJournal
(
pPg
);

26010 if( 
rc
!=0 )

26013 return 
rc
;

26016 if( 
pPager
->
eState
!=4 )

26019 
pPg
->
flags
 |= 0x008;

26032 
pPg
->
flags
 |= 0x004;

26037 if( 
pPager
->
nSavepoint
>0 )

26040 
rc
 = 
	`subjournalPageIfRequired
(
pPg
);

26044 if( 
pPager
->
dbSize
<
pPg
->
pgno
 )

26047 
pPager
->
dbSize
 = 
pPg
->
pgno
;

26049 return 
rc
;

26050 
	}
}

26052 static 
__attribute__
((
noinline
)) int 
	$pagerWriteLargeSector
(
PgHdr
 *
pPg
)

26055 int 
rc
 = 0;

26056 
Pgno
 
nPageCount
;

26057 
Pgno
 
pg1
;

26058 int 
nPage
 = 0;

26059 int 
ii
;

26060 int 
needSync
 = 0;

26061 
Pager
 *
pPager
 = 
pPg
->pPager;

26062 
Pgno
 
nPagePerSector
 = (
pPager
->
sectorSize
/pPager->
pageSize
);

26070 
pPager
->
doNotSpill
 |= 0x04;

26076 
pg1
 = ((
pPg
->
pgno
-1) & ~(
nPagePerSector
-1)) + 1;

26078 
nPageCount
 = 
pPager
->
dbSize
;

26079 if( 
pPg
->
pgno
>
nPageCount
 )

26082 
nPage
 = (
pPg
->
pgno
 - 
pg1
)+1;

26083 }else if( (
pg1
+
nPagePerSector
-1)>
nPageCount
 )

26086 
nPage
 = 
nPageCount
+1-
pg1
;

26088 
nPage
 = 
nPagePerSector
;

26094 for(
ii
=0; ii<
nPage
 && 
rc
==0; ii++)

26097 
Pgno
 
pg
 = 
pg1
+
ii
;

26098 
PgHdr
 *
pPage
;

26099 if( 
pg
==
pPg
->
pgno
 || !
	`sqlite3BitvecTest
(
pPager
->
pInJournal
, pg) )

26102 if( 
pg
!=((
Pgno
)((
sqlite3PendingByte
/((
pPager
)->
pageSize
))+1)) )

26105 
rc
 = 
	`sqlite3PagerGet
(
pPager
, 
pg
, &
pPage
, 0);

26106 if( 
rc
==0 )

26109 
rc
 = 
	`pager_write
(
pPage
);

26110 if( 
pPage
->
flags
&0x008 )

26113 
needSync
 = 1;

26115 
	`sqlite3PagerUnrefNotNull
(
pPage
);

26118 }else if( (
pPage
 = 
	`sqlite3PagerLookup
(
pPager
, 
pg
))!=0 )

26121 if( 
pPage
->
flags
&0x008 )

26124 
needSync
 = 1;

26126 
	`sqlite3PagerUnrefNotNull
(
pPage
);

26136 if( 
rc
==0 && 
needSync
 )

26140 for(
ii
=0; ii<
nPage
; ii++)

26143 
PgHdr
 *
pPage
 = 
	`sqlite3PagerLookup
(
pPager
, 
pg1
+
ii
);

26144 if( 
pPage
 )

26147 
pPage
->
flags
 |= 0x008;

26148 
	`sqlite3PagerUnrefNotNull
(
pPage
);

26154 
pPager
->
doNotSpill
 &= ~0x04;

26155 return 
rc
;

26156 
	}
}

26158 static int 
	$sqlite3PagerWrite
(
PgHdr
 *
pPg
)

26161 
Pager
 *
pPager
 = 
pPg
->pPager;

26165 if( 
pPager
->
errCode
 )

26168 return 
pPager
->
errCode
;

26169 }else if( (
pPg
->
flags
 & 0x004)!=0 && 
pPager
->
dbSize
>=pPg->
pgno
 )

26172 if( 
pPager
->
nSavepoint
 ) return 
	`subjournalPageIfRequired
(
pPg
);

26174 }else if( 
pPager
->
sectorSize
 > (
u32
)pPager->
pageSize
 )

26177 return 
	`pagerWriteLargeSector
(
pPg
);

26179 return 
	`pager_write
(
pPg
);

26181 
	}
}

26183 static void 
	$sqlite3PagerDontWrite
(
PgHdr
 *
pPg
)

26186 
Pager
 *
pPager
 = 
pPg
->pPager;

26187 if( (
pPg
->
flags
&0x002) && 
pPager
->
nSavepoint
==0 )

26192 
pPg
->
flags
 |= 0x020;

26193 
pPg
->
flags
 &= ~0x004;

26196 
	}
}

26198 static int 
	$pager_incr_changecounter
(
Pager
 *
pPager
, int 
isDirectMode
)

26201 int 
rc
 = 0;

26209 (void)(
isDirectMode
);

26214 if( !
pPager
->
changeCountDone
 && (pPager->
dbSize
>0) )

26217 
PgHdr
 *
pPgHdr
;

26222 
rc
 = 
	`sqlite3PagerGet
(
pPager
, 1, &
pPgHdr
, 0);

26230 if( !0 && (
rc
==0) )

26233 
rc
 = 
	`sqlite3PagerWrite
(
pPgHdr
);

26236 if( 
rc
==0 )

26240 
	`pager_write_changecounter
(
pPgHdr
);

26246 const void *
zBuf
;

26248 
zBuf
=(char*)
pPgHdr
->
pData
;

26249 if( 
rc
==0 )

26252 
rc
 = 
	`sqlite3OsWrite
(
pPager
->
fd
, 
zBuf
, pPager->
pageSize
, 0);

26253 
pPager
->
aStat
[2]++;

26255 if( 
rc
==0 )

26261 const void *
pCopy
 = (const void *)&((const char *)
zBuf
)[24];

26262 
	`memcpy
(&
pPager
->
dbFileVers
, 
pCopy
, sizeof(pPager->dbFileVers));

26263 
pPager
->
changeCountDone
 = 1;

26266 
pPager
->
changeCountDone
 = 1;

26271 
	`sqlite3PagerUnref
(
pPgHdr
);

26273 return 
rc
;

26274 
	}
}

26276 static int 
	$sqlite3PagerSync
(
Pager
 *
pPager
, const char *
zMaster
)

26279 int 
rc
 = 0;

26281 if( ((
pPager
->
fd
)->
pMethods
!=0) )

26284 void *
pArg
 = (void*)
zMaster
;

26285 
rc
 = 
	`sqlite3OsFileControl
(
pPager
->
fd
, 21, 
pArg
);

26286 if( 
rc
==12 ) rc = 0;

26288 if( 
rc
==0 && !
pPager
->
noSync
 )

26292 
rc
 = 
	`sqlite3OsSync
(
pPager
->
fd
, pPager->
syncFlags
);

26294 return 
rc
;

26295 
	}
}

26297 static int 
	$sqlite3PagerExclusiveLock
(
Pager
 *
pPager
)

26300 int 
rc
 = 
pPager
->
errCode
;

26302 if( 
rc
==0 )

26310 if( 0==
	`pagerUseWal
(
pPager
) )

26313 
rc
 = 
	`pager_wait_on_lock
(
pPager
, 4);

26316 return 
rc
;

26317 
	}
}

26319 static int 
	$sqlite3PagerCommitPhaseOne
(

26320 
Pager
 *
pPager
,

26321 const char *
zMaster
,

26322 int 
noSync


26326 int 
rc
 = 0;

26336 if( (
pPager
->
errCode
) ) return pPager->errCode;

26342 if( 
pPager
->
eState
<3 ) return 0;

26344 if( 
pPager
->
memDb
 )

26351 
	`sqlite3BackupRestart
(
pPager
->
pBackup
);

26353 if( 
	`pagerUseWal
(
pPager
) )

26356 
PgHdr
 *
pList
 = 
	`sqlite3PcacheDirtyList
(
pPager
->
pPCache
);

26357 
PgHdr
 *
pPageOne
 = 0;

26358 if( 
pList
==0 )

26363 
rc
 = 
	`sqlite3PagerGet
(
pPager
, 1, &
pPageOne
, 0);

26364 
pList
 = 
pPageOne
;

26365 
pList
->
pDirty
 = 0;

26368 if( (
pList
) )

26371 
rc
 = 
	`pagerWalFrames
(
pPager
, 
pList
, pPager->
dbSize
, 1);

26373 
	`sqlite3PagerUnref
(
pPageOne
);

26374 if( 
rc
==0 )

26377 
	`sqlite3PcacheCleanAll
(
pPager
->
pPCache
);

26381 
rc
 = 
	`pager_incr_changecounter
(
pPager
, 0);

26383 if( 
rc
!=0 ) goto 
commit_phase_one_exit
;

26389 
rc
 = 
	`writeMasterJournal
(
pPager
, 
zMaster
);

26390 if( 
rc
!=0 ) goto 
commit_phase_one_exit
;

26392 
rc
 = 
	`syncJournal
(
pPager
, 0);

26393 if( 
rc
!=0 ) goto 
commit_phase_one_exit
;

26395 
rc
 = 
	`pager_write_pagelist
(
pPager
,
	`sqlite3PcacheDirtyList
(pPager->
pPCache
));

26396 if( 
rc
!=0 )

26400 goto 
commit_phase_one_exit
;

26402 
	`sqlite3PcacheCleanAll
(
pPager
->
pPCache
);

26410 if( 
pPager
->
dbSize
>pPager->
dbFileSize
 )

26413 
Pgno
 
nNew
 = 
pPager
->
dbSize
 - (pPager->dbSize==((Pgno)((
sqlite3PendingByte
/((pPager)->
pageSize
))+1)));

26415 
rc
 = 
	`pager_truncate
(
pPager
, 
nNew
);

26416 if( 
rc
!=0 ) goto 
commit_phase_one_exit
;

26420 if( !
noSync
 )

26423 
rc
 = 
	`sqlite3PagerSync
(
pPager
, 
zMaster
);

26429 
commit_phase_one_exit
:

26430 if( 
rc
==0 && !
	`pagerUseWal
(
pPager
) )

26433 
pPager
->
eState
 = 5;

26435 return 
rc
;

26436 
	}
}

26438 static int 
	$sqlite3PagerCommitPhaseTwo
(
Pager
 *
pPager
)

26441 int 
rc
 = 0;

26446 if( (
pPager
->
errCode
) ) return pPager->errCode;

26454 if( 
pPager
->
eState
==2

26455 && 
pPager
->
exclusiveMode


26456 && 
pPager
->
journalMode
==1

26461 
pPager
->
eState
 = 1;

26466 
pPager
->
iDataVersion
++;

26467 
rc
 = 
	`pager_end_transaction
(
pPager
, pPager->
setMaster
, 1);

26468 return 
	`pager_error
(
pPager
, 
rc
);

26469 
	}
}

26471 static int 
	$sqlite3PagerRollback
(
Pager
 *
pPager
)

26474 int 
rc
 = 0;

26482 if( 
pPager
->
eState
==6 ) return pPager->
errCode
;

26483 if( 
pPager
->
eState
<=1 ) return 0;

26485 if( 
	`pagerUseWal
(
pPager
) )

26488 int 
rc2
;

26489 
rc
 = 
	`sqlite3PagerSavepoint
(
pPager
, 2, -1);

26490 
rc2
 = 
	`pager_end_transaction
(
pPager
, pPager->
setMaster
, 0);

26491 if( 
rc
==0 ) rc = 
rc2
;

26492 }else if( !((
pPager
->
jfd
)->
pMethods
!=0) || pPager->
eState
==2 )

26495 int 
eState
 = 
pPager
->eState;

26496 
rc
 = 
	`pager_end_transaction
(
pPager
, 0, 0);

26497 if( !
pPager
->
memDb
 && 
eState
>2 )

26504 
pPager
->
errCode
 = 4;

26505 
pPager
->
eState
 = 6;

26506 return 
rc
;

26509 
rc
 = 
	`pager_playback
(
pPager
, 0);

26521 return 
	`pager_error
(
pPager
, 
rc
);

26522 
	}
}

26528 static 
u8
 
	$sqlite3PagerIsreadonly
(
Pager
 *
pPager
)

26531 return 
pPager
->
readOnly
;

26532 
	}
}

26534 static int 
	$sqlite3PagerMemUsed
(
Pager
 *
pPager
)

26537 int 
perPageSize
 = 
pPager
->
pageSize
 + pPager->
nExtra
 + sizeof(
PgHdr
)

26539 return 
perPageSize
*
	`sqlite3PcachePagecount
(
pPager
->
pPCache
)

26540 + 
	`sqlite3MallocSize
(
pPager
)

26541 + 
pPager
->
pageSize
;

26542 
	}
}

26547 static int 
	$sqlite3PagerPageRefcount
(
DbPage
 *
pPage
)

26550 return 
	`sqlite3PcachePageRefcount
(
pPage
);

26551 
	}
}

26553 static void 
	$sqlite3PagerCacheStat
(
Pager
 *
pPager
, int 
eStat
, int 
reset
, int *
pnVal
)

26566 *
pnVal
 += 
pPager
->
aStat
[
eStat
 - 7];

26567 if( 
reset
 )

26570 
pPager
->
aStat
[
eStat
 - 7] = 0;

26572 
	}
}

26577 static int 
	$sqlite3PagerIsMemdb
(
Pager
 *
pPager
)

26580 return 
pPager
->
memDb
;

26581 
	}
}

26583 static 
__attribute__
((
noinline
)) int 
	$pagerOpenSavepoint
(
Pager
 *
pPager
, int 
nSavepoint
)

26586 int 
rc
 = 0;

26587 int 
nCurrent
 = 
pPager
->
nSavepoint
;

26588 int 
ii
;

26589 
PagerSavepoint
 *
aNew
;

26599 
aNew
 = (
PagerSavepoint
 *)
	`sqlite3Realloc
(

26600 
pPager
->
aSavepoint
, sizeof(
PagerSavepoint
)*
nSavepoint


26602 if( !
aNew
 )

26607 
	`memset
(&
aNew
[
nCurrent
], 0, (
nSavepoint
-nCurrent) * sizeof(
PagerSavepoint
));

26608 
pPager
->
aSavepoint
 = 
aNew
;

26611 for(
ii
=
nCurrent
; ii<
nSavepoint
; ii++)

26614 
aNew
[
ii
].
nOrig
 = 
pPager
->
dbSize
;

26615 if( ((
pPager
->
jfd
)->
pMethods
!=0) && pPager->
journalOff
>0 )

26618 
aNew
[
ii
].
iOffset
 = 
pPager
->
journalOff
;

26620 
aNew
[
ii
].
iOffset
 = (
pPager
->
sectorSize
);

26622 
aNew
[
ii
].
iSubRec
 = 
pPager
->
nSubRec
;

26623 
aNew
[
ii
].
pInSavepoint
 = 
	`sqlite3BitvecCreate
(
pPager
->
dbSize
);

26624 if( !
aNew
[
ii
].
pInSavepoint
 )

26629 if( 
	`pagerUseWal
(
pPager
) )

26632 
	`sqlite3WalSavepoint
(
pPager
->
pWal
, 
aNew
[
ii
].
aWalData
);

26634 
pPager
->
nSavepoint
 = 
ii
+1;

26638 return 
rc
;

26639 
	}
}

26640 static int 
	$sqlite3PagerOpenSavepoint
(
Pager
 *
pPager
, int 
nSavepoint
)

26646 if( 
nSavepoint
>
pPager
->nSavepoint && pPager->
useJournal
 )

26649 return 
	`pagerOpenSavepoint
(
pPager
, 
nSavepoint
);

26653 
	}
}

26655 static int 
	$sqlite3PagerSavepoint
(
Pager
 *
pPager
, int 
op
, int 
iSavepoint
)

26658 int 
rc
 = 
pPager
->
errCode
;

26663 if( 
rc
==0 && 
iSavepoint
<
pPager
->
nSavepoint
 )

26666 int 
ii
;

26667 int 
nNew
;

26673 
nNew
 = 
iSavepoint
 + (( 
op
==1 ) ? 0 : 1);

26674 for(
ii
=
nNew
; ii<
pPager
->
nSavepoint
; ii++)

26677 
	`sqlite3BitvecDestroy
(
pPager
->
aSavepoint
[
ii
].
pInSavepoint
);

26679 
pPager
->
nSavepoint
 = 
nNew
;

26683 if( 
op
==1 )

26686 if( 
nNew
==0 && ((
pPager
->
sjfd
)->
pMethods
!=0) )

26690 if( 
	`sqlite3JournalIsInMemory
(
pPager
->
sjfd
) )

26693 
rc
 = 
	`sqlite3OsTruncate
(
pPager
->
sjfd
, 0);

26696 
pPager
->
nSubRec
 = 0;

26704 else if( 
	`pagerUseWal
(
pPager
) || ((pPager->
jfd
)->
pMethods
!=0) )

26707 
PagerSavepoint
 *
pSavepoint
 = (
nNew
==0)?0:&
pPager
->
aSavepoint
[nNew-1];

26708 
rc
 = 
	`pagerPlaybackSavepoint
(
pPager
, 
pSavepoint
);

26713 return 
rc
;

26714 
	}
}

26716 static const char *
	$sqlite3PagerFilename
(
Pager
 *
pPager
, int 
nullIfMemDb
)

26719 return (
nullIfMemDb
 && 
pPager
->
memDb
) ? "" : pPager->
zFilename
;

26720 
	}
}

26725 static 
sqlite3_vfs
 *
	$sqlite3PagerVfs
(
Pager
 *
pPager
)

26728 return 
pPager
->
pVfs
;

26729 
	}
}

26736 static 
sqlite3_file
 *
	$sqlite3PagerFile
(
Pager
 *
pPager
)

26739 return 
pPager
->
fd
;

26740 
	}
}

26746 static 
sqlite3_file
 *
	$sqlite3PagerJrnlFile
(
Pager
 *
pPager
)

26752 return 
pPager
->
pWal
 ? 
	`sqlite3WalFile
(pPager->pWal) : pPager->
jfd
;

26754 
	}
}

26759 static const char *
	$sqlite3PagerJournalname
(
Pager
 *
pPager
)

26762 return 
pPager
->
zJournal
;

26763 
	}
}

26765 static int 
	$sqlite3PagerMovepage
(
Pager
 *
pPager
, 
DbPage
 *
pPg
, 
Pgno
 
pgno
, int 
isCommit
)

26768 
PgHdr
 *
pPgOld
;

26769 
Pgno
 
needSyncPgno
 = 0;

26770 int 
rc
;

26771 
Pgno
 
origPgno
;

26782 if( 
pPager
->
memDb
 )

26785 
rc
 = 
	`sqlite3PagerWrite
(
pPg
);

26786 if( 
rc
 ) return rc;

26789 if( (
pPg
->
flags
 & 0x002)!=0

26790 && 0!=(
rc
 = 
	`subjournalPageIfRequired
(
pPg
))

26794 return 
rc
;

26801 if( (
pPg
->
flags
&0x008) && !
isCommit
 )

26804 
needSyncPgno
 = 
pPg
->
pgno
;

26815 
pPg
->
flags
 &= ~0x008;

26816 
pPgOld
 = 
	`sqlite3PagerLookup
(
pPager
, 
pgno
);

26818 if( 
pPgOld
 )

26821 
pPg
->
flags
 |= (
pPgOld
->flags&0x008);

26822 if( 
pPager
->
memDb
 )

26827 
	`sqlite3PcacheMove
(
pPgOld
, 
pPager
->
dbSize
+1);

26829 
	`sqlite3PcacheDrop
(
pPgOld
);

26833 
origPgno
 = 
pPg
->
pgno
;

26834 
	`sqlite3PcacheMove
(
pPg
, 
pgno
);

26835 
	`sqlite3PcacheMakeDirty
(
pPg
);

26841 if( 
pPager
->
memDb
 )

26845 
	`sqlite3PcacheMove
(
pPgOld
, 
origPgno
);

26846 
	`sqlite3PagerUnrefNotNull
(
pPgOld
);

26849 if( 
needSyncPgno
 )

26853 
PgHdr
 *
pPgHdr
;

26854 
rc
 = 
	`sqlite3PagerGet
(
pPager
, 
needSyncPgno
, &
pPgHdr
, 0);

26855 if( 
rc
!=0 )

26858 if( 
needSyncPgno
<=
pPager
->
dbOrigSize
 )

26862 
	`sqlite3BitvecClear
(
pPager
->
pInJournal
, 
needSyncPgno
, pPager->
pTmpSpace
);

26864 return 
rc
;

26866 
pPgHdr
->
flags
 |= 0x008;

26867 
	`sqlite3PcacheMakeDirty
(
pPgHdr
);

26868 
	`sqlite3PagerUnrefNotNull
(
pPgHdr
);

26872 
	}
}

26874 static void 
	$sqlite3PagerRekey
(
DbPage
 *
pPg
, 
Pgno
 
iNew
, 
u16
 
flags
)

26878 
pPg
->
flags
 = flags;

26879 
	`sqlite3PcacheMove
(
pPg
, 
iNew
);

26880 
	}
}

26885 static void *
	$sqlite3PagerGetData
(
DbPage
 *
pPg
)

26889 return 
pPg
->
pData
;

26890 
	}
}

26896 static void *
	$sqlite3PagerGetExtra
(
DbPage
 *
pPg
)

26899 return 
pPg
->
pExtra
;

26900 
	}
}

26902 static int 
	$sqlite3PagerLockingMode
(
Pager
 *
pPager
, int 
eMode
)

26911 if( 
eMode
>=0 && !
pPager
->
tempFile
 && !
	`sqlite3WalHeapMemory
(pPager->
pWal
) )

26914 
pPager
->
exclusiveMode
 = (
u8
)
eMode
;

26916 return (int)
pPager
->
exclusiveMode
;

26917 
	}
}

26919 static int 
	$sqlite3PagerSetJournalMode
(
Pager
 *
pPager
, int 
eMode
)

26922 
u8
 
eOld
 = 
pPager
->
journalMode
;

26940 if( 
pPager
->
memDb
 )

26944 if( 
eMode
!=4 && eMode!=2 )

26947 
eMode
 = 
eOld
;

26951 if( 
eMode
!=
eOld
 )

26957 
pPager
->
journalMode
 = (
u8
)
eMode
;

26971 if( !
pPager
->
exclusiveMode
 && (
eOld
 & 5)==1 && (
eMode
 & 1)==0 )

26975 
	`sqlite3OsClose
(
pPager
->
jfd
);

26976 if( 
pPager
->
eLock
>=2 )

26979 
	`sqlite3OsDelete
(
pPager
->
pVfs
, pPager->
zJournal
, 0);

26981 int 
rc
 = 0;

26982 int 
state
 = 
pPager
->
eState
;

26984 if( 
state
==0 )

26987 
rc
 = 
	`sqlite3PagerSharedLock
(
pPager
);

26989 if( 
pPager
->
eState
==1 )

26993 
rc
 = 
	`pagerLockDb
(
pPager
, 2);

26995 if( 
rc
==0 )

26998 
	`sqlite3OsDelete
(
pPager
->
pVfs
, pPager->
zJournal
, 0);

27000 if( 
rc
==0 && 
state
==1 )

27003 
	`pagerUnlockDb
(
pPager
, 1);

27004 }else if( 
state
==0 )

27007 
	`pager_unlock
(
pPager
);

27011 }else if( 
eMode
==2 )

27014 
	`sqlite3OsClose
(
pPager
->
jfd
);

27019 return (int)
pPager
->
journalMode
;

27020 
	}
}

27025 static int 
	$sqlite3PagerGetJournalMode
(
Pager
 *
pPager
)

27028 return (int)
pPager
->
journalMode
;

27029 
	}
}

27036 static int 
	$sqlite3PagerOkToChangeJournalMode
(
Pager
 *
pPager
)

27040 if( 
pPager
->
eState
>=3 ) return 0;

27041 if( (((
pPager
->
jfd
)->
pMethods
!=0) && pPager->
journalOff
>0) ) return 0;

27043 
	}
}

27051 static 
i64
 
	$sqlite3PagerJournalSizeLimit
(
Pager
 *
pPager
, 
i64
 
iLimit
)

27054 if( 
iLimit
>=-1 )

27057 
pPager
->
journalSizeLimit
 = 
iLimit
;

27058 
	`sqlite3WalLimit
(
pPager
->
pWal
, 
iLimit
);

27060 return 
pPager
->
journalSizeLimit
;

27061 
	}
}

27069 static 
sqlite3_backup
 **
	$sqlite3PagerBackupPtr
(
Pager
 *
pPager
)

27072 return &
pPager
->
pBackup
;

27073 
	}
}

27079 static void 
	$sqlite3PagerClearCache
(
Pager
 *
pPager
)

27082 if( !
pPager
->
memDb
 && pPager->
tempFile
==0 ) 
	`pager_reset
(pPager);

27083 
	}
}

27085 static int 
	$sqlite3PagerCheckpoint
(
Pager
 *
pPager
, int 
eMode
, int *
pnLog
, int *
pnCkpt
)

27088 int 
rc
 = 0;

27089 if( 
pPager
->
pWal
 )

27092 
rc
 = 
	`sqlite3WalCheckpoint
(
pPager
->
pWal
, 
eMode
,

27093 (
eMode
==0 ? 0 : 
pPager
->
xBusyHandler
),

27094 
pPager
->
pBusyHandlerArg
,

27095 
pPager
->
ckptSyncFlags
, pPager->
pageSize
, (
u8
 *)pPager->
pTmpSpace
,

27096 
pnLog
, 
pnCkpt


27099 return 
rc
;

27100 
	}
}

27102 static int 
	$sqlite3PagerWalCallback
(
Pager
 *
pPager
)

27105 return 
	`sqlite3WalCallback
(
pPager
->
pWal
);

27106 
	}
}

27112 static int 
	$sqlite3PagerWalSupported
(
Pager
 *
pPager
)

27115 const 
sqlite3_io_methods
 *
pMethods
 = 
pPager
->
fd
->pMethods;

27116 if( 
pPager
->
noLock
 ) return 0;

27117 return 
pPager
->
exclusiveMode
 || (
pMethods
->
iVersion
>=2 && pMethods->
xShmMap
);

27118 
	}
}

27124 static int 
	$pagerExclusiveLock
(
Pager
 *
pPager
)

27127 int 
rc
;

27130 
rc
 = 
	`pagerLockDb
(
pPager
, 4);

27131 if( 
rc
!=0 )

27136 
	`pagerUnlockDb
(
pPager
, 1);

27139 return 
rc
;

27140 
	}
}

27148 static int 
	$pagerOpenWal
(
Pager
 *
pPager
)

27151 int 
rc
 = 0;

27161 if( 
pPager
->
exclusiveMode
 )

27164 
rc
 = 
	`pagerExclusiveLock
(
pPager
);

27170 if( 
rc
==0 )

27173 
rc
 = 
	`sqlite3WalOpen
(
pPager
->
pVfs
,

27174 
pPager
->
fd
, pPager->
zWal
, pPager->
exclusiveMode
,

27175 
pPager
->
journalSizeLimit
, &pPager->
pWal


27178 
	`pagerFixMaplimit
(
pPager
);

27180 return 
rc
;

27181 
	}
}

27183 static int 
	$sqlite3PagerOpenWal
(

27184 
Pager
 *
pPager
,

27185 int *
pbOpen


27189 int 
rc
 = 0;

27197 if( !
pPager
->
tempFile
 && !pPager->
pWal
 )

27200 if( !
	`sqlite3PagerWalSupported
(
pPager
) ) return 14;

27203 
	`sqlite3OsClose
(
pPager
->
jfd
);

27205 
rc
 = 
	`pagerOpenWal
(
pPager
);

27206 if( 
rc
==0 )

27209 
pPager
->
journalMode
 = 5;

27210 
pPager
->
eState
 = 0;

27213 *
pbOpen
 = 1;

27216 return 
rc
;

27217 
	}
}

27219 static int 
	$sqlite3PagerCloseWal
(
Pager
 *
pPager
)

27222 int 
rc
 = 0;

27230 if( !
pPager
->
pWal
 )

27233 int 
logexists
 = 0;

27234 
rc
 = 
	`pagerLockDb
(
pPager
, 1);

27235 if( 
rc
==0 )

27238 
rc
 = 
	`sqlite3OsAccess
(

27239 
pPager
->
pVfs
, pPager->
zWal
, 0, &
logexists


27242 if( 
rc
==0 && 
logexists
 )

27245 
rc
 = 
	`pagerOpenWal
(
pPager
);

27252 if( 
rc
==0 && 
pPager
->
pWal
 )

27255 
rc
 = 
	`pagerExclusiveLock
(
pPager
);

27256 if( 
rc
==0 )

27259 
rc
 = 
	`sqlite3WalClose
(
pPager
->
pWal
, pPager->
ckptSyncFlags
,

27260 
pPager
->
pageSize
, (
u8
*)pPager->
pTmpSpace
);

27261 
pPager
->
pWal
 = 0;

27262 
	`pagerFixMaplimit
(
pPager
);

27265 return 
rc
;

27266 
	}
}

27268 typedef struct 
WalIndexHdr
 
	tWalIndexHdr
;

27269 typedef struct 
WalIterator
 
	tWalIterator
;

27270 typedef struct 
WalCkptInfo
 
	tWalCkptInfo
;

27272 struct 
	sWalIndexHdr
 {

27273 
u32
 
	miVersion
;

27274 
u32
 
	munused
;

27275 
u32
 
	miChange
;

27276 
u8
 
	misInit
;

27277 
u8
 
	mbigEndCksum
;

27278 
u16
 
	mszPage
;

27279 
u32
 
	mmxFrame
;

27280 
u32
 
	mnPage
;

27281 
u32
 
	maFrameCksum
[2];

27282 
u32
 
	maSalt
[2];

27283 
u32
 
	maCksum
[2];

27286 struct 
	sWalCkptInfo
 {

27287 
u32
 
	mnBackfill
;

27288 
u32
 
	maReadMark
[(8 -3)];

27289 
u8
 
	maLock
[8];

27290 
u32
 
	mnBackfillAttempted
;

27291 
u32
 
	mnotUsed0
;

27294 struct 
	sWal
 {

27295 
sqlite3_vfs
 *
	mpVfs
;

27296 
sqlite3_file
 *
	mpDbFd
;

27297 
sqlite3_file
 *
	mpWalFd
;

27298 
u32
 
	miCallback
;

27299 
i64
 
	mmxWalSize
;

27300 int 
	mnWiData
;

27301 int 
	mszFirstBlock
;

27302 volatile 
u32
 **
	mapWiData
;

27303 
u32
 
	mszPage
;

27304 
i16
 
	mreadLock
;

27305 
u8
 
	msyncFlags
;

27306 
u8
 
	mexclusiveMode
;

27307 
u8
 
	mwriteLock
;

27308 
u8
 
	mckptLock
;

27309 
u8
 
	mreadOnly
;

27310 
u8
 
	mtruncateOnCommit
;

27311 
u8
 
	msyncHeader
;

27312 
u8
 
	mpadToSectorBoundary
;

27313 
WalIndexHdr
 
	mhdr
;

27314 
u32
 
	mminFrame
;

27315 
u32
 
	miReCksum
;

27316 const char *
	mzWalName
;

27317 
u32
 
	mnCkpt
;

27326 typedef 
u16
 
	tht_slot
;

27328 struct 
	sWalIterator
 {

27329 int 
	miPrior
;

27330 int 
	mnSegment
;

27331 struct 
	sWalSegment
 {

27332 int 
	miNext
;

27333 
ht_slot
 *
	maIndex
;

27334 
u32
 *
	maPgno
;

27335 int 
	mnEntry
;

27336 int 
	miZero
;

27337 } 
	maSegment
[1];

27340 static int 
	$walIndexPage
(
Wal
 *
pWal
, int 
iPage
, volatile 
u32
 **
ppPage
)

27343 int 
rc
 = 0;

27346 if( 
pWal
->
nWiData
<=
iPage
 )

27349 int 
nByte
 = sizeof(
u32
*)*(
iPage
+1);

27350 volatile 
u32
 **
apNew
;

27351 
apNew
 = (volatile 
u32
 **)
	`sqlite3_realloc64
((void *)
pWal
->
apWiData
, 
nByte
);

27352 if( !
apNew
 )

27355 *
ppPage
 = 0;

27358 
	`memset
((void*)&
apNew
[
pWal
->
nWiData
], 0,

27359 sizeof(
u32
*)*(
iPage
+1-
pWal
->
nWiData
));

27360 
pWal
->
apWiData
 = 
apNew
;

27361 
pWal
->
nWiData
 = 
iPage
+1;

27365 if( 
pWal
->
apWiData
[
iPage
]==0 )

27368 if( 
pWal
->
exclusiveMode
==2 )

27371 
pWal
->
apWiData
[
iPage
] = (
u32
 volatile *)
	`sqlite3MallocZero
(( sizeof(
ht_slot
)*(4096*2) + 4096*sizeof(u32) ));

27372 if( !
pWal
->
apWiData
[
iPage
] ) 
rc
 = 7;

27374 
rc
 = 
	`sqlite3OsShmMap
(
pWal
->
pDbFd
, 
iPage
, ( sizeof(
ht_slot
)*(4096*2) + 4096*sizeof(
u32
) ),

27375 
pWal
->
writeLock
, (void volatile **)&pWal->
apWiData
[
iPage
]

27377 if( 
rc
==8 )

27380 
pWal
->
readOnly
 |= 2;

27381 
rc
 = 0;

27386 *
ppPage
 = 
pWal
->
apWiData
[
iPage
];

27388 return 
rc
;

27389 
	}
}

27394 static volatile 
WalCkptInfo
 *
	$walCkptInfo
(
Wal
 *
pWal
)

27398 return (volatile 
WalCkptInfo
*)&(
pWal
->
apWiData
[0][sizeof(
WalIndexHdr
)/2]);

27399 
	}
}

27404 static volatile 
WalIndexHdr
 *
	$walIndexHdr
(
Wal
 *
pWal
)

27408 return (volatile 
WalIndexHdr
*)
pWal
->
apWiData
[0];

27409 
	}
}

27411 static void 
	$walChecksumBytes
(

27412 int 
nativeCksum
,

27413 
u8
 *
a
,

27414 int 
nByte
,

27415 const 
u32
 *
aIn
,

27416 
u32
 *
aOut


27420 
u32
 
s1
, 
s2
;

27421 
u32
 *
aData
 = (u32 *)
a
;

27422 
u32
 *
aEnd
 = (u32 *)&
a
[
nByte
];

27424 if( 
aIn
 )

27427 
s1
 = 
aIn
[0];

27428 
s2
 = 
aIn
[1];

27430 
s1
 = 
s2
 = 0;

27436 if( 
nativeCksum
 )

27440 
s1
 += *
aData
++ + 
s2
;

27441 
s2
 += *
aData
++ + 
s1
;

27442 }while( 
aData
<
aEnd
 );

27445 
s1
 += ( (((
aData
[0])&0x000000FF)<<24) + (((aData[0])&0x0000FF00)<<8) + (((aData[0])&0x00FF0000)>>8) + (((aData[0])&0xFF000000)>>24) ) + 
s2
;

27446 
s2
 += ( (((
aData
[1])&0x000000FF)<<24) + (((aData[1])&0x0000FF00)<<8) + (((aData[1])&0x00FF0000)>>8) + (((aData[1])&0xFF000000)>>24) ) + 
s1
;

27447 
aData
 += 2;

27448 }while( 
aData
<
aEnd
 );

27451 
aOut
[0] = 
s1
;

27452 
aOut
[1] = 
s2
;

27453 
	}
}

27455 static void 
	$walShmBarrier
(
Wal
 *
pWal
)

27458 if( 
pWal
->
exclusiveMode
!=2 )

27461 
	`sqlite3OsShmBarrier
(
pWal
->
pDbFd
);

27463 
	}
}

27470 static void 
	$walIndexWriteHdr
(
Wal
 *
pWal
)

27473 volatile 
WalIndexHdr
 *
aHdr
 = 
	`walIndexHdr
(
pWal
);

27474 const int 
nCksum
 = 
	`__builtin_offsetof
 (
WalIndexHdr
, 
aCksum
);

27477 
pWal
->
hdr
.
isInit
 = 1;

27478 
pWal
->
hdr
.
iVersion
 = 3007000;

27479 
	`walChecksumBytes
(1, (
u8
*)&
pWal
->
hdr
, 
nCksum
, 0, pWal->hdr.
aCksum
);

27480 
	`memcpy
((void*)&
aHdr
[1], (const void*)&
pWal
->
hdr
, sizeof(
WalIndexHdr
));

27481 
	`walShmBarrier
(
pWal
);

27482 
	`memcpy
((void*)&
aHdr
[0], (const void*)&
pWal
->
hdr
, sizeof(
WalIndexHdr
));

27483 
	}
}

27485 static void 
	$walEncodeFrame
(

27486 
Wal
 *
pWal
,

27487 
u32
 
iPage
,

27488 
u32
 
nTruncate
,

27489 
u8
 *
aData
,

27490 
u8
 *
aFrame


27494 int 
nativeCksum
;

27495 
u32
 *
aCksum
 = 
pWal
->
hdr
.
aFrameCksum
;

27497 
	`sqlite3Put4byte
(&
aFrame
[0], 
iPage
);

27498 
	`sqlite3Put4byte
(&
aFrame
[4], 
nTruncate
);

27499 if( 
pWal
->
iReCksum
==0 )

27502 
	`memcpy
(&
aFrame
[8], 
pWal
->
hdr
.
aSalt
, 8);

27504 
nativeCksum
 = (
pWal
->
hdr
.
bigEndCksum
==0);

27505 
	`walChecksumBytes
(
nativeCksum
, 
aFrame
, 8, 
aCksum
, aCksum);

27506 
	`walChecksumBytes
(
nativeCksum
, 
aData
, 
pWal
->
szPage
, 
aCksum
, aCksum);

27508 
	`sqlite3Put4byte
(&
aFrame
[16], 
aCksum
[0]);

27509 
	`sqlite3Put4byte
(&
aFrame
[20], 
aCksum
[1]);

27511 
	`memset
(&
aFrame
[8], 0, 16);

27513 
	}
}

27520 static int 
	$walDecodeFrame
(

27521 
Wal
 *
pWal
,

27522 
u32
 *
piPage
,

27523 
u32
 *
pnTruncate
,

27524 
u8
 *
aData
,

27525 
u8
 *
aFrame


27529 int 
nativeCksum
;

27530 
u32
 *
aCksum
 = 
pWal
->
hdr
.
aFrameCksum
;

27531 
u32
 
pgno
;

27537 if( 
	`memcmp
(&
pWal
->
hdr
.
aSalt
, &
aFrame
[8], 8)!=0 )

27545 
pgno
 = 
	`sqlite3Get4byte
(&
aFrame
[0]);

27546 if( 
pgno
==0 )

27557 
nativeCksum
 = (
pWal
->
hdr
.
bigEndCksum
==0);

27558 
	`walChecksumBytes
(
nativeCksum
, 
aFrame
, 8, 
aCksum
, aCksum);

27559 
	`walChecksumBytes
(
nativeCksum
, 
aData
, 
pWal
->
szPage
, 
aCksum
, aCksum);

27560 if( 
aCksum
[0]!=
	`sqlite3Get4byte
(&
aFrame
[16])

27561 || 
aCksum
[1]!=
	`sqlite3Get4byte
(&
aFrame
[20])

27572 *
piPage
 = 
pgno
;

27573 *
pnTruncate
 = 
	`sqlite3Get4byte
(&
aFrame
[4]);

27575 
	}
}

27577 static int 
	$walLockShared
(
Wal
 *
pWal
, int 
lockIdx
)

27580 int 
rc
;

27581 if( 
pWal
->
exclusiveMode
 ) return 0;

27582 
rc
 = 
	`sqlite3OsShmLock
(
pWal
->
pDbFd
, 
lockIdx
, 1,

27587 return 
rc
;

27588 
	}
}

27589 static void 
	$walUnlockShared
(
Wal
 *
pWal
, int 
lockIdx
)

27592 if( 
pWal
->
exclusiveMode
 ) return;

27593 (void)
	`sqlite3OsShmLock
(
pWal
->
pDbFd
, 
lockIdx
, 1,

27596 
	}
}

27597 static int 
	$walLockExclusive
(
Wal
 *
pWal
, int 
lockIdx
, int 
n
)

27600 int 
rc
;

27601 if( 
pWal
->
exclusiveMode
 ) return 0;

27602 
rc
 = 
	`sqlite3OsShmLock
(
pWal
->
pDbFd
, 
lockIdx
, 
n
,

27607 return 
rc
;

27608 
	}
}

27609 static void 
	$walUnlockExclusive
(
Wal
 *
pWal
, int 
lockIdx
, int 
n
)

27612 if( 
pWal
->
exclusiveMode
 ) return;

27613 (void)
	`sqlite3OsShmLock
(
pWal
->
pDbFd
, 
lockIdx
, 
n
,

27617 
	}
}

27624 static int 
	$walHash
(
u32
 
iPage
)

27629 return (
iPage
*383) & ((4096*2)-1);

27630 
	}
}

27631 static int 
	$walNextHash
(int 
iPriorHash
)

27634 return (
iPriorHash
+1)&((4096*2)-1);

27635 
	}
}

27637 static int 
	$walHashGet
(

27638 
Wal
 *
pWal
,

27639 int 
iHash
,

27640 volatile 
ht_slot
 **
paHash
,

27641 volatile 
u32
 **
paPgno
,

27642 
u32
 *
piZero


27646 int 
rc
;

27647 volatile 
u32
 *
aPgno
;

27649 
rc
 = 
	`walIndexPage
(
pWal
, 
iHash
, &
aPgno
);

27652 if( 
rc
==0 )

27655 
u32
 
iZero
;

27656 volatile 
ht_slot
 *
aHash
;

27658 
aHash
 = (volatile 
ht_slot
 *)&
aPgno
[4096];

27659 if( 
iHash
==0 )

27662 
aPgno
 = &aPgno[(sizeof(
WalIndexHdr
)*2+sizeof(
WalCkptInfo
))/sizeof(
u32
)];

27663 
iZero
 = 0;

27665 
iZero
 = (4096 - ((sizeof(
WalIndexHdr
)*2+sizeof(
WalCkptInfo
))/sizeof(
u32
))) + (
iHash
-1)*4096;

27668 *
paPgno
 = &
aPgno
[-1];

27669 *
paHash
 = 
aHash
;

27670 *
piZero
 = 
iZero
;

27672 return 
rc
;

27673 
	}
}

27681 static int 
	$walFramePage
(
u32
 
iFrame
)

27684 int 
iHash
 = (
iFrame
+4096 -(4096 - ((sizeof(
WalIndexHdr
)*2+sizeof(
WalCkptInfo
))/sizeof(
u32
)))-1) / 4096;

27691 return 
iHash
;

27692 
	}
}

27697 static 
u32
 
	$walFramePgno
(
Wal
 *
pWal
, 
u32
 
iFrame
)

27700 int 
iHash
 = 
	`walFramePage
(
iFrame
);

27701 if( 
iHash
==0 )

27704 return 
pWal
->
apWiData
[0][(sizeof(
WalIndexHdr
)*2+sizeof(
WalCkptInfo
))/sizeof(
u32
) + 
iFrame
 - 1];

27706 return 
pWal
->
apWiData
[
iHash
][(
iFrame
-1-(4096 - ((sizeof(
WalIndexHdr
)*2+sizeof(
WalCkptInfo
))/sizeof(
u32
))))%4096];

27707 
	}
}

27709 static void 
	$walCleanupHash
(
Wal
 *
pWal
)

27712 volatile 
ht_slot
 *
aHash
 = 0;

27713 volatile 
u32
 *
aPgno
 = 0;

27714 
u32
 
iZero
 = 0;

27715 int 
iLimit
 = 0;

27716 int 
nByte
;

27717 int 
i
;

27724 if( 
pWal
->
hdr
.
mxFrame
==0 ) return;

27732 
	`walHashGet
(
pWal
, 
	`walFramePage
(pWal->
hdr
.
mxFrame
), &
aHash
, &
aPgno
, &
iZero
);

27737 
iLimit
 = 
pWal
->
hdr
.
mxFrame
 - 
iZero
;

27739 for(
i
=0; i<(4096*2); i++)

27742 if( 
aHash
[
i
]>
iLimit
 )

27745 
aHash
[
i
] = 0;

27752 
nByte
 = (int)((char *)
aHash
 - (char *)&
aPgno
[
iLimit
+1]);

27753 
	`memset
((void *)&
aPgno
[
iLimit
+1], 0, 
nByte
);

27755 
	}
}

27762 static int 
	$walIndexAppend
(
Wal
 *
pWal
, 
u32
 
iFrame
, u32 
iPage
)

27765 int 
rc
;

27766 
u32
 
iZero
 = 0;

27767 volatile 
u32
 *
aPgno
 = 0;

27768 volatile 
ht_slot
 *
aHash
 = 0;

27770 
rc
 = 
	`walHashGet
(
pWal
, 
	`walFramePage
(
iFrame
), &
aHash
, &
aPgno
, &
iZero
);

27775 if( 
rc
==0 )

27778 int 
iKey
;

27779 int 
idx
;

27780 int 
nCollide
;

27782 
idx
 = 
iFrame
 - 
iZero
;

27788 if( 
idx
==1 )

27791 int 
nByte
 = (int)((
u8
 *)&
aHash
[(4096*2)] - (u8 *)&
aPgno
[1]);

27792 
	`memset
((void*)&
aPgno
[1], 0, 
nByte
);

27801 if( 
aPgno
[
idx
] )

27804 
	`walCleanupHash
(
pWal
);

27809 
nCollide
 = 
idx
;

27810 for(
iKey
=
	`walHash
(
iPage
); 
aHash
[iKey]; iKey=
	`walNextHash
(iKey))

27813 if( (
nCollide
--)==0 ) return 
	`sqlite3CorruptError
(52399);

27815 
aPgno
[
idx
] = 
iPage
;

27816 
aHash
[
iKey
] = (
ht_slot
)
idx
;

27821 return 
rc
;

27822 
	}
}

27824 static int 
	$walIndexRecover
(
Wal
 *
pWal
)

27827 int 
rc
;

27828 
i64
 
nSize
;

27829 
u32
 
aFrameCksum
[2] = {0, 0};

27830 int 
iLock
;

27831 int 
nLock
;

27843 
iLock
 = 1 + 
pWal
->
ckptLock
;

27844 
nLock
 = 8 - 
iLock
;

27845 
rc
 = 
	`walLockExclusive
(
pWal
, 
iLock
, 
nLock
);

27846 if( 
rc
 )

27849 return 
rc
;

27853 
	`memset
(&
pWal
->
hdr
, 0, sizeof(
WalIndexHdr
));

27855 
rc
 = 
	`sqlite3OsFileSize
(
pWal
->
pWalFd
, &
nSize
);

27856 if( 
rc
!=0 )

27859 goto 
recovery_error
;

27862 if( 
nSize
>32 )

27865 
u8
 
aBuf
[32];

27866 
u8
 *
aFrame
 = 0;

27867 int 
szFrame
;

27868 
u8
 *
aData
;

27869 int 
iFrame
;

27870 
i64
 
iOffset
;

27871 int 
szPage
;

27872 
u32
 
magic
;

27873 
u32
 
version
;

27874 int 
isValid
;

27877 
rc
 = 
	`sqlite3OsRead
(
pWal
->
pWalFd
, 
aBuf
, 32, 0);

27878 if( 
rc
!=0 )

27881 goto 
recovery_error
;

27889 
magic
 = 
	`sqlite3Get4byte
(&
aBuf
[0]);

27890 
szPage
 = 
	`sqlite3Get4byte
(&
aBuf
[8]);

27891 if( (
magic
&0xFFFFFFFE)!=0x377f0682

27892 || 
szPage
&(szPage-1)

27893 || 
szPage
>65536

27894 || 
szPage
<512

27898 goto 
finished
;

27900 
pWal
->
hdr
.
bigEndCksum
 = (
u8
)(
magic
&0x00000001);

27901 
pWal
->
szPage
 = szPage;

27902 
pWal
->
nCkpt
 = 
	`sqlite3Get4byte
(&
aBuf
[12]);

27903 
	`memcpy
(&
pWal
->
hdr
.
aSalt
, &
aBuf
[16], 8);

27906 
	`walChecksumBytes
(
pWal
->
hdr
.
bigEndCksum
==0,

27907 
aBuf
, 32 -2*4, 0, 
pWal
->
hdr
.
aFrameCksum


27909 if( 
pWal
->
hdr
.
aFrameCksum
[0]!=
	`sqlite3Get4byte
(&
aBuf
[24])

27910 || 
pWal
->
hdr
.
aFrameCksum
[1]!=
	`sqlite3Get4byte
(&
aBuf
[28])

27914 goto 
finished
;

27919 
version
 = 
	`sqlite3Get4byte
(&
aBuf
[4]);

27920 if( 
version
!=3007000 )

27923 
rc
 = 
	`sqlite3CantopenError
(52530);

27924 goto 
finished
;

27928 
szFrame
 = 
szPage
 + 24;

27929 
aFrame
 = (
u8
 *)
	`sqlite3_malloc64
(
szFrame
);

27930 if( !
aFrame
 )

27933 
rc
 = 7;

27934 goto 
recovery_error
;

27936 
aData
 = &
aFrame
[24];

27939 
iFrame
 = 0;

27940 for(
iOffset
=32; (iOffset+
szFrame
)<=
nSize
; iOffset+=szFrame)

27943 
u32
 
pgno
;

27944 
u32
 
nTruncate
;

27947 
iFrame
++;

27948 
rc
 = 
	`sqlite3OsRead
(
pWal
->
pWalFd
, 
aFrame
, 
szFrame
, 
iOffset
);

27949 if( 
rc
!=0 ) break;

27950 
isValid
 = 
	`walDecodeFrame
(
pWal
, &
pgno
, &
nTruncate
, 
aData
, 
aFrame
);

27951 if( !
isValid
 ) break;

27952 
rc
 = 
	`walIndexAppend
(
pWal
, 
iFrame
, 
pgno
);

27953 if( 
rc
!=0 ) break;

27956 if( 
nTruncate
 )

27959 
pWal
->
hdr
.
mxFrame
 = 
iFrame
;

27960 
pWal
->
hdr
.
nPage
 = 
nTruncate
;

27961 
pWal
->
hdr
.
szPage
 = (
u16
)((szPage&0xff00) | (szPage>>16));

27964 
aFrameCksum
[0] = 
pWal
->
hdr
.aFrameCksum[0];

27965 
aFrameCksum
[1] = 
pWal
->
hdr
.aFrameCksum[1];

27969 
	`sqlite3_free
(
aFrame
);

27972 
finished
:

27973 if( 
rc
==0 )

27976 volatile 
WalCkptInfo
 *
pInfo
;

27977 int 
i
;

27978 
pWal
->
hdr
.
aFrameCksum
[0] = aFrameCksum[0];

27979 
pWal
->
hdr
.
aFrameCksum
[1] = aFrameCksum[1];

27980 
	`walIndexWriteHdr
(
pWal
);

27986 
pInfo
 = 
	`walCkptInfo
(
pWal
);

27987 
pInfo
->
nBackfill
 = 0;

27988 
pInfo
->
nBackfillAttempted
 = 
pWal
->
hdr
.
mxFrame
;

27989 
pInfo
->
aReadMark
[0] = 0;

27990 for(
i
=1; i<(8 -3); i++) 
pInfo
->
aReadMark
[i] = 0xffffffff;

27991 if( 
pWal
->
hdr
.
mxFrame
 ) 
pInfo
->
aReadMark
[1] = pWal->hdr.mxFrame;

27998 if( 
pWal
->
hdr
.
nPage
 )

28001 
	`sqlite3_log
((27 | (1<<8)),

28003 
pWal
->
hdr
.
mxFrame
, pWal->
zWalName


28008 
recovery_error
:

28010 
	`walUnlockExclusive
(
pWal
, 
iLock
, 
nLock
);

28011 return 
rc
;

28012 
	}
}

28017 static void 
	$walIndexClose
(
Wal
 *
pWal
, int 
isDelete
)

28020 if( 
pWal
->
exclusiveMode
==2 )

28023 int 
i
;

28024 for(
i
=0; i<
pWal
->
nWiData
; i++)

28027 
	`sqlite3_free
((void *)
pWal
->
apWiData
[
i
]);

28028 
pWal
->
apWiData
[
i
] = 0;

28031 
	`sqlite3OsShmUnmap
(
pWal
->
pDbFd
, 
isDelete
);

28033 
	}
}

28035 static int 
	$sqlite3WalOpen
(

28036 
sqlite3_vfs
 *
pVfs
,

28037 
sqlite3_file
 *
pDbFd
,

28038 const char *
zWalName
,

28039 int 
bNoShm
,

28040 
i64
 
mxWalSize
,

28041 
Wal
 **
ppWal


28045 int 
rc
;

28046 
Wal
 *
pRet
;

28047 int 
flags
;

28069 *
ppWal
 = 0;

28070 
pRet
 = (
Wal
*)
	`sqlite3MallocZero
(sizeof(Wal) + 
pVfs
->
szOsFile
);

28071 if( !
pRet
 )

28077 
pRet
->
pVfs
 = pVfs;

28078 
pRet
->
pWalFd
 = (
sqlite3_file
 *)&pRet[1];

28079 
pRet
->
pDbFd
 = pDbFd;

28080 
pRet
->
readLock
 = -1;

28081 
pRet
->
mxWalSize
 = mxWalSize;

28082 
pRet
->
zWalName
 = zWalName;

28083 
pRet
->
syncHeader
 = 1;

28084 
pRet
->
padToSectorBoundary
 = 1;

28085 
pRet
->
exclusiveMode
 = (
bNoShm
 ? 2: 0);

28088 
flags
 = (0x00000002|0x00000004|0x00080000);

28089 
rc
 = 
	`sqlite3OsOpen
(
pVfs
, 
zWalName
, 
pRet
->
pWalFd
, 
flags
, &flags);

28090 if( 
rc
==0 && 
flags
&0x00000001 )

28093 
pRet
->
readOnly
 = 1;

28096 if( 
rc
!=0 )

28099 
	`walIndexClose
(
pRet
, 0);

28100 
	`sqlite3OsClose
(
pRet
->
pWalFd
);

28101 
	`sqlite3_free
(
pRet
);

28103 int 
iDC
 = 
	`sqlite3OsDeviceCharacteristics
(
pDbFd
);

28104 if( 
iDC
 & 0x00000400 )

28106 
pRet
->
syncHeader
 = 0; }

28107 if( 
iDC
 & 0x00001000 )

28110 
pRet
->
padToSectorBoundary
 = 0;

28112 *
ppWal
 = 
pRet
;

28115 return 
rc
;

28116 
	}
}

28121 static void 
	$sqlite3WalLimit
(
Wal
 *
pWal
, 
i64
 
iLimit
)

28124 if( 
pWal
 ) pWal->
mxWalSize
 = 
iLimit
;

28125 
	}
}

28127 static int 
	$walIteratorNext
(

28128 
WalIterator
 *
p
,

28129 
u32
 *
piPage
,

28130 
u32
 *
piFrame


28134 
u32
 
iMin
;

28135 
u32
 
iRet
 = 0xFFFFFFFF;

28136 int 
i
;

28138 
iMin
 = 
p
->
iPrior
;

28140 for(
i
=
p
->
nSegment
-1; i>=0; i--)

28143 struct 
WalSegment
 *
pSegment
 = &
p
->
aSegment
[
i
];

28144 while( 
pSegment
->
iNext
<pSegment->
nEntry
 )

28147 
u32
 
iPg
 = 
pSegment
->
aPgno
[pSegment->
aIndex
[pSegment->
iNext
]];

28148 if( 
iPg
>
iMin
 )

28151 if( 
iPg
<
iRet
 )

28154 
iRet
 = 
iPg
;

28155 *
piFrame
 = 
pSegment
->
iZero
 + pSegment->
aIndex
[pSegment->
iNext
];

28159 
pSegment
->
iNext
++;

28163 *
piPage
 = 
p
->
iPrior
 = 
iRet
;

28164 return (
iRet
==0xFFFFFFFF);

28165 
	}
}

28167 static void 
	$walMerge
(

28168 const 
u32
 *
aContent
,

28169 
ht_slot
 *
aLeft
,

28170 int 
nLeft
,

28171 
ht_slot
 **
paRight
,

28172 int *
pnRight
,

28173 
ht_slot
 *
aTmp


28177 int 
iLeft
 = 0;

28178 int 
iRight
 = 0;

28179 int 
iOut
 = 0;

28180 int 
nRight
 = *
pnRight
;

28181 
ht_slot
 *
aRight
 = *
paRight
;

28184 while( 
iRight
<
nRight
 || 
iLeft
<
nLeft
 )

28187 
ht_slot
 
logpage
;

28188 
Pgno
 
dbpage
;

28190 if( (
iLeft
<
nLeft
)

28191 && (
iRight
>=
nRight
 || 
aContent
[
aLeft
[
iLeft
]]<aContent[
aRight
[iRight]])

28195 
logpage
 = 
aLeft
[
iLeft
++];

28197 
logpage
 = 
aRight
[
iRight
++];

28199 
dbpage
 = 
aContent
[
logpage
];

28201 
aTmp
[
iOut
++] = 
logpage
;

28202 if( 
iLeft
<
nLeft
 && 
aContent
[
aLeft
[iLeft]]==
dbpage
 ) iLeft++;

28208 *
paRight
 = 
aLeft
;

28209 *
pnRight
 = 
iOut
;

28210 
	`memcpy
(
aLeft
, 
aTmp
, sizeof(aTmp[0])*
iOut
);

28211 
	}
}

28213 static void 
	$walMergesort
(

28214 const 
u32
 *
aContent
,

28215 
ht_slot
 *
aBuffer
,

28216 
ht_slot
 *
aList
,

28217 int *
pnList


28221 struct 
	sSublist
 {

28222 int 
nList
;

28223 
ht_slot
 *
aList
;

28226 const int 
nList
 = *
pnList
;

28227 int 
nMerge
 = 0;

28228 
ht_slot
 *
aMerge
 = 0;

28229 int 
iList
;

28230 
u32
 
iSub
 = 0;

28231 struct 
Sublist
 
aSub
[13];

28233 
	`memset
(
aSub
, 0, sizeof(aSub));

28237 for(
iList
=0; iList<
nList
; iList++)

28240 
nMerge
 = 1;

28241 
aMerge
 = &
aList
[
iList
];

28242 for(
iSub
=0; 
iList
 & (1<<iSub); iSub++)

28245 struct 
Sublist
 *
p
;

28247 
p
 = &
aSub
[
iSub
];

28250 
	`walMerge
(
aContent
, 
p
->
aList
, p->
nList
, &
aMerge
, &
nMerge
, 
aBuffer
);

28252 
aSub
[
iSub
].
aList
 = 
aMerge
;

28253 
aSub
[
iSub
].
nList
 = 
nMerge
;

28256 for(
iSub
++; iSub<((int)(sizeof(
aSub
)/sizeof(aSub[0]))); iSub++)

28259 if( 
nList
 & (1<<
iSub
) )

28262 struct 
Sublist
 *
p
;

28264 
p
 = &
aSub
[
iSub
];

28267 
	`walMerge
(
aContent
, 
p
->
aList
, p->
nList
, &
aMerge
, &
nMerge
, 
aBuffer
);

28271 *
pnList
 = 
nMerge
;

28273 
	}
}

28278 static void 
	$walIteratorFree
(
WalIterator
 *
p
)

28281 
	`sqlite3_free
(
p
);

28282 
	}
}

28284 static int 
	$walIteratorInit
(
Wal
 *
pWal
, 
WalIterator
 **
pp
)

28287 
WalIterator
 *
p
;

28288 int 
nSegment
;

28289 
u32
 
iLast
;

28290 int 
nByte
;

28291 int 
i
;

28292 
ht_slot
 *
aTmp
;

28293 int 
rc
 = 0;

28299 
iLast
 = 
pWal
->
hdr
.
mxFrame
;

28302 
nSegment
 = 
	`walFramePage
(
iLast
) + 1;

28303 
nByte
 = sizeof(
WalIterator
)

28304 + (
nSegment
-1)*sizeof(struct 
WalSegment
)

28305 + 
iLast
*sizeof(
ht_slot
);

28306 
p
 = (
WalIterator
 *)
	`sqlite3_malloc64
(
nByte
);

28307 if( !
p
 )

28312 
	`memset
(
p
, 0, 
nByte
);

28313 
p
->
nSegment
 = nSegment;

28318 
aTmp
 = (
ht_slot
 *)
	`sqlite3_malloc64
(

28319 sizeof(
ht_slot
) * (
iLast
>4096?4096:iLast)

28321 if( !
aTmp
 )

28324 
rc
 = 7;

28327 for(
i
=0; 
rc
==0 && i<
nSegment
; i++)

28330 volatile 
ht_slot
 *
aHash
;

28331 
u32
 
iZero
;

28332 volatile 
u32
 *
aPgno
;

28334 
rc
 = 
	`walHashGet
(
pWal
, 
i
, &
aHash
, &
aPgno
, &
iZero
);

28335 if( 
rc
==0 )

28338 int 
j
;

28339 int 
nEntry
;

28340 
ht_slot
 *
aIndex
;

28342 
aPgno
++;

28343 if( (
i
+1)==
nSegment
 )

28346 
nEntry
 = (int)(
iLast
 - 
iZero
);

28348 
nEntry
 = (int)((
u32
*)
aHash
 - (u32*)
aPgno
);

28350 
aIndex
 = &((
ht_slot
 *)&
p
->
aSegment
[p->
nSegment
])[
iZero
];

28351 
iZero
++;

28353 for(
j
=0; j<
nEntry
; j++)

28356 
aIndex
[
j
] = (
ht_slot
)j;

28358 
	`walMergesort
((
u32
 *)
aPgno
, 
aTmp
, 
aIndex
, &
nEntry
);

28359 
p
->
aSegment
[
i
].
iZero
 = iZero;

28360 
p
->
aSegment
[
i
].
nEntry
 = nEntry;

28361 
p
->
aSegment
[
i
].
aIndex
 = aIndex;

28362 
p
->
aSegment
[
i
].
aPgno
 = (
u32
 *)aPgno;

28365 
	`sqlite3_free
(
aTmp
);

28367 if( 
rc
!=0 )

28370 
	`walIteratorFree
(
p
);

28372 *
pp
 = 
p
;

28373 return 
rc
;

28374 
	}
}

28382 static int 
walBusyLock
(

28383 
Wal
 *
pWal
,

28384 int (*
xBusy
)(void*),

28385 void *
pBusyArg
,

28386 int 
lockIdx
,

28387 int 
n


28391 int 
rc
;

28393 
rc
 = 
	`walLockExclusive
(
pWal
, 
lockIdx
, 
n
);

28394 }while( 
xBusy
 && 
rc
==5 && 
	`xBusy
(
pBusyArg
) );

28395 return 
rc
;

28396 
	}
}

28402 static int 
	$walPagesize
(
Wal
 *
pWal
)

28405 return (
pWal
->
hdr
.
szPage
&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);

28406 
	}
}

28408 static void 
	$walRestartHdr
(
Wal
 *
pWal
, 
u32
 
salt1
)

28411 volatile 
WalCkptInfo
 *
pInfo
 = 
	`walCkptInfo
(
pWal
);

28412 int 
i
;

28413 
u32
 *
aSalt
 = 
pWal
->
hdr
.aSalt;

28414 
pWal
->
nCkpt
++;

28415 
pWal
->
hdr
.
mxFrame
 = 0;

28416 
	`sqlite3Put4byte
((
u8
*)&
aSalt
[0], 1 + 
	`sqlite3Get4byte
((u8*)&aSalt[0]));

28417 
	`memcpy
(&
pWal
->
hdr
.
aSalt
[1], &
salt1
, 4);

28418 
	`walIndexWriteHdr
(
pWal
);

28419 
pInfo
->
nBackfill
 = 0;

28420 
pInfo
->
nBackfillAttempted
 = 0;

28421 
pInfo
->
aReadMark
[1] = 0;

28422 for(
i
=2; i<(8 -3); i++) 
pInfo
->
aReadMark
[i] = 0xffffffff;

28424 
	}
}

28426 static int 
walCheckpoint
(

28427 
Wal
 *
pWal
,

28428 int 
eMode
,

28429 int (*
xBusy
)(void*),

28430 void *
pBusyArg
,

28431 int 
sync_flags
,

28432 
u8
 *
zBuf


28436 int 
rc
 = 0;

28437 int 
szPage
;

28438 
WalIterator
 *
pIter
 = 0;

28439 
u32
 
iDbpage
 = 0;

28440 
u32
 
iFrame
 = 0;

28441 
u32
 
mxSafeFrame
;

28442 
u32
 
mxPage
;

28443 int 
i
;

28444 volatile 
WalCkptInfo
 *
pInfo
;

28446 
szPage
 = 
	`walPagesize
(
pWal
);

28449 
pInfo
 = 
	`walCkptInfo
(
pWal
);

28450 if( 
pInfo
->
nBackfill
<
pWal
->
hdr
.
mxFrame
 )

28455 
rc
 = 
	`walIteratorInit
(
pWal
, &
pIter
);

28456 if( 
rc
!=0 )

28459 return 
rc
;

28472 
mxSafeFrame
 = 
pWal
->
hdr
.
mxFrame
;

28473 
mxPage
 = 
pWal
->
hdr
.
nPage
;

28474 for(
i
=1; i<(8 -3); i++)

28478 
u32
 
y
 = 
pInfo
->
aReadMark
[
i
];

28479 if( 
mxSafeFrame
>
y
 )

28483 
rc
 = 
	`walBusyLock
(
pWal
, 
xBusy
, 
pBusyArg
, (3+(
i
)), 1);

28484 if( 
rc
==0 )

28487 
pInfo
->
aReadMark
[
i
] = (i==1 ? 
mxSafeFrame
 : 0xffffffff);

28488 
	`walUnlockExclusive
(
pWal
, (3+(
i
)), 1);

28489 }else if( 
rc
==5 )

28492 
mxSafeFrame
 = 
y
;

28493 
xBusy
 = 0;

28495 goto 
walcheckpoint_out
;

28500 if( 
pInfo
->
nBackfill
<
mxSafeFrame


28501 && (
rc
 = 
	`walBusyLock
(
pWal
, 
xBusy
, 
pBusyArg
, (3+(0)),1))==0

28505 
i64
 
nSize
;

28506 
u32
 
nBackfill
 = 
pInfo
->nBackfill;

28508 
pInfo
->
nBackfillAttempted
 = 
mxSafeFrame
;

28511 if( 
sync_flags
 )

28514 
rc
 = 
	`sqlite3OsSync
(
pWal
->
pWalFd
, 
sync_flags
);

28520 if( 
rc
==0 )

28523 
i64
 
nReq
 = ((i64)
mxPage
 * 
szPage
);

28524 
rc
 = 
	`sqlite3OsFileSize
(
pWal
->
pDbFd
, &
nSize
);

28525 if( 
rc
==0 && 
nSize
<
nReq
 )

28528 
	`sqlite3OsFileControlHint
(
pWal
->
pDbFd
, 5, &
nReq
);

28534 while( 
rc
==0 && 0==
	`walIteratorNext
(
pIter
, &
iDbpage
, &
iFrame
) )

28537 
i64
 
iOffset
;

28539 if( 
iFrame
<=
nBackfill
 || iFrame>
mxSafeFrame
 || 
iDbpage
>
mxPage
 )

28544 
iOffset
 = ( 32 + ((
iFrame
)-1)*(
i64
)((
szPage
)+24) ) + 24;

28546 
rc
 = 
	`sqlite3OsRead
(
pWal
->
pWalFd
, 
zBuf
, 
szPage
, 
iOffset
);

28547 if( 
rc
!=0 ) break;

28548 
iOffset
 = (
iDbpage
-1)*(
i64
)
szPage
;

28550 
rc
 = 
	`sqlite3OsWrite
(
pWal
->
pDbFd
, 
zBuf
, 
szPage
, 
iOffset
);

28551 if( 
rc
!=0 ) break;

28555 if( 
rc
==0 )

28558 if( 
mxSafeFrame
==
	`walIndexHdr
(
pWal
)->
mxFrame
 )

28561 
i64
 
szDb
 = 
pWal
->
hdr
.
nPage
*(i64)
szPage
;

28563 
rc
 = 
	`sqlite3OsTruncate
(
pWal
->
pDbFd
, 
szDb
);

28564 if( 
rc
==0 && 
sync_flags
 )

28567 
rc
 = 
	`sqlite3OsSync
(
pWal
->
pDbFd
, 
sync_flags
);

28570 if( 
rc
==0 )

28573 
pInfo
->
nBackfill
 = 
mxSafeFrame
;

28578 
	`walUnlockExclusive
(
pWal
, (3+(0)), 1);

28581 if( 
rc
==5 )

28586 
rc
 = 0;

28595 if( 
rc
==0 && 
eMode
!=0 )

28599 if( 
pInfo
->
nBackfill
<
pWal
->
hdr
.
mxFrame
 )

28602 
rc
 = 5;

28603 }else if( 
eMode
>=2 )

28606 
u32
 
salt1
;

28607 
	`sqlite3_randomness
(4, &
salt1
);

28609 
rc
 = 
	`walBusyLock
(
pWal
, 
xBusy
, 
pBusyArg
, (3+(1)), (8 -3)-1);

28610 if( 
rc
==0 )

28613 if( 
eMode
==3 )

28617 
	`walRestartHdr
(
pWal
, 
salt1
);

28618 
rc
 = 
	`sqlite3OsTruncate
(
pWal
->
pWalFd
, 0);

28620 
	`walUnlockExclusive
(
pWal
, (3+(1)), (8 -3)-1);

28625 
walcheckpoint_out
:

28626 
	`walIteratorFree
(
pIter
);

28627 return 
rc
;

28628 
	}
}

28634 static void 
	$walLimitSize
(
Wal
 *
pWal
, 
i64
 
nMax
)

28637 
i64
 
sz
;

28638 int 
rx
;

28639 
	`sqlite3BeginBenignMalloc
();

28640 
rx
 = 
	`sqlite3OsFileSize
(
pWal
->
pWalFd
, &
sz
);

28641 if( 
rx
==0 && (
sz
 > 
nMax
 ) )

28644 
rx
 = 
	`sqlite3OsTruncate
(
pWal
->
pWalFd
, 
nMax
);

28646 
	`sqlite3EndBenignMalloc
();

28647 if( 
rx
 )

28650 
	`sqlite3_log
(
rx
, "cannot limit WAL size: %s", 
pWal
->
zWalName
);

28652 
	}
}

28657 static int 
	$sqlite3WalClose
(

28658 
Wal
 *
pWal
,

28659 int 
sync_flags
,

28660 int 
nBuf
,

28661 
u8
 *
zBuf


28665 int 
rc
 = 0;

28666 if( 
pWal
 )

28669 int 
isDelete
 = 0;

28671 
rc
 = 
	`sqlite3OsLock
(
pWal
->
pDbFd
, 4);

28672 if( 
rc
==0 )

28675 if( 
pWal
->
exclusiveMode
==0 )

28678 
pWal
->
exclusiveMode
 = 1;

28680 
rc
 = 
	`sqlite3WalCheckpoint
(

28681 
pWal
, 0, 0, 0, 
sync_flags
, 
nBuf
, 
zBuf
, 0, 0

28683 if( 
rc
==0 )

28686 int 
bPersist
 = -1;

28687 
	`sqlite3OsFileControlHint
(

28688 
pWal
->
pDbFd
, 10, &
bPersist


28690 if( 
bPersist
!=1 )

28696 
isDelete
 = 1;

28697 }else if( 
pWal
->
mxWalSize
>=0 )

28706 
	`walLimitSize
(
pWal
, 0);

28711 
	`walIndexClose
(
pWal
, 
isDelete
);

28712 
	`sqlite3OsClose
(
pWal
->
pWalFd
);

28713 if( 
isDelete
 )

28716 
	`sqlite3BeginBenignMalloc
();

28717 
	`sqlite3OsDelete
(
pWal
->
pVfs
, pWal->
zWalName
, 0);

28718 
	`sqlite3EndBenignMalloc
();

28721 
	`sqlite3_free
((void *)
pWal
->
apWiData
);

28722 
	`sqlite3_free
(
pWal
);

28724 return 
rc
;

28725 
	}
}

28727 static int 
	$walIndexTryHdr
(
Wal
 *
pWal
, int *
pChanged
)

28730 
u32
 
aCksum
[2];

28731 
WalIndexHdr
 
h1
, 
h2
;

28732 
WalIndexHdr
 volatile *
aHdr
;

28737 
aHdr
 = 
	`walIndexHdr
(
pWal
);

28738 
	`memcpy
(&
h1
, (void *)&
aHdr
[0], sizeof(h1));

28739 
	`walShmBarrier
(
pWal
);

28740 
	`memcpy
(&
h2
, (void *)&
aHdr
[1], sizeof(h2));

28742 if( 
	`memcmp
(&
h1
, &
h2
, sizeof(h1))!=0 )

28747 if( 
h1
.
isInit
==0 )

28752 
	`walChecksumBytes
(1, (
u8
*)&
h1
, sizeof(h1)-sizeof(h1.
aCksum
), 0, aCksum);

28753 if( 
aCksum
[0]!=
h1
.aCksum[0] || aCksum[1]!=h1.aCksum[1] )

28759 if( 
	`memcmp
(&
pWal
->
hdr
, &
h1
, sizeof(
WalIndexHdr
)) )

28762 *
pChanged
 = 1;

28763 
	`memcpy
(&
pWal
->
hdr
, &
h1
, sizeof(
WalIndexHdr
));

28764 
pWal
->
szPage
 = (pWal->
hdr
.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);

28771 
	}
}

28773 static int 
	$walIndexReadHdr
(
Wal
 *
pWal
, int *
pChanged
)

28776 int 
rc
;

28777 int 
badHdr
;

28778 volatile 
u32
 *
page0
;

28784 
rc
 = 
	`walIndexPage
(
pWal
, 0, &
page0
);

28785 if( 
rc
!=0 )

28788 return 
rc
;

28797 
badHdr
 = (
page0
 ? 
	`walIndexTryHdr
(
pWal
, 
pChanged
) : 1);

28803 if( 
badHdr
 )

28806 if( 
pWal
->
readOnly
 & 2 )

28809 if( 0==(
rc
 = 
	`walLockShared
(
pWal
, 0)) )

28812 
	`walUnlockShared
(
pWal
, 0);

28813 
rc
 = (8 | (1<<8));

28815 }else if( 0==(
rc
 = 
	`walLockExclusive
(
pWal
, 0, 1)) )

28818 
pWal
->
writeLock
 = 1;

28819 if( 0==(
rc
 = 
	`walIndexPage
(
pWal
, 0, &
page0
)) )

28822 
badHdr
 = 
	`walIndexTryHdr
(
pWal
, 
pChanged
);

28823 if( 
badHdr
 )

28830 
rc
 = 
	`walIndexRecover
(
pWal
);

28831 *
pChanged
 = 1;

28834 
pWal
->
writeLock
 = 0;

28835 
	`walUnlockExclusive
(
pWal
, 0, 1);

28843 if( 
badHdr
==0 && 
pWal
->
hdr
.
iVersion
!=3007000 )

28846 
rc
 = 
	`sqlite3CantopenError
(53476);

28849 return 
rc
;

28850 
	}
}

28852 static int 
	$walTryBeginRead
(
Wal
 *
pWal
, int *
pChanged
, int 
useWal
, int 
cnt
)

28855 volatile 
WalCkptInfo
 *
pInfo
;

28856 
u32
 
mxReadMark
;

28857 int 
mxI
;

28858 int 
i
;

28859 int 
rc
 = 0;

28860 
u32
 
mxFrame
;

28864 if( 
cnt
>5 )

28867 int 
nDelay
 = 1;

28868 if( 
cnt
>100 )

28874 if( 
cnt
>=10 ) 
nDelay
 = (cnt-9)*(cnt-9)*39;

28875 
	`sqlite3OsSleep
(
pWal
->
pVfs
, 
nDelay
);

28878 if( !
useWal
 )

28881 
rc
 = 
	`walIndexReadHdr
(
pWal
, 
pChanged
);

28882 if( 
rc
==5 )

28886 if( 
pWal
->
apWiData
[0]==0 )

28896 
rc
 = (-1);

28897 }else if( 0==(
rc
 = 
	`walLockShared
(
pWal
, 2)) )

28900 
	`walUnlockShared
(
pWal
, 2);

28901 
rc
 = (-1);

28902 }else if( 
rc
==5 )

28905 
rc
 = (5 | (1<<8));

28908 if( 
rc
!=0 )

28911 return 
rc
;

28915 
pInfo
 = 
	`walCkptInfo
(
pWal
);

28916 if( !
useWal
 && 
pInfo
->
nBackfill
==
pWal
->
hdr
.
mxFrame


28927 
rc
 = 
	`walLockShared
(
pWal
, (3+(0)));

28928 
	`walShmBarrier
(
pWal
);

28929 if( 
rc
==0 )

28932 if( 
	`memcmp
((void *)
	`walIndexHdr
(
pWal
), &pWal->
hdr
, sizeof(
WalIndexHdr
)) )

28936 
	`walUnlockShared
(
pWal
, (3+(0)));

28939 
pWal
->
readLock
 = 0;

28941 }else if( 
rc
!=5 )

28944 return 
rc
;

28953 
mxReadMark
 = 0;

28954 
mxI
 = 0;

28955 
mxFrame
 = 
pWal
->
hdr
.mxFrame;

28961 for(
i
=1; i<(8 -3); i++)

28964 
u32
 
thisMark
 = 
pInfo
->
aReadMark
[
i
];

28965 if( 
mxReadMark
<=
thisMark
 && thisMark<=
mxFrame
 )

28969 
mxReadMark
 = 
thisMark
;

28970 
mxI
 = 
i
;

28973 if( (
pWal
->
readOnly
 & 2)==0

28974 && (
mxReadMark
<
mxFrame
 || 
mxI
==0)

28978 for(
i
=1; i<(8 -3); i++)

28981 
rc
 = 
	`walLockExclusive
(
pWal
, (3+(
i
)), 1);

28982 if( 
rc
==0 )

28985 
mxReadMark
 = 
pInfo
->
aReadMark
[
i
] = 
mxFrame
;

28986 
mxI
 = 
i
;

28987 
	`walUnlockExclusive
(
pWal
, (3+(
i
)), 1);

28989 }else if( 
rc
!=5 )

28992 return 
rc
;

28996 if( 
mxI
==0 )

29000 return 
rc
==5 ? (-1) : (8 | (2<<8));

29003 
rc
 = 
	`walLockShared
(
pWal
, (3+(
mxI
)));

29004 if( 
rc
 )

29007 return 
rc
==5 ? (-1) : rc;

29010 
pWal
->
minFrame
 = 
pInfo
->
nBackfill
+1;

29011 
	`walShmBarrier
(
pWal
);

29012 if( 
pInfo
->
aReadMark
[
mxI
]!=
mxReadMark


29013 || 
	`memcmp
((void *)
	`walIndexHdr
(
pWal
), &pWal->
hdr
, sizeof(
WalIndexHdr
))

29017 
	`walUnlockShared
(
pWal
, (3+(
mxI
)));

29021 
pWal
->
readLock
 = (
i16
)
mxI
;

29023 return 
rc
;

29024 
	}
}

29026 static int 
	$sqlite3WalBeginReadTransaction
(
Wal
 *
pWal
, int *
pChanged
)

29029 int 
rc
;

29030 int 
cnt
 = 0;

29033 
rc
 = 
	`walTryBeginRead
(
pWal
, 
pChanged
, 0, ++
cnt
);

29034 }while( 
rc
==(-1) );

29040 return 
rc
;

29041 
	}
}

29047 static void 
	$sqlite3WalEndReadTransaction
(
Wal
 *
pWal
)

29050 
	`sqlite3WalEndWriteTransaction
(
pWal
);

29051 if( 
pWal
->
readLock
>=0 )

29054 
	`walUnlockShared
(
pWal
, (3+(pWal->
readLock
)));

29055 
pWal
->
readLock
 = -1;

29057 
	}
}

29059 static int 
	$sqlite3WalFindFrame
(

29060 
Wal
 *
pWal
,

29061 
Pgno
 
pgno
,

29062 
u32
 *
piRead


29066 
u32
 
iRead
 = 0;

29067 
u32
 
iLast
 = 
pWal
->
hdr
.
mxFrame
;

29068 int 
iHash
;

29069 int 
iMinHash
;

29080 if( 
iLast
==0 || 
pWal
->
readLock
==0 )

29083 *
piRead
 = 0;

29087 
iMinHash
 = 
	`walFramePage
(
pWal
->
minFrame
);

29088 for(
iHash
=
	`walFramePage
(
iLast
); iHash>=
iMinHash
 && 
iRead
==0; iHash--)

29091 volatile 
ht_slot
 *
aHash
;

29092 volatile 
u32
 *
aPgno
;

29093 
u32
 
iZero
;

29094 int 
iKey
;

29095 int 
nCollide
;

29096 int 
rc
;

29098 
rc
 = 
	`walHashGet
(
pWal
, 
iHash
, &
aHash
, &
aPgno
, &
iZero
);

29099 if( 
rc
!=0 )

29102 return 
rc
;

29104 
nCollide
 = (4096*2);

29105 for(
iKey
=
	`walHash
(
pgno
); 
aHash
[iKey]; iKey=
	`walNextHash
(iKey))

29108 
u32
 
iFrame
 = 
aHash
[
iKey
] + 
iZero
;

29109 if( 
iFrame
<=
iLast
 && iFrame>=
pWal
->
minFrame
 && 
aPgno
[
aHash
[
iKey
]]==
pgno
 )

29113 
iRead
 = 
iFrame
;

29115 if( (
nCollide
--)==0 )

29118 return 
	`sqlite3CorruptError
(53923);

29123 *
piRead
 = 
iRead
;

29125 
	}
}

29132 static int 
	$sqlite3WalReadFrame
(

29133 
Wal
 *
pWal
,

29134 
u32
 
iRead
,

29135 int 
nOut
,

29136 
u8
 *
pOut


29140 int 
sz
;

29141 
i64
 
iOffset
;

29142 
sz
 = 
pWal
->
hdr
.
szPage
;

29143 
sz
 = (sz&0xfe00) + ((sz&0x0001)<<16);

29146 
iOffset
 = ( 32 + ((
iRead
)-1)*(
i64
)((
sz
)+24) ) + 24;

29148 return 
	`sqlite3OsRead
(
pWal
->
pWalFd
, 
pOut
, (
nOut
>
sz
 ? sz : nOut), 
iOffset
);

29149 
	}
}

29154 static 
Pgno
 
	$sqlite3WalDbsize
(
Wal
 *
pWal
)

29157 if( 
pWal
 && (pWal->
readLock
>=0) )

29160 return 
pWal
->
hdr
.
nPage
;

29163 
	}
}

29165 static int 
	$sqlite3WalBeginWriteTransaction
(
Wal
 *
pWal
)

29168 int 
rc
;

29175 if( 
pWal
->
readOnly
 )

29184 
rc
 = 
	`walLockExclusive
(
pWal
, 0, 1);

29185 if( 
rc
 )

29188 return 
rc
;

29190 
pWal
->
writeLock
 = 1;

29196 if( 
	`memcmp
(&
pWal
->
hdr
, (void *)
	`walIndexHdr
(pWal), sizeof(
WalIndexHdr
))!=0 )

29199 
	`walUnlockExclusive
(
pWal
, 0, 1);

29200 
pWal
->
writeLock
 = 0;

29201 
rc
 = (5 | (2<<8));

29204 return 
rc
;

29205 
	}
}

29211 static int 
	$sqlite3WalEndWriteTransaction
(
Wal
 *
pWal
)

29214 if( 
pWal
->
writeLock
 )

29217 
	`walUnlockExclusive
(
pWal
, 0, 1);

29218 
pWal
->
writeLock
 = 0;

29219 
pWal
->
iReCksum
 = 0;

29220 
pWal
->
truncateOnCommit
 = 0;

29223 
	}
}

29225 static int 
sqlite3WalUndo
(
Wal
 *
pWal
, int (*
xUndo
)(void *, 
Pgno
), void *
pUndoCtx
)

29228 int 
rc
 = 0;

29229 if( (
pWal
->
writeLock
) )

29232 
Pgno
 
iMax
 = 
pWal
->
hdr
.
mxFrame
;

29233 
Pgno
 
iFrame
;

29238 
	`memcpy
(&
pWal
->
hdr
, (void *)
	`walIndexHdr
(pWal), sizeof(
WalIndexHdr
));

29240 for(
iFrame
=
pWal
->
hdr
.
mxFrame
+1;

29241 (
rc
==0) && 
iFrame
<=
iMax
;

29242 
iFrame
++

29248 
rc
 = 
	`xUndo
(
pUndoCtx
, 
	`walFramePgno
(
pWal
, 
iFrame
));

29250 if( 
iMax
!=
pWal
->
hdr
.
mxFrame
 ) 
	`walCleanupHash
(pWal);

29252 return 
rc
;

29253 
	}
}

29261 static void 
	$sqlite3WalSavepoint
(
Wal
 *
pWal
, 
u32
 *
aWalData
)

29265 
aWalData
[0] = 
pWal
->
hdr
.
mxFrame
;

29266 
aWalData
[1] = 
pWal
->
hdr
.
aFrameCksum
[0];

29267 
aWalData
[2] = 
pWal
->
hdr
.
aFrameCksum
[1];

29268 
aWalData
[3] = 
pWal
->
nCkpt
;

29269 
	}
}

29277 static int 
	$sqlite3WalSavepointUndo
(
Wal
 *
pWal
, 
u32
 *
aWalData
)

29280 int 
rc
 = 0;

29285 if( 
aWalData
[3]!=
pWal
->
nCkpt
 )

29292 
aWalData
[0] = 0;

29293 
aWalData
[3] = 
pWal
->
nCkpt
;

29296 if( 
aWalData
[0]<
pWal
->
hdr
.
mxFrame
 )

29299 
pWal
->
hdr
.
mxFrame
 = 
aWalData
[0];

29300 
pWal
->
hdr
.
aFrameCksum
[0] = 
aWalData
[1];

29301 
pWal
->
hdr
.
aFrameCksum
[1] = 
aWalData
[2];

29302 
	`walCleanupHash
(
pWal
);

29305 return 
rc
;

29306 
	}
}

29308 static int 
	$walRestartLog
(
Wal
 *
pWal
)

29311 int 
rc
 = 0;

29312 int 
cnt
;

29314 if( 
pWal
->
readLock
==0 )

29317 volatile 
WalCkptInfo
 *
pInfo
 = 
	`walCkptInfo
(
pWal
);

29319 if( 
pInfo
->
nBackfill
>0 )

29322 
u32
 
salt1
;

29323 
	`sqlite3_randomness
(4, &
salt1
);

29324 
rc
 = 
	`walLockExclusive
(
pWal
, (3+(1)), (8 -3)-1);

29325 if( 
rc
==0 )

29329 
	`walRestartHdr
(
pWal
, 
salt1
);

29330 
	`walUnlockExclusive
(
pWal
, (3+(1)), (8 -3)-1);

29331 }else if( 
rc
!=5 )

29334 return 
rc
;

29337 
	`walUnlockShared
(
pWal
, (3+(0)));

29338 
pWal
->
readLock
 = -1;

29339 
cnt
 = 0;

29341 int 
notUsed
;

29342 
rc
 = 
	`walTryBeginRead
(
pWal
, &
notUsed
, 1, ++
cnt
);

29343 }while( 
rc
==(-1) );

29349 return 
rc
;

29350 
	}
}

29357 typedef struct 
	sWalWriter
 {

29358 
Wal
 *
	mpWal
;

29359 
sqlite3_file
 *
	mpFd
;

29360 
sqlite3_int64
 
	miSyncPoint
;

29361 int 
	msyncFlags
;

29362 int 
	mszPage
;

29363 } 
	tWalWriter
;

29365 static int 
	$walWriteToLog
(

29366 
WalWriter
 *
p
,

29367 void *
pContent
,

29368 int 
iAmt
,

29369 
sqlite3_int64
 
iOffset


29373 int 
rc
;

29374 if( 
iOffset
<
p
->
iSyncPoint
 && iOffset+
iAmt
>=p->iSyncPoint )

29377 int 
iFirstAmt
 = (int)(
p
->
iSyncPoint
 - 
iOffset
);

29378 
rc
 = 
	`sqlite3OsWrite
(
p
->
pFd
, 
pContent
, 
iFirstAmt
, 
iOffset
);

29379 if( 
rc
 ) return rc;

29380 
iOffset
 += 
iFirstAmt
;

29381 
iAmt
 -= 
iFirstAmt
;

29382 
pContent
 = (void*)(
iFirstAmt
 + (char*)pContent);

29384 
rc
 = 
	`sqlite3OsSync
(
p
->
pFd
, p->
syncFlags
 & 0x13);

29385 if( 
iAmt
==0 || 
rc
 ) return rc;

29387 
rc
 = 
	`sqlite3OsWrite
(
p
->
pFd
, 
pContent
, 
iAmt
, 
iOffset
);

29388 return 
rc
;

29389 
	}
}

29394 static int 
	$walWriteOneFrame
(

29395 
WalWriter
 *
p
,

29396 
PgHdr
 *
pPage
,

29397 int 
nTruncate
,

29398 
sqlite3_int64
 
iOffset


29402 int 
rc
;

29403 void *
pData
;

29404 
u8
 
aFrame
[24];

29408 
pData
 = 
pPage
->pData;

29410 
	`walEncodeFrame
(
p
->
pWal
, 
pPage
->
pgno
, 
nTruncate
, 
pData
, 
aFrame
);

29411 
rc
 = 
	`walWriteToLog
(
p
, 
aFrame
, sizeof(aFrame), 
iOffset
);

29412 if( 
rc
 ) return rc;

29414 
rc
 = 
	`walWriteToLog
(
p
, 
pData
, p->
szPage
, 
iOffset
+sizeof(
aFrame
));

29415 return 
rc
;

29416 
	}
}

29418 static int 
	$walRewriteChecksums
(
Wal
 *
pWal
, 
u32
 
iLast
)

29421 const int 
szPage
 = 
pWal
->szPage;

29422 int 
rc
 = 0;

29423 
u8
 *
aBuf
;

29424 
u8
 
aFrame
[24];

29425 
u32
 
iRead
;

29426 
i64
 
iCksumOff
;

29428 
aBuf
 = 
	`sqlite3_malloc
(
szPage
 + 24);

29429 if( 
aBuf
==0 ) return 7;

29437 if( 
pWal
->
iReCksum
==1 )

29440 
iCksumOff
 = 24;

29442 
iCksumOff
 = ( 32 + ((
pWal
->
iReCksum
-1)-1)*(
i64
)((
szPage
)+24) ) + 16;

29444 
rc
 = 
	`sqlite3OsRead
(
pWal
->
pWalFd
, 
aBuf
, sizeof(
u32
)*2, 
iCksumOff
);

29445 
pWal
->
hdr
.
aFrameCksum
[0] = 
	`sqlite3Get4byte
(
aBuf
);

29446 
pWal
->
hdr
.
aFrameCksum
[1] = 
	`sqlite3Get4byte
(&
aBuf
[sizeof(
u32
)]);

29448 
iRead
 = 
pWal
->
iReCksum
;

29449 
pWal
->
iReCksum
 = 0;

29450 for(; 
rc
==0 && 
iRead
<=
iLast
; iRead++)

29453 
i64
 
iOff
 = ( 32 + ((
iRead
)-1)*(i64)((
szPage
)+24) );

29454 
rc
 = 
	`sqlite3OsRead
(
pWal
->
pWalFd
, 
aBuf
, 
szPage
+24, 
iOff
);

29455 if( 
rc
==0 )

29458 
u32
 
iPgno
, 
nDbSize
;

29459 
iPgno
 = 
	`sqlite3Get4byte
(
aBuf
);

29460 
nDbSize
 = 
	`sqlite3Get4byte
(&
aBuf
[4]);

29462 
	`walEncodeFrame
(
pWal
, 
iPgno
, 
nDbSize
, &
aBuf
[24], 
aFrame
);

29463 
rc
 = 
	`sqlite3OsWrite
(
pWal
->
pWalFd
, 
aFrame
, sizeof(aFrame), 
iOff
);

29467 
	`sqlite3_free
(
aBuf
);

29468 return 
rc
;

29469 
	}
}

29475 static int 
	$sqlite3WalFrames
(

29476 
Wal
 *
pWal
,

29477 int 
szPage
,

29478 
PgHdr
 *
pList
,

29479 
Pgno
 
nTruncate
,

29480 int 
isCommit
,

29481 int 
sync_flags


29485 int 
rc
;

29486 
u32
 
iFrame
;

29487 
PgHdr
 *
p
;

29488 
PgHdr
 *
pLast
 = 0;

29489 int 
nExtra
 = 0;

29490 int 
szFrame
;

29491 
i64
 
iOffset
;

29492 
WalWriter
 
w
;

29493 
u32
 
iFirst
 = 0;

29494 
WalIndexHdr
 *
pLive
;

29503 
pLive
 = (
WalIndexHdr
*)
	`walIndexHdr
(
pWal
);

29504 if( 
	`memcmp
(&
pWal
->
hdr
, (void *)
pLive
, sizeof(
WalIndexHdr
))!=0 )

29507 
iFirst
 = 
pLive
->
mxFrame
+1;

29513 if( 0!=(
rc
 = 
	`walRestartLog
(
pWal
)) )

29516 return 
rc
;

29523 
iFrame
 = 
pWal
->
hdr
.
mxFrame
;

29524 if( 
iFrame
==0 )

29527 
u8
 
aWalHdr
[32];

29528 
u32
 
aCksum
[2];

29530 
	`sqlite3Put4byte
(&
aWalHdr
[0], (0x377f0682 | 0));

29531 
	`sqlite3Put4byte
(&
aWalHdr
[4], 3007000);

29532 
	`sqlite3Put4byte
(&
aWalHdr
[8], 
szPage
);

29533 
	`sqlite3Put4byte
(&
aWalHdr
[12], 
pWal
->
nCkpt
);

29534 if( 
pWal
->
nCkpt
==0 ) 
	`sqlite3_randomness
(8, pWal->
hdr
.
aSalt
);

29535 
	`memcpy
(&
aWalHdr
[16], 
pWal
->
hdr
.
aSalt
, 8);

29536 
	`walChecksumBytes
(1, 
aWalHdr
, 32 -2*4, 0, 
aCksum
);

29537 
	`sqlite3Put4byte
(&
aWalHdr
[24], 
aCksum
[0]);

29538 
	`sqlite3Put4byte
(&
aWalHdr
[28], 
aCksum
[1]);

29540 
pWal
->
szPage
 = szPage;

29541 
pWal
->
hdr
.
bigEndCksum
 = 0;

29542 
pWal
->
hdr
.
aFrameCksum
[0] = 
aCksum
[0];

29543 
pWal
->
hdr
.
aFrameCksum
[1] = 
aCksum
[1];

29544 
pWal
->
truncateOnCommit
 = 1;

29546 
rc
 = 
	`sqlite3OsWrite
(
pWal
->
pWalFd
, 
aWalHdr
, sizeof(aWalHdr), 0);

29548 if( 
rc
!=0 )

29551 return 
rc
;

29554 if( 
pWal
->
syncHeader
 && 
sync_flags
 )

29557 
rc
 = 
	`sqlite3OsSync
(
pWal
->
pWalFd
, 
sync_flags
 & 0x13);

29558 if( 
rc
 ) return rc;

29564 
w
.
pWal
 = pWal;

29565 
w
.
pFd
 = 
pWal
->
pWalFd
;

29566 
w
.
iSyncPoint
 = 0;

29567 
w
.
syncFlags
 = 
sync_flags
;

29568 
w
.
szPage
 = szPage;

29569 
iOffset
 = ( 32 + ((
iFrame
+1)-1)*(
i64
)((
szPage
)+24) );

29570 
szFrame
 = 
szPage
 + 24;

29573 for(
p
=
pList
; p; p=p->
pDirty
)

29576 int 
nDbSize
;

29582 if( 
iFirst
 && (
p
->
pDirty
 || 
isCommit
==0) )

29585 
u32
 
iWrite
 = 0;

29586 
	`sqlite3WalFindFrame
(
pWal
, 
p
->
pgno
, &
iWrite
);

29588 if( 
iWrite
>=
iFirst
 )

29591 
i64
 
iOff
 = ( 32 + ((
iWrite
)-1)*(i64)((
szPage
)+24) ) + 24;

29592 void *
pData
;

29593 if( 
pWal
->
iReCksum
==0 || 
iWrite
<pWal->iReCksum )

29596 
pWal
->
iReCksum
 = 
iWrite
;

29601 
pData
 = 
p
->pData;

29603 
rc
 = 
	`sqlite3OsWrite
(
pWal
->
pWalFd
, 
pData
, 
szPage
, 
iOff
);

29604 if( 
rc
 ) return rc;

29605 
p
->
flags
 &= ~0x080;

29610 
iFrame
++;

29612 
nDbSize
 = (
isCommit
 && 
p
->
pDirty
==0) ? 
nTruncate
 : 0;

29613 
rc
 = 
	`walWriteOneFrame
(&
w
, 
p
, 
nDbSize
, 
iOffset
);

29614 if( 
rc
 ) return rc;

29615 
pLast
 = 
p
;

29616 
iOffset
 += 
szFrame
;

29617 
p
->
flags
 |= 0x080;

29621 if( 
isCommit
 && 
pWal
->
iReCksum
 )

29624 
rc
 = 
	`walRewriteChecksums
(
pWal
, 
iFrame
);

29625 if( 
rc
 ) return rc;

29628 if( 
isCommit
 && (
sync_flags
 & 0x20)!=0 )

29631 if( 
pWal
->
padToSectorBoundary
 )

29634 int 
sectorSize
 = 
	`sqlite3SectorSize
(
pWal
->
pWalFd
);

29635 
w
.
iSyncPoint
 = ((
iOffset
+
sectorSize
-1)/sectorSize)*sectorSize;

29636 while( 
iOffset
<
w
.
iSyncPoint
 )

29639 
rc
 = 
	`walWriteOneFrame
(&
w
, 
pLast
, 
nTruncate
, 
iOffset
);

29640 if( 
rc
 ) return rc;

29641 
iOffset
 += 
szFrame
;

29642 
nExtra
++;

29645 
rc
 = 
	`sqlite3OsSync
(
w
.
pFd
, 
sync_flags
 & 0x13);

29653 if( 
isCommit
 && 
pWal
->
truncateOnCommit
 && pWal->
mxWalSize
>=0 )

29656 
i64
 
sz
 = 
pWal
->
mxWalSize
;

29657 if( ( 32 + ((
iFrame
+
nExtra
+1)-1)*(
i64
)((
szPage
)+24) )>
pWal
->
mxWalSize
 )

29660 
sz
 = ( 32 + ((
iFrame
+
nExtra
+1)-1)*(
i64
)((
szPage
)+24) );

29662 
	`walLimitSize
(
pWal
, 
sz
);

29663 
pWal
->
truncateOnCommit
 = 0;

29671 
iFrame
 = 
pWal
->
hdr
.
mxFrame
;

29672 for(
p
=
pList
; p && 
rc
==0; p=p->
pDirty
)

29675 if( (
p
->
flags
 & 0x080)==0 ) continue;

29676 
iFrame
++;

29677 
rc
 = 
	`walIndexAppend
(
pWal
, 
iFrame
, 
p
->
pgno
);

29679 while( 
rc
==0 && 
nExtra
>0 )

29682 
iFrame
++;

29683 
nExtra
--;

29684 
rc
 = 
	`walIndexAppend
(
pWal
, 
iFrame
, 
pLast
->
pgno
);

29687 if( 
rc
==0 )

29691 
pWal
->
hdr
.
szPage
 = (
u16
)((szPage&0xff00) | (szPage>>16));

29694 
pWal
->
hdr
.
mxFrame
 = 
iFrame
;

29695 if( 
isCommit
 )

29698 
pWal
->
hdr
.
iChange
++;

29699 
pWal
->
hdr
.
nPage
 = 
nTruncate
;

29702 if( 
isCommit
 )

29705 
	`walIndexWriteHdr
(
pWal
);

29706 
pWal
->
iCallback
 = 
iFrame
;

29711 return 
rc
;

29712 
	}
}

29714 static int 
sqlite3WalCheckpoint
(

29715 
Wal
 *
pWal
,

29716 int 
eMode
,

29717 int (*
xBusy
)(void*),

29718 void *
pBusyArg
,

29719 int 
sync_flags
,

29720 int 
nBuf
,

29721 
u8
 *
zBuf
,

29722 int *
pnLog
,

29723 int *
pnCkpt


29727 int 
rc
;

29728 int 
isChanged
 = 0;

29729 int 
eMode2
 = 
eMode
;

29730 int (*
xBusy2
)(void*) = 
xBusy
;

29739 if( 
pWal
->
readOnly
 ) return 8;

29744 
rc
 = 
	`walLockExclusive
(
pWal
, 1, 1);

29745 if( 
rc
 )

29756 return 
rc
;

29758 
pWal
->
ckptLock
 = 1;

29760 if( 
eMode
!=0 )

29763 
rc
 = 
	`walBusyLock
(
pWal
, 
xBusy
, 
pBusyArg
, 0, 1);

29764 if( 
rc
==0 )

29767 
pWal
->
writeLock
 = 1;

29768 }else if( 
rc
==5 )

29771 
eMode2
 = 0;

29772 
xBusy2
 = 0;

29773 
rc
 = 0;

29778 if( 
rc
==0 )

29781 
rc
 = 
	`walIndexReadHdr
(
pWal
, &
isChanged
);

29782 if( 
isChanged
 && 
pWal
->
pDbFd
->
pMethods
->
iVersion
>=3 )

29785 
	`sqlite3OsUnfetch
(
pWal
->
pDbFd
, 0, 0);

29790 if( 
rc
==0 )

29794 if( 
pWal
->
hdr
.
mxFrame
 && 
	`walPagesize
(pWal)!=
nBuf
 )

29797 
rc
 = 
	`sqlite3CorruptError
(54623);

29799 
rc
 = 
	`walCheckpoint
(
pWal
, 
eMode2
, 
xBusy2
, 
pBusyArg
, 
sync_flags
, 
zBuf
);

29803 if( 
rc
==0 || rc==5 )

29806 if( 
pnLog
 ) *pnLog = (int)
pWal
->
hdr
.
mxFrame
;

29807 if( 
pnCkpt
 ) *pnCkpt = (int)(
	`walCkptInfo
(
pWal
)->
nBackfill
);

29811 if( 
isChanged
 )

29820 
	`memset
(&
pWal
->
hdr
, 0, sizeof(
WalIndexHdr
));

29824 
	`sqlite3WalEndWriteTransaction
(
pWal
);

29825 
	`walUnlockExclusive
(
pWal
, 1, 1);

29826 
pWal
->
ckptLock
 = 0;

29828 return (
rc
==0 && 
eMode
!=
eMode2
 ? 5 : rc);

29829 
	}
}

29836 static int 
	$sqlite3WalCallback
(
Wal
 *
pWal
)

29839 
u32
 
ret
 = 0;

29840 if( 
pWal
 )

29843 
ret
 = 
pWal
->
iCallback
;

29844 
pWal
->
iCallback
 = 0;

29846 return (int)
ret
;

29847 
	}
}

29849 static int 
	$sqlite3WalExclusiveMode
(
Wal
 *
pWal
, int 
op
)

29852 int 
rc
;

29865 if( 
op
==0 )

29868 if( 
pWal
->
exclusiveMode
 )

29871 
pWal
->
exclusiveMode
 = 0;

29872 if( 
	`walLockShared
(
pWal
, (3+(pWal->
readLock
)))!=0 )

29875 
pWal
->
exclusiveMode
 = 1;

29877 
rc
 = 
pWal
->
exclusiveMode
==0;

29880 
rc
 = 0;

29882 }else if( 
op
>0 )

29887 
	`walUnlockShared
(
pWal
, (3+(pWal->
readLock
)));

29888 
pWal
->
exclusiveMode
 = 1;

29889 
rc
 = 1;

29891 
rc
 = 
pWal
->
exclusiveMode
==0;

29893 return 
rc
;

29894 
	}
}

29901 static int 
	$sqlite3WalHeapMemory
(
Wal
 *
pWal
)

29904 return (
pWal
 && pWal->
exclusiveMode
==2 );

29905 
	}
}

29907 static 
sqlite3_file
 *
	$sqlite3WalFile
(
Wal
 *
pWal
)

29910 return 
pWal
->
pWalFd
;

29911 
	}
}

29913 typedef struct 
MemPage
 
	tMemPage
;

29914 typedef struct 
BtLock
 
	tBtLock
;

29915 typedef struct 
CellInfo
 
	tCellInfo
;

29917 struct 
	sMemPage
 {

29918 
u8
 
	misInit
;

29919 
u8
 
	mnOverflow
;

29920 
u8
 
	mintKey
;

29921 
u8
 
	mintKeyLeaf
;

29922 
u8
 
	mleaf
;

29923 
u8
 
	mhdrOffset
;

29924 
u8
 
	mchildPtrSize
;

29925 
u8
 
	mmax1bytePayload
;

29926 
u8
 
	mbBusy
;

29927 
u16
 
	mmaxLocal
;

29928 
u16
 
	mminLocal
;

29929 
u16
 
	mcellOffset
;

29930 
u16
 
	mnFree
;

29931 
u16
 
	mnCell
;

29932 
u16
 
	mmaskPage
;

29933 
u16
 
	maiOvfl
[5];

29935 
u8
 *
	mapOvfl
[5];

29936 
BtShared
 *
	mpBt
;

29937 
u8
 *
	maData
;

29938 
u8
 *
	maDataEnd
;

29939 
u8
 *
	maCellIdx
;

29940 
u8
 *
	maDataOfst
;

29941 
DbPage
 *
	mpDbPage
;

29942 
u16
 (*
xCellSize
)(
	mMemPage
*,
	mu8
*);

29943 void (*
	mxParseCell
)(
	mMemPage
*,
	mu8
*,
	mCellInfo
*);

29944 
Pgno
 
	mpgno
;

29947 struct 
	sBtLock
 {

29948 
Btree
 *
	mpBtree
;

29949 
Pgno
 
	miTable
;

29950 
u8
 
	meLock
;

29951 
BtLock
 *
	mpNext
;

29954 struct 
	sBtree
 {

29955 
sqlite3
 *
	mdb
;

29956 
BtShared
 *
	mpBt
;

29957 
u8
 
	minTrans
;

29958 
u8
 
	msharable
;

29959 
u8
 
	mlocked
;

29960 
u8
 
	mhasIncrblobCur
;

29961 int 
	mwantToLock
;

29962 int 
	mnBackup
;

29963 
u32
 
	miDataVersion
;

29964 
Btree
 *
	mpNext
;

29965 
Btree
 *
	mpPrev
;

29967 
BtLock
 
	mlock
;

29971 struct 
	sBtShared
 {

29972 
Pager
 *
	mpPager
;

29973 
sqlite3
 *
	mdb
;

29974 
BtCursor
 *
	mpCursor
;

29975 
MemPage
 *
	mpPage1
;

29976 
u8
 
	mopenFlags
;

29978 
u8
 
	mautoVacuum
;

29979 
u8
 
	mincrVacuum
;

29980 
u8
 
	mbDoTruncate
;

29982 
u8
 
	minTransaction
;

29983 
u8
 
	mmax1bytePayload
;

29987 
u16
 
	mbtsFlags
;

29988 
u16
 
	mmaxLocal
;

29989 
u16
 
	mminLocal
;

29990 
u16
 
	mmaxLeaf
;

29991 
u16
 
	mminLeaf
;

29992 
u32
 
	mpageSize
;

29993 
u32
 
	musableSize
;

29994 int 
	mnTransaction
;

29995 
u32
 
	mnPage
;

29996 void *
	mpSchema
;

29997 void (*
	mxFreeSchema
)(void*);

29998 
sqlite3_mutex
 *
	mmutex
;

29999 
Bitvec
 *
	mpHasContent
;

30001 int 
	mnRef
;

30002 
BtShared
 *
	mpNext
;

30003 
BtLock
 *
	mpLock
;

30004 
Btree
 *
	mpWriter
;

30006 
u8
 *
	mpTmpSpace
;

30009 struct 
	sCellInfo
 {

30010 
i64
 
	mnKey
;

30011 
u8
 *
	mpPayload
;

30012 
u32
 
	mnPayload
;

30013 
u16
 
	mnLocal
;

30014 
u16
 
	mnSize
;

30017 struct 
	sBtCursor
 {

30018 
Btree
 *
	mpBtree
;

30019 
BtShared
 *
	mpBt
;

30020 
BtCursor
 *
	mpNext
;

30021 
Pgno
 *
	maOverflow
;

30022 
CellInfo
 
	minfo
;

30023 
i64
 
	mnKey
;

30024 void *
	mpKey
;

30025 
Pgno
 
	mpgnoRoot
;

30026 int 
	mnOvflAlloc
;

30027 int 
	mskipNext
;

30029 
u8
 
	mcurFlags
;

30030 
u8
 
	mcurPagerFlags
;

30031 
u8
 
	meState
;

30032 
u8
 
	mhints
;

30036 
i8
 
	miPage
;

30037 
u8
 
	mcurIntKey
;

30038 struct 
KeyInfo
 *
	mpKeyInfo
;

30039 void *
	mpadding1
;

30040 
u16
 
	maiIdx
[20];

30041 
MemPage
 *
	mapPage
[20];

30044 typedef struct 
IntegrityCk
 
	tIntegrityCk
;

30045 struct 
	sIntegrityCk
 {

30046 
BtShared
 *
	mpBt
;

30047 
Pager
 *
	mpPager
;

30048 
u8
 *
	maPgRef
;

30049 
Pgno
 
	mnPage
;

30050 int 
	mmxErr
;

30051 int 
	mnErr
;

30052 int 
	mmallocFailed
;

30053 const char *
	mzPfx
;

30054 int 
	mv1
, 
	mv2
;

30055 
StrAccum
 
	merrMsg
;

30056 
u32
 *
	mheap
;

30059 static void 
	$lockBtreeMutex
(
Btree
 *
p
)

30066 
	`sqlite3_mutex_enter
(
p
->
pBt
->
mutex
);

30067 
p
->
pBt
->
db
 = p->db;

30068 
p
->
locked
 = 1;

30069 
	}
}

30075 static void 
__attribute__
((
noinline
)) 
	$unlockBtreeMutex
(
Btree
 *
p
)

30078 
BtShared
 *
pBt
 = 
p
->pBt;

30084 
	`sqlite3_mutex_leave
(
pBt
->
mutex
);

30085 
p
->
locked
 = 0;

30086 
	}
}

30089 static void 
__attribute__
((
noinline
)) 
btreeLockCarefully
(
Btree
 *
p
);

30091 static void 
	$sqlite3BtreeEnter
(
Btree
 *
p
)

30115 if( !
p
->
sharable
 ) return;

30116 
p
->
wantToLock
++;

30117 if( 
p
->
locked
 ) return;

30118 
	`btreeLockCarefully
(
p
);

30119 
	}
}

30127 static void 
__attribute__
((
noinline
)) 
	$btreeLockCarefully
(
Btree
 *
p
)

30130 
Btree
 *
pLater
;

30136 if( 
	`sqlite3_mutex_try
(
p
->
pBt
->
mutex
)==0 )

30139 
p
->
pBt
->
db
 = p->db;

30140 
p
->
locked
 = 1;

30149 for(
pLater
=
p
->
pNext
; pLater; pLater=pLater->pNext)

30155 if( 
pLater
->
locked
 )

30158 
	`unlockBtreeMutex
(
pLater
);

30161 
	`lockBtreeMutex
(
p
);

30162 for(
pLater
=
p
->
pNext
; pLater; pLater=pLater->pNext)

30165 if( 
pLater
->
wantToLock
 )

30168 
	`lockBtreeMutex
(
pLater
);

30171 
	}
}

30177 static void 
	$sqlite3BtreeLeave
(
Btree
 *
p
)

30181 if( 
p
->
sharable
 )

30185 
p
->
wantToLock
--;

30186 if( 
p
->
wantToLock
==0 )

30189 
	`unlockBtreeMutex
(
p
);

30192 
	}
}

30194 static void 
	$sqlite3BtreeEnterAll
(
sqlite3
 *
db
)

30197 int 
i
;

30198 
Btree
 *
p
;

30200 for(
i
=0; i<
db
->
nDb
; i++)

30203 
p
 = 
db
->
aDb
[
i
].
pBt
;

30204 if( 
p
 ) 
	`sqlite3BtreeEnter
(p);

30206 
	}
}

30207 static void 
	$sqlite3BtreeLeaveAll
(
sqlite3
 *
db
)

30210 int 
i
;

30211 
Btree
 *
p
;

30213 for(
i
=0; i<
db
->
nDb
; i++)

30216 
p
 = 
db
->
aDb
[
i
].
pBt
;

30217 if( 
p
 ) 
	`sqlite3BtreeLeave
(p);

30219 
	}
}

30221 static void 
	$sqlite3BtreeEnterCursor
(
BtCursor
 *
pCur
)

30224 
	`sqlite3BtreeEnter
(
pCur
->
pBtree
);

30225 
	}
}

30227 static void 
	$sqlite3BtreeLeaveCursor
(
BtCursor
 *
pCur
)

30230 
	`sqlite3BtreeLeave
(
pCur
->
pBtree
);

30231 
	}
}

30233 static const char 
	gzMagicHeader
[] = "SQLite format 3";

30235 static 
BtShared
 * 
	gsqlite3SharedCacheList
 = 0;

30237 int 
	$sqlite3_enable_shared_cache
(int 
enable
)

30240 
sqlite3Config
.
sharedCacheEnabled
 = 
enable
;

30242 
	}
}

30244 static int 
	$querySharedCacheTableLock
(
Btree
 *
p
, 
Pgno
 
iTab
, 
u8
 
eLock
)

30247 
BtShared
 *
pBt
 = 
p
->pBt;

30248 
BtLock
 *
pIter
;

30263 if( !
p
->
sharable
 )

30272 if( 
pBt
->
pWriter
!=
p
 && (pBt->
btsFlags
 & 0x0020)!=0 )

30279 for(
pIter
=
pBt
->
pLock
; pIter; pIter=pIter->
pNext
)

30285 if( 
pIter
->
pBtree
!=
p
 && pIter->
iTable
==
iTab
 && pIter->
eLock
!=eLock )

30289 if( 
eLock
==2 )

30293 
pBt
->
btsFlags
 |= 0x0040;

30299 
	}
}

30301 static int 
	$setSharedCacheTableLock
(
Btree
 *
p
, 
Pgno
 
iTable
, 
u8
 
eLock
)

30304 
BtShared
 *
pBt
 = 
p
->pBt;

30305 
BtLock
 *
pLock
 = 0;

30306 
BtLock
 *
pIter
;

30324 for(
pIter
=
pBt
->
pLock
; pIter; pIter=pIter->
pNext
)

30327 if( 
pIter
->
iTable
==iTable && pIter->
pBtree
==
p
 )

30330 
pLock
 = 
pIter
;

30338 if( !
pLock
 )

30341 
pLock
 = (
BtLock
 *)
	`sqlite3MallocZero
(sizeof(BtLock));

30342 if( !
pLock
 )

30347 
pLock
->
iTable
 = iTable;

30348 
pLock
->
pBtree
 = 
p
;

30349 
pLock
->
pNext
 = 
pBt
->pLock;

30350 
pBt
->
pLock
 = pLock;

30358 if( 
eLock
>
pLock
->eLock )

30361 
pLock
->
eLock
 = eLock;

30365 
	}
}

30367 static void 
	$clearAllSharedCacheTableLocks
(
Btree
 *
p
)

30370 
BtShared
 *
pBt
 = 
p
->pBt;

30371 
BtLock
 **
ppIter
 = &
pBt
->
pLock
;

30377 while( *
ppIter
 )

30380 
BtLock
 *
pLock
 = *
ppIter
;

30383 if( 
pLock
->
pBtree
==
p
 )

30386 *
ppIter
 = 
pLock
->
pNext
;

30388 if( 
pLock
->
iTable
!=1 )

30391 
	`sqlite3_free
(
pLock
);

30394 
ppIter
 = &
pLock
->
pNext
;

30399 if( 
pBt
->
pWriter
==
p
 )

30402 
pBt
->
pWriter
 = 0;

30403 
pBt
->
btsFlags
 &= ~(0x0020|0x0040);

30404 }else if( 
pBt
->
nTransaction
==2 )

30408 
pBt
->
btsFlags
 &= ~0x0040;

30410 
	}
}

30415 static void 
	$downgradeAllSharedCacheTableLocks
(
Btree
 *
p
)

30418 
BtShared
 *
pBt
 = 
p
->pBt;

30419 if( 
pBt
->
pWriter
==
p
 )

30422 
BtLock
 *
pLock
;

30423 
pBt
->
pWriter
 = 0;

30424 
pBt
->
btsFlags
 &= ~(0x0020|0x0040);

30425 for(
pLock
=
pBt
->pLock; pLock; pLock=pLock->
pNext
)

30429 
pLock
->
eLock
 = 1;

30432 
	}
}

30436 static void 
releasePage
(
MemPage
 *
pPage
);

30438 static void 
	$invalidateAllOverflowCache
(
BtShared
 *
pBt
)

30441 
BtCursor
 *
p
;

30443 for(
p
=
pBt
->
pCursor
; p; p=p->
pNext
)

30446 (
p
->
curFlags
 &= ~0x04);

30448 
	}
}

30450 static void 
	$invalidateIncrblobCursors
(

30451 
Btree
 *
pBtree
,

30452 
i64
 
iRow
,

30453 int 
isClearTable


30457 
BtCursor
 *
p
;

30458 if( 
pBtree
->
hasIncrblobCur
==0 ) return;

30460 
pBtree
->
hasIncrblobCur
 = 0;

30461 for(
p
=
pBtree
->
pBt
->
pCursor
; p; p=p->
pNext
)

30464 if( (
p
->
curFlags
 & 0x10)!=0 )

30467 
pBtree
->
hasIncrblobCur
 = 1;

30468 if( 
isClearTable
 || 
p
->
info
.
nKey
==
iRow
 )

30471 
p
->
eState
 = 0;

30475 
	}
}

30477 static int 
	$btreeSetHasContent
(
BtShared
 *
pBt
, 
Pgno
 
pgno
)

30480 int 
rc
 = 0;

30481 if( !
pBt
->
pHasContent
 )

30485 
pBt
->
pHasContent
 = 
	`sqlite3BitvecCreate
(pBt->
nPage
);

30486 if( !
pBt
->
pHasContent
 )

30489 
rc
 = 7;

30492 if( 
rc
==0 && 
pgno
<=
	`sqlite3BitvecSize
(
pBt
->
pHasContent
) )

30495 
rc
 = 
	`sqlite3BitvecSet
(
pBt
->
pHasContent
, 
pgno
);

30497 return 
rc
;

30498 
	}
}

30500 static int 
	$btreeGetHasContent
(
BtShared
 *
pBt
, 
Pgno
 
pgno
)

30503 
Bitvec
 *
p
 = 
pBt
->
pHasContent
;

30504 return (
p
 && (
pgno
>
	`sqlite3BitvecSize
(p) || 
	`sqlite3BitvecTest
(p, pgno)));

30505 
	}
}

30511 static void 
	$btreeClearHasContent
(
BtShared
 *
pBt
)

30514 
	`sqlite3BitvecDestroy
(
pBt
->
pHasContent
);

30515 
pBt
->
pHasContent
 = 0;

30516 
	}
}

30521 static void 
	$btreeReleaseAllCursorPages
(
BtCursor
 *
pCur
)

30524 int 
i
;

30525 for(
i
=0; i<=
pCur
->
iPage
; i++)

30528 
	`releasePage
(
pCur
->
apPage
[
i
]);

30529 
pCur
->
apPage
[
i
] = 0;

30531 
pCur
->
iPage
 = -1;

30532 
	}
}

30534 static int 
	$saveCursorKey
(
BtCursor
 *
pCur
)

30537 int 
rc
;

30542 
rc
 = 
	`sqlite3BtreeKeySize
(
pCur
, &pCur->
nKey
);

30550 if( 0==
pCur
->
curIntKey
 )

30553 void *
pKey
 = 
	`sqlite3Malloc
( 
pCur
->
nKey
 );

30554 if( 
pKey
 )

30557 
rc
 = 
	`sqlite3BtreeKey
(
pCur
, 0, (int)pCur->
nKey
, 
pKey
);

30558 if( 
rc
==0 )

30561 
pCur
->
pKey
 = pKey;

30563 
	`sqlite3_free
(
pKey
);

30566 
rc
 = 7;

30570 return 
rc
;

30571 
	}
}

30573 static int 
	$saveCursorPosition
(
BtCursor
 *
pCur
)

30576 int 
rc
;

30582 if( 
pCur
->
eState
==2 )

30585 
pCur
->
eState
 = 1;

30587 
pCur
->
skipNext
 = 0;

30590 
rc
 = 
	`saveCursorKey
(
pCur
);

30591 if( 
rc
==0 )

30594 
	`btreeReleaseAllCursorPages
(
pCur
);

30595 
pCur
->
eState
 = 3;

30598 
pCur
->
curFlags
 &= ~(0x02|0x04|0x08);

30599 return 
rc
;

30600 
	}
}

30603 static int 
__attribute__
((
noinline
)) 
saveCursorsOnList
(
BtCursor
*,
Pgno
,BtCursor*);

30605 static int 
	$saveAllCursors
(
BtShared
 *
pBt
, 
Pgno
 
iRoot
, 
BtCursor
 *
pExcept
)

30608 
BtCursor
 *
p
;

30611 for(
p
=
pBt
->
pCursor
; p; p=p->
pNext
)

30614 if( 
p
!=
pExcept
 && (0==
iRoot
 || p->
pgnoRoot
==iRoot) ) break;

30616 if( 
p
 ) return 
	`saveCursorsOnList
(p, 
iRoot
, 
pExcept
);

30617 if( 
pExcept
 ) pExcept->
curFlags
 &= ~0x20;

30619 
	}
}

30626 static int 
__attribute__
((
noinline
)) 
	$saveCursorsOnList
(

30627 
BtCursor
 *
p
,

30628 
Pgno
 
iRoot
,

30629 
BtCursor
 *
pExcept


30634 if( 
p
!=
pExcept
 && (0==
iRoot
 || p->
pgnoRoot
==iRoot) )

30637 if( 
p
->
eState
==1 || p->eState==2 )

30640 int 
rc
 = 
	`saveCursorPosition
(
p
);

30641 if( 0!=
rc
 )

30644 return 
rc
;

30648 
	`btreeReleaseAllCursorPages
(
p
);

30651 
p
 = p->
pNext
;

30652 }while( 
p
 );

30654 
	}
}

30659 static void 
	$sqlite3BtreeClearCursor
(
BtCursor
 *
pCur
)

30663 
	`sqlite3_free
(
pCur
->
pKey
);

30664 
pCur
->
pKey
 = 0;

30665 
pCur
->
eState
 = 0;

30666 
	}
}

30673 static int 
	$btreeMoveto
(

30674 
BtCursor
 *
pCur
,

30675 const void *
pKey
,

30676 
i64
 
nKey
,

30677 int 
bias
,

30678 int *
pRes


30682 int 
rc
;

30683 
UnpackedRecord
 *
pIdxKey
;

30684 char 
aSpace
[200];

30685 char *
pFree
 = 0;

30687 if( 
pKey
 )

30691 
pIdxKey
 = 
	`sqlite3VdbeAllocUnpackedRecord
(

30692 
pCur
->
pKeyInfo
, 
aSpace
, sizeof(aSpace), &
pFree


30694 if( 
pIdxKey
==0 ) return 7;

30695 
	`sqlite3VdbeRecordUnpack
(
pCur
->
pKeyInfo
, (int)
nKey
, 
pKey
, 
pIdxKey
);

30696 if( 
pIdxKey
->
nField
==0 )

30699 
	`sqlite3DbFree
(
pCur
->
pKeyInfo
->
db
, 
pFree
);

30700 return 
	`sqlite3CorruptError
(56571);

30703 
pIdxKey
 = 0;

30705 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pCur
, 
pIdxKey
, 
nKey
, 
bias
, 
pRes
);

30706 if( 
pFree
 )

30709 
	`sqlite3DbFree
(
pCur
->
pKeyInfo
->
db
, 
pFree
);

30711 return 
rc
;

30712 
	}
}

30714 static int 
	$btreeRestoreCursorPosition
(
BtCursor
 *
pCur
)

30717 int 
rc
;

30718 int 
skipNext
;

30721 if( 
pCur
->
eState
==4 )

30724 return 
pCur
->
skipNext
;

30726 
pCur
->
eState
 = 0;

30727 
rc
 = 
	`btreeMoveto
(
pCur
, pCur->
pKey
, pCur->
nKey
, 0, &
skipNext
);

30728 if( 
rc
==0 )

30731 
	`sqlite3_free
(
pCur
->
pKey
);

30732 
pCur
->
pKey
 = 0;

30734 
pCur
->
skipNext
 |= skipNext;

30735 if( 
pCur
->
skipNext
 && pCur->
eState
==1 )

30738 
pCur
->
eState
 = 2;

30741 return 
rc
;

30742 
	}
}

30744 static int 
	$sqlite3BtreeCursorHasMoved
(
BtCursor
 *
pCur
)

30747 return 
pCur
->
eState
!=1;

30748 
	}
}

30750 static int 
	$sqlite3BtreeCursorRestore
(
BtCursor
 *
pCur
, int *
pDifferentRow
)

30753 int 
rc
;

30757 
rc
 = (
pCur
->
eState
>=3 ? 
	`btreeRestoreCursorPosition
(pCur) : 0);

30758 if( 
rc
 )

30761 *
pDifferentRow
 = 1;

30762 return 
rc
;

30764 if( 
pCur
->
eState
!=1 )

30767 *
pDifferentRow
 = 1;

30770 *
pDifferentRow
 = 0;

30773 
	}
}

30775 static void 
	$sqlite3BtreeCursorHintFlags
(
BtCursor
 *
pCur
, unsigned 
x
)

30779 
pCur
->
hints
 = 
x
;

30780 
	}
}

30782 static 
Pgno
 
	$ptrmapPageno
(
BtShared
 *
pBt
, 
Pgno
 
pgno
)

30785 int 
nPagesPerMapPage
;

30786 
Pgno
 
iPtrMap
, 
ret
;

30788 if( 
pgno
<2 ) return 0;

30789 
nPagesPerMapPage
 = (
pBt
->
usableSize
/5)+1;

30790 
iPtrMap
 = (
pgno
-2)/
nPagesPerMapPage
;

30791 
ret
 = (
iPtrMap
*
nPagesPerMapPage
) + 2;

30792 if( 
ret
==((
Pgno
)((
sqlite3PendingByte
/((
pBt
)->
pageSize
))+1)) )

30795 
ret
++;

30797 return 
ret
;

30798 
	}
}

30800 static void 
	$ptrmapPut
(
BtShared
 *
pBt
, 
Pgno
 
key
, 
u8
 
eType
, Pgno 
parent
, int *
pRC
)

30803 
DbPage
 *
pDbPage
;

30804 
u8
 *
pPtrmap
;

30805 
Pgno
 
iPtrmap
;

30806 int 
offset
;

30807 int 
rc
;

30809 if( *
pRC
 ) return;

30816 if( 
key
==0 )

30819 *
pRC
 = 
	`sqlite3CorruptError
(56734);

30822 
iPtrmap
 = 
	`ptrmapPageno
(
pBt
, 
key
);

30823 
rc
 = 
	`sqlite3PagerGet
(
pBt
->
pPager
, 
iPtrmap
, &
pDbPage
, 0);

30824 if( 
rc
!=0 )

30827 *
pRC
 = 
rc
;

30830 
offset
 = (5*(
key
-
iPtrmap
-1));

30831 if( 
offset
<0 )

30834 *
pRC
 = 
	`sqlite3CorruptError
(56745);

30835 goto 
ptrmap_exit
;

30838 
pPtrmap
 = (
u8
 *)
	`sqlite3PagerGetData
(
pDbPage
);

30840 if( 
eType
!=
pPtrmap
[
offset
] || 
	`sqlite3Get4byte
(&pPtrmap[offset+1])!=
parent
 )

30844 *
pRC
= 
rc
 = 
	`sqlite3PagerWrite
(
pDbPage
);

30845 if( 
rc
==0 )

30848 
pPtrmap
[
offset
] = 
eType
;

30849 
	`sqlite3Put4byte
(&
pPtrmap
[
offset
+1], 
parent
);

30853 
ptrmap_exit
:

30854 
	`sqlite3PagerUnref
(
pDbPage
);

30855 
	}
}

30857 static int 
	$ptrmapGet
(
BtShared
 *
pBt
, 
Pgno
 
key
, 
u8
 *
pEType
, Pgno *
pPgno
)

30860 
DbPage
 *
pDbPage
;

30861 int 
iPtrmap
;

30862 
u8
 *
pPtrmap
;

30863 int 
offset
;

30864 int 
rc
;

30868 
iPtrmap
 = 
	`ptrmapPageno
(
pBt
, 
key
);

30869 
rc
 = 
	`sqlite3PagerGet
(
pBt
->
pPager
, 
iPtrmap
, &
pDbPage
, 0);

30870 if( 
rc
!=0 )

30873 return 
rc
;

30875 
pPtrmap
 = (
u8
 *)
	`sqlite3PagerGetData
(
pDbPage
);

30877 
offset
 = (5*(
key
-
iPtrmap
-1));

30878 if( 
offset
<0 )

30881 
	`sqlite3PagerUnref
(
pDbPage
);

30882 return 
	`sqlite3CorruptError
(56790);

30886 *
pEType
 = 
pPtrmap
[
offset
];

30887 if( 
pPgno
 ) *pPgno = 
	`sqlite3Get4byte
(&
pPtrmap
[
offset
+1]);

30889 
	`sqlite3PagerUnref
(
pDbPage
);

30890 if( *
pEType
<1 || *pEType>5 ) return 
	`sqlite3CorruptError
(56798);

30892 
	}
}

30894 static 
__attribute__
((
noinline
)) void 
	$btreeParseCellAdjustSizeForOverflow
(

30895 
MemPage
 *
pPage
,

30896 
u8
 *
pCell
,

30897 
CellInfo
 *
pInfo


30902 int 
minLocal
;

30903 int 
maxLocal
;

30904 int 
surplus
;

30906 
minLocal
 = 
pPage
->minLocal;

30907 
maxLocal
 = 
pPage
->maxLocal;

30908 
surplus
 = 
minLocal
 + (
pInfo
->
nPayload
 - minLocal)%(
pPage
->
pBt
->
usableSize
-4);

30911 if( 
surplus
 <= 
maxLocal
 )

30914 
pInfo
->
nLocal
 = (
u16
)
surplus
;

30916 
pInfo
->
nLocal
 = (
u16
)
minLocal
;

30918 
pInfo
->
nSize
 = (
u16
)(&pInfo->
pPayload
[pInfo->
nLocal
] - 
pCell
) + 4;

30919 
	}
}

30921 static void 
	$btreeParseCellPtrNoPayload
(

30922 
MemPage
 *
pPage
,

30923 
u8
 *
pCell
,

30924 
CellInfo
 *
pInfo


30932 (void)(
pPage
);

30934 
pInfo
->
nSize
 = 4 + 
	`sqlite3GetVarint
(&
pCell
[4], (
u64
*)&pInfo->
nKey
);

30935 
pInfo
->
nPayload
 = 0;

30936 
pInfo
->
nLocal
 = 0;

30937 
pInfo
->
pPayload
 = 0;

30939 
	}
}

30940 static void 
	$btreeParseCellPtr
(

30941 
MemPage
 *
pPage
,

30942 
u8
 *
pCell
,

30943 
CellInfo
 *
pInfo


30947 
u8
 *
pIter
;

30948 
u32
 
nPayload
;

30949 
u64
 
iKey
;

30955 
pIter
 = 
pCell
;

30963 
nPayload
 = *
pIter
;

30964 if( 
nPayload
>=0x80 )

30967 
u8
 *
pEnd
 = &
pIter
[8];

30968 
nPayload
 &= 0x7f;

30970 
nPayload
 = (nPayload<<7) | (*++
pIter
 & 0x7f);

30971 }while( (*
pIter
)>=0x80 && pIter<
pEnd
 );

30973 
pIter
++;

30981 
iKey
 = *
pIter
;

30982 if( 
iKey
>=0x80 )

30985 
u8
 *
pEnd
 = &
pIter
[7];

30986 
iKey
 &= 0x7f;

30990 
iKey
 = (iKey<<7) | (*++
pIter
 & 0x7f);

30991 if( (*
pIter
)<0x80 ) break;

30992 if( 
pIter
>=
pEnd
 )

30995 
iKey
 = (iKey<<8) | *++
pIter
;

31000 
pIter
++;

31002 
pInfo
->
nKey
 = *(
i64
*)&
iKey
;

31003 
pInfo
->
nPayload
 = nPayload;

31004 
pInfo
->
pPayload
 = 
pIter
;

31007 if( 
nPayload
<=
pPage
->
maxLocal
 )

31013 
pInfo
->
nSize
 = 
nPayload
 + (
u16
)(
pIter
 - 
pCell
);

31014 if( 
pInfo
->
nSize
<4 ) pInfo->nSize = 4;

31015 
pInfo
->
nLocal
 = (
u16
)
nPayload
;

31017 
	`btreeParseCellAdjustSizeForOverflow
(
pPage
, 
pCell
, 
pInfo
);

31019 
	}
}

31020 static void 
	$btreeParseCellPtrIndex
(

31021 
MemPage
 *
pPage
,

31022 
u8
 *
pCell
,

31023 
CellInfo
 *
pInfo


31027 
u8
 *
pIter
;

31028 
u32
 
nPayload
;

31033 
pIter
 = 
pCell
 + 
pPage
->
childPtrSize
;

31034 
nPayload
 = *
pIter
;

31035 if( 
nPayload
>=0x80 )

31038 
u8
 *
pEnd
 = &
pIter
[8];

31039 
nPayload
 &= 0x7f;

31041 
nPayload
 = (nPayload<<7) | (*++
pIter
 & 0x7f);

31042 }while( *(
pIter
)>=0x80 && pIter<
pEnd
 );

31044 
pIter
++;

31045 
pInfo
->
nKey
 = 
nPayload
;

31046 
pInfo
->
nPayload
 = nPayload;

31047 
pInfo
->
pPayload
 = 
pIter
;

31050 if( 
nPayload
<=
pPage
->
maxLocal
 )

31056 
pInfo
->
nSize
 = 
nPayload
 + (
u16
)(
pIter
 - 
pCell
);

31057 if( 
pInfo
->
nSize
<4 ) pInfo->nSize = 4;

31058 
pInfo
->
nLocal
 = (
u16
)
nPayload
;

31060 
	`btreeParseCellAdjustSizeForOverflow
(
pPage
, 
pCell
, 
pInfo
);

31062 
	}
}

31063 static void 
	$btreeParseCell
(

31064 
MemPage
 *
pPage
,

31065 int 
iCell
,

31066 
CellInfo
 *
pInfo


31070 
pPage
->
	`xParseCell
(pPage, ((pPage)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
iCell
)])))), 
pInfo
);

31071 
	}
}

31073 static 
u16
 
	$cellSizePtr
(
MemPage
 *
pPage
, 
u8
 *
pCell
)

31076 
u8
 *
pIter
 = 
pCell
 + 
pPage
->
childPtrSize
;

31077 
u8
 *
pEnd
;

31078 
u32
 
nSize
;

31080 
nSize
 = *
pIter
;

31081 if( 
nSize
>=0x80 )

31084 
pEnd
 = &
pIter
[8];

31085 
nSize
 &= 0x7f;

31087 
nSize
 = (nSize<<7) | (*++
pIter
 & 0x7f);

31088 }while( *(
pIter
)>=0x80 && pIter<
pEnd
 );

31090 
pIter
++;

31091 if( 
pPage
->
intKey
 )

31097 
pEnd
 = &
pIter
[9];

31098 while( (*
pIter
++)&0x80 && pIter<
pEnd
 );

31102 if( 
nSize
<=
pPage
->
maxLocal
 )

31105 
nSize
 += (
u32
)(
pIter
 - 
pCell
);

31106 if( 
nSize
<4 ) nSize = 4;

31108 int 
minLocal
 = 
pPage
->minLocal;

31109 
nSize
 = 
minLocal
 + (nSize - minLocal) % (
pPage
->
pBt
->
usableSize
 - 4);

31112 if( 
nSize
>
pPage
->
maxLocal
 )

31115 
nSize
 = 
minLocal
;

31117 
nSize
 += 4 + (
u16
)(
pIter
 - 
pCell
);

31120 return (
u16
)
nSize
;

31121 
	}
}

31122 static 
u16
 
	$cellSizePtrNoPayload
(
MemPage
 *
pPage
, 
u8
 *
pCell
)

31125 
u8
 *
pIter
 = 
pCell
 + 4;

31126 
u8
 *
pEnd
;

31128 (void)(
pPage
);

31132 
pEnd
 = 
pIter
 + 9;

31133 while( (*
pIter
++)&0x80 && pIter<
pEnd
 );

31135 return (
u16
)(
pIter
 - 
pCell
);

31136 
	}
}

31138 static void 
	$ptrmapPutOvflPtr
(
MemPage
 *
pPage
, 
u8
 *
pCell
, int *
pRC
)

31141 
CellInfo
 
info
;

31142 if( *
pRC
 ) return;

31144 
pPage
->
	`xParseCell
(pPage, 
pCell
, &
info
);

31145 if( 
info
.
nLocal
<info.
nPayload
 )

31148 
Pgno
 
ovfl
 = 
	`sqlite3Get4byte
(&
pCell
[
info
.
nSize
-4]);

31149 
	`ptrmapPut
(
pPage
->
pBt
, 
ovfl
, 3, pPage->
pgno
, 
pRC
);

31151 
	}
}

31153 static int 
	$defragmentPage
(
MemPage
 *
pPage
)

31156 int 
i
;

31157 int 
pc
;

31158 int 
hdr
;

31159 int 
size
;

31160 int 
usableSize
;

31161 int 
cellOffset
;

31162 int 
cbrk
;

31163 int 
nCell
;

31164 unsigned char *
data
;

31165 unsigned char *
temp
;

31166 unsigned char *
src
;

31167 int 
iCellFirst
;

31168 int 
iCellLast
;

31176 
temp
 = 0;

31177 
src
 = 
data
 = 
pPage
->
aData
;

31178 
hdr
 = 
pPage
->
hdrOffset
;

31179 
cellOffset
 = 
pPage
->cellOffset;

31180 
nCell
 = 
pPage
->nCell;

31182 
usableSize
 = 
pPage
->
pBt
->usableSize;

31183 
cbrk
 = 
usableSize
;

31184 
iCellFirst
 = 
cellOffset
 + 2*
nCell
;

31185 
iCellLast
 = 
usableSize
 - 4;

31186 for(
i
=0; i<
nCell
; i++)

31189 
u8
 *
pAddr
;

31190 
pAddr
 = &
data
[
cellOffset
 + 
i
*2];

31191 
pc
 = ((
pAddr
)[0]<<8 | (pAddr)[1]);

31197 if( 
pc
<
iCellFirst
 || pc>
iCellLast
 )

31200 return 
	`sqlite3CorruptError
(57167);

31203 
size
 = 
pPage
->
	`xCellSize
(pPage, &
src
[
pc
]);

31204 
cbrk
 -= 
size
;

31205 if( 
cbrk
<
iCellFirst
 || 
pc
+
size
>
usableSize
 )

31208 return 
	`sqlite3CorruptError
(57173);

31213 ((
pAddr
)[0] = (
u8
)((
cbrk
)>>8), (pAddr)[1] = (u8)(cbrk));

31214 if( 
temp
==0 )

31217 int 
x
;

31218 if( 
cbrk
==
pc
 ) continue;

31219 
temp
 = 
	`sqlite3PagerTempSpace
(
pPage
->
pBt
->
pPager
);

31220 
x
 = ((&
data
[
hdr
+5])[0]<<8 | (&data[hdr+5])[1]);

31221 
	`memcpy
(&
temp
[
x
], &
data
[x], (
cbrk
+
size
) - x);

31222 
src
 = 
temp
;

31224 
	`memcpy
(&
data
[
cbrk
], &
src
[
pc
], 
size
);

31227 ((&
data
[
hdr
+5])[0] = (
u8
)((
cbrk
)>>8), (&data[hdr+5])[1] = (u8)(cbrk));

31228 
data
[
hdr
+1] = 0;

31229 
data
[
hdr
+2] = 0;

31230 
data
[
hdr
+7] = 0;

31231 
	`memset
(&
data
[
iCellFirst
], 0, 
cbrk
-iCellFirst);

31233 if( 
cbrk
-
iCellFirst
!=
pPage
->
nFree
 )

31236 return 
	`sqlite3CorruptError
(57197);

31239 
	}
}

31241 static 
u8
 *
	$pageFindSlot
(
MemPage
 *
pPg
, int 
nByte
, int *
pRc
)

31244 const int 
hdr
 = 
pPg
->
hdrOffset
;

31245 
u8
 * const 
aData
 = 
pPg
->aData;

31246 int 
iAddr
 = 
hdr
 + 1;

31247 int 
pc
 = ((&
aData
[
iAddr
])[0]<<8 | (&aData[iAddr])[1]);

31248 int 
x
;

31249 int 
usableSize
 = 
pPg
->
pBt
->usableSize;

31253 int 
size
;

31256 if( 
pc
>
usableSize
-4 || pc<
iAddr
+4 )

31259 *
pRc
 = 
	`sqlite3CorruptError
(57230);

31265 
size
 = ((&
aData
[
pc
+2])[0]<<8 | (&aData[pc+2])[1]);

31266 if( (
x
 = 
size
 - 
nByte
)>=0 )

31271 if( 
pc
 < 
pPg
->
cellOffset
+2*pPg->
nCell
 || 
size
+pc > 
usableSize
 )

31274 *
pRc
 = 
	`sqlite3CorruptError
(57241);

31276 }else if( 
x
<4 )

31281 if( 
aData
[
hdr
+7]>57 ) return 0;

31285 
	`memcpy
(&
aData
[
iAddr
], &aData[
pc
], 2);

31286 
aData
[
hdr
+7] += (
u8
)
x
;

31290 ((&
aData
[
pc
+2])[0] = (
u8
)((
x
)>>8), (&aData[pc+2])[1] = (u8)(x));

31292 return &
aData
[
pc
 + 
x
];

31294 
iAddr
 = 
pc
;

31295 
pc
 = ((&
aData
[pc])[0]<<8 | (&aData[pc])[1]);

31296 }while( 
pc
 );

31299 
	}
}

31301 static int 
	$allocateSpace
(
MemPage
 *
pPage
, int 
nByte
, int *
pIdx
)

31304 const int 
hdr
 = 
pPage
->
hdrOffset
;

31305 
u8
 * const 
data
 = 
pPage
->
aData
;

31306 int 
top
;

31307 int 
rc
 = 0;

31308 int 
gap
;

31319 
gap
 = 
pPage
->
cellOffset
 + 2*pPage->
nCell
;

31326 
top
 = ((&
data
[
hdr
+5])[0]<<8 | (&data[hdr+5])[1]);

31328 if( 
gap
>
top
 )

31331 if( 
top
==0 && 
pPage
->
pBt
->
usableSize
==65536 )

31334 
top
 = 65536;

31336 return 
	`sqlite3CorruptError
(57308);

31347 if( (
data
[
hdr
+2] || data[hdr+1]) && 
gap
+2<=
top
 )

31350 
u8
 *
pSpace
 = 
	`pageFindSlot
(
pPage
, 
nByte
, &
rc
);

31351 if( 
pSpace
 )

31355 *
pIdx
 = (int)(
pSpace
 - 
data
);

31357 }else if( 
rc
 )

31360 return 
rc
;

31368 if( 
gap
+2+
nByte
>
top
 )

31372 
rc
 = 
	`defragmentPage
(
pPage
);

31373 if( 
rc
 ) return rc;

31374 
top
 = (((((int)((&
data
[
hdr
+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);

31378 
top
 -= 
nByte
;

31379 ((&
data
[
hdr
+5])[0] = (
u8
)((
top
)>>8), (&data[hdr+5])[1] = (u8)(top));

31381 *
pIdx
 = 
top
;

31383 
	}
}

31385 static int 
	$freeSpace
(
MemPage
 *
pPage
, 
u16
 
iStart
, u16 
iSize
)

31388 
u16
 
iPtr
;

31389 
u16
 
iFreeBlk
;

31390 
u8
 
hdr
;

31391 
u8
 
nFrag
 = 0;

31392 
u16
 
iOrigSize
 = 
iSize
;

31393 
u32
 
iLast
 = 
pPage
->
pBt
->
usableSize
-4;

31394 
u32
 
iEnd
 = 
iStart
 + 
iSize
;

31395 unsigned char *
data
 = 
pPage
->
aData
;

31407 if( 
pPage
->
pBt
->
btsFlags
 & 0x0004 )

31410 
	`memset
(&
data
[
iStart
], 0, 
iSize
);

31416 
hdr
 = 
pPage
->
hdrOffset
;

31417 
iPtr
 = 
hdr
 + 1;

31418 if( 
data
[
iPtr
+1]==0 && data[iPtr]==0 )

31421 
iFreeBlk
 = 0;

31423 while( (
iFreeBlk
 = ((&
data
[
iPtr
])[0]<<8 | (&data[iPtr])[1]))>0 && iFreeBlk<
iStart
 )

31426 if( 
iFreeBlk
<
iPtr
+4 ) return 
	`sqlite3CorruptError
(57402);

31427 
iPtr
 = 
iFreeBlk
;

31429 if( 
iFreeBlk
>
iLast
 ) return 
	`sqlite3CorruptError
(57405);

31438 if( 
iFreeBlk
 && 
iEnd
+3>=iFreeBlk )

31441 
nFrag
 = 
iFreeBlk
 - 
iEnd
;

31442 if( 
iEnd
>
iFreeBlk
 ) return 
	`sqlite3CorruptError
(57416);

31443 
iEnd
 = 
iFreeBlk
 + ((&
data
[iFreeBlk+2])[0]<<8 | (&data[iFreeBlk+2])[1]);

31444 if( 
iEnd
 > 
pPage
->
pBt
->
usableSize
 ) return 
	`sqlite3CorruptError
(57418);

31445 
iSize
 = 
iEnd
 - 
iStart
;

31446 
iFreeBlk
 = ((&
data
[iFreeBlk])[0]<<8 | (&data[iFreeBlk])[1]);

31453 if( 
iPtr
>
hdr
+1 )

31456 int 
iPtrEnd
 = 
iPtr
 + ((&
data
[iPtr+2])[0]<<8 | (&data[iPtr+2])[1]);

31457 if( 
iPtrEnd
+3>=
iStart
 )

31460 if( 
iPtrEnd
>
iStart
 ) return 
	`sqlite3CorruptError
(57430);

31461 
nFrag
 += 
iStart
 - 
iPtrEnd
;

31462 
iSize
 = 
iEnd
 - 
iPtr
;

31463 
iStart
 = 
iPtr
;

31466 if( 
nFrag
>
data
[
hdr
+7] ) return 
	`sqlite3CorruptError
(57436);

31467 
data
[
hdr
+7] -= 
nFrag
;

31469 if( 
iStart
==((&
data
[
hdr
+5])[0]<<8 | (&data[hdr+5])[1]) )

31475 if( 
iPtr
!=
hdr
+1 ) return 
	`sqlite3CorruptError
(57443);

31476 ((&
data
[
hdr
+1])[0] = (
u8
)((
iFreeBlk
)>>8), (&data[hdr+1])[1] = (u8)(iFreeBlk));

31477 ((&
data
[
hdr
+5])[0] = (
u8
)((
iEnd
)>>8), (&data[hdr+5])[1] = (u8)(iEnd));

31480 ((&
data
[
iPtr
])[0] = (
u8
)((
iStart
)>>8), (&data[iPtr])[1] = (u8)(iStart));

31481 ((&
data
[
iStart
])[0] = (
u8
)((
iFreeBlk
)>>8), (&data[iStart])[1] = (u8)(iFreeBlk));

31482 ((&
data
[
iStart
+2])[0] = (
u8
)((
iSize
)>>8), (&data[iStart+2])[1] = (u8)(iSize));

31484 
pPage
->
nFree
 += 
iOrigSize
;

31486 
	}
}

31488 static int 
	$decodeFlags
(
MemPage
 *
pPage
, int 
flagByte
)

31491 
BtShared
 *
pBt
;

31495 
pPage
->
leaf
 = (
u8
)(
flagByte
>>3); ((void) (0));

31496 
flagByte
 &= ~0x08;

31497 
pPage
->
childPtrSize
 = 4-4*pPage->
leaf
;

31498 
pPage
->
xCellSize
 = 
cellSizePtr
;

31499 
pBt
 = 
pPage
->pBt;

31500 if( 
flagByte
==(0x04 | 0x01) )

31509 
pPage
->
intKey
 = 1;

31510 if( 
pPage
->
leaf
 )

31513 
pPage
->
intKeyLeaf
 = 1;

31514 
pPage
->
xParseCell
 = 
btreeParseCellPtr
;

31516 
pPage
->
intKeyLeaf
 = 0;

31517 
pPage
->
xCellSize
 = 
cellSizePtrNoPayload
;

31518 
pPage
->
xParseCell
 = 
btreeParseCellPtrNoPayload
;

31520 
pPage
->
maxLocal
 = 
pBt
->
maxLeaf
;

31521 
pPage
->
minLocal
 = 
pBt
->
minLeaf
;

31522 }else if( 
flagByte
==0x02 )

31531 
pPage
->
intKey
 = 0;

31532 
pPage
->
intKeyLeaf
 = 0;

31533 
pPage
->
xParseCell
 = 
btreeParseCellPtrIndex
;

31534 
pPage
->
maxLocal
 = 
pBt
->maxLocal;

31535 
pPage
->
minLocal
 = 
pBt
->minLocal;

31539 return 
	`sqlite3CorruptError
(57511);

31541 
pPage
->
max1bytePayload
 = 
pBt
->max1bytePayload;

31543 
	}
}

31545 static int 
	$btreeInitPage
(
MemPage
 *
pPage
)

31556 if( !
pPage
->
isInit
 )

31559 
u16
 
pc
;

31560 
u8
 
hdr
;

31561 
u8
 *
data
;

31562 
BtShared
 *
pBt
;

31563 int 
usableSize
;

31564 
u16
 
cellOffset
;

31565 int 
nFree
;

31566 int 
top
;

31567 int 
iCellFirst
;

31568 int 
iCellLast
;

31570 
pBt
 = 
pPage
->pBt;

31572 
hdr
 = 
pPage
->
hdrOffset
;

31573 
data
 = 
pPage
->
aData
;

31576 if( 
	`decodeFlags
(
pPage
, 
data
[
hdr
]) ) return 
	`sqlite3CorruptError
(57553);

31578 
pPage
->
maskPage
 = (
u16
)(
pBt
->
pageSize
 - 1);

31579 
pPage
->
nOverflow
 = 0;

31580 
usableSize
 = 
pBt
->usableSize;

31581 
pPage
->
cellOffset
 = cellOffset = 
hdr
 + 8 + pPage->
childPtrSize
;

31582 
pPage
->
aDataEnd
 = &
data
[
usableSize
];

31583 
pPage
->
aCellIdx
 = &
data
[
cellOffset
];

31584 
pPage
->
aDataOfst
 = &
data
[pPage->
childPtrSize
];

31588 
top
 = (((((int)((&
data
[
hdr
+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);

31591 
pPage
->
nCell
 = ((&
data
[
hdr
+3])[0]<<8 | (&data[hdr+3])[1]);

31592 if( 
pPage
->
nCell
>((
pBt
->
pageSize
-8)/6) )

31596 return 
	`sqlite3CorruptError
(57571);

31605 
iCellFirst
 = 
cellOffset
 + 2*
pPage
->
nCell
;

31606 
iCellLast
 = 
usableSize
 - 4;

31607 if( 
pBt
->
db
->
flags
 & 0x10000000 )

31610 int 
i
;

31611 int 
sz
;

31613 if( !
pPage
->
leaf
 ) 
iCellLast
--;

31614 for(
i
=0; i<
pPage
->
nCell
; i++)

31617 
pc
 = 
	`__builtin_bswap16
(*(
u16
*)(&
data
[
cellOffset
+
i
*2]));

31620 if( 
pc
<
iCellFirst
 || pc>
iCellLast
 )

31623 return 
	`sqlite3CorruptError
(57599);

31625 
sz
 = 
pPage
->
	`xCellSize
(pPage, &
data
[
pc
]);

31627 if( 
pc
+
sz
>
usableSize
 )

31630 return 
	`sqlite3CorruptError
(57604);

31633 if( !
pPage
->
leaf
 ) 
iCellLast
++;

31640 
pc
 = ((&
data
[
hdr
+1])[0]<<8 | (&data[hdr+1])[1]);

31641 
nFree
 = 
data
[
hdr
+7] + 
top
;

31642 while( 
pc
>0 )

31645 
u16
 
next
, 
size
;

31646 if( 
pc
<
iCellFirst
 || pc>
iCellLast
 )

31654 return 
	`sqlite3CorruptError
(57624);

31656 
next
 = ((&
data
[
pc
])[0]<<8 | (&data[pc])[1]);

31657 
size
 = ((&
data
[
pc
+2])[0]<<8 | (&data[pc+2])[1]);

31658 if( (
next
>0 && next<=
pc
+
size
+3) || pc+size>
usableSize
 )

31663 return 
	`sqlite3CorruptError
(57631);

31665 
nFree
 = nFree + 
size
;

31666 
pc
 = 
next
;

31669 if( 
nFree
>
usableSize
 )

31672 return 
	`sqlite3CorruptError
(57645);

31674 
pPage
->
nFree
 = (
u16
)(nFree - 
iCellFirst
);

31675 
pPage
->
isInit
 = 1;

31678 
	}
}

31684 static void 
	$zeroPage
(
MemPage
 *
pPage
, int 
flags
)

31687 unsigned char *
data
 = 
pPage
->
aData
;

31688 
BtShared
 *
pBt
 = 
pPage
->pBt;

31689 
u8
 
hdr
 = 
pPage
->
hdrOffset
;

31690 
u16
 
first
;

31697 if( 
pBt
->
btsFlags
 & 0x0004 )

31700 
	`memset
(&
data
[
hdr
], 0, 
pBt
->
usableSize
 - hdr);

31702 
data
[
hdr
] = (char)
flags
;

31703 
first
 = 
hdr
 + ((
flags
&0x08)==0 ? 12 : 8);

31704 
	`memset
(&
data
[
hdr
+1], 0, 4);

31705 
data
[
hdr
+7] = 0;

31706 ((&
data
[
hdr
+5])[0] = (
u8
)((
pBt
->
usableSize
)>>8), (&data[hdr+5])[1] = (u8)(pBt->usableSize));

31707 
pPage
->
nFree
 = (
u16
)(
pBt
->
usableSize
 - 
first
);

31708 
	`decodeFlags
(
pPage
, 
flags
);

31709 
pPage
->
cellOffset
 = 
first
;

31710 
pPage
->
aDataEnd
 = &
data
[
pBt
->
usableSize
];

31711 
pPage
->
aCellIdx
 = &
data
[
first
];

31712 
pPage
->
aDataOfst
 = &
data
[pPage->
childPtrSize
];

31713 
pPage
->
nOverflow
 = 0;

31715 
pPage
->
maskPage
 = (
u16
)(
pBt
->
pageSize
 - 1);

31716 
pPage
->
nCell
 = 0;

31717 
pPage
->
isInit
 = 1;

31718 
	}
}

31725 static 
MemPage
 *
	$btreePageFromDbPage
(
DbPage
 *
pDbPage
, 
Pgno
 
pgno
, 
BtShared
 *
pBt
)

31728 
MemPage
 *
pPage
 = (MemPage*)
	`sqlite3PagerGetExtra
(
pDbPage
);

31729 if( 
pgno
!=
pPage
->pgno )

31732 
pPage
->
aData
 = 
	`sqlite3PagerGetData
(
pDbPage
);

31733 
pPage
->
pDbPage
 = pDbPage;

31734 
pPage
->
pBt
 = pBt;

31735 
pPage
->
pgno
 = pgno;

31736 
pPage
->
hdrOffset
 = 
pgno
==1 ? 100 : 0;

31739 return 
pPage
;

31740 
	}
}

31742 static int 
	$btreeGetPage
(

31743 
BtShared
 *
pBt
,

31744 
Pgno
 
pgno
,

31745 
MemPage
 **
ppPage
,

31746 int 
flags


31750 int 
rc
;

31751 
DbPage
 *
pDbPage
;

31755 
rc
 = 
	`sqlite3PagerGet
(
pBt
->
pPager
, 
pgno
, (
DbPage
**)&
pDbPage
, 
flags
);

31756 if( 
rc
 ) return rc;

31757 *
ppPage
 = 
	`btreePageFromDbPage
(
pDbPage
, 
pgno
, 
pBt
);

31759 
	}
}

31766 static 
MemPage
 *
	$btreePageLookup
(
BtShared
 *
pBt
, 
Pgno
 
pgno
)

31769 
DbPage
 *
pDbPage
;

31771 
pDbPage
 = 
	`sqlite3PagerLookup
(
pBt
->
pPager
, 
pgno
);

31772 if( 
pDbPage
 )

31775 return 
	`btreePageFromDbPage
(
pDbPage
, 
pgno
, 
pBt
);

31778 
	}
}

31784 static 
Pgno
 
	$btreePagecount
(
BtShared
 *
pBt
)

31787 return 
pBt
->
nPage
;

31788 
	}
}

31789 static 
u32
 
	$sqlite3BtreeLastPage
(
Btree
 *
p
)

31794 return 
	`btreePagecount
(
p
->
pBt
);

31795 
	}
}

31797 static int 
	$getAndInitPage
(

31798 
BtShared
 *
pBt
,

31799 
Pgno
 
pgno
,

31800 
MemPage
 **
ppPage
,

31801 
BtCursor
 *
pCur
,

31802 int 
bReadOnly


31806 int 
rc
;

31807 
DbPage
 *
pDbPage
;

31813 if( 
pgno
>
	`btreePagecount
(
pBt
) )

31816 
rc
 = 
	`sqlite3CorruptError
(57791);

31817 goto 
getAndInitPage_error
;

31819 
rc
 = 
	`sqlite3PagerGet
(
pBt
->
pPager
, 
pgno
, (
DbPage
**)&
pDbPage
, 
bReadOnly
);

31820 if( 
rc
 )

31823 goto 
getAndInitPage_error
;

31825 *
ppPage
 = (
MemPage
*)
	`sqlite3PagerGetExtra
(
pDbPage
);

31826 if( (*
ppPage
)->
isInit
==0 )

31829 
	`btreePageFromDbPage
(
pDbPage
, 
pgno
, 
pBt
);

31830 
rc
 = 
	`btreeInitPage
(*
ppPage
);

31831 if( 
rc
!=0 )

31834 
	`releasePage
(*
ppPage
);

31835 goto 
getAndInitPage_error
;

31843 if( 
pCur
 && ((*
ppPage
)->
nCell
<1 || (*ppPage)->
intKey
!=pCur->
curIntKey
) )

31846 
rc
 = 
	`sqlite3CorruptError
(57813);

31847 
	`releasePage
(*
ppPage
);

31848 goto 
getAndInitPage_error
;

31852 
getAndInitPage_error
:

31853 if( 
pCur
 ) pCur->
iPage
--;

31856 return 
rc
;

31857 
	}
}

31863 static void 
	$releasePageNotNull
(
MemPage
 *
pPage
)

31872 
	`sqlite3PagerUnrefNotNull
(
pPage
->
pDbPage
);

31873 
	}
}

31874 static void 
	$releasePage
(
MemPage
 *
pPage
)

31877 if( 
pPage
 ) 
	`releasePageNotNull
(pPage);

31878 
	}
}

31880 static int 
	$btreeGetUnusedPage
(

31881 
BtShared
 *
pBt
,

31882 
Pgno
 
pgno
,

31883 
MemPage
 **
ppPage
,

31884 int 
flags


31888 int 
rc
 = 
	`btreeGetPage
(
pBt
, 
pgno
, 
ppPage
, 
flags
);

31889 if( 
rc
==0 )

31892 if( 
	`sqlite3PagerPageRefcount
((*
ppPage
)->
pDbPage
)>1 )

31895 
	`releasePage
(*
ppPage
);

31896 *
ppPage
 = 0;

31897 return 
	`sqlite3CorruptError
(57863);

31899 (*
ppPage
)->
isInit
 = 0;

31901 *
ppPage
 = 0;

31903 return 
rc
;

31904 
	}
}

31906 static void 
	$pageReinit
(
DbPage
 *
pData
)

31909 
MemPage
 *
pPage
;

31910 
pPage
 = (
MemPage
 *)
	`sqlite3PagerGetExtra
(
pData
);

31912 if( 
pPage
->
isInit
 )

31916 
pPage
->
isInit
 = 0;

31917 if( 
	`sqlite3PagerPageRefcount
(
pData
)>1 )

31926 
	`btreeInitPage
(
pPage
);

31929 
	}
}

31934 static int 
	$btreeInvokeBusyHandler
(void *
pArg
)

31937 
BtShared
 *
pBt
 = (BtShared*)
pArg
;

31940 return 
	`sqlite3InvokeBusyHandler
(&
pBt
->
db
->
busyHandler
);

31941 
	}
}

31943 static int 
	$sqlite3BtreeOpen
(

31944 
sqlite3_vfs
 *
pVfs
,

31945 const char *
zFilename
,

31946 
sqlite3
 *
db
,

31947 
Btree
 **
ppBtree
,

31948 int 
flags
,

31949 int 
vfsFlags


31953 
BtShared
 *
pBt
 = 0;

31954 
Btree
 *
p
;

31955 
sqlite3_mutex
 *
mutexOpen
 = 0;

31956 int 
rc
 = 0;

31957 
u8
 
nReserve
;

31958 unsigned char 
zDbHeader
[100];

31961 const int 
isTempDb
 = 
zFilename
==0 || zFilename[0]==0;

31969 const int 
isMemdb
 = (
zFilename
 && 
	`strcmp
(zFilename, ":memory:")==0)

31970 || (
isTempDb
 && 
	`sqlite3TempInMemory
(
db
))

31971 || (
vfsFlags
 & 0x00000080)!=0;

31985 if( 
isMemdb
 )

31988 
flags
 |= 2;

31990 if( (
vfsFlags
 & 0x00000100)!=0 && (
isMemdb
 || 
isTempDb
) )

31993 
vfsFlags
 = (vfsFlags & ~0x00000100) | 0x00000200;

31995 
p
 = 
	`sqlite3MallocZero
(sizeof(
Btree
));

31996 if( !
p
 )

32001 
p
->
inTrans
 = 0;

32002 
p
->
db
 = db;

32004 
p
->
lock
.
pBtree
 = p;

32005 
p
->
lock
.
iTable
 = 1;

32013 if( 
isTempDb
==0 && (
isMemdb
==0 || (
vfsFlags
&0x00000040)!=0) )

32016 if( 
vfsFlags
 & 0x00020000 )

32019 int 
nFilename
 = 
	`sqlite3Strlen30
(
zFilename
)+1;

32020 int 
nFullPathname
 = 
pVfs
->
mxPathname
+1;

32021 char *
zFullPathname
 = 
	`sqlite3Malloc
(((
nFullPathname
)>(
nFilename
)?(nFullPathname):(nFilename)));

32022 
sqlite3_mutex
 *
mutexShared
;

32024 
p
->
sharable
 = 1;

32025 if( !
zFullPathname
 )

32028 
	`sqlite3_free
(
p
);

32031 if( 
isMemdb
 )

32034 
	`memcpy
(
zFullPathname
, 
zFilename
, 
nFilename
);

32036 
rc
 = 
	`sqlite3OsFullPathname
(
pVfs
, 
zFilename
,

32037 
nFullPathname
, 
zFullPathname
);

32038 if( 
rc
 )

32041 
	`sqlite3_free
(
zFullPathname
);

32042 
	`sqlite3_free
(
p
);

32043 return 
rc
;

32047 
mutexOpen
 = 
	`sqlite3MutexAlloc
(4);

32048 
	`sqlite3_mutex_enter
(
mutexOpen
);

32049 
mutexShared
 = 
	`sqlite3MutexAlloc
(2);

32050 
	`sqlite3_mutex_enter
(
mutexShared
);

32052 for(
pBt
=
sqlite3SharedCacheList
; pBt; pBt=pBt->
pNext
)

32056 if( 0==
	`strcmp
(
zFullPathname
, 
	`sqlite3PagerFilename
(
pBt
->
pPager
, 0))

32057 && 
	`sqlite3PagerVfs
(
pBt
->
pPager
)==
pVfs
 )

32060 int 
iDb
;

32061 for(
iDb
=
db
->
nDb
-1; iDb>=0; iDb--)

32064 
Btree
 *
pExisting
 = 
db
->
aDb
[
iDb
].
pBt
;

32065 if( 
pExisting
 && pExisting->
pBt
==pBt )

32068 
	`sqlite3_mutex_leave
(
mutexShared
);

32069 
	`sqlite3_mutex_leave
(
mutexOpen
);

32070 
	`sqlite3_free
(
zFullPathname
);

32071 
	`sqlite3_free
(
p
);

32075 
p
->
pBt
 = pBt;

32076 
pBt
->
nRef
++;

32080 
	`sqlite3_mutex_leave
(
mutexShared
);

32081 
	`sqlite3_free
(
zFullPathname
);

32086 if( 
pBt
==0 )

32100 
pBt
 = 
	`sqlite3MallocZero
( sizeof(*pBt) );

32101 if( 
pBt
==0 )

32104 
rc
 = 7;

32105 goto 
btree_open_out
;

32107 
rc
 = 
	`sqlite3PagerOpen
(
pVfs
, &
pBt
->
pPager
, 
zFilename
,

32108 sizeof(
MemPage
), 
flags
, 
vfsFlags
, 
pageReinit
);

32109 if( 
rc
==0 )

32112 
	`sqlite3PagerSetMmapLimit
(
pBt
->
pPager
, 
db
->
szMmap
);

32113 
rc
 = 
	`sqlite3PagerReadFileheader
(
pBt
->
pPager
,sizeof(
zDbHeader
),zDbHeader);

32115 if( 
rc
!=0 )

32118 goto 
btree_open_out
;

32120 
pBt
->
openFlags
 = (
u8
)
flags
;

32121 
pBt
->
db
 = db;

32122 
	`sqlite3PagerSetBusyhandler
(
pBt
->
pPager
, 
btreeInvokeBusyHandler
, pBt);

32123 
p
->
pBt
 = pBt;

32125 
pBt
->
pCursor
 = 0;

32126 
pBt
->
pPage1
 = 0;

32127 if( 
	`sqlite3PagerIsreadonly
(
pBt
->
pPager
) ) pBt->
btsFlags
 |= 0x0001;

32134 
pBt
->
pageSize
 = (
zDbHeader
[16]<<8) | (zDbHeader[17]<<16);

32135 if( 
pBt
->
pageSize
<512 || pBt->pageSize>65536

32136 || ((
pBt
->
pageSize
-1)&pBt->pageSize)!=0 )

32139 
pBt
->
pageSize
 = 0;

32147 if( 
zFilename
 && !
isMemdb
 )

32150 
pBt
->
autoVacuum
 = (0 ? 1 : 0);

32151 
pBt
->
incrVacuum
 = (0==2 ? 1 : 0);

32154 
nReserve
 = 0;

32159 
nReserve
 = 
zDbHeader
[20];

32160 
pBt
->
btsFlags
 |= 0x0002;

32162 
pBt
->
autoVacuum
 = (
	`sqlite3Get4byte
(&
zDbHeader
[36 + 4*4])?1:0);

32163 
pBt
->
incrVacuum
 = (
	`sqlite3Get4byte
(&
zDbHeader
[36 + 7*4])?1:0);

32166 
rc
 = 
	`sqlite3PagerSetPagesize
(
pBt
->
pPager
, &pBt->
pageSize
, 
nReserve
);

32167 if( 
rc
 ) goto 
btree_open_out
;

32168 
pBt
->
usableSize
 = pBt->
pageSize
 - 
nReserve
;

32174 if( 
p
->
sharable
 )

32177 
sqlite3_mutex
 *
mutexShared
;

32178 
pBt
->
nRef
 = 1;

32179 
mutexShared
 = 
	`sqlite3MutexAlloc
(2);

32180 if( 1 && 
sqlite3Config
.
bCoreMutex
 )

32183 
pBt
->
mutex
 = 
	`sqlite3MutexAlloc
(0);

32184 if( 
pBt
->
mutex
==0 )

32187 
rc
 = 7;

32188 goto 
btree_open_out
;

32191 
	`sqlite3_mutex_enter
(
mutexShared
);

32192 
pBt
->
pNext
 = 
sqlite3SharedCacheList
;

32193 
sqlite3SharedCacheList
 = 
pBt
;

32194 
	`sqlite3_mutex_leave
(
mutexShared
);

32204 if( 
p
->
sharable
 )

32207 int 
i
;

32208 
Btree
 *
pSib
;

32209 for(
i
=0; i<
db
->
nDb
; i++)

32212 if( (
pSib
 = 
db
->
aDb
[
i
].
pBt
)!=0 && pSib->
sharable
 )

32215 while( 
pSib
->
pPrev
 )

32217 
pSib
 = pSib->
pPrev
; }

32218 if( (
uptr
)
p
->
pBt
<(uptr)
pSib
->pBt )

32221 
p
->
pNext
 = 
pSib
;

32222 
p
->
pPrev
 = 0;

32223 
pSib
->
pPrev
 = 
p
;

32225 while( 
pSib
->
pNext
 && (
uptr
)pSib->pNext->
pBt
<(uptr)
p
->pBt )

32228 
pSib
 = pSib->
pNext
;

32230 
p
->
pNext
 = 
pSib
->pNext;

32231 
p
->
pPrev
 = 
pSib
;

32232 if( 
p
->
pNext
 )

32235 
p
->
pNext
->
pPrev
 = p;

32237 
pSib
->
pNext
 = 
p
;

32244 *
ppBtree
 = 
p
;

32246 
btree_open_out
:

32247 if( 
rc
!=0 )

32250 if( 
pBt
 && pBt->
pPager
 )

32253 
	`sqlite3PagerClose
(
pBt
->
pPager
);

32255 
	`sqlite3_free
(
pBt
);

32256 
	`sqlite3_free
(
p
);

32257 *
ppBtree
 = 0;

32263 if( 
	`sqlite3BtreeSchema
(
p
, 0, 0)==0 )

32266 
	`sqlite3PagerSetCachesize
(
p
->
pBt
->
pPager
, -2000);

32269 if( 
mutexOpen
 )

32273 
	`sqlite3_mutex_leave
(
mutexOpen
);

32275 return 
rc
;

32276 
	}
}

32284 static int 
	$removeFromSharingList
(
BtShared
 *
pBt
)

32288 
sqlite3_mutex
 *
pMaster
;

32289 
BtShared
 *
pList
;

32290 int 
removed
 = 0;

32293 
pMaster
 = 
	`sqlite3MutexAlloc
(2);

32294 
	`sqlite3_mutex_enter
(
pMaster
);

32295 
pBt
->
nRef
--;

32296 if( 
pBt
->
nRef
<=0 )

32299 if( 
sqlite3SharedCacheList
==
pBt
 )

32302 
sqlite3SharedCacheList
 = 
pBt
->
pNext
;

32304 
pList
 = 
sqlite3SharedCacheList
;

32305 while( (
pList
) && pList->
pNext
!=
pBt
 )

32308 
pList
=pList->
pNext
;

32310 if( (
pList
) )

32313 
pList
->
pNext
 = 
pBt
->pNext;

32319 
	`sqlite3_mutex_free
(
pBt
->
mutex
);

32321 
removed
 = 1;

32323 
	`sqlite3_mutex_leave
(
pMaster
);

32324 return 
removed
;

32328 
	}
}

32335 static void 
	$allocateTempSpace
(
BtShared
 *
pBt
)

32338 if( !
pBt
->
pTmpSpace
 )

32341 
pBt
->
pTmpSpace
 = 
	`sqlite3PageMalloc
( pBt->
pageSize
 );

32343 if( 
pBt
->
pTmpSpace
 )

32346 
	`memset
(
pBt
->
pTmpSpace
, 0, 8);

32347 
pBt
->
pTmpSpace
 += 4;

32350 
	}
}

32355 static void 
	$freeTempSpace
(
BtShared
 *
pBt
)

32358 if( 
pBt
->
pTmpSpace
 )

32361 
pBt
->
pTmpSpace
 -= 4;

32362 
	`sqlite3PageFree
(
pBt
->
pTmpSpace
);

32363 
pBt
->
pTmpSpace
 = 0;

32365 
	}
}

32370 static int 
	$sqlite3BtreeClose
(
Btree
 *
p
)

32373 
BtShared
 *
pBt
 = 
p
->pBt;

32374 
BtCursor
 *
pCur
;

32378 
	`sqlite3BtreeEnter
(
p
);

32379 
pCur
 = 
pBt
->
pCursor
;

32380 while( 
pCur
 )

32383 
BtCursor
 *
pTmp
 = 
pCur
;

32384 
pCur
 = pCur->
pNext
;

32385 if( 
pTmp
->
pBtree
==
p
 )

32388 
	`sqlite3BtreeCloseCursor
(
pTmp
);

32396 
	`sqlite3BtreeRollback
(
p
, 0, 0);

32397 
	`sqlite3BtreeLeave
(
p
);

32404 if( !
p
->
sharable
 || 
	`removeFromSharingList
(
pBt
) )

32413 
	`sqlite3PagerClose
(
pBt
->
pPager
);

32414 if( 
pBt
->
xFreeSchema
 && pBt->
pSchema
 )

32417 
pBt
->
	`xFreeSchema
(pBt->
pSchema
);

32419 
	`sqlite3DbFree
(0, 
pBt
->
pSchema
);

32420 
	`freeTempSpace
(
pBt
);

32421 
	`sqlite3_free
(
pBt
);

32427 if( 
p
->
pPrev
 ) p->pPrev->
pNext
 = p->pNext;

32428 if( 
p
->
pNext
 ) p->pNext->
pPrev
 = p->pPrev;

32431 
	`sqlite3_free
(
p
);

32433 
	}
}

32435 static int 
	$sqlite3BtreeSetCacheSize
(
Btree
 *
p
, int 
mxPage
)

32438 
BtShared
 *
pBt
 = 
p
->pBt;

32440 
	`sqlite3BtreeEnter
(
p
);

32441 
	`sqlite3PagerSetCachesize
(
pBt
->
pPager
, 
mxPage
);

32442 
	`sqlite3BtreeLeave
(
p
);

32444 
	}
}

32446 static int 
	$sqlite3BtreeSetSpillSize
(
Btree
 *
p
, int 
mxPage
)

32449 
BtShared
 *
pBt
 = 
p
->pBt;

32450 int 
res
;

32452 
	`sqlite3BtreeEnter
(
p
);

32453 
res
 = 
	`sqlite3PagerSetSpillsize
(
pBt
->
pPager
, 
mxPage
);

32454 
	`sqlite3BtreeLeave
(
p
);

32455 return 
res
;

32456 
	}
}

32463 static int 
	$sqlite3BtreeSetMmapLimit
(
Btree
 *
p
, 
sqlite3_int64
 
szMmap
)

32466 
BtShared
 *
pBt
 = 
p
->pBt;

32468 
	`sqlite3BtreeEnter
(
p
);

32469 
	`sqlite3PagerSetMmapLimit
(
pBt
->
pPager
, 
szMmap
);

32470 
	`sqlite3BtreeLeave
(
p
);

32472 
	}
}

32474 static int 
	$sqlite3BtreeSetPagerFlags
(

32475 
Btree
 *
p
,

32476 unsigned 
pgFlags


32480 
BtShared
 *
pBt
 = 
p
->pBt;

32482 
	`sqlite3BtreeEnter
(
p
);

32483 
	`sqlite3PagerSetFlags
(
pBt
->
pPager
, 
pgFlags
);

32484 
	`sqlite3BtreeLeave
(
p
);

32486 
	}
}

32488 static int 
	$sqlite3BtreeSetPageSize
(
Btree
 *
p
, int 
pageSize
, int 
nReserve
, int 
iFix
)

32491 int 
rc
 = 0;

32492 
BtShared
 *
pBt
 = 
p
->pBt;

32494 
	`sqlite3BtreeEnter
(
p
);

32498 if( 
pBt
->
btsFlags
 & 0x0002 )

32501 
	`sqlite3BtreeLeave
(
p
);

32504 if( 
nReserve
<0 )

32507 
nReserve
 = 
pBt
->
pageSize
 - pBt->
usableSize
;

32510 if( 
pageSize
>=512 && pageSize<=65536 &&

32511 ((
pageSize
-1)&pageSize)==0 )

32516 
pBt
->
pageSize
 = (
u32
)pageSize;

32517 
	`freeTempSpace
(
pBt
);

32519 
rc
 = 
	`sqlite3PagerSetPagesize
(
pBt
->
pPager
, &pBt->
pageSize
, 
nReserve
);

32520 
pBt
->
usableSize
 = pBt->
pageSize
 - (
u16
)
nReserve
;

32521 if( 
iFix
 ) 
pBt
->
btsFlags
 |= 0x0002;

32522 
	`sqlite3BtreeLeave
(
p
);

32523 return 
rc
;

32524 
	}
}

32529 static int 
	$sqlite3BtreeGetPageSize
(
Btree
 *
p
)

32532 return 
p
->
pBt
->
pageSize
;

32533 
	}
}

32535 static int 
	$sqlite3BtreeGetReserveNoMutex
(
Btree
 *
p
)

32538 int 
n
;

32540 
n
 = 
p
->
pBt
->
pageSize
 - p->pBt->
usableSize
;

32541 return 
n
;

32542 
	}
}

32544 static int 
	$sqlite3BtreeGetOptimalReserve
(
Btree
 *
p
)

32547 int 
n
;

32548 
	`sqlite3BtreeEnter
(
p
);

32549 
n
 = 
	`sqlite3BtreeGetReserveNoMutex
(
p
);

32553 
	`sqlite3BtreeLeave
(
p
);

32554 return 
n
;

32555 
	}
}

32563 static int 
	$sqlite3BtreeMaxPageCount
(
Btree
 *
p
, int 
mxPage
)

32566 int 
n
;

32567 
	`sqlite3BtreeEnter
(
p
);

32568 
n
 = 
	`sqlite3PagerMaxPageCount
(
p
->
pBt
->
pPager
, 
mxPage
);

32569 
	`sqlite3BtreeLeave
(
p
);

32570 return 
n
;

32571 
	}
}

32578 static int 
	$sqlite3BtreeSecureDelete
(
Btree
 *
p
, int 
newFlag
)

32581 int 
b
;

32582 if( 
p
==0 ) return 0;

32583 
	`sqlite3BtreeEnter
(
p
);

32584 if( 
newFlag
>=0 )

32587 
p
->
pBt
->
btsFlags
 &= ~0x0004;

32588 if( 
newFlag
 ) 
p
->
pBt
->
btsFlags
 |= 0x0004;

32590 
b
 = (
p
->
pBt
->
btsFlags
 & 0x0004)!=0;

32591 
	`sqlite3BtreeLeave
(
p
);

32592 return 
b
;

32593 
	}
}

32601 static int 
	$sqlite3BtreeSetAutoVacuum
(
Btree
 *
p
, int 
autoVacuum
)

32607 
BtShared
 *
pBt
 = 
p
->pBt;

32608 int 
rc
 = 0;

32609 
u8
 
av
 = (u8)
autoVacuum
;

32611 
	`sqlite3BtreeEnter
(
p
);

32612 if( (
pBt
->
btsFlags
 & 0x0002)!=0 && (
av
 ?1:0)!=pBt->
autoVacuum
 )

32615 
rc
 = 8;

32617 
pBt
->
autoVacuum
 = 
av
 ?1:0;

32618 
pBt
->
incrVacuum
 = 
av
==2 ?1:0;

32620 
	`sqlite3BtreeLeave
(
p
);

32621 return 
rc
;

32623 
	}
}

32629 static int 
	$sqlite3BtreeGetAutoVacuum
(
Btree
 *
p
)

32635 int 
rc
;

32636 
	`sqlite3BtreeEnter
(
p
);

32637 
rc
 = (

32638 (!
p
->
pBt
->
autoVacuum
)?0:

32639 (!
p
->
pBt
->
incrVacuum
)?1:

32642 
	`sqlite3BtreeLeave
(
p
);

32643 return 
rc
;

32645 
	}
}

32647 static int 
	$lockBtree
(
BtShared
 *
pBt
)

32650 int 
rc
;

32651 
MemPage
 *
pPage1
;

32652 int 
nPage
;

32653 int 
nPageFile
 = 0;

32654 int 
nPageHeader
;

32658 
rc
 = 
	`sqlite3PagerSharedLock
(
pBt
->
pPager
);

32659 if( 
rc
!=0 ) return rc;

32660 
rc
 = 
	`btreeGetPage
(
pBt
, 1, &
pPage1
, 0);

32661 if( 
rc
!=0 ) return rc;

32666 
nPage
 = 
nPageHeader
 = 
	`sqlite3Get4byte
(28+(
u8
*)
pPage1
->
aData
);

32667 
	`sqlite3PagerPagecount
(
pBt
->
pPager
, &
nPageFile
);

32668 if( 
nPage
==0 || 
	`memcmp
(24+(
u8
*)
pPage1
->
aData
, 92+(u8*)pPage1->aData,4)!=0 )

32671 
nPage
 = 
nPageFile
;

32673 if( 
nPage
>0 )

32676 
u32
 
pageSize
;

32677 
u32
 
usableSize
;

32678 
u8
 *
page1
 = 
pPage1
->
aData
;

32679 
rc
 = 26;

32683 if( 
	`memcmp
(
page1
, 
zMagicHeader
, 16)!=0 )

32686 goto 
page1_init_failed
;

32689 if( 
page1
[18]>2 )

32692 
pBt
->
btsFlags
 |= 0x0001;

32694 if( 
page1
[19]>2 )

32697 goto 
page1_init_failed
;

32700 if( 
page1
[19]==2 && (
pBt
->
btsFlags
 & 0x0010)==0 )

32703 int 
isOpen
 = 0;

32704 
rc
 = 
	`sqlite3PagerOpenWal
(
pBt
->
pPager
, &
isOpen
);

32705 if( 
rc
!=0 )

32708 goto 
page1_init_failed
;

32711 if( 
isOpen
==0 )

32714 
	`releasePage
(
pPage1
);

32718 
rc
 = 26;

32721 if( 
	`memcmp
(&
page1
[21], "\100\040\040",3)!=0 )

32724 goto 
page1_init_failed
;

32729 
pageSize
 = (
page1
[16]<<8) | (page1[17]<<16);

32732 if( ((
pageSize
-1)&pageSize)!=0

32733 || 
pageSize
>65536

32734 || 
pageSize
<=256

32738 goto 
page1_init_failed
;

32748 
usableSize
 = 
pageSize
 - 
page1
[20];

32749 if( (
u32
)
pageSize
!=
pBt
->pageSize )

32758 
	`releasePage
(
pPage1
);

32759 
pBt
->
usableSize
 = usableSize;

32760 
pBt
->
pageSize
 = pageSize;

32761 
	`freeTempSpace
(
pBt
);

32762 
rc
 = 
	`sqlite3PagerSetPagesize
(
pBt
->
pPager
, &pBt->
pageSize
,

32763 
pageSize
-
usableSize
);

32764 return 
rc
;

32766 if( (
pBt
->
db
->
flags
 & 0x00010000)==0 && 
nPage
>
nPageFile
 )

32769 
rc
 = 
	`sqlite3CorruptError
(58737);

32770 goto 
page1_init_failed
;

32775 if( 
usableSize
<480 )

32778 goto 
page1_init_failed
;

32780 
pBt
->
pageSize
 = pageSize;

32781 
pBt
->
usableSize
 = usableSize;

32783 
pBt
->
autoVacuum
 = (
	`sqlite3Get4byte
(&
page1
[36 + 4*4])?1:0);

32784 
pBt
->
incrVacuum
 = (
	`sqlite3Get4byte
(&
page1
[36 + 7*4])?1:0);

32788 
pBt
->
maxLocal
 = (
u16
)((pBt->
usableSize
-12)*64/255 - 23);

32789 
pBt
->
minLocal
 = (
u16
)((pBt->
usableSize
-12)*32/255 - 23);

32790 
pBt
->
maxLeaf
 = (
u16
)(pBt->
usableSize
 - 35);

32791 
pBt
->
minLeaf
 = (
u16
)((pBt->
usableSize
-12)*32/255 - 23);

32792 if( 
pBt
->
maxLocal
>127 )

32795 
pBt
->
max1bytePayload
 = 127;

32797 
pBt
->
max1bytePayload
 = (
u8
)pBt->
maxLocal
;

32800 
pBt
->
pPage1
 = pPage1;

32801 
pBt
->
nPage
 = nPage;

32804 
page1_init_failed
:

32805 
	`releasePage
(
pPage1
);

32806 
pBt
->
pPage1
 = 0;

32807 return 
rc
;

32808 
	}
}

32810 static void 
	$unlockBtreeIfUnused
(
BtShared
 *
pBt
)

32815 if( 
pBt
->
inTransaction
==0 && pBt->
pPage1
!=0 )

32818 
MemPage
 *
pPage1
 = 
pBt
->pPage1;

32821 
pBt
->
pPage1
 = 0;

32822 
	`releasePageNotNull
(
pPage1
);

32824 
	}
}

32831 static int 
	$newDatabase
(
BtShared
 *
pBt
)

32834 
MemPage
 *
pP1
;

32835 unsigned char *
data
;

32836 int 
rc
;

32839 if( 
pBt
->
nPage
>0 )

32844 
pP1
 = 
pBt
->
pPage1
;

32846 
data
 = 
pP1
->
aData
;

32847 
rc
 = 
	`sqlite3PagerWrite
(
pP1
->
pDbPage
);

32848 if( 
rc
 ) return rc;

32849 
	`memcpy
(
data
, 
zMagicHeader
, sizeof(zMagicHeader));

32851 
data
[16] = (
u8
)((
pBt
->
pageSize
>>8)&0xff);

32852 
data
[17] = (
u8
)((
pBt
->
pageSize
>>16)&0xff);

32853 
data
[18] = 1;

32854 
data
[19] = 1;

32856 
data
[20] = (
u8
)(
pBt
->
pageSize
 - pBt->
usableSize
);

32857 
data
[21] = 64;

32858 
data
[22] = 32;

32859 
data
[23] = 32;

32860 
	`memset
(&
data
[24], 0, 100-24);

32861 
	`zeroPage
(
pP1
, 0x01|0x08|0x04 );

32862 
pBt
->
btsFlags
 |= 0x0002;

32866 
	`sqlite3Put4byte
(&
data
[36 + 4*4], 
pBt
->
autoVacuum
);

32867 
	`sqlite3Put4byte
(&
data
[36 + 7*4], 
pBt
->
incrVacuum
);

32869 
pBt
->
nPage
 = 1;

32870 
data
[31] = 1;

32872 
	}
}

32879 static int 
	$sqlite3BtreeNewDb
(
Btree
 *
p
)

32882 int 
rc
;

32883 
	`sqlite3BtreeEnter
(
p
);

32884 
p
->
pBt
->
nPage
 = 0;

32885 
rc
 = 
	`newDatabase
(
p
->
pBt
);

32886 
	`sqlite3BtreeLeave
(
p
);

32887 return 
rc
;

32888 
	}
}

32890 static int 
	$sqlite3BtreeBeginTrans
(
Btree
 *
p
, int 
wrflag
)

32893 
BtShared
 *
pBt
 = 
p
->pBt;

32894 int 
rc
 = 0;

32896 
	`sqlite3BtreeEnter
(
p
);

32903 if( 
p
->
inTrans
==2 || (p->inTrans==1 && !
wrflag
) )

32906 goto 
trans_begun
;

32911 if( (
pBt
->
btsFlags
 & 0x0001)!=0 && 
wrflag
 )

32914 
rc
 = 8;

32915 goto 
trans_begun
;

32920 
sqlite3
 *
pBlock
 = 0;

32925 if( (
wrflag
 && 
pBt
->
inTransaction
==2)

32926 || (
pBt
->
btsFlags
 & 0x0040)!=0

32930 
pBlock
 = 
pBt
->
pWriter
->
db
;

32931 }else if( 
wrflag
>1 )

32934 
BtLock
 *
pIter
;

32935 for(
pIter
=
pBt
->
pLock
; pIter; pIter=pIter->
pNext
)

32938 if( 
pIter
->
pBtree
!=
p
 )

32941 
pBlock
 = 
pIter
->
pBtree
->
db
;

32946 if( 
pBlock
 )

32950 
rc
 = (6 | (1<<8));

32951 goto 
trans_begun
;

32959 
rc
 = 
	`querySharedCacheTableLock
(
p
, 1, 1);

32960 if( 0!=
rc
 ) goto 
trans_begun
;

32962 
pBt
->
btsFlags
 &= ~0x0008;

32963 if( 
pBt
->
nPage
==0 ) pBt->
btsFlags
 |= 0x0008;

32972 while( 
pBt
->
pPage1
==0 && 0==(
rc
 = 
	`lockBtree
(pBt)) );

32974 if( 
rc
==0 && 
wrflag
 )

32977 if( (
pBt
->
btsFlags
 & 0x0001)!=0 )

32980 
rc
 = 8;

32982 
rc
 = 
	`sqlite3PagerBegin
(
pBt
->
pPager
,
wrflag
>1,
	`sqlite3TempInMemory
(
p
->
db
));

32983 if( 
rc
==0 )

32986 
rc
 = 
	`newDatabase
(
pBt
);

32991 if( 
rc
!=0 )

32994 
	`unlockBtreeIfUnused
(
pBt
);

32996 }while( (
rc
&0xFF)==5 && 
pBt
->
inTransaction
==0 &&

32997 
	`btreeInvokeBusyHandler
(
pBt
) );

32999 if( 
rc
==0 )

33002 if( 
p
->
inTrans
==0 )

33005 
pBt
->
nTransaction
++;

33007 if( 
p
->
sharable
 )

33011 
p
->
lock
.
eLock
 = 1;

33012 
p
->
lock
.
pNext
 = 
pBt
->
pLock
;

33013 
pBt
->
pLock
 = &
p
->
lock
;

33017 
p
->
inTrans
 = (
wrflag
?2:1);

33018 if( 
p
->
inTrans
>
pBt
->
inTransaction
 )

33021 
pBt
->
inTransaction
 = 
p
->
inTrans
;

33023 if( 
wrflag
 )

33026 
MemPage
 *
pPage1
 = 
pBt
->pPage1;

33029 
pBt
->
pWriter
 = 
p
;

33030 
pBt
->
btsFlags
 &= ~0x0020;

33031 if( 
wrflag
>1 ) 
pBt
->
btsFlags
 |= 0x0020;

33033 if( 
pBt
->
nPage
!=
	`sqlite3Get4byte
(&
pPage1
->
aData
[28]) )

33036 
rc
 = 
	`sqlite3PagerWrite
(
pPage1
->
pDbPage
);

33037 if( 
rc
==0 )

33040 
	`sqlite3Put4byte
(&
pPage1
->
aData
[28], 
pBt
->
nPage
);

33047 
trans_begun
:

33048 if( 
rc
==0 && 
wrflag
 )

33055 
rc
 = 
	`sqlite3PagerOpenSavepoint
(
pBt
->
pPager
, 
p
->
db
->
nSavepoint
);

33059 
	`sqlite3BtreeLeave
(
p
);

33060 return 
rc
;

33061 
	}
}

33063 static int 
	$setChildPtrmaps
(
MemPage
 *
pPage
)

33066 int 
i
;

33067 int 
nCell
;

33068 int 
rc
;

33069 
BtShared
 *
pBt
 = 
pPage
->pBt;

33070 
u8
 
isInitOrig
 = 
pPage
->
isInit
;

33071 
Pgno
 
pgno
 = 
pPage
->pgno;

33074 
rc
 = 
	`btreeInitPage
(
pPage
);

33075 if( 
rc
!=0 )

33078 goto 
set_child_ptrmaps_out
;

33080 
nCell
 = 
pPage
->nCell;

33082 for(
i
=0; i<
nCell
; i++)

33085 
u8
 *
pCell
 = ((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
i
)]))));

33087 
	`ptrmapPutOvflPtr
(
pPage
, 
pCell
, &
rc
);

33089 if( !
pPage
->
leaf
 )

33092 
Pgno
 
childPgno
 = 
	`sqlite3Get4byte
(
pCell
);

33093 
	`ptrmapPut
(
pBt
, 
childPgno
, 5, 
pgno
, &
rc
);

33097 if( !
pPage
->
leaf
 )

33100 
Pgno
 
childPgno
 = 
	`sqlite3Get4byte
(&
pPage
->
aData
[pPage->
hdrOffset
+8]);

33101 
	`ptrmapPut
(
pBt
, 
childPgno
, 5, 
pgno
, &
rc
);

33104 
set_child_ptrmaps_out
:

33105 
pPage
->
isInit
 = 
isInitOrig
;

33106 return 
rc
;

33107 
	}
}

33109 static int 
	$modifyPagePointer
(
MemPage
 *
pPage
, 
Pgno
 
iFrom
, Pgno 
iTo
, 
u8
 
eType
)

33114 if( 
eType
==4 )

33118 if( 
	`sqlite3Get4byte
(
pPage
->
aData
)!=
iFrom
 )

33121 return 
	`sqlite3CorruptError
(59127);

33123 
	`sqlite3Put4byte
(
pPage
->
aData
, 
iTo
);

33125 
u8
 
isInitOrig
 = 
pPage
->
isInit
;

33126 int 
i
;

33127 int 
nCell
;

33128 int 
rc
;

33130 
rc
 = 
	`btreeInitPage
(
pPage
);

33131 if( 
rc
 ) return rc;

33132 
nCell
 = 
pPage
->nCell;

33134 for(
i
=0; i<
nCell
; i++)

33137 
u8
 *
pCell
 = ((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
i
)]))));

33138 if( 
eType
==3 )

33141 
CellInfo
 
info
;

33142 
pPage
->
	`xParseCell
(pPage, 
pCell
, &
info
);

33143 if( 
info
.
nLocal
<info.
nPayload


33144 && 
pCell
+
info
.
nSize
-1<=
pPage
->
aData
+pPage->
maskPage


33145 && 
iFrom
==
	`sqlite3Get4byte
(
pCell
+
info
.
nSize
-4)

33149 
	`sqlite3Put4byte
(
pCell
+
info
.
nSize
-4, 
iTo
);

33153 if( 
	`sqlite3Get4byte
(
pCell
)==
iFrom
 )

33156 
	`sqlite3Put4byte
(
pCell
, 
iTo
);

33162 if( 
i
==
nCell
 )

33165 if( 
eType
!=5 ||

33166 
	`sqlite3Get4byte
(&
pPage
->
aData
[pPage->
hdrOffset
+8])!=
iFrom
 )

33169 return 
	`sqlite3CorruptError
(59163);

33171 
	`sqlite3Put4byte
(&
pPage
->
aData
[pPage->
hdrOffset
+8], 
iTo
);

33174 
pPage
->
isInit
 = 
isInitOrig
;

33177 
	}
}

33179 static int 
	$relocatePage
(

33180 
BtShared
 *
pBt
,

33181 
MemPage
 *
pDbPage
,

33182 
u8
 
eType
,

33183 
Pgno
 
iPtrPage
,

33184 
Pgno
 
iFreePage
,

33185 int 
isCommit


33189 
MemPage
 *
pPtrPage
;

33190 
Pgno
 
iDbPage
 = 
pDbPage
->
pgno
;

33191 
Pager
 *
pPager
 = 
pBt
->pPager;

33192 int 
rc
;

33202 
rc
 = 
	`sqlite3PagerMovepage
(
pPager
, 
pDbPage
->pDbPage, 
iFreePage
, 
isCommit
);

33203 if( 
rc
!=0 )

33206 return 
rc
;

33208 
pDbPage
->
pgno
 = 
iFreePage
;

33210 if( 
eType
==5 || eType==1 )

33213 
rc
 = 
	`setChildPtrmaps
(
pDbPage
);

33214 if( 
rc
!=0 )

33217 return 
rc
;

33220 
Pgno
 
nextOvfl
 = 
	`sqlite3Get4byte
(
pDbPage
->
aData
);

33221 if( 
nextOvfl
!=0 )

33224 
	`ptrmapPut
(
pBt
, 
nextOvfl
, 4, 
iFreePage
, &
rc
);

33225 if( 
rc
!=0 )

33228 return 
rc
;

33237 if( 
eType
!=1 )

33240 
rc
 = 
	`btreeGetPage
(
pBt
, 
iPtrPage
, &
pPtrPage
, 0);

33241 if( 
rc
!=0 )

33244 return 
rc
;

33246 
rc
 = 
	`sqlite3PagerWrite
(
pPtrPage
->
pDbPage
);

33247 if( 
rc
!=0 )

33250 
	`releasePage
(
pPtrPage
);

33251 return 
rc
;

33253 
rc
 = 
	`modifyPagePointer
(
pPtrPage
, 
iDbPage
, 
iFreePage
, 
eType
);

33254 
	`releasePage
(
pPtrPage
);

33255 if( 
rc
==0 )

33258 
	`ptrmapPut
(
pBt
, 
iFreePage
, 
eType
, 
iPtrPage
, &
rc
);

33261 return 
rc
;

33262 
	}
}

33265 static int 
allocateBtreePage
(
BtShared
 *, 
MemPage
 **, 
Pgno
 *, Pgno, 
u8
);

33267 static int 
	$incrVacuumStep
(
BtShared
 *
pBt
, 
Pgno
 
nFin
, Pgno 
iLastPg
, int 
bCommit
)

33270 
Pgno
 
nFreeList
;

33271 int 
rc
;

33276 if( !(
	`ptrmapPageno
((
pBt
), (
iLastPg
))==(iLastPg)) && iLastPg!=((
Pgno
)((
sqlite3PendingByte
/((pBt)->
pageSize
))+1)) )

33279 
u8
 
eType
;

33280 
Pgno
 
iPtrPage
;

33282 
nFreeList
 = 
	`sqlite3Get4byte
(&
pBt
->
pPage1
->
aData
[36]);

33283 if( 
nFreeList
==0 )

33289 
rc
 = 
	`ptrmapGet
(
pBt
, 
iLastPg
, &
eType
, &
iPtrPage
);

33290 if( 
rc
!=0 )

33293 return 
rc
;

33295 if( 
eType
==1 )

33298 return 
	`sqlite3CorruptError
(59297);

33301 if( 
eType
==2 )

33304 if( 
bCommit
==0 )

33312 
Pgno
 
iFreePg
;

33313 
MemPage
 *
pFreePg
;

33314 
rc
 = 
	`allocateBtreePage
(
pBt
, &
pFreePg
, &
iFreePg
, 
iLastPg
, 1);

33315 if( 
rc
!=0 )

33318 return 
rc
;

33321 
	`releasePage
(
pFreePg
);

33324 
Pgno
 
iFreePg
;

33325 
MemPage
 *
pLastPg
;

33326 
u8
 
eMode
 = 0;

33327 
Pgno
 
iNear
 = 0;

33329 
rc
 = 
	`btreeGetPage
(
pBt
, 
iLastPg
, &
pLastPg
, 0);

33330 if( 
rc
!=0 )

33333 return 
rc
;

33336 if( 
bCommit
==0 )

33339 
eMode
 = 2;

33340 
iNear
 = 
nFin
;

33343 
MemPage
 *
pFreePg
;

33344 
rc
 = 
	`allocateBtreePage
(
pBt
, &
pFreePg
, &
iFreePg
, 
iNear
, 
eMode
);

33345 if( 
rc
!=0 )

33348 
	`releasePage
(
pLastPg
);

33349 return 
rc
;

33351 
	`releasePage
(
pFreePg
);

33352 }while( 
bCommit
 && 
iFreePg
>
nFin
 );

33355 
rc
 = 
	`relocatePage
(
pBt
, 
pLastPg
, 
eType
, 
iPtrPage
, 
iFreePg
, 
bCommit
);

33356 
	`releasePage
(
pLastPg
);

33357 if( 
rc
!=0 )

33360 return 
rc
;

33365 if( 
bCommit
==0 )

33369 
iLastPg
--;

33370 }while( 
iLastPg
==((
Pgno
)((
sqlite3PendingByte
/((
pBt
)->
pageSize
))+1)) || (
	`ptrmapPageno
((pBt), (iLastPg))==(iLastPg)) );

33371 
pBt
->
bDoTruncate
 = 1;

33372 
pBt
->
nPage
 = 
iLastPg
;

33375 
	}
}

33382 static 
Pgno
 
	$finalDbSize
(
BtShared
 *
pBt
, 
Pgno
 
nOrig
, Pgno 
nFree
)

33385 int 
nEntry
;

33386 
Pgno
 
nPtrmap
;

33387 
Pgno
 
nFin
;

33389 
nEntry
 = 
pBt
->
usableSize
/5;

33390 
nPtrmap
 = (
nFree
-
nOrig
+
	`ptrmapPageno
(
pBt
, nOrig)+
nEntry
)/nEntry;

33391 
nFin
 = 
nOrig
 - 
nFree
 - 
nPtrmap
;

33392 if( 
nOrig
>((
Pgno
)((
sqlite3PendingByte
/((
pBt
)->
pageSize
))+1)) && 
nFin
<((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) )

33395 
nFin
--;

33397 while( (
	`ptrmapPageno
((
pBt
), (
nFin
))==(nFin)) || nFin==((
Pgno
)((
sqlite3PendingByte
/((pBt)->
pageSize
))+1)) )

33400 
nFin
--;

33403 return 
nFin
;

33404 
	}
}

33406 static int 
	$sqlite3BtreeIncrVacuum
(
Btree
 *
p
)

33409 int 
rc
;

33410 
BtShared
 *
pBt
 = 
p
->pBt;

33412 
	`sqlite3BtreeEnter
(
p
);

33414 if( !
pBt
->
autoVacuum
 )

33417 
rc
 = 101;

33419 
Pgno
 
nOrig
 = 
	`btreePagecount
(
pBt
);

33420 
Pgno
 
nFree
 = 
	`sqlite3Get4byte
(&
pBt
->
pPage1
->
aData
[36]);

33421 
Pgno
 
nFin
 = 
	`finalDbSize
(
pBt
, 
nOrig
, 
nFree
);

33423 if( 
nOrig
<
nFin
 )

33426 
rc
 = 
	`sqlite3CorruptError
(59412);

33427 }else if( 
nFree
>0 )

33430 
rc
 = 
	`saveAllCursors
(
pBt
, 0, 0);

33431 if( 
rc
==0 )

33434 
	`invalidateAllOverflowCache
(
pBt
);

33435 
rc
 = 
	`incrVacuumStep
(
pBt
, 
nFin
, 
nOrig
, 0);

33437 if( 
rc
==0 )

33440 
rc
 = 
	`sqlite3PagerWrite
(
pBt
->
pPage1
->
pDbPage
);

33441 
	`sqlite3Put4byte
(&
pBt
->
pPage1
->
aData
[28], pBt->
nPage
);

33444 
rc
 = 101;

33447 
	`sqlite3BtreeLeave
(
p
);

33448 return 
rc
;

33449 
	}
}

33451 static int 
	$autoVacuumCommit
(
BtShared
 *
pBt
)

33454 int 
rc
 = 0;

33455 
Pager
 *
pPager
 = 
pBt
->pPager;

33459 
	`invalidateAllOverflowCache
(
pBt
);

33461 if( !
pBt
->
incrVacuum
 )

33464 
Pgno
 
nFin
;

33465 
Pgno
 
nFree
;

33466 
Pgno
 
iFree
;

33467 
Pgno
 
nOrig
;

33469 
nOrig
 = 
	`btreePagecount
(
pBt
);

33470 if( (
	`ptrmapPageno
((
pBt
), (
nOrig
))==(nOrig)) || nOrig==((
Pgno
)((
sqlite3PendingByte
/((pBt)->
pageSize
))+1)) )

33477 return 
	`sqlite3CorruptError
(59460);

33480 
nFree
 = 
	`sqlite3Get4byte
(&
pBt
->
pPage1
->
aData
[36]);

33481 
nFin
 = 
	`finalDbSize
(
pBt
, 
nOrig
, 
nFree
);

33482 if( 
nFin
>
nOrig
 ) return 
	`sqlite3CorruptError
(59465);

33483 if( 
nFin
<
nOrig
 )

33486 
rc
 = 
	`saveAllCursors
(
pBt
, 0, 0);

33488 for(
iFree
=
nOrig
; iFree>
nFin
 && 
rc
==0; iFree--)

33491 
rc
 = 
	`incrVacuumStep
(
pBt
, 
nFin
, 
iFree
, 1);

33493 if( (
rc
==101 || rc==0) && 
nFree
>0 )

33496 
rc
 = 
	`sqlite3PagerWrite
(
pBt
->
pPage1
->
pDbPage
);

33497 
	`sqlite3Put4byte
(&
pBt
->
pPage1
->
aData
[32], 0);

33498 
	`sqlite3Put4byte
(&
pBt
->
pPage1
->
aData
[36], 0);

33499 
	`sqlite3Put4byte
(&
pBt
->
pPage1
->
aData
[28], 
nFin
);

33500 
pBt
->
bDoTruncate
 = 1;

33501 
pBt
->
nPage
 = 
nFin
;

33503 if( 
rc
!=0 )

33506 
	`sqlite3PagerRollback
(
pPager
);

33511 return 
rc
;

33512 
	}
}

33514 static int 
	$sqlite3BtreeCommitPhaseOne
(
Btree
 *
p
, const char *
zMaster
)

33517 int 
rc
 = 0;

33518 if( 
p
->
inTrans
==2 )

33521 
BtShared
 *
pBt
 = 
p
->pBt;

33522 
	`sqlite3BtreeEnter
(
p
);

33524 if( 
pBt
->
autoVacuum
 )

33527 
rc
 = 
	`autoVacuumCommit
(
pBt
);

33528 if( 
rc
!=0 )

33531 
	`sqlite3BtreeLeave
(
p
);

33532 return 
rc
;

33535 if( 
pBt
->
bDoTruncate
 )

33538 
	`sqlite3PagerTruncateImage
(
pBt
->
pPager
, pBt->
nPage
);

33541 
rc
 = 
	`sqlite3PagerCommitPhaseOne
(
pBt
->
pPager
, 
zMaster
, 0);

33542 
	`sqlite3BtreeLeave
(
p
);

33544 return 
rc
;

33545 
	}
}

33551 static void 
	$btreeEndTransaction
(
Btree
 *
p
)

33554 
BtShared
 *
pBt
 = 
p
->pBt;

33555 
sqlite3
 *
db
 = 
p
->db;

33559 
pBt
->
bDoTruncate
 = 0;

33561 if( 
p
->
inTrans
>0 && 
db
->
nVdbeRead
>1 )

33567 
	`downgradeAllSharedCacheTableLocks
(
p
);

33568 
p
->
inTrans
 = 1;

33574 if( 
p
->
inTrans
!=0 )

33577 
	`clearAllSharedCacheTableLocks
(
p
);

33578 
pBt
->
nTransaction
--;

33579 if( 0==
pBt
->
nTransaction
 )

33582 
pBt
->
inTransaction
 = 0;

33588 
p
->
inTrans
 = 0;

33589 
	`unlockBtreeIfUnused
(
pBt
);

33593 
	}
}

33595 static int 
	$sqlite3BtreeCommitPhaseTwo
(
Btree
 *
p
, int 
bCleanup
)

33599 if( 
p
->
inTrans
==0 ) return 0;

33600 
	`sqlite3BtreeEnter
(
p
);

33606 if( 
p
->
inTrans
==2 )

33609 int 
rc
;

33610 
BtShared
 *
pBt
 = 
p
->pBt;

33613 
rc
 = 
	`sqlite3PagerCommitPhaseTwo
(
pBt
->
pPager
);

33614 if( 
rc
!=0 && 
bCleanup
==0 )

33617 
	`sqlite3BtreeLeave
(
p
);

33618 return 
rc
;

33620 
p
->
iDataVersion
--;

33621 
pBt
->
inTransaction
 = 1;

33622 
	`btreeClearHasContent
(
pBt
);

33625 
	`btreeEndTransaction
(
p
);

33626 
	`sqlite3BtreeLeave
(
p
);

33628 
	}
}

33633 static int 
	$sqlite3BtreeCommit
(
Btree
 *
p
)

33636 int 
rc
;

33637 
	`sqlite3BtreeEnter
(
p
);

33638 
rc
 = 
	`sqlite3BtreeCommitPhaseOne
(
p
, 0);

33639 if( 
rc
==0 )

33642 
rc
 = 
	`sqlite3BtreeCommitPhaseTwo
(
p
, 0);

33644 
	`sqlite3BtreeLeave
(
p
);

33645 return 
rc
;

33646 
	}
}

33648 static int 
	$sqlite3BtreeTripAllCursors
(
Btree
 *
pBtree
, int 
errCode
, int 
writeOnly
)

33651 
BtCursor
 *
p
;

33652 int 
rc
 = 0;

33655 if( 
pBtree
 )

33658 
	`sqlite3BtreeEnter
(
pBtree
);

33659 for(
p
=
pBtree
->
pBt
->
pCursor
; p; p=p->
pNext
)

33662 int 
i
;

33663 if( 
writeOnly
 && (
p
->
curFlags
 & 0x01)==0 )

33666 if( 
p
->
eState
==1 || p->eState==2 )

33669 
rc
 = 
	`saveCursorPosition
(
p
);

33670 if( 
rc
!=0 )

33673 (void)
	`sqlite3BtreeTripAllCursors
(
pBtree
, 
rc
, 0);

33678 
	`sqlite3BtreeClearCursor
(
p
);

33679 
p
->
eState
 = 4;

33680 
p
->
skipNext
 = 
errCode
;

33682 for(
i
=0; i<=
p
->
iPage
; i++)

33685 
	`releasePage
(
p
->
apPage
[
i
]);

33686 
p
->
apPage
[
i
] = 0;

33689 
	`sqlite3BtreeLeave
(
pBtree
);

33691 return 
rc
;

33692 
	}
}

33694 static int 
	$sqlite3BtreeRollback
(
Btree
 *
p
, int 
tripCode
, int 
writeOnly
)

33697 int 
rc
;

33698 
BtShared
 *
pBt
 = 
p
->pBt;

33699 
MemPage
 *
pPage1
;

33703 
	`sqlite3BtreeEnter
(
p
);

33704 if( 
tripCode
==0 )

33707 
rc
 = 
tripCode
 = 
	`saveAllCursors
(
pBt
, 0, 0);

33708 if( 
rc
 ) 
writeOnly
 = 0;

33710 
rc
 = 0;

33712 if( 
tripCode
 )

33715 int 
rc2
 = 
	`sqlite3BtreeTripAllCursors
(
p
, 
tripCode
, 
writeOnly
);

33717 if( 
rc2
!=0 ) 
rc
 = rc2;

33721 if( 
p
->
inTrans
==2 )

33724 int 
rc2
;

33727 
rc2
 = 
	`sqlite3PagerRollback
(
pBt
->
pPager
);

33728 if( 
rc2
!=0 )

33731 
rc
 = 
rc2
;

33737 if( 
	`btreeGetPage
(
pBt
, 1, &
pPage1
, 0)==0 )

33740 int 
nPage
 = 
	`sqlite3Get4byte
(28+(
u8
*)
pPage1
->
aData
);

33742 if( 
nPage
==0 ) 
	`sqlite3PagerPagecount
(
pBt
->
pPager
, &nPage);

33744 
pBt
->
nPage
 = nPage;

33745 
	`releasePage
(
pPage1
);

33748 
pBt
->
inTransaction
 = 1;

33749 
	`btreeClearHasContent
(
pBt
);

33752 
	`btreeEndTransaction
(
p
);

33753 
	`sqlite3BtreeLeave
(
p
);

33754 return 
rc
;

33755 
	}
}

33757 static int 
	$sqlite3BtreeBeginStmt
(
Btree
 *
p
, int 
iStatement
)

33760 int 
rc
;

33761 
BtShared
 *
pBt
 = 
p
->pBt;

33762 
	`sqlite3BtreeEnter
(
p
);

33773 
rc
 = 
	`sqlite3PagerOpenSavepoint
(
pBt
->
pPager
, 
iStatement
);

33774 
	`sqlite3BtreeLeave
(
p
);

33775 return 
rc
;

33776 
	}
}

33778 static int 
	$sqlite3BtreeSavepoint
(
Btree
 *
p
, int 
op
, int 
iSavepoint
)

33781 int 
rc
 = 0;

33782 if( 
p
 && p->
inTrans
==2 )

33785 
BtShared
 *
pBt
 = 
p
->pBt;

33788 
	`sqlite3BtreeEnter
(
p
);

33789 
rc
 = 
	`sqlite3PagerSavepoint
(
pBt
->
pPager
, 
op
, 
iSavepoint
);

33790 if( 
rc
==0 )

33793 if( 
iSavepoint
<0 && (
pBt
->
btsFlags
 & 0x0008)!=0 )

33796 
pBt
->
nPage
 = 0;

33798 
rc
 = 
	`newDatabase
(
pBt
);

33799 
pBt
->
nPage
 = 
	`sqlite3Get4byte
(28 + pBt->
pPage1
->
aData
);

33806 
	`sqlite3BtreeLeave
(
p
);

33808 return 
rc
;

33809 
	}
}

33811 static int 
	$btreeCursor
(

33812 
Btree
 *
p
,

33813 int 
iTable
,

33814 int 
wrFlag
,

33815 struct 
KeyInfo
 *
pKeyInfo
,

33816 
BtCursor
 *
pCur


33820 
BtShared
 *
pBt
 = 
p
->pBt;

33821 
BtCursor
 *
pX
;

33842 if( 
wrFlag
 )

33845 
	`allocateTempSpace
(
pBt
);

33846 if( 
pBt
->
pTmpSpace
==0 ) return 7;

33848 if( 
iTable
==1 && 
	`btreePagecount
(
pBt
)==0 )

33852 
iTable
 = 0;

33857 
pCur
->
pgnoRoot
 = (
Pgno
)
iTable
;

33858 
pCur
->
iPage
 = -1;

33859 
pCur
->
pKeyInfo
 = pKeyInfo;

33860 
pCur
->
pBtree
 = 
p
;

33861 
pCur
->
pBt
 = pBt;

33862 
pCur
->
curFlags
 = 
wrFlag
 ? 0x01 : 0;

33863 
pCur
->
curPagerFlags
 = 
wrFlag
 ? 0 : 0x02;

33866 for(
pX
=
pBt
->
pCursor
; pX; pX=pX->
pNext
)

33869 if( 
pX
->
pgnoRoot
==(
Pgno
)
iTable
 )

33872 
pX
->
curFlags
 |= 0x20;

33873 
pCur
->
curFlags
 |= 0x20;

33876 
pCur
->
pNext
 = 
pBt
->
pCursor
;

33877 
pBt
->
pCursor
 = 
pCur
;

33878 
pCur
->
eState
 = 0;

33880 
	}
}

33881 static int 
	$sqlite3BtreeCursor
(

33882 
Btree
 *
p
,

33883 int 
iTable
,

33884 int 
wrFlag
,

33885 struct 
KeyInfo
 *
pKeyInfo
,

33886 
BtCursor
 *
pCur


33890 int 
rc
;

33891 if( 
iTable
<1 )

33894 
rc
 = 
	`sqlite3CorruptError
(59956);

33896 
	`sqlite3BtreeEnter
(
p
);

33897 
rc
 = 
	`btreeCursor
(
p
, 
iTable
, 
wrFlag
, 
pKeyInfo
, 
pCur
);

33898 
	`sqlite3BtreeLeave
(
p
);

33900 return 
rc
;

33901 
	}
}

33903 static int 
	$sqlite3BtreeCursorSize
(void)

33906 return (((sizeof(
BtCursor
))+7)&~7);

33907 
	}
}

33909 static void 
	$sqlite3BtreeCursorZero
(
BtCursor
 *
p
)

33912 
	`memset
(
p
, 0, 
	`__builtin_offsetof
 (
BtCursor
, 
iPage
));

33913 
	}
}

33919 static int 
	$sqlite3BtreeCloseCursor
(
BtCursor
 *
pCur
)

33922 
Btree
 *
pBtree
 = 
pCur
->pBtree;

33923 if( 
pBtree
 )

33926 int 
i
;

33927 
BtShared
 *
pBt
 = 
pCur
->pBt;

33928 
	`sqlite3BtreeEnter
(
pBtree
);

33929 
	`sqlite3BtreeClearCursor
(
pCur
);

33931 if( 
pBt
->
pCursor
==
pCur
 )

33934 
pBt
->
pCursor
 = 
pCur
->
pNext
;

33936 
BtCursor
 *
pPrev
 = 
pBt
->
pCursor
;

33938 if( 
pPrev
->
pNext
==
pCur
 )

33941 
pPrev
->
pNext
 = 
pCur
->pNext;

33944 
pPrev
 = pPrev->
pNext
;

33945 }while( (
pPrev
) );

33947 for(
i
=0; i<=
pCur
->
iPage
; i++)

33950 
	`releasePage
(
pCur
->
apPage
[
i
]);

33952 
	`unlockBtreeIfUnused
(
pBt
);

33953 
	`sqlite3_free
(
pCur
->
aOverflow
);

33955 
	`sqlite3BtreeLeave
(
pBtree
);

33958 
	}
}

33960 static 
__attribute__
((
noinline
)) void 
	$getCellInfo
(
BtCursor
 *
pCur
)

33963 if( 
pCur
->
info
.
nSize
==0 )

33966 int 
iPage
 = 
pCur
->iPage;

33967 
pCur
->
curFlags
 |= 0x02;

33968 
	`btreeParseCell
(
pCur
->
apPage
[
iPage
],pCur->
aiIdx
[iPage],&pCur->
info
);

33972 
	}
}

33974 static int 
	$sqlite3BtreeKeySize
(
BtCursor
 *
pCur
, 
i64
 *
pSize
)

33979 
	`getCellInfo
(
pCur
);

33980 *
pSize
 = 
pCur
->
info
.
nKey
;

33982 
	}
}

33984 static int 
	$sqlite3BtreeDataSize
(
BtCursor
 *
pCur
, 
u32
 *
pSize
)

33992 
	`getCellInfo
(
pCur
);

33993 *
pSize
 = 
pCur
->
info
.
nPayload
;

33995 
	}
}

33997 static int 
	$getOverflowPage
(

33998 
BtShared
 *
pBt
,

33999 
Pgno
 
ovfl
,

34000 
MemPage
 **
ppPage
,

34001 
Pgno
 *
pPgnoNext


34005 
Pgno
 
next
 = 0;

34006 
MemPage
 *
pPage
 = 0;

34007 int 
rc
 = 0;

34012 if( 
pBt
->
autoVacuum
 )

34015 
Pgno
 
pgno
;

34016 
Pgno
 
iGuess
 = 
ovfl
+1;

34017 
u8
 
eType
;

34019 while( (
	`ptrmapPageno
((
pBt
), (
iGuess
))==(iGuess)) || iGuess==((
Pgno
)((
sqlite3PendingByte
/((pBt)->
pageSize
))+1)) )

34022 
iGuess
++;

34025 if( 
iGuess
<=
	`btreePagecount
(
pBt
) )

34028 
rc
 = 
	`ptrmapGet
(
pBt
, 
iGuess
, &
eType
, &
pgno
);

34029 if( 
rc
==0 && 
eType
==4 && 
pgno
==
ovfl
 )

34032 
next
 = 
iGuess
;

34033 
rc
 = 101;

34040 if( 
rc
==0 )

34043 
rc
 = 
	`btreeGetPage
(
pBt
, 
ovfl
, &
pPage
, (
ppPage
==0) ? 0x02 : 0);

34045 if( 
rc
==0 )

34048 
next
 = 
	`sqlite3Get4byte
(
pPage
->
aData
);

34052 *
pPgnoNext
 = 
next
;

34053 if( 
ppPage
 )

34056 *
ppPage
 = 
pPage
;

34058 
	`releasePage
(
pPage
);

34060 return (
rc
==101 ? 0 : rc);

34061 
	}
}

34063 static int 
	$copyPayload
(

34064 void *
pPayload
,

34065 void *
pBuf
,

34066 int 
nByte
,

34067 int 
eOp
,

34068 
DbPage
 *
pDbPage


34072 if( 
eOp
 )

34076 int 
rc
 = 
	`sqlite3PagerWrite
(
pDbPage
);

34077 if( 
rc
!=0 )

34080 return 
rc
;

34082 
	`memcpy
(
pPayload
, 
pBuf
, 
nByte
);

34085 
	`memcpy
(
pBuf
, 
pPayload
, 
nByte
);

34088 
	}
}

34090 static int 
	$accessPayload
(

34091 
BtCursor
 *
pCur
,

34092 
u32
 
offset
,

34093 
u32
 
amt
,

34094 unsigned char *
pBuf
,

34095 int 
eOp


34099 unsigned char *
aPayload
;

34100 int 
rc
 = 0;

34101 int 
iIdx
 = 0;

34102 
MemPage
 *
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

34103 
BtShared
 *
pBt
 = 
pCur
->pBt;

34115 
	`getCellInfo
(
pCur
);

34116 
aPayload
 = 
pCur
->
info
.
pPayload
;

34123 if( (
uptr
)(
aPayload
 - 
pPage
->
aData
) > (
pBt
->
usableSize
 - 
pCur
->
info
.
nLocal
) )

34131 return 
	`sqlite3CorruptError
(60282);

34135 if( 
offset
<
pCur
->
info
.
nLocal
 )

34138 int 
a
 = 
amt
;

34139 if( 
a
+
offset
>
pCur
->
info
.
nLocal
 )

34142 
a
 = 
pCur
->
info
.
nLocal
 - 
offset
;

34144 
rc
 = 
	`copyPayload
(&
aPayload
[
offset
], 
pBuf
, 
a
, (
eOp
 & 0x01), 
pPage
->
pDbPage
);

34145 
offset
 = 0;

34146 
pBuf
 += 
a
;

34147 
amt
 -= 
a
;

34149 
offset
 -= 
pCur
->
info
.
nLocal
;

34153 if( 
rc
==0 && 
amt
>0 )

34156 const 
u32
 
ovflSize
 = 
pBt
->
usableSize
 - 4;

34157 
Pgno
 
nextPage
;

34159 
nextPage
 = 
	`sqlite3Get4byte
(&
aPayload
[
pCur
->
info
.
nLocal
]);

34161 if( 
eOp
!=2 && (
pCur
->
curFlags
 & 0x04)==0 )

34164 int 
nOvfl
 = (
pCur
->
info
.
nPayload
-pCur->info.
nLocal
+
ovflSize
-1)/ovflSize;

34165 if( 
nOvfl
>
pCur
->
nOvflAlloc
 )

34168 
Pgno
 *
aNew
 = (Pgno*)
	`sqlite3Realloc
(

34169 
pCur
->
aOverflow
, 
nOvfl
*2*sizeof(
Pgno
)

34171 if( 
aNew
==0 )

34174 
rc
 = 7;

34176 
pCur
->
nOvflAlloc
 = 
nOvfl
*2;

34177 
pCur
->
aOverflow
 = 
aNew
;

34180 if( 
rc
==0 )

34183 
	`memset
(
pCur
->
aOverflow
, 0, 
nOvfl
*sizeof(
Pgno
));

34184 
pCur
->
curFlags
 |= 0x04;

34192 if( (
pCur
->
curFlags
 & 0x04)!=0

34193 && 
pCur
->
aOverflow
[
offset
/
ovflSize
]

34197 
iIdx
 = (
offset
/
ovflSize
);

34198 
nextPage
 = 
pCur
->
aOverflow
[
iIdx
];

34199 
offset
 = (offset%
ovflSize
);

34202 for( ; 
rc
==0 && 
amt
>0 && 
nextPage
; 
iIdx
++)

34207 if( (
pCur
->
curFlags
 & 0x04)!=0 )

34213 
pCur
->
aOverflow
[
iIdx
] = 
nextPage
;

34216 if( 
offset
>=
ovflSize
 )

34223 if( 
pCur
->
aOverflow
[
iIdx
+1] )

34226 
nextPage
 = 
pCur
->
aOverflow
[
iIdx
+1];

34228 
rc
 = 
	`getOverflowPage
(
pBt
, 
nextPage
, 0, &nextPage);

34230 
offset
 -= 
ovflSize
;

34238 int 
a
 = 
amt
;

34239 if( 
a
 + 
offset
 > 
ovflSize
 )

34242 
a
 = 
ovflSize
 - 
offset
;

34246 
DbPage
 *
pDbPage
;

34247 
rc
 = 
	`sqlite3PagerGet
(
pBt
->
pPager
, 
nextPage
, &
pDbPage
,

34248 ((
eOp
&0x01)==0 ? 0x02 : 0)

34250 if( 
rc
==0 )

34253 
aPayload
 = 
	`sqlite3PagerGetData
(
pDbPage
);

34254 
nextPage
 = 
	`sqlite3Get4byte
(
aPayload
);

34255 
rc
 = 
	`copyPayload
(&
aPayload
[
offset
+4], 
pBuf
, 
a
, (
eOp
&0x01), 
pDbPage
);

34256 
	`sqlite3PagerUnref
(
pDbPage
);

34257 
offset
 = 0;

34260 
amt
 -= 
a
;

34261 
pBuf
 += 
a
;

34266 if( 
rc
==0 && 
amt
>0 )

34269 return 
	`sqlite3CorruptError
(60439);

34271 return 
rc
;

34272 
	}
}

34274 static int 
	$sqlite3BtreeKey
(
BtCursor
 *
pCur
, 
u32
 
offset
, u32 
amt
, void *
pBuf
)

34281 return 
	`accessPayload
(
pCur
, 
offset
, 
amt
, (unsigned char*)
pBuf
, 0);

34282 
	}
}

34284 static int 
	$sqlite3BtreeData
(
BtCursor
 *
pCur
, 
u32
 
offset
, u32 
amt
, void *
pBuf
)

34287 int 
rc
;

34290 if ( 
pCur
->
eState
==0 )

34298 
rc
 = (
pCur
->
eState
>=3 ? 
	`btreeRestoreCursorPosition
(pCur) : 0);

34299 if( 
rc
==0 )

34305 
rc
 = 
	`accessPayload
(
pCur
, 
offset
, 
amt
, 
pBuf
, 0);

34307 return 
rc
;

34308 
	}
}

34310 static const void *
	$fetchPayload
(

34311 
BtCursor
 *
pCur
,

34312 
u32
 *
pAmt


34316 
u32
 
amt
;

34325 
amt
 = (int)(
pCur
->
apPage
[pCur->
iPage
]->
aDataEnd
 - pCur->
info
.
pPayload
);

34326 if( 
pCur
->
info
.
nLocal
<
amt
 ) amt = pCur->info.nLocal;

34327 *
pAmt
 = 
amt
;

34328 return (void*)
pCur
->
info
.
pPayload
;

34329 
	}
}

34331 static const void *
	$sqlite3BtreeKeyFetch
(
BtCursor
 *
pCur
, 
u32
 *
pAmt
)

34334 return 
	`fetchPayload
(
pCur
, 
pAmt
);

34335 
	}
}

34336 static const void *
	$sqlite3BtreeDataFetch
(
BtCursor
 *
pCur
, 
u32
 *
pAmt
)

34339 return 
	`fetchPayload
(
pCur
, 
pAmt
);

34340 
	}
}

34342 static int 
	$moveToChild
(
BtCursor
 *
pCur
, 
u32
 
newPgno
)

34345 
BtShared
 *
pBt
 = 
pCur
->pBt;

34351 if( 
pCur
->
iPage
>=(20 -1) )

34354 return 
	`sqlite3CorruptError
(60571);

34356 
pCur
->
info
.
nSize
 = 0;

34357 
pCur
->
curFlags
 &= ~(0x02|0x04);

34358 
pCur
->
iPage
++;

34359 
pCur
->
aiIdx
[pCur->
iPage
] = 0;

34360 return 
	`getAndInitPage
(
pBt
, 
newPgno
, &
pCur
->
apPage
[pCur->
iPage
],

34361 
pCur
, pCur->
curPagerFlags
);

34362 
	}
}

34364 static void 
	$moveToParent
(
BtCursor
 *
pCur
)

34377 
pCur
->
info
.
nSize
 = 0;

34378 
pCur
->
curFlags
 &= ~(0x02|0x04);

34379 
	`releasePageNotNull
(
pCur
->
apPage
[pCur->
iPage
--]);

34380 
	}
}

34382 static int 
	$moveToRoot
(
BtCursor
 *
pCur
)

34385 
MemPage
 *
pRoot
;

34386 int 
rc
 = 0;

34392 if( 
pCur
->
eState
>=3 )

34395 if( 
pCur
->
eState
==4 )

34399 return 
pCur
->
skipNext
;

34401 
	`sqlite3BtreeClearCursor
(
pCur
);

34404 if( 
pCur
->
iPage
>=0 )

34407 while( 
pCur
->
iPage
 )

34411 
	`releasePageNotNull
(
pCur
->
apPage
[pCur->
iPage
--]);

34413 }else if( 
pCur
->
pgnoRoot
==0 )

34416 
pCur
->
eState
 = 0;

34420 
rc
 = 
	`getAndInitPage
(
pCur
->
pBtree
->
pBt
, pCur->
pgnoRoot
, &pCur->
apPage
[0],

34421 0, 
pCur
->
curPagerFlags
);

34422 if( 
rc
!=0 )

34425 
pCur
->
eState
 = 0;

34426 return 
rc
;

34428 
pCur
->
iPage
 = 0;

34429 
pCur
->
curIntKey
 = pCur->
apPage
[0]->
intKey
;

34431 
pRoot
 = 
pCur
->
apPage
[0];

34435 if( 
pRoot
->
isInit
==0 || (
pCur
->
pKeyInfo
==0)!=pRoot->
intKey
 )

34438 return 
	`sqlite3CorruptError
(60698);

34441 
pCur
->
aiIdx
[0] = 0;

34442 
pCur
->
info
.
nSize
 = 0;

34443 
pCur
->
curFlags
 &= ~(0x08|0x02|0x04);

34445 if( 
pRoot
->
nCell
>0 )

34448 
pCur
->
eState
 = 1;

34449 }else if( !
pRoot
->
leaf
 )

34452 
Pgno
 
subpage
;

34453 if( 
pRoot
->
pgno
!=1 ) return 
	`sqlite3CorruptError
(60709);

34454 
subpage
 = 
	`sqlite3Get4byte
(&
pRoot
->
aData
[pRoot->
hdrOffset
+8]);

34455 
pCur
->
eState
 = 1;

34456 
rc
 = 
	`moveToChild
(
pCur
, 
subpage
);

34458 
pCur
->
eState
 = 0;

34460 return 
rc
;

34461 
	}
}

34463 static int 
	$moveToLeftmost
(
BtCursor
 *
pCur
)

34466 
Pgno
 
pgno
;

34467 int 
rc
 = 0;

34468 
MemPage
 *
pPage
;

34472 while( 
rc
==0 && !(
pPage
 = 
pCur
->
apPage
[pCur->
iPage
])->
leaf
 )

34476 
pgno
 = 
	`sqlite3Get4byte
(((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
pCur
->
aiIdx
[pCur->
iPage
])])))));

34477 
rc
 = 
	`moveToChild
(
pCur
, 
pgno
);

34479 return 
rc
;

34480 
	}
}

34482 static int 
	$moveToRightmost
(
BtCursor
 *
pCur
)

34485 
Pgno
 
pgno
;

34486 int 
rc
 = 0;

34487 
MemPage
 *
pPage
 = 0;

34491 while( !(
pPage
 = 
pCur
->
apPage
[pCur->
iPage
])->
leaf
 )

34494 
pgno
 = 
	`sqlite3Get4byte
(&
pPage
->
aData
[pPage->
hdrOffset
+8]);

34495 
pCur
->
aiIdx
[pCur->
iPage
] = 
pPage
->
nCell
;

34496 
rc
 = 
	`moveToChild
(
pCur
, 
pgno
);

34497 if( 
rc
 ) return rc;

34499 
pCur
->
aiIdx
[pCur->
iPage
] = 
pPage
->
nCell
-1;

34503 
	}
}

34509 static int 
	$sqlite3BtreeFirst
(
BtCursor
 *
pCur
, int *
pRes
)

34512 int 
rc
;

34516 
rc
 = 
	`moveToRoot
(
pCur
);

34517 if( 
rc
==0 )

34520 if( 
pCur
->
eState
==0 )

34524 *
pRes
 = 1;

34527 *
pRes
 = 0;

34528 
rc
 = 
	`moveToLeftmost
(
pCur
);

34531 return 
rc
;

34532 
	}
}

34538 static int 
	$sqlite3BtreeLast
(
BtCursor
 *
pCur
, int *
pRes
)

34541 int 
rc
;

34547 if( 1==
pCur
->
eState
 && (pCur->
curFlags
 & 0x08)!=0 )

34554 
rc
 = 
	`moveToRoot
(
pCur
);

34555 if( 
rc
==0 )

34558 if( 0==
pCur
->
eState
 )

34562 *
pRes
 = 1;

34565 *
pRes
 = 0;

34566 
rc
 = 
	`moveToRightmost
(
pCur
);

34567 if( 
rc
==0 )

34570 
pCur
->
curFlags
 |= 0x08;

34572 
pCur
->
curFlags
 &= ~0x08;

34577 return 
rc
;

34578 
	}
}

34580 static int 
	$sqlite3BtreeMovetoUnpacked
(

34581 
BtCursor
 *
pCur
,

34582 
UnpackedRecord
 *
pIdxKey
,

34583 
i64
 
intKey
,

34584 int 
biasRight
,

34585 int *
pRes


34589 int 
rc
;

34590 
RecordCompare
 
xRecordCompare
;

34599 if( 
pCur
->
eState
==1 && (pCur->
curFlags
 & 0x02)!=0

34600 && 
pCur
->
curIntKey


34604 if( 
pCur
->
info
.
nKey
==
intKey
 )

34607 *
pRes
 = 0;

34610 if( (
pCur
->
curFlags
 & 0x08)!=0 && pCur->
info
.
nKey
<
intKey
 )

34613 *
pRes
 = -1;

34618 if( 
pIdxKey
 )

34621 
xRecordCompare
 = 
	`sqlite3VdbeFindCompare
(
pIdxKey
);

34622 
pIdxKey
->
errCode
 = 0;

34628 
xRecordCompare
 = 0;

34631 
rc
 = 
	`moveToRoot
(
pCur
);

34632 if( 
rc
 )

34635 return 
rc
;

34640 if( 
pCur
->
eState
==0 )

34643 *
pRes
 = -1;

34652 int 
lwr
, 
upr
, 
idx
, 
c
;

34653 
Pgno
 
chldPg
;

34654 
MemPage
 *
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

34655 
u8
 *
pCell
;

34665 
lwr
 = 0;

34666 
upr
 = 
pPage
->
nCell
-1;

34668 
idx
 = 
upr
>>(1-
biasRight
);

34669 
pCur
->
aiIdx
[pCur->
iPage
] = (
u16
)
idx
;

34670 if( 
xRecordCompare
==0 )

34676 
i64
 
nCellKey
;

34677 
pCell
 = ((
pPage
)->
aDataOfst
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
idx
)]))));

34678 if( 
pPage
->
intKeyLeaf
 )

34681 while( 0x80 <= *(
pCell
++) )

34684 if( 
pCell
>=
pPage
->
aDataEnd
 ) return 
	`sqlite3CorruptError
(60948);

34687 
	`sqlite3GetVarint
(
pCell
, (
u64
*)&
nCellKey
);

34688 if( 
nCellKey
<
intKey
 )

34691 
lwr
 = 
idx
+1;

34692 if( 
lwr
>
upr
 )

34694 
c
 = -1; break; }

34695 }else if( 
nCellKey
>
intKey
 )

34698 
upr
 = 
idx
-1;

34699 if( 
lwr
>
upr
 )

34701 
c
 = +1; break; }

34704 
pCur
->
curFlags
 |= 0x02;

34705 
pCur
->
info
.
nKey
 = 
nCellKey
;

34706 
pCur
->
aiIdx
[pCur->
iPage
] = (
u16
)
idx
;

34707 if( !
pPage
->
leaf
 )

34710 
lwr
 = 
idx
;

34711 goto 
moveto_next_layer
;

34713 *
pRes
 = 0;

34714 
rc
 = 0;

34715 goto 
moveto_finish
;

34719 
idx
 = (
lwr
+
upr
)>>1;

34725 int 
nCell
;

34726 
pCell
 = ((
pPage
)->
aDataOfst
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
idx
)]))));

34728 
nCell
 = 
pCell
[0];

34729 if( 
nCell
<=
pPage
->
max1bytePayload
 )

34736 
c
 = 
	`xRecordCompare
(
nCell
, (void*)&
pCell
[1], 
pIdxKey
);

34737 }else if( !(
pCell
[1] & 0x80)

34738 && (
nCell
 = ((nCell&0x7f)<<7) + 
pCell
[1])<=
pPage
->
maxLocal


34745 
c
 = 
	`xRecordCompare
(
nCell
, (void*)&
pCell
[2], 
pIdxKey
);

34748 void *
pCellKey
;

34749 
u8
 * const 
pCellBody
 = 
pCell
 - 
pPage
->
childPtrSize
;

34750 
pPage
->
	`xParseCell
(pPage, 
pCellBody
, &
pCur
->
info
);

34751 
nCell
 = (int)
pCur
->
info
.
nKey
;

34756 if( 
nCell
<2 )

34759 
rc
 = 
	`sqlite3CorruptError
(61021);

34760 goto 
moveto_finish
;

34762 
pCellKey
 = 
	`sqlite3Malloc
( 
nCell
+18 );

34763 if( 
pCellKey
==0 )

34766 
rc
 = 7;

34767 goto 
moveto_finish
;

34769 
pCur
->
aiIdx
[pCur->
iPage
] = (
u16
)
idx
;

34770 
rc
 = 
	`accessPayload
(
pCur
, 0, 
nCell
, (unsigned char*)
pCellKey
, 2);

34771 if( 
rc
 )

34774 
	`sqlite3_free
(
pCellKey
);

34775 goto 
moveto_finish
;

34777 
c
 = 
	`xRecordCompare
(
nCell
, 
pCellKey
, 
pIdxKey
);

34778 
	`sqlite3_free
(
pCellKey
);

34784 if( 
c
<0 )

34787 
lwr
 = 
idx
+1;

34788 }else if( 
c
>0 )

34791 
upr
 = 
idx
-1;

34794 *
pRes
 = 0;

34795 
rc
 = 0;

34796 
pCur
->
aiIdx
[pCur->
iPage
] = (
u16
)
idx
;

34797 if( 
pIdxKey
->
errCode
 ) 
rc
 = 11;

34798 goto 
moveto_finish
;

34800 if( 
lwr
>
upr
 ) break;

34802 
idx
 = (
lwr
+
upr
)>>1;

34807 if( 
pPage
->
leaf
 )

34811 
pCur
->
aiIdx
[pCur->
iPage
] = (
u16
)
idx
;

34812 *
pRes
 = 
c
;

34813 
rc
 = 0;

34814 goto 
moveto_finish
;

34816 
moveto_next_layer
:

34817 if( 
lwr
>=
pPage
->
nCell
 )

34820 
chldPg
 = 
	`sqlite3Get4byte
(&
pPage
->
aData
[pPage->
hdrOffset
+8]);

34822 
chldPg
 = 
	`sqlite3Get4byte
(((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
lwr
)])))));

34824 
pCur
->
aiIdx
[pCur->
iPage
] = (
u16
)
lwr
;

34825 
rc
 = 
	`moveToChild
(
pCur
, 
chldPg
);

34826 if( 
rc
 ) break;

34828 
moveto_finish
:

34829 
pCur
->
info
.
nSize
 = 0;

34830 
pCur
->
curFlags
 &= ~(0x02|0x04);

34831 return 
rc
;

34832 
	}
}

34834 static int 
	$sqlite3BtreeEof
(
BtCursor
 *
pCur
)

34841 return (1!=
pCur
->
eState
);

34842 
	}
}

34844 static 
__attribute__
((
noinline
)) int 
	$btreeNext
(
BtCursor
 *
pCur
, int *
pRes
)

34847 int 
rc
;

34848 int 
idx
;

34849 
MemPage
 *
pPage
;

34854 if( 
pCur
->
eState
!=1 )

34858 
rc
 = (
pCur
->
eState
>=3 ? 
	`btreeRestoreCursorPosition
(pCur) : 0);

34859 if( 
rc
!=0 )

34862 return 
rc
;

34864 if( 0==
pCur
->
eState
 )

34867 *
pRes
 = 1;

34870 if( 
pCur
->
skipNext
 )

34874 
pCur
->
eState
 = 1;

34875 if( 
pCur
->
skipNext
>0 )

34878 
pCur
->
skipNext
 = 0;

34881 
pCur
->
skipNext
 = 0;

34885 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

34886 
idx
 = ++
pCur
->
aiIdx
[pCur->
iPage
];

34896 if( 
idx
>=
pPage
->
nCell
 )

34899 if( !
pPage
->
leaf
 )

34902 
rc
 = 
	`moveToChild
(
pCur
, 
	`sqlite3Get4byte
(&
pPage
->
aData
[pPage->
hdrOffset
+8]));

34903 if( 
rc
 ) return rc;

34904 return 
	`moveToLeftmost
(
pCur
);

34907 if( 
pCur
->
iPage
==0 )

34910 *
pRes
 = 1;

34911 
pCur
->
eState
 = 0;

34914 
	`moveToParent
(
pCur
);

34915 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

34916 }while( 
pCur
->
aiIdx
[pCur->
iPage
]>=
pPage
->
nCell
 );

34917 if( 
pPage
->
intKey
 )

34920 return 
	`sqlite3BtreeNext
(
pCur
, 
pRes
);

34925 if( 
pPage
->
leaf
 )

34930 return 
	`moveToLeftmost
(
pCur
);

34932 
	}
}

34933 static int 
	$sqlite3BtreeNext
(
BtCursor
 *
pCur
, int *
pRes
)

34936 
MemPage
 *
pPage
;

34941 
pCur
->
info
.
nSize
 = 0;

34942 
pCur
->
curFlags
 &= ~(0x02|0x04);

34943 *
pRes
 = 0;

34944 if( 
pCur
->
eState
!=1 ) return 
	`btreeNext
(pCur, 
pRes
);

34945 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

34946 if( (++
pCur
->
aiIdx
[pCur->
iPage
])>=
pPage
->
nCell
 )

34949 
pCur
->
aiIdx
[pCur->
iPage
]--;

34950 return 
	`btreeNext
(
pCur
, 
pRes
);

34952 if( 
pPage
->
leaf
 )

34957 return 
	`moveToLeftmost
(
pCur
);

34959 
	}
}

34961 static 
__attribute__
((
noinline
)) int 
	$btreePrevious
(
BtCursor
 *
pCur
, int *
pRes
)

34964 int 
rc
;

34965 
MemPage
 *
pPage
;

34973 if( 
pCur
->
eState
!=1 )

34976 
rc
 = (
pCur
->
eState
>=3 ? 
	`btreeRestoreCursorPosition
(pCur) : 0);

34977 if( 
rc
!=0 )

34980 return 
rc
;

34982 if( 0==
pCur
->
eState
 )

34985 *
pRes
 = 1;

34988 if( 
pCur
->
skipNext
 )

34992 
pCur
->
eState
 = 1;

34993 if( 
pCur
->
skipNext
<0 )

34996 
pCur
->
skipNext
 = 0;

34999 
pCur
->
skipNext
 = 0;

35003 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

35005 if( !
pPage
->
leaf
 )

35008 int 
idx
 = 
pCur
->
aiIdx
[pCur->
iPage
];

35009 
rc
 = 
	`moveToChild
(
pCur
, 
	`sqlite3Get4byte
(((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
idx
)]))))));

35010 if( 
rc
 ) return rc;

35011 
rc
 = 
	`moveToRightmost
(
pCur
);

35013 while( 
pCur
->
aiIdx
[pCur->
iPage
]==0 )

35016 if( 
pCur
->
iPage
==0 )

35019 
pCur
->
eState
 = 0;

35020 *
pRes
 = 1;

35023 
	`moveToParent
(
pCur
);

35028 
pCur
->
aiIdx
[pCur->
iPage
]--;

35029 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

35030 if( 
pPage
->
intKey
 && !pPage->
leaf
 )

35033 
rc
 = 
	`sqlite3BtreePrevious
(
pCur
, 
pRes
);

35035 
rc
 = 0;

35038 return 
rc
;

35039 
	}
}

35040 static int 
	$sqlite3BtreePrevious
(
BtCursor
 *
pCur
, int *
pRes
)

35047 *
pRes
 = 0;

35048 
pCur
->
curFlags
 &= ~(0x08|0x04|0x02);

35049 
pCur
->
info
.
nSize
 = 0;

35050 if( 
pCur
->
eState
!=1

35051 || 
pCur
->
aiIdx
[pCur->
iPage
]==0

35052 || 
pCur
->
apPage
[pCur->
iPage
]->
leaf
==0

35056 return 
	`btreePrevious
(
pCur
, 
pRes
);

35058 
pCur
->
aiIdx
[pCur->
iPage
]--;

35060 
	}
}

35062 static int 
	$allocateBtreePage
(

35063 
BtShared
 *
pBt
,

35064 
MemPage
 **
ppPage
,

35065 
Pgno
 *
pPgno
,

35066 
Pgno
 
nearby
,

35067 
u8
 
eMode


35071 
MemPage
 *
pPage1
;

35072 int 
rc
;

35073 
u32
 
n
;

35074 
u32
 
k
;

35075 
MemPage
 *
pTrunk
 = 0;

35076 
MemPage
 *
pPrevTrunk
 = 0;

35077 
Pgno
 
mxPage
;

35081 
pPage1
 = 
pBt
->pPage1;

35082 
mxPage
 = 
	`btreePagecount
(
pBt
);

35085 
n
 = 
	`sqlite3Get4byte
(&
pPage1
->
aData
[36]);

35087 if( 
n
>=
mxPage
 )

35090 return 
	`sqlite3CorruptError
(61354);

35092 if( 
n
>0 )

35096 
Pgno
 
iTrunk
;

35097 
u8
 
searchList
 = 0;

35098 
u32
 
nSearch
 = 0;

35105 if( 
eMode
==1 )

35108 if( 
nearby
<=
mxPage
 )

35111 
u8
 
eType
;

35114 
rc
 = 
	`ptrmapGet
(
pBt
, 
nearby
, &
eType
, 0);

35115 if( 
rc
 ) return rc;

35116 if( 
eType
==2 )

35119 
searchList
 = 1;

35122 }else if( 
eMode
==2 )

35125 
searchList
 = 1;

35132 
rc
 = 
	`sqlite3PagerWrite
(
pPage1
->
pDbPage
);

35133 if( 
rc
 ) return rc;

35134 
	`sqlite3Put4byte
(&
pPage1
->
aData
[36], 
n
-1);

35142 
pPrevTrunk
 = 
pTrunk
;

35143 if( 
pPrevTrunk
 )

35149 
iTrunk
 = 
	`sqlite3Get4byte
(&
pPrevTrunk
->
aData
[0]);

35154 
iTrunk
 = 
	`sqlite3Get4byte
(&
pPage1
->
aData
[32]);

35157 if( 
iTrunk
>
mxPage
 || 
nSearch
++ > 
n
 )

35160 
rc
 = 
	`sqlite3CorruptError
(61410);

35162 
rc
 = 
	`btreeGetUnusedPage
(
pBt
, 
iTrunk
, &
pTrunk
, 0);

35164 if( 
rc
 )

35167 
pTrunk
 = 0;

35168 goto 
end_allocate_page
;

35174 
k
 = 
	`sqlite3Get4byte
(&
pTrunk
->
aData
[4]);

35175 if( 
k
==0 && !
searchList
 )

35182 
rc
 = 
	`sqlite3PagerWrite
(
pTrunk
->
pDbPage
);

35183 if( 
rc
 )

35186 goto 
end_allocate_page
;

35188 *
pPgno
 = 
iTrunk
;

35189 
	`memcpy
(&
pPage1
->
aData
[32], &
pTrunk
->aData[0], 4);

35190 *
ppPage
 = 
pTrunk
;

35191 
pTrunk
 = 0;

35193 }else if( 
k
>(
u32
)(
pBt
->
usableSize
/4 - 2) )

35197 
rc
 = 
	`sqlite3CorruptError
(61439);

35198 goto 
end_allocate_page
;

35200 }else if( 
searchList


35201 && (
nearby
==
iTrunk
 || (iTrunk<nearby && 
eMode
==2))

35208 *
pPgno
 = 
iTrunk
;

35209 *
ppPage
 = 
pTrunk
;

35210 
searchList
 = 0;

35211 
rc
 = 
	`sqlite3PagerWrite
(
pTrunk
->
pDbPage
);

35212 if( 
rc
 )

35215 goto 
end_allocate_page
;

35217 if( 
k
==0 )

35220 if( !
pPrevTrunk
 )

35223 
	`memcpy
(&
pPage1
->
aData
[32], &
pTrunk
->aData[0], 4);

35225 
rc
 = 
	`sqlite3PagerWrite
(
pPrevTrunk
->
pDbPage
);

35226 if( 
rc
!=0 )

35229 goto 
end_allocate_page
;

35231 
	`memcpy
(&
pPrevTrunk
->
aData
[0], &
pTrunk
->aData[0], 4);

35238 
MemPage
 *
pNewTrunk
;

35239 
Pgno
 
iNewTrunk
 = 
	`sqlite3Get4byte
(&
pTrunk
->
aData
[8]);

35240 if( 
iNewTrunk
>
mxPage
 )

35243 
rc
 = 
	`sqlite3CorruptError
(61473);

35244 goto 
end_allocate_page
;

35247 
rc
 = 
	`btreeGetUnusedPage
(
pBt
, 
iNewTrunk
, &
pNewTrunk
, 0);

35248 if( 
rc
!=0 )

35251 goto 
end_allocate_page
;

35253 
rc
 = 
	`sqlite3PagerWrite
(
pNewTrunk
->
pDbPage
);

35254 if( 
rc
!=0 )

35257 
	`releasePage
(
pNewTrunk
);

35258 goto 
end_allocate_page
;

35260 
	`memcpy
(&
pNewTrunk
->
aData
[0], &
pTrunk
->aData[0], 4);

35261 
	`sqlite3Put4byte
(&
pNewTrunk
->
aData
[4], 
k
-1);

35262 
	`memcpy
(&
pNewTrunk
->
aData
[8], &
pTrunk
->aData[12], (
k
-1)*4);

35263 
	`releasePage
(
pNewTrunk
);

35264 if( !
pPrevTrunk
 )

35268 
	`sqlite3Put4byte
(&
pPage1
->
aData
[32], 
iNewTrunk
);

35270 
rc
 = 
	`sqlite3PagerWrite
(
pPrevTrunk
->
pDbPage
);

35271 if( 
rc
 )

35274 goto 
end_allocate_page
;

35276 
	`sqlite3Put4byte
(&
pPrevTrunk
->
aData
[0], 
iNewTrunk
);

35279 
pTrunk
 = 0;

35282 }else if( 
k
>0 )

35286 
u32
 
closest
;

35287 
Pgno
 
iPage
;

35288 unsigned char *
aData
 = 
pTrunk
->aData;

35289 if( 
nearby
>0 )

35292 
u32
 
i
;

35293 
closest
 = 0;

35294 if( 
eMode
==2 )

35297 for(
i
=0; i<
k
; i++)

35300 
iPage
 = 
	`sqlite3Get4byte
(&
aData
[8+
i
*4]);

35301 if( 
iPage
<=
nearby
 )

35304 
closest
 = 
i
;

35309 int 
dist
;

35310 
dist
 = 
	`sqlite3AbsInt32
(
	`sqlite3Get4byte
(&
aData
[8]) - 
nearby
);

35311 for(
i
=1; i<
k
; i++)

35314 int 
d2
 = 
	`sqlite3AbsInt32
(
	`sqlite3Get4byte
(&
aData
[8+
i
*4]) - 
nearby
);

35315 if( 
d2
<
dist
 )

35318 
closest
 = 
i
;

35319 
dist
 = 
d2
;

35324 
closest
 = 0;

35327 
iPage
 = 
	`sqlite3Get4byte
(&
aData
[8+
closest
*4]);

35329 if( 
iPage
>
mxPage
 )

35332 
rc
 = 
	`sqlite3CorruptError
(61538);

35333 goto 
end_allocate_page
;

35336 if( !
searchList


35337 || (
iPage
==
nearby
 || (iPage<nearby && 
eMode
==2))

35341 int 
noContent
;

35342 *
pPgno
 = 
iPage
;

35346 
rc
 = 
	`sqlite3PagerWrite
(
pTrunk
->
pDbPage
);

35347 if( 
rc
 ) goto 
end_allocate_page
;

35348 if( 
closest
<
k
-1 )

35351 
	`memcpy
(&
aData
[8+
closest
*4], &aData[4+
k
*4], 4);

35353 
	`sqlite3Put4byte
(&
aData
[4], 
k
-1);

35354 
noContent
 = !
	`btreeGetHasContent
(
pBt
, *
pPgno
)? 0x01 : 0;

35355 
rc
 = 
	`btreeGetUnusedPage
(
pBt
, *
pPgno
, 
ppPage
, 
noContent
);

35356 if( 
rc
==0 )

35359 
rc
 = 
	`sqlite3PagerWrite
((*
ppPage
)->
pDbPage
);

35360 if( 
rc
!=0 )

35363 
	`releasePage
(*
ppPage
);

35364 *
ppPage
 = 0;

35367 
searchList
 = 0;

35370 
	`releasePage
(
pPrevTrunk
);

35371 
pPrevTrunk
 = 0;

35372 }while( 
searchList
 );

35375 int 
bNoContent
 = (0==(
pBt
->
bDoTruncate
))? 0x01:0;

35377 
rc
 = 
	`sqlite3PagerWrite
(
pBt
->
pPage1
->
pDbPage
);

35378 if( 
rc
 ) return rc;

35379 
pBt
->
nPage
++;

35380 if( 
pBt
->
nPage
==((
Pgno
)((
sqlite3PendingByte
/((pBt)->
pageSize
))+1)) ) pBt->nPage++;

35383 if( 
pBt
->
autoVacuum
 && (
	`ptrmapPageno
((pBt), (pBt->
nPage
))==(pBt->nPage)) )

35390 
MemPage
 *
pPg
 = 0;

35393 
rc
 = 
	`btreeGetUnusedPage
(
pBt
, pBt->
nPage
, &
pPg
, 
bNoContent
);

35394 if( 
rc
==0 )

35397 
rc
 = 
	`sqlite3PagerWrite
(
pPg
->
pDbPage
);

35398 
	`releasePage
(
pPg
);

35400 if( 
rc
 ) return rc;

35401 
pBt
->
nPage
++;

35402 if( 
pBt
->
nPage
==((
Pgno
)((
sqlite3PendingByte
/((pBt)->
pageSize
))+1)) )

35404 
pBt
->
nPage
++; }

35407 
	`sqlite3Put4byte
(28 + (
u8
*)
pBt
->
pPage1
->
aData
, pBt->
nPage
);

35408 *
pPgno
 = 
pBt
->
nPage
;

35411 
rc
 = 
	`btreeGetUnusedPage
(
pBt
, *
pPgno
, 
ppPage
, 
bNoContent
);

35412 if( 
rc
 ) return rc;

35413 
rc
 = 
	`sqlite3PagerWrite
((*
ppPage
)->
pDbPage
);

35414 if( 
rc
!=0 )

35417 
	`releasePage
(*
ppPage
);

35418 *
ppPage
 = 0;

35425 
end_allocate_page
:

35426 
	`releasePage
(
pTrunk
);

35427 
	`releasePage
(
pPrevTrunk
);

35430 return 
rc
;

35431 
	}
}

35433 static int 
	$freePage2
(
BtShared
 *
pBt
, 
MemPage
 *
pMemPage
, 
Pgno
 
iPage
)

35436 
MemPage
 *
pTrunk
 = 0;

35437 
Pgno
 
iTrunk
 = 0;

35438 
MemPage
 *
pPage1
 = 
pBt
->pPage1;

35439 
MemPage
 *
pPage
;

35440 int 
rc
;

35441 int 
nFree
;

35447 if( 
iPage
<2 ) return 
	`sqlite3CorruptError
(61664);

35448 if( 
pMemPage
 )

35451 
pPage
 = 
pMemPage
;

35452 
	`sqlite3PagerRef
(
pPage
->
pDbPage
);

35454 
pPage
 = 
	`btreePageLookup
(
pBt
, 
iPage
);

35458 
rc
 = 
	`sqlite3PagerWrite
(
pPage1
->
pDbPage
);

35459 if( 
rc
 ) goto 
freepage_out
;

35460 
nFree
 = 
	`sqlite3Get4byte
(&
pPage1
->
aData
[36]);

35461 
	`sqlite3Put4byte
(&
pPage1
->
aData
[36], 
nFree
+1);

35463 if( 
pBt
->
btsFlags
 & 0x0004 )

35469 if( (!
pPage
 && ((
rc
 = 
	`btreeGetPage
(
pBt
, 
iPage
, &pPage, 0))!=0) )

35470 || ((
rc
 = 
	`sqlite3PagerWrite
(
pPage
->
pDbPage
))!=0)

35474 goto 
freepage_out
;

35476 
	`memset
(
pPage
->
aData
, 0, pPage->
pBt
->
pageSize
);

35482 if( (
pBt
->
autoVacuum
) )

35485 
	`ptrmapPut
(
pBt
, 
iPage
, 2, 0, &
rc
);

35486 if( 
rc
 ) goto 
freepage_out
;

35489 if( 
nFree
!=0 )

35492 
u32
 
nLeaf
;

35494 
iTrunk
 = 
	`sqlite3Get4byte
(&
pPage1
->
aData
[32]);

35495 
rc
 = 
	`btreeGetPage
(
pBt
, 
iTrunk
, &
pTrunk
, 0);

35496 if( 
rc
!=0 )

35499 goto 
freepage_out
;

35502 
nLeaf
 = 
	`sqlite3Get4byte
(&
pTrunk
->
aData
[4]);

35504 if( 
nLeaf
 > (
u32
)
pBt
->
usableSize
/4 - 2 )

35507 
rc
 = 
	`sqlite3CorruptError
(61717);

35508 goto 
freepage_out
;

35510 if( 
nLeaf
 < (
u32
)
pBt
->
usableSize
/4 - 8 )

35514 
rc
 = 
	`sqlite3PagerWrite
(
pTrunk
->
pDbPage
);

35515 if( 
rc
==0 )

35518 
	`sqlite3Put4byte
(&
pTrunk
->
aData
[4], 
nLeaf
+1);

35519 
	`sqlite3Put4byte
(&
pTrunk
->
aData
[8+
nLeaf
*4], 
iPage
);

35520 if( 
pPage
 && (
pBt
->
btsFlags
 & 0x0004)==0 )

35523 
	`sqlite3PagerDontWrite
(
pPage
->
pDbPage
);

35525 
rc
 = 
	`btreeSetHasContent
(
pBt
, 
iPage
);

35528 goto 
freepage_out
;

35538 if( 
pPage
==0 && 0!=(
rc
 = 
	`btreeGetPage
(
pBt
, 
iPage
, &pPage, 0)) )

35541 goto 
freepage_out
;

35543 
rc
 = 
	`sqlite3PagerWrite
(
pPage
->
pDbPage
);

35544 if( 
rc
!=0 )

35547 goto 
freepage_out
;

35549 
	`sqlite3Put4byte
(
pPage
->
aData
, 
iTrunk
);

35550 
	`sqlite3Put4byte
(&
pPage
->
aData
[4], 0);

35551 
	`sqlite3Put4byte
(&
pPage1
->
aData
[32], 
iPage
);

35554 
freepage_out
:

35555 if( 
pPage
 )

35558 
pPage
->
isInit
 = 0;

35560 
	`releasePage
(
pPage
);

35561 
	`releasePage
(
pTrunk
);

35562 return 
rc
;

35563 
	}
}

35564 static void 
	$freePage
(
MemPage
 *
pPage
, int *
pRC
)

35567 if( (*
pRC
)==0 )

35570 *
pRC
 = 
	`freePage2
(
pPage
->
pBt
, pPage, pPage->
pgno
);

35572 
	}
}

35579 static int 
	$clearCell
(

35580 
MemPage
 *
pPage
,

35581 unsigned char *
pCell
,

35582 
u16
 *
pnSize


35586 
BtShared
 *
pBt
 = 
pPage
->pBt;

35587 
CellInfo
 
info
;

35588 
Pgno
 
ovflPgno
;

35589 int 
rc
;

35590 int 
nOvfl
;

35591 
u32
 
ovflPageSize
;

35594 
pPage
->
	`xParseCell
(pPage, 
pCell
, &
info
);

35595 *
pnSize
 = 
info
.
nSize
;

35596 if( 
info
.
nLocal
==info.
nPayload
 )

35601 if( 
pCell
+
info
.
nSize
-1 > 
pPage
->
aData
+pPage->
maskPage
 )

35604 return 
	`sqlite3CorruptError
(61810);

35606 
ovflPgno
 = 
	`sqlite3Get4byte
(
pCell
 + 
info
.
nSize
 - 4);

35608 
ovflPageSize
 = 
pBt
->
usableSize
 - 4;

35609 
nOvfl
 = (
info
.
nPayload
 - info.
nLocal
 + 
ovflPageSize
 - 1)/ovflPageSize;

35613 while( 
nOvfl
-- )

35616 
Pgno
 
iNext
 = 0;

35617 
MemPage
 *
pOvfl
 = 0;

35618 if( 
ovflPgno
<2 || ovflPgno>
	`btreePagecount
(
pBt
) )

35624 return 
	`sqlite3CorruptError
(61826);

35626 if( 
nOvfl
 )

35629 
rc
 = 
	`getOverflowPage
(
pBt
, 
ovflPgno
, &
pOvfl
, &
iNext
);

35630 if( 
rc
 ) return rc;

35633 if( ( 
pOvfl
 || ((pOvfl = 
	`btreePageLookup
(
pBt
, 
ovflPgno
))!=0) )

35634 && 
	`sqlite3PagerPageRefcount
(
pOvfl
->
pDbPage
)!=1

35639 
rc
 = 
	`sqlite3CorruptError
(61846);

35641 
rc
 = 
	`freePage2
(
pBt
, 
pOvfl
, 
ovflPgno
);

35644 if( 
pOvfl
 )

35647 
	`sqlite3PagerUnref
(
pOvfl
->
pDbPage
);

35649 if( 
rc
 ) return rc;

35650 
ovflPgno
 = 
iNext
;

35653 
	}
}

35655 static int 
	$fillInCell
(

35656 
MemPage
 *
pPage
,

35657 unsigned char *
pCell
,

35658 const void *
pKey
, 
i64
 
nKey
,

35659 const void *
pData
,int 
nData
,

35660 int 
nZero
,

35661 int *
pnSize


35665 int 
nPayload
;

35666 const 
u8
 *
pSrc
;

35667 int 
nSrc
, 
n
, 
rc
;

35668 int 
spaceLeft
;

35669 
MemPage
 *
pOvfl
 = 0;

35670 
MemPage
 *
pToRelease
 = 0;

35671 unsigned char *
pPrior
;

35672 unsigned char *
pPayload
;

35673 
BtShared
 *
pBt
 = 
pPage
->pBt;

35674 
Pgno
 
pgnoOvfl
 = 0;

35675 int 
nHeader
;

35685 
nHeader
 = 
pPage
->
childPtrSize
;

35686 
nPayload
 = 
nData
 + 
nZero
;

35687 if( 
pPage
->
intKeyLeaf
 )

35690 
nHeader
 += (
u8
)(((
u32
)(
nPayload
)<(u32)0x80)?(*(&
pCell
[nHeader])=(unsigned char)(nPayload)),1: 
	`sqlite3PutVarint
((&pCell[nHeader]),(nPayload)));

35695 
nHeader
 += 
	`sqlite3PutVarint
(&
pCell
[nHeader], *(
u64
*)&
nKey
);

35698 if( 
pPage
->
intKey
 )

35701 
pSrc
 = 
pData
;

35702 
nSrc
 = 
nData
;

35703 
nData
 = 0;

35706 
nPayload
 = (int)
nKey
;

35707 
pSrc
 = 
pKey
;

35708 
nSrc
 = (int)
nKey
;

35710 if( 
nPayload
<=
pPage
->
maxLocal
 )

35713 
n
 = 
nHeader
 + 
nPayload
;

35716 if( 
n
<4 ) n = 4;

35717 *
pnSize
 = 
n
;

35718 
spaceLeft
 = 
nPayload
;

35719 
pPrior
 = 
pCell
;

35721 int 
mn
 = 
pPage
->
minLocal
;

35722 
n
 = 
mn
 + (
nPayload
 - mn) % (
pPage
->
pBt
->
usableSize
 - 4);

35725 if( 
n
 > 
pPage
->
maxLocal
 ) n = 
mn
;

35726 
spaceLeft
 = 
n
;

35727 *
pnSize
 = 
n
 + 
nHeader
 + 4;

35728 
pPrior
 = &
pCell
[
nHeader
+
n
];

35730 
pPayload
 = &
pCell
[
nHeader
];

35732 while( 
nPayload
>0 )

35735 if( 
spaceLeft
==0 )

35739 
Pgno
 
pgnoPtrmap
 = 
pgnoOvfl
;

35740 if( 
pBt
->
autoVacuum
 )

35744 
pgnoOvfl
++;

35746 (
	`ptrmapPageno
((
pBt
), (
pgnoOvfl
))==(pgnoOvfl)) || pgnoOvfl==((
Pgno
)((
sqlite3PendingByte
/((pBt)->
pageSize
))+1))

35750 
rc
 = 
	`allocateBtreePage
(
pBt
, &
pOvfl
, &
pgnoOvfl
, pgnoOvfl, 0);

35752 if( 
pBt
->
autoVacuum
 && 
rc
==0 )

35755 
u8
 
eType
 = (
pgnoPtrmap
?4:3);

35756 
	`ptrmapPut
(
pBt
, 
pgnoOvfl
, 
eType
, 
pgnoPtrmap
, &
rc
);

35757 if( 
rc
 )

35760 
	`releasePage
(
pOvfl
);

35764 if( 
rc
 )

35767 
	`releasePage
(
pToRelease
);

35768 return 
rc
;

35780 
	`sqlite3Put4byte
(
pPrior
, 
pgnoOvfl
);

35781 
	`releasePage
(
pToRelease
);

35782 
pToRelease
 = 
pOvfl
;

35783 
pPrior
 = 
pOvfl
->
aData
;

35784 
	`sqlite3Put4byte
(
pPrior
, 0);

35785 
pPayload
 = &
pOvfl
->
aData
[4];

35786 
spaceLeft
 = 
pBt
->
usableSize
 - 4;

35788 
n
 = 
nPayload
;

35789 if( 
n
>
spaceLeft
 ) n = spaceLeft;

35800 if( 
nSrc
>0 )

35803 if( 
n
>
nSrc
 ) n = nSrc;

35805 
	`memcpy
(
pPayload
, 
pSrc
, 
n
);

35807 
	`memset
(
pPayload
, 0, 
n
);

35809 
nPayload
 -= 
n
;

35810 
pPayload
 += 
n
;

35811 
pSrc
 += 
n
;

35812 
nSrc
 -= 
n
;

35813 
spaceLeft
 -= 
n
;

35814 if( 
nSrc
==0 )

35817 
nSrc
 = 
nData
;

35818 
pSrc
 = 
pData
;

35821 
	`releasePage
(
pToRelease
);

35823 
	}
}

35825 static void 
	$dropCell
(
MemPage
 *
pPage
, int 
idx
, int 
sz
, int *
pRC
)

35828 
u32
 
pc
;

35829 
u8
 *
data
;

35830 
u8
 *
ptr
;

35831 int 
rc
;

35832 int 
hdr
;

35834 if( *
pRC
 ) return;

35840 
data
 = 
pPage
->
aData
;

35841 
ptr
 = &
pPage
->
aCellIdx
[2*
idx
];

35842 
pc
 = ((
ptr
)[0]<<8 | (ptr)[1]);

35843 
hdr
 = 
pPage
->
hdrOffset
;

35846 if( 
pc
 < (
u32
)((&
data
[
hdr
+5])[0]<<8 | (&data[hdr+5])[1]) || pc+
sz
 > 
pPage
->
pBt
->
usableSize
 )

35849 *
pRC
 = 
	`sqlite3CorruptError
(62080);

35852 
rc
 = 
	`freeSpace
(
pPage
, 
pc
, 
sz
);

35853 if( 
rc
 )

35856 *
pRC
 = 
rc
;

35859 
pPage
->
nCell
--;

35860 if( 
pPage
->
nCell
==0 )

35863 
	`memset
(&
data
[
hdr
+1], 0, 4);

35864 
data
[
hdr
+7] = 0;

35865 ((&
data
[
hdr
+5])[0] = (
u8
)((
pPage
->
pBt
->
usableSize
)>>8), (&data[hdr+5])[1] = (u8)(pPage->pBt->usableSize));

35866 
pPage
->
nFree
 = pPage->
pBt
->
usableSize
 - pPage->
hdrOffset


35867 - 
pPage
->
childPtrSize
 - 8;

35869 
	`memmove
(
ptr
, ptr+2, 2*(
pPage
->
nCell
 - 
idx
));

35870 ((&
data
[
hdr
+3])[0] = (
u8
)((
pPage
->
nCell
)>>8), (&data[hdr+3])[1] = (u8)(pPage->nCell));

35871 
pPage
->
nFree
 += 2;

35873 
	}
}

35875 static void 
	$insertCell
(

35876 
MemPage
 *
pPage
,

35877 int 
i
,

35878 
u8
 *
pCell
,

35879 int 
sz
,

35880 
u8
 *
pTemp
,

35881 
Pgno
 
iChild
,

35882 int *
pRC


35886 int 
idx
 = 0;

35887 int 
j
;

35888 
u8
 *
data
;

35889 
u8
 *
pIns
;

35891 if( *
pRC
 ) return;

35905 if( 
pPage
->
nOverflow
 || 
sz
+2>pPage->
nFree
 )

35908 if( 
pTemp
 )

35911 
	`memcpy
(
pTemp
, 
pCell
, 
sz
);

35912 
pCell
 = 
pTemp
;

35914 if( 
iChild
 )

35917 
	`sqlite3Put4byte
(
pCell
, 
iChild
);

35919 
j
 = 
pPage
->
nOverflow
++;

35921 
pPage
->
apOvfl
[
j
] = 
pCell
;

35922 
pPage
->
aiOvfl
[
j
] = (
u16
)
i
;

35932 int 
rc
 = 
	`sqlite3PagerWrite
(
pPage
->
pDbPage
);

35933 if( 
rc
!=0 )

35936 *
pRC
 = 
rc
;

35940 
data
 = 
pPage
->
aData
;

35942 
rc
 = 
	`allocateSpace
(
pPage
, 
sz
, &
idx
);

35943 if( 
rc
 )

35945 *
pRC
 = 
rc
; return; }

35951 
pPage
->
nFree
 -= (
u16
)(2 + 
sz
);

35952 
	`memcpy
(&
data
[
idx
], 
pCell
, 
sz
);

35953 if( 
iChild
 )

35956 
	`sqlite3Put4byte
(&
data
[
idx
], 
iChild
);

35958 
pIns
 = 
pPage
->
aCellIdx
 + 
i
*2;

35959 
	`memmove
(
pIns
+2, pIns, 2*(
pPage
->
nCell
 - 
i
));

35960 ((
pIns
)[0] = (
u8
)((
idx
)>>8), (pIns)[1] = (u8)(idx));

35961 
pPage
->
nCell
++;

35963 if( (++
data
[
pPage
->
hdrOffset
+4])==0 ) data[pPage->hdrOffset+3]++;

35966 if( 
pPage
->
pBt
->
autoVacuum
 )

35972 
	`ptrmapPutOvflPtr
(
pPage
, 
pCell
, 
pRC
);

35976 
	}
}

35982 typedef struct 
CellArray
 
	tCellArray
;

35983 struct 
	sCellArray
 {

35984 int 
	mnCell
;

35985 
MemPage
 *
	mpRef
;

35986 
u8
 **
	mapCell
;

35987 
u16
 *
	mszCell
;

35994 static void 
	$populateCellCache
(
CellArray
 *
p
, int 
idx
, int 
N
)

35998 while( 
N
>0 )

36002 if( 
p
->
szCell
[
idx
]==0 )

36005 
p
->
szCell
[
idx
] = p->
pRef
->
	`xCellSize
(p->pRef, p->
apCell
[idx]);

36010 
idx
++;

36011 
N
--;

36013 
	}
}

36018 static 
__attribute__
((
noinline
)) 
u16
 
	$computeCellSize
(
CellArray
 *
p
, int 
N
)

36023 
p
->
szCell
[
N
] = p->
pRef
->
	`xCellSize
(p->pRef, p->
apCell
[N]);

36024 return 
p
->
szCell
[
N
];

36025 
	}
}

36026 static 
u16
 
	$cachedCellSize
(
CellArray
 *
p
, int 
N
)

36030 if( 
p
->
szCell
[
N
] ) return p->szCell[N];

36031 return 
	`computeCellSize
(
p
, 
N
);

36032 
	}
}

36034 static int 
	$rebuildPage
(

36035 
MemPage
 *
pPg
,

36036 int 
nCell
,

36037 
u8
 **
apCell
,

36038 
u16
 *
szCell


36042 const int 
hdr
 = 
pPg
->
hdrOffset
;

36043 
u8
 * const 
aData
 = 
pPg
->aData;

36044 const int 
usableSize
 = 
pPg
->
pBt
->usableSize;

36045 
u8
 * const 
pEnd
 = &
aData
[
usableSize
];

36046 int 
i
;

36047 
u8
 *
pCellptr
 = 
pPg
->
aCellIdx
;

36048 
u8
 *
pTmp
 = 
	`sqlite3PagerTempSpace
(
pPg
->
pBt
->
pPager
);

36049 
u8
 *
pData
;

36051 
i
 = ((&
aData
[
hdr
+5])[0]<<8 | (&aData[hdr+5])[1]);

36052 
	`memcpy
(&
pTmp
[
i
], &
aData
[i], 
usableSize
 - i);

36054 
pData
 = 
pEnd
;

36055 for(
i
=0; i<
nCell
; i++)

36058 
u8
 *
pCell
 = 
apCell
[
i
];

36059 if( (((
uptr
)(
pCell
)>=(uptr)(
aData
))&&((uptr)(pCell)<(uptr)(
pEnd
))) )

36062 
pCell
 = &
pTmp
[pCell - 
aData
];

36064 
pData
 -= 
szCell
[
i
];

36065 ((
pCellptr
)[0] = (
u8
)(((
pData
 - 
aData
))>>8), (pCellptr)[1] = (u8)((pData - aData)));

36066 
pCellptr
 += 2;

36067 if( 
pData
 < 
pCellptr
 ) return 
	`sqlite3CorruptError
(62287);

36068 
	`memcpy
(
pData
, 
pCell
, 
szCell
[
i
]);

36074 
pPg
->
nCell
 = nCell;

36075 
pPg
->
nOverflow
 = 0;

36077 ((&
aData
[
hdr
+1])[0] = (
u8
)((0)>>8), (&aData[hdr+1])[1] = (u8)(0));

36078 ((&
aData
[
hdr
+3])[0] = (
u8
)((
pPg
->
nCell
)>>8), (&aData[hdr+3])[1] = (u8)(pPg->nCell));

36079 ((&
aData
[
hdr
+5])[0] = (
u8
)((
pData
 - aData)>>8), (&aData[hdr+5])[1] = (u8)(pData - aData));

36080 
aData
[
hdr
+7] = 0x00;

36082 
	}
}

36084 static int 
	$pageInsertArray
(

36085 
MemPage
 *
pPg
,

36086 
u8
 *
pBegin
,

36087 
u8
 **
ppData
,

36088 
u8
 *
pCellptr
,

36089 int 
iFirst
,

36090 int 
nCell
,

36091 
CellArray
 *
pCArray


36095 int 
i
;

36096 
u8
 *
aData
 = 
pPg
->aData;

36097 
u8
 *
pData
 = *
ppData
;

36098 int 
iEnd
 = 
iFirst
 + 
nCell
;

36100 for(
i
=
iFirst
; i<
iEnd
; i++)

36103 int 
sz
, 
rc
;

36104 
u8
 *
pSlot
;

36105 
sz
 = 
	`cachedCellSize
(
pCArray
, 
i
);

36106 if( (
aData
[1]==0 && aData[2]==0) || (
pSlot
 = 
	`pageFindSlot
(
pPg
,
sz
,&
rc
))==0 )

36109 
pData
 -= 
sz
;

36110 if( 
pData
<
pBegin
 ) return 1;

36111 
pSlot
 = 
pData
;

36119 
	`memmove
(
pSlot
, 
pCArray
->
apCell
[
i
], 
sz
);

36120 ((
pCellptr
)[0] = (
u8
)(((
pSlot
 - 
aData
))>>8), (pCellptr)[1] = (u8)((pSlot - aData)));

36121 
pCellptr
 += 2;

36123 *
ppData
 = 
pData
;

36125 
	}
}

36127 static int 
	$pageFreeArray
(

36128 
MemPage
 *
pPg
,

36129 int 
iFirst
,

36130 int 
nCell
,

36131 
CellArray
 *
pCArray


36135 
u8
 * const 
aData
 = 
pPg
->aData;

36136 
u8
 * const 
pEnd
 = &
aData
[
pPg
->
pBt
->
usableSize
];

36137 
u8
 * const 
pStart
 = &
aData
[
pPg
->
hdrOffset
 + 8 + pPg->
childPtrSize
];

36138 int 
nRet
 = 0;

36139 int 
i
;

36140 int 
iEnd
 = 
iFirst
 + 
nCell
;

36141 
u8
 *
pFree
 = 0;

36142 int 
szFree
 = 0;

36144 for(
i
=
iFirst
; i<
iEnd
; i++)

36147 
u8
 *
pCell
 = 
pCArray
->
apCell
[
i
];

36148 if( (((
uptr
)(
pCell
)>=(uptr)(
pStart
))&&((uptr)(pCell)<(uptr)(
pEnd
))) )

36151 int 
sz
;

36155 
sz
 = 
pCArray
->
szCell
[
i
]; ((void) (0));

36156 if( 
pFree
!=(
pCell
 + 
sz
) )

36159 if( 
pFree
 )

36163 
	`freeSpace
(
pPg
, (
u16
)(
pFree
 - 
aData
), 
szFree
);

36165 
pFree
 = 
pCell
;

36166 
szFree
 = 
sz
;

36167 if( 
pFree
+
sz
>
pEnd
 ) return 0;

36169 
pFree
 = 
pCell
;

36170 
szFree
 += 
sz
;

36172 
nRet
++;

36175 if( 
pFree
 )

36179 
	`freeSpace
(
pPg
, (
u16
)(
pFree
 - 
aData
), 
szFree
);

36181 return 
nRet
;

36182 
	}
}

36184 static int 
	$editPage
(

36185 
MemPage
 *
pPg
,

36186 int 
iOld
,

36187 int 
iNew
,

36188 int 
nNew
,

36189 
CellArray
 *
pCArray


36193 
u8
 * const 
aData
 = 
pPg
->aData;

36194 const int 
hdr
 = 
pPg
->
hdrOffset
;

36195 
u8
 *
pBegin
 = &
pPg
->
aCellIdx
[
nNew
 * 2];

36196 int 
nCell
 = 
pPg
->nCell;

36197 
u8
 *
pData
;

36198 
u8
 *
pCellptr
;

36199 int 
i
;

36200 int 
iOldEnd
 = 
iOld
 + 
pPg
->
nCell
 + pPg->
nOverflow
;

36201 int 
iNewEnd
 = 
iNew
 + 
nNew
;

36209 if( 
iOld
<
iNew
 )

36212 int 
nShift
 = 
	`pageFreeArray
(
pPg
, 
iOld
, 
iNew
-iOld, 
pCArray
);

36213 
	`memmove
(
pPg
->
aCellIdx
, &pPg->aCellIdx[
nShift
*2], 
nCell
*2);

36214 
nCell
 -= 
nShift
;

36216 if( 
iNewEnd
 < 
iOldEnd
 )

36219 
nCell
 -= 
	`pageFreeArray
(
pPg
, 
iNewEnd
, 
iOldEnd
 - iNewEnd, 
pCArray
);

36222 
pData
 = &
aData
[(((((int)((&aData[
hdr
+5])[0]<<8 | (&aData[hdr+5])[1]))-1)&0xffff)+1)];

36223 if( 
pData
<
pBegin
 ) goto 
editpage_fail
;

36226 if( 
iNew
<
iOld
 )

36229 int 
nAdd
 = ((
nNew
)<(
iOld
-
iNew
)?(nNew):(iOld-iNew));

36231 
pCellptr
 = 
pPg
->
aCellIdx
;

36232 
	`memmove
(&
pCellptr
[
nAdd
*2], pCellptr, 
nCell
*2);

36233 if( 
	`pageInsertArray
(

36234 
pPg
, 
pBegin
, &
pData
, 
pCellptr
,

36235 
iNew
, 
nAdd
, 
pCArray


36236 ) ) goto 
editpage_fail
;

36237 
nCell
 += 
nAdd
;

36241 for(
i
=0; i<
pPg
->
nOverflow
; i++)

36244 int 
iCell
 = (
iOld
 + 
pPg
->
aiOvfl
[
i
]) - 
iNew
;

36245 if( 
iCell
>=0 && iCell<
nNew
 )

36248 
pCellptr
 = &
pPg
->
aCellIdx
[
iCell
 * 2];

36249 
	`memmove
(&
pCellptr
[2], pCellptr, (
nCell
 - 
iCell
) * 2);

36250 
nCell
++;

36251 if( 
	`pageInsertArray
(

36252 
pPg
, 
pBegin
, &
pData
, 
pCellptr
,

36253 
iCell
+
iNew
, 1, 
pCArray


36254 ) ) goto 
editpage_fail
;

36259 
pCellptr
 = &
pPg
->
aCellIdx
[
nCell
*2];

36260 if( 
	`pageInsertArray
(

36261 
pPg
, 
pBegin
, &
pData
, 
pCellptr
,

36262 
iNew
+
nCell
, 
nNew
-nCell, 
pCArray


36263 ) ) goto 
editpage_fail
;

36265 
pPg
->
nCell
 = 
nNew
;

36266 
pPg
->
nOverflow
 = 0;

36268 ((&
aData
[
hdr
+3])[0] = (
u8
)((
pPg
->
nCell
)>>8), (&aData[hdr+3])[1] = (u8)(pPg->nCell));

36269 ((&
aData
[
hdr
+5])[0] = (
u8
)((
pData
 - aData)>>8), (&aData[hdr+5])[1] = (u8)(pData - aData));

36272 
editpage_fail
:

36274 
	`populateCellCache
(
pCArray
, 
iNew
, 
nNew
);

36275 return 
	`rebuildPage
(
pPg
, 
nNew
, &
pCArray
->
apCell
[
iNew
], &pCArray->
szCell
[iNew]);

36276 
	}
}

36278 static int 
	$balance_quick
(
MemPage
 *
pParent
, MemPage *
pPage
, 
u8
 *
pSpace
)

36281 
BtShared
 *const 
pBt
 = 
pPage
->pBt;

36282 
MemPage
 *
pNew
;

36283 int 
rc
;

36284 
Pgno
 
pgnoNew
;

36291 if( (
pPage
->
nCell
==0) ) return 
	`sqlite3CorruptError
(62577);

36297 
rc
 = 
	`allocateBtreePage
(
pBt
, &
pNew
, &
pgnoNew
, 0, 0);

36299 if( 
rc
==0 )

36303 
u8
 *
pOut
 = &
pSpace
[4];

36304 
u8
 *
pCell
 = 
pPage
->
apOvfl
[0];

36305 
u16
 
szCell
 = 
pPage
->
	`xCellSize
(pPage, 
pCell
);

36306 
u8
 *
pStop
;

36310 
	`zeroPage
(
pNew
, 0x01|0x04|0x08);

36311 
rc
 = 
	`rebuildPage
(
pNew
, 1, &
pCell
, &
szCell
);

36312 if( (
rc
) ) return rc;

36313 
pNew
->
nFree
 = 
pBt
->
usableSize
 - pNew->
cellOffset
 - 2 - 
szCell
;

36315 if( (
pBt
->
autoVacuum
) )

36318 
	`ptrmapPut
(
pBt
, 
pgnoNew
, 5, 
pParent
->
pgno
, &
rc
);

36319 if( 
szCell
>
pNew
->
minLocal
 )

36322 
	`ptrmapPutOvflPtr
(
pNew
, 
pCell
, &
rc
);

36326 
pCell
 = ((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(pPage->
nCell
-1)]))));

36327 
pStop
 = &
pCell
[9];

36328 while( (*(
pCell
++)&0x80) && pCell<
pStop
 );

36329 
pStop
 = &
pCell
[9];

36330 while( ((*(
pOut
++) = *(
pCell
++))&0x80) && pCell<
pStop
 );

36333 
	`insertCell
(
pParent
, pParent->
nCell
, 
pSpace
, (int)(
pOut
-pSpace),

36334 0, 
pPage
->
pgno
, &
rc
);

36337 
	`sqlite3Put4byte
(&
pParent
->
aData
[pParent->
hdrOffset
+8], 
pgnoNew
);

36340 
	`releasePage
(
pNew
);

36343 return 
rc
;

36344 
	}
}

36346 static void 
	$copyNodeContent
(
MemPage
 *
pFrom
, MemPage *
pTo
, int *
pRC
)

36349 if( (*
pRC
)==0 )

36352 
BtShared
 * const 
pBt
 = 
pFrom
->pBt;

36353 
u8
 * const 
aFrom
 = 
pFrom
->
aData
;

36354 
u8
 * const 
aTo
 = 
pTo
->
aData
;

36355 int const 
iFromHdr
 = 
pFrom
->
hdrOffset
;

36356 int const 
iToHdr
 = ((
pTo
->
pgno
==1) ? 100 : 0);

36357 int 
rc
;

36358 int 
iData
;

36366 
iData
 = ((&
aFrom
[
iFromHdr
+5])[0]<<8 | (&aFrom[iFromHdr+5])[1]);

36367 
	`memcpy
(&
aTo
[
iData
], &
aFrom
[iData], 
pBt
->
usableSize
-iData);

36368 
	`memcpy
(&
aTo
[
iToHdr
], &
aFrom
[
iFromHdr
], 
pFrom
->
cellOffset
 + 2*pFrom->
nCell
);

36375 
pTo
->
isInit
 = 0;

36376 
rc
 = 
	`btreeInitPage
(
pTo
);

36377 if( 
rc
!=0 )

36380 *
pRC
 = 
rc
;

36387 if( (
pBt
->
autoVacuum
) )

36390 *
pRC
 = 
	`setChildPtrmaps
(
pTo
);

36393 
	}
}

36395 static int 
	$balance_nonroot
(

36396 
MemPage
 *
pParent
,

36397 int 
iParentIdx
,

36398 
u8
 *
aOvflSpace
,

36399 int 
isRoot
,

36400 int 
bBulk


36404 
BtShared
 *
pBt
;

36405 int 
nMaxCells
 = 0;

36406 int 
nNew
 = 0;

36407 int 
nOld
;

36408 int 
i
, 
j
, 
k
;

36409 int 
nxDiv
;

36410 int 
rc
 = 0;

36411 
u16
 
leafCorrection
;

36412 int 
leafData
;

36413 int 
usableSpace
;

36414 int 
pageFlags
;

36415 int 
iSpace1
 = 0;

36416 int 
iOvflSpace
 = 0;

36417 int 
szScratch
;

36418 
MemPage
 *
apOld
[(1*2+1)];

36419 
MemPage
 *
apNew
[(1*2+1)+2];

36420 
u8
 *
pRight
;

36421 
u8
 *
apDiv
[(1*2+1)-1];

36422 int 
cntNew
[(1*2+1)+2];

36423 int 
cntOld
[(1*2+1)+2];

36424 int 
szNew
[(1*2+1)+2];

36425 
u8
 *
aSpace1
;

36426 
Pgno
 
pgno
;

36427 
u8
 
abDone
[(1*2+1)+2];

36428 
Pgno
 
aPgno
[(1*2+1)+2];

36429 
Pgno
 
aPgOrder
[(1*2+1)+2];

36430 
u16
 
aPgFlags
[(1*2+1)+2];

36431 
CellArray
 
b
;

36433 
	`memset
(
abDone
, 0, sizeof(abDone));

36434 
b
.
nCell
 = 0;

36435 
b
.
apCell
 = 0;

36436 
pBt
 = 
pParent
->pBt;

36443 if( !
aOvflSpace
 )

36449 
i
 = 
pParent
->
nOverflow
 + pParent->
nCell
;

36450 if( 
i
<2 )

36453 
nxDiv
 = 0;

36456 if( 
iParentIdx
==0 )

36459 
nxDiv
 = 0;

36460 }else if( 
iParentIdx
==
i
 )

36463 
nxDiv
 = 
i
-2+
bBulk
;

36465 
nxDiv
 = 
iParentIdx
-1;

36467 
i
 = 2-
bBulk
;

36469 
nOld
 = 
i
+1;

36470 if( (
i
+
nxDiv
-
pParent
->
nOverflow
)==pParent->
nCell
 )

36473 
pRight
 = &
pParent
->
aData
[pParent->
hdrOffset
+8];

36475 
pRight
 = ((
pParent
)->
aData
 + ((pParent)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pParent)->
aCellIdx
[2*(
i
+
nxDiv
-pParent->
nOverflow
)]))));

36477 
pgno
 = 
	`sqlite3Get4byte
(
pRight
);

36481 
rc
 = 
	`getAndInitPage
(
pBt
, 
pgno
, &
apOld
[
i
], 0, 0);

36482 if( 
rc
 )

36485 
	`memset
(
apOld
, 0, (
i
+1)*sizeof(
MemPage
*));

36486 goto 
balance_cleanup
;

36488 
nMaxCells
 += 1+
apOld
[
i
]->
nCell
+apOld[i]->
nOverflow
;

36489 if( (
i
--)==0 ) break;

36491 if( 
i
+
nxDiv
==
pParent
->
aiOvfl
[0] && pParent->
nOverflow
 )

36494 
apDiv
[
i
] = 
pParent
->
apOvfl
[0];

36495 
pgno
 = 
	`sqlite3Get4byte
(
apDiv
[
i
]);

36496 
szNew
[
i
] = 
pParent
->
	`xCellSize
(pParent, 
apDiv
[i]);

36497 
pParent
->
nOverflow
 = 0;

36499 
apDiv
[
i
] = ((
pParent
)->
aData
 + ((pParent)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pParent)->
aCellIdx
[2*(i+
nxDiv
-pParent->
nOverflow
)]))));

36500 
pgno
 = 
	`sqlite3Get4byte
(
apDiv
[
i
]);

36501 
szNew
[
i
] = 
pParent
->
	`xCellSize
(pParent, 
apDiv
[i]);

36503 if( 
pBt
->
btsFlags
 & 0x0004 )

36506 int 
iOff
;

36508 
iOff
 = ((int)(long int)(
apDiv
[
i
])) - ((int)(long int)(
pParent
->
aData
));

36509 if( (
iOff
+
szNew
[
i
])>(int)
pBt
->
usableSize
 )

36512 
rc
 = 
	`sqlite3CorruptError
(62916);

36513 
	`memset
(
apOld
, 0, (
i
+1)*sizeof(
MemPage
*));

36514 goto 
balance_cleanup
;

36516 
	`memcpy
(&
aOvflSpace
[
iOff
], 
apDiv
[
i
], 
szNew
[i]);

36517 
apDiv
[
i
] = &
aOvflSpace
[apDiv[i]-
pParent
->
aData
];

36520 
	`dropCell
(
pParent
, 
i
+
nxDiv
-pParent->
nOverflow
, 
szNew
[i], &
rc
);

36526 
nMaxCells
 = (nMaxCells + 3)&~3;

36531 
szScratch
 =

36532 
nMaxCells
*sizeof(
u8
*)

36533 + 
nMaxCells
*sizeof(
u16
)

36534 + 
pBt
->
pageSize
;

36539 
b
.
apCell
 = 
	`sqlite3ScratchMalloc
( 
szScratch
 );

36540 if( 
b
.
apCell
==0 )

36543 
rc
 = 7;

36544 goto 
balance_cleanup
;

36546 
b
.
szCell
 = (
u16
*)&b.
apCell
[
nMaxCells
];

36547 
aSpace1
 = (
u8
*)&
b
.
szCell
[
nMaxCells
];

36550 
b
.
pRef
 = 
apOld
[0];

36551 
leafCorrection
 = 
b
.
pRef
->
leaf
*4;

36552 
leafData
 = 
b
.
pRef
->
intKeyLeaf
;

36553 for(
i
=0; i<
nOld
; i++)

36556 
MemPage
 *
pOld
 = 
apOld
[
i
];

36557 int 
limit
 = 
pOld
->
nCell
;

36558 
u8
 *
aData
 = 
pOld
->aData;

36559 
u16
 
maskPage
 = 
pOld
->maskPage;

36560 
u8
 *
piCell
 = 
aData
 + 
pOld
->
cellOffset
;

36561 
u8
 *
piEnd
;

36566 if( 
pOld
->
aData
[0]!=
apOld
[0]->aData[0] )

36569 
rc
 = 
	`sqlite3CorruptError
(62983);

36570 goto 
balance_cleanup
;

36573 
	`memset
(&
b
.
szCell
[b.
nCell
], 0, sizeof(b.szCell[0])*(
limit
+
pOld
->
nOverflow
));

36574 if( 
pOld
->
nOverflow
>0 )

36577 
limit
 = 
pOld
->
aiOvfl
[0];

36578 for(
j
=0; j<
limit
; j++)

36581 
b
.
apCell
[b.
nCell
] = 
aData
 + (
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(
piCell
)));

36582 
piCell
 += 2;

36583 
b
.
nCell
++;

36585 for(
k
=0; k<
pOld
->
nOverflow
; k++)

36589 
b
.
apCell
[b.
nCell
] = 
pOld
->
apOvfl
[
k
];

36590 
b
.
nCell
++;

36593 
piEnd
 = 
aData
 + 
pOld
->
cellOffset
 + 2*pOld->
nCell
;

36594 while( 
piCell
<
piEnd
 )

36598 
b
.
apCell
[b.
nCell
] = 
aData
 + (
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(
piCell
)));

36599 
piCell
 += 2;

36600 
b
.
nCell
++;

36603 
cntOld
[
i
] = 
b
.
nCell
;

36604 if( 
i
<
nOld
-1 && !
leafData
)

36607 
u16
 
sz
 = (u16)
szNew
[
i
];

36608 
u8
 *
pTemp
;

36610 
b
.
szCell
[b.
nCell
] = 
sz
;

36611 
pTemp
 = &
aSpace1
[
iSpace1
];

36612 
iSpace1
 += 
sz
;

36615 
	`memcpy
(
pTemp
, 
apDiv
[
i
], 
sz
);

36616 
b
.
apCell
[b.
nCell
] = 
pTemp
+
leafCorrection
;

36618 
b
.
szCell
[b.
nCell
] = b.szCell[b.nCell] - 
leafCorrection
;

36619 if( !
pOld
->
leaf
 )

36626 
	`memcpy
(
b
.
apCell
[b.
nCell
], &
pOld
->
aData
[8], 4);

36629 while( 
b
.
szCell
[b.
nCell
]<4 )

36636 
aSpace1
[
iSpace1
++] = 0x00;

36637 
b
.
szCell
[b.
nCell
]++;

36640 
b
.
nCell
++;

36644 
usableSpace
 = 
pBt
->
usableSize
 - 12 + 
leafCorrection
;

36645 for(
i
=0; i<
nOld
; i++)

36648 
MemPage
 *
p
 = 
apOld
[
i
];

36649 
szNew
[
i
] = 
usableSpace
 - 
p
->
nFree
;

36650 if( 
szNew
[
i
]<0 )

36652 
rc
 = 
	`sqlite3CorruptError
(63081); goto 
balance_cleanup
; }

36653 for(
j
=0; j<
p
->
nOverflow
; j++)

36656 
szNew
[
i
] += 2 + 
p
->
	`xCellSize
(p, p->
apOvfl
[
j
]);

36658 
cntNew
[
i
] = 
cntOld
[i];

36660 
k
 = 
nOld
;

36661 for(
i
=0; i<
k
; i++)

36664 int 
sz
;

36665 while( 
szNew
[
i
]>
usableSpace
 )

36668 if( 
i
+1>=
k
 )

36671 
k
 = 
i
+2;

36672 if( 
k
>(1*2+1)+2 )

36674 
rc
 = 
	`sqlite3CorruptError
(63093); goto 
balance_cleanup
; }

36675 
szNew
[
k
-1] = 0;

36676 
cntNew
[
k
-1] = 
b
.
nCell
;

36678 
sz
 = 2 + 
	`cachedCellSize
(&
b
, 
cntNew
[
i
]-1);

36679 
szNew
[
i
] -= 
sz
;

36680 if( !
leafData
 )

36683 if( 
cntNew
[
i
]<
b
.
nCell
 )

36686 
sz
 = 2 + 
	`cachedCellSize
(&
b
, 
cntNew
[
i
]);

36688 
sz
 = 0;

36691 
szNew
[
i
+1] += 
sz
;

36692 
cntNew
[
i
]--;

36694 while( 
cntNew
[
i
]<
b
.
nCell
 )

36697 
sz
 = 2 + 
	`cachedCellSize
(&
b
, 
cntNew
[
i
]);

36698 if( 
szNew
[
i
]+
sz
>
usableSpace
 ) break;

36699 
szNew
[
i
] += 
sz
;

36700 
cntNew
[
i
]++;

36701 if( !
leafData
 )

36704 if( 
cntNew
[
i
]<
b
.
nCell
 )

36707 
sz
 = 2 + 
	`cachedCellSize
(&
b
, 
cntNew
[
i
]);

36709 
sz
 = 0;

36712 
szNew
[
i
+1] -= 
sz
;

36714 if( 
cntNew
[
i
]>=
b
.
nCell
 )

36717 
k
 = 
i
+1;

36718 }else if( 
cntNew
[
i
] <= (i>0 ? cntNew[i-1] : 0) )

36721 
rc
 = 
	`sqlite3CorruptError
(63126);

36722 goto 
balance_cleanup
;

36726 for(
i
=
k
-1; i>0; i--)

36729 int 
szRight
 = 
szNew
[
i
];

36730 int 
szLeft
 = 
szNew
[
i
-1];

36731 int 
r
;

36732 int 
d
;

36734 
r
 = 
cntNew
[
i
-1] - 1;

36735 
d
 = 
r
 + 1 - 
leafData
;

36736 (void)
	`cachedCellSize
(&
b
, 
d
);

36740 (void)
	`cachedCellSize
(&
b
, 
r
);

36741 if( 
szRight
!=0

36742 && (
bBulk
 || 
szRight
+
b
.
szCell
[
d
]+2 > 
szLeft
-(b.szCell[
r
]+2)) )

36747 
szRight
 += 
b
.
szCell
[
d
] + 2;

36748 
szLeft
 -= 
b
.
szCell
[
r
] + 2;

36749 
cntNew
[
i
-1] = 
r
;

36750 
r
--;

36751 
d
--;

36752 }while( 
r
>=0 );

36753 
szNew
[
i
] = 
szRight
;

36754 
szNew
[
i
-1] = 
szLeft
;

36755 if( 
cntNew
[
i
-1] <= (i>1 ? cntNew[i-2] : 0) )

36758 
rc
 = 
	`sqlite3CorruptError
(63168);

36759 goto 
balance_cleanup
;

36773 
pageFlags
 = 
apOld
[0]->
aData
[0];

36774 for(
i
=0; i<
k
; i++)

36777 
MemPage
 *
pNew
;

36778 if( 
i
<
nOld
 )

36781 
pNew
 = 
apNew
[
i
] = 
apOld
[i];

36782 
apOld
[
i
] = 0;

36783 
rc
 = 
	`sqlite3PagerWrite
(
pNew
->
pDbPage
);

36784 
nNew
++;

36785 if( 
rc
 ) goto 
balance_cleanup
;

36788 
rc
 = 
	`allocateBtreePage
(
pBt
, &
pNew
, &
pgno
, (
bBulk
 ? 1 : pgno), 0);

36789 if( 
rc
 ) goto 
balance_cleanup
;

36790 
	`zeroPage
(
pNew
, 
pageFlags
);

36791 
apNew
[
i
] = 
pNew
;

36792 
nNew
++;

36793 
cntOld
[
i
] = 
b
.
nCell
;

36796 if( (
pBt
->
autoVacuum
) )

36799 
	`ptrmapPut
(
pBt
, 
pNew
->
pgno
, 5, 
pParent
->pgno, &
rc
);

36800 if( 
rc
!=0 )

36803 goto 
balance_cleanup
;

36809 for(
i
=0; i<
nNew
; i++)

36812 
aPgOrder
[
i
] = 
aPgno
[i] = 
apNew
[i]->
pgno
;

36813 
aPgFlags
[
i
] = 
apNew
[i]->
pDbPage
->
flags
;

36814 for(
j
=0; j<
i
; j++)

36817 if( 
aPgno
[
j
]==aPgno[
i
] )

36827 
rc
 = 
	`sqlite3CorruptError
(63242);

36828 goto 
balance_cleanup
;

36832 for(
i
=0; i<
nNew
; i++)

36835 int 
iBest
 = 0;

36836 for(
j
=1; j<
nNew
; j++)

36839 if( 
aPgOrder
[
j
]<aPgOrder[
iBest
] ) iBest = j;

36841 
pgno
 = 
aPgOrder
[
iBest
];

36842 
aPgOrder
[
iBest
] = 0xffffffff;

36843 if( 
iBest
!=
i
 )

36846 if( 
iBest
>
i
 )

36849 
	`sqlite3PagerRekey
(
apNew
[
iBest
]->
pDbPage
, 
pBt
->
nPage
+iBest+1, 0);

36851 
	`sqlite3PagerRekey
(
apNew
[
i
]->
pDbPage
, 
pgno
, 
aPgFlags
[
iBest
]);

36852 
apNew
[
i
]->
pgno
 = pgno;

36861 
	`sqlite3Put4byte
(
pRight
, 
apNew
[
nNew
-1]->
pgno
);

36866 if( (
pageFlags
 & 0x08)==0 && 
nOld
!=
nNew
 )

36869 
MemPage
 *
pOld
 = (
nNew
>
nOld
 ? 
apNew
 : 
apOld
)[nOld-1];

36870 
	`memcpy
(&
apNew
[
nNew
-1]->
aData
[8], &
pOld
->aData[8], 4);

36873 if( (
pBt
->
autoVacuum
) )

36876 
MemPage
 *
pNew
 = 
apNew
[0];

36877 
u8
 *
aOld
 = 
pNew
->
aData
;

36878 int 
cntOldNext
 = 
pNew
->
nCell
 + pNew->
nOverflow
;

36879 int 
usableSize
 = 
pBt
->usableSize;

36880 int 
iNew
 = 0;

36881 int 
iOld
 = 0;

36883 for(
i
=0; i<
b
.
nCell
; i++)

36886 
u8
 *
pCell
 = 
b
.
apCell
[
i
];

36887 if( 
i
==
cntOldNext
 )

36890 
MemPage
 *
pOld
 = (++
iOld
)<
nNew
 ? 
apNew
[iOld] : 
apOld
[iOld];

36891 
cntOldNext
 += 
pOld
->
nCell
 + pOld->
nOverflow
 + !
leafData
;

36892 
aOld
 = 
pOld
->
aData
;

36894 if( 
i
==
cntNew
[
iNew
] )

36897 
pNew
 = 
apNew
[++
iNew
];

36898 if( !
leafData
 ) continue;

36907 if( 
iOld
>=
nNew


36908 || 
pNew
->
pgno
!=
aPgno
[
iOld
]

36909 || !(((
uptr
)(
pCell
)>=(uptr)(
aOld
))&&((uptr)(pCell)<(uptr)(&aOld[
usableSize
])))

36913 if( !
leafCorrection
 )

36916 
	`ptrmapPut
(
pBt
, 
	`sqlite3Get4byte
(
pCell
), 5, 
pNew
->
pgno
, &
rc
);

36918 if( 
	`cachedCellSize
(&
b
,
i
)>
pNew
->
minLocal
 )

36921 
	`ptrmapPutOvflPtr
(
pNew
, 
pCell
, &
rc
);

36923 if( 
rc
 ) goto 
balance_cleanup
;

36929 for(
i
=0; i<
nNew
-1; i++)

36932 
u8
 *
pCell
;

36933 
u8
 *
pTemp
;

36934 int 
sz
;

36935 
MemPage
 *
pNew
 = 
apNew
[
i
];

36936 
j
 = 
cntNew
[
i
];

36940 
pCell
 = 
b
.
apCell
[
j
];

36941 
sz
 = 
b
.
szCell
[
j
] + 
leafCorrection
;

36942 
pTemp
 = &
aOvflSpace
[
iOvflSpace
];

36943 if( !
pNew
->
leaf
 )

36946 
	`memcpy
(&
pNew
->
aData
[8], 
pCell
, 4);

36947 }else if( 
leafData
 )

36955 
CellInfo
 
info
;

36956 
j
--;

36957 
pNew
->
	`xParseCell
(pNew, 
b
.
apCell
[
j
], &
info
);

36958 
pCell
 = 
pTemp
;

36959 
sz
 = 4 + 
	`sqlite3PutVarint
(&
pCell
[4], 
info
.
nKey
);

36960 
pTemp
 = 0;

36962 
pCell
 -= 4;

36964 if( 
b
.
szCell
[
j
]==4 )

36968 
sz
 = 
pParent
->
	`xCellSize
(pParent, 
pCell
);

36971 
iOvflSpace
 += 
sz
;

36974 
	`insertCell
(
pParent
, 
nxDiv
+
i
, 
pCell
, 
sz
, 
pTemp
, 
pNew
->
pgno
, &
rc
);

36975 if( 
rc
!=0 ) goto 
balance_cleanup
;

36979 for(
i
=1-
nNew
; i<nNew; i++)

36982 int 
iPg
 = 
i
<0 ? -i : i;

36984 if( 
abDone
[
iPg
] ) continue;

36985 if( 
i
>=0

36986 || 
cntOld
[
iPg
-1]>=
cntNew
[iPg-1]

36990 int 
iNew
;

36991 int 
iOld
;

36992 int 
nNewCell
;

37002 if( 
iPg
==0 )

37005 
iNew
 = 
iOld
 = 0;

37006 
nNewCell
 = 
cntNew
[0];

37008 
iOld
 = 
iPg
<
nOld
 ? (
cntOld
[iPg-1] + !
leafData
) : 
b
.
nCell
;

37009 
iNew
 = 
cntNew
[
iPg
-1] + !
leafData
;

37010 
nNewCell
 = 
cntNew
[
iPg
] - 
iNew
;

37013 
rc
 = 
	`editPage
(
apNew
[
iPg
], 
iOld
, 
iNew
, 
nNewCell
, &
b
);

37014 if( 
rc
 ) goto 
balance_cleanup
;

37015 
abDone
[
iPg
]++;

37016 
apNew
[
iPg
]->
nFree
 = 
usableSpace
-
szNew
[iPg];

37028 if( 
isRoot
 && 
pParent
->
nCell
==0 && pParent->
hdrOffset
<=
apNew
[0]->
nFree
 )

37033 
rc
 = 
	`defragmentPage
(
apNew
[0]);

37039 
	`copyNodeContent
(
apNew
[0], 
pParent
, &
rc
);

37040 
	`freePage
(
apNew
[0], &
rc
);

37041 }else if( (
pBt
->
autoVacuum
) && !
leafCorrection
 )

37047 for(
i
=0; i<
nNew
; i++)

37050 
u32
 
key
 = 
	`sqlite3Get4byte
(&
apNew
[
i
]->
aData
[8]);

37051 
	`ptrmapPut
(
pBt
, 
key
, 5, 
apNew
[
i
]->
pgno
, &
rc
);

37061 for(
i
=
nNew
; i<
nOld
; i++)

37064 
	`freePage
(
apOld
[
i
], &
rc
);

37067 
balance_cleanup
:

37068 
	`sqlite3ScratchFree
(
b
.
apCell
);

37069 for(
i
=0; i<
nOld
; i++)

37072 
	`releasePage
(
apOld
[
i
]);

37074 for(
i
=0; i<
nNew
; i++)

37077 
	`releasePage
(
apNew
[
i
]);

37080 return 
rc
;

37081 
	}
}

37083 static int 
	$balance_deeper
(
MemPage
 *
pRoot
, MemPage **
ppChild
)

37086 int 
rc
;

37087 
MemPage
 *
pChild
 = 0;

37088 
Pgno
 
pgnoChild
 = 0;

37089 
BtShared
 *
pBt
 = 
pRoot
->pBt;

37098 
rc
 = 
	`sqlite3PagerWrite
(
pRoot
->
pDbPage
);

37099 if( 
rc
==0 )

37102 
rc
 = 
	`allocateBtreePage
(
pBt
,&
pChild
,&
pgnoChild
,
pRoot
->
pgno
,0);

37103 
	`copyNodeContent
(
pRoot
, 
pChild
, &
rc
);

37104 if( (
pBt
->
autoVacuum
) )

37107 
	`ptrmapPut
(
pBt
, 
pgnoChild
, 5, 
pRoot
->
pgno
, &
rc
);

37110 if( 
rc
 )

37113 *
ppChild
 = 0;

37114 
	`releasePage
(
pChild
);

37115 return 
rc
;

37124 
	`memcpy
(
pChild
->
aiOvfl
, 
pRoot
->aiOvfl,

37125 
pRoot
->
nOverflow
*sizeof(pRoot->
aiOvfl
[0]));

37126 
	`memcpy
(
pChild
->
apOvfl
, 
pRoot
->apOvfl,

37127 
pRoot
->
nOverflow
*sizeof(pRoot->
apOvfl
[0]));

37128 
pChild
->
nOverflow
 = 
pRoot
->nOverflow;

37131 
	`zeroPage
(
pRoot
, 
pChild
->
aData
[0] & ~0x08);

37132 
	`sqlite3Put4byte
(&
pRoot
->
aData
[pRoot->
hdrOffset
+8], 
pgnoChild
);

37134 *
ppChild
 = 
pChild
;

37136 
	}
}

37138 static int 
	$balance
(
BtCursor
 *
pCur
)

37141 int 
rc
 = 0;

37142 const int 
nMin
 = 
pCur
->
pBt
->
usableSize
 * 2 / 3;

37143 
u8
 
aBalanceQuickSpace
[13];

37144 
u8
 *
pFree
 = 0;

37150 int 
iPage
 = 
pCur
->iPage;

37151 
MemPage
 *
pPage
 = 
pCur
->
apPage
[
iPage
];

37153 if( 
iPage
==0 )

37156 if( 
pPage
->
nOverflow
 )

37166 
rc
 = 
	`balance_deeper
(
pPage
, &
pCur
->
apPage
[1]);

37167 if( 
rc
==0 )

37170 
pCur
->
iPage
 = 1;

37171 
pCur
->
aiIdx
[0] = 0;

37172 
pCur
->
aiIdx
[1] = 0;

37178 }else if( 
pPage
->
nOverflow
==0 && pPage->
nFree
<=
nMin
 )

37183 
MemPage
 * const 
pParent
 = 
pCur
->
apPage
[
iPage
-1];

37184 int const 
iIdx
 = 
pCur
->
aiIdx
[
iPage
-1];

37186 
rc
 = 
	`sqlite3PagerWrite
(
pParent
->
pDbPage
);

37187 if( 
rc
==0 )

37191 if( 
pPage
->
intKeyLeaf


37192 && 
pPage
->
nOverflow
==1

37193 && 
pPage
->
aiOvfl
[0]==pPage->
nCell


37194 && 
pParent
->
pgno
!=1

37195 && 
pParent
->
nCell
==
iIdx


37202 
rc
 = 
	`balance_quick
(
pParent
, 
pPage
, 
aBalanceQuickSpace
);

37207 
u8
 *
pSpace
 = 
	`sqlite3PageMalloc
(
pCur
->
pBt
->
pageSize
);

37208 
rc
 = 
	`balance_nonroot
(
pParent
, 
iIdx
, 
pSpace
, 
iPage
==1,

37209 
pCur
->
hints
&0x00000001);

37210 if( 
pFree
 )

37217 
	`sqlite3PageFree
(
pFree
);

37223 
pFree
 = 
pSpace
;

37227 
pPage
->
nOverflow
 = 0;

37230 
	`releasePage
(
pPage
);

37231 
pCur
->
iPage
--;

37234 }while( 
rc
==0 );

37236 if( 
pFree
 )

37239 
	`sqlite3PageFree
(
pFree
);

37241 return 
rc
;

37242 
	}
}

37244 static int 
	$sqlite3BtreeInsert
(

37245 
BtCursor
 *
pCur
,

37246 const void *
pKey
, 
i64
 
nKey
,

37247 const void *
pData
, int 
nData
,

37248 int 
nZero
,

37249 int 
appendBias
,

37250 int 
seekResult


37254 int 
rc
;

37255 int 
loc
 = 
seekResult
;

37256 int 
szNew
 = 0;

37257 int 
idx
;

37258 
MemPage
 *
pPage
;

37259 
Btree
 *
p
 = 
pCur
->
pBtree
;

37260 
BtShared
 *
pBt
 = 
p
->pBt;

37261 unsigned char *
oldCell
;

37262 unsigned char *
newCell
 = 0;

37264 if( 
pCur
->
eState
==4 )

37268 return 
pCur
->
skipNext
;

37284 if( 
pCur
->
curFlags
 & 0x20 )

37287 
rc
 = 
	`saveAllCursors
(
pBt
, 
pCur
->
pgnoRoot
, pCur);

37288 if( 
rc
 ) return rc;

37291 if( 
pCur
->
pKeyInfo
==0 )

37297 
	`invalidateIncrblobCursors
(
p
, 
nKey
, 0);

37302 if( (
pCur
->
curFlags
&0x02)!=0 && 
nKey
>0

37303 && 
pCur
->
info
.
nKey
==nKey-1 )

37306 
loc
 = -1;

37307 }else if( 
loc
==0 )

37310 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pCur
, 0, 
nKey
, 
appendBias
, &
loc
);

37311 if( 
rc
 ) return rc;

37313 }else if( 
loc
==0 )

37316 
rc
 = 
	`btreeMoveto
(
pCur
, 
pKey
, 
nKey
, 
appendBias
, &
loc
);

37317 if( 
rc
 ) return rc;

37321 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

37329 
newCell
 = 
pBt
->
pTmpSpace
;

37331 
rc
 = 
	`fillInCell
(
pPage
, 
newCell
, 
pKey
, 
nKey
, 
pData
, 
nData
, 
nZero
, &
szNew
);

37332 if( 
rc
 ) goto 
end_insert
;

37335 
idx
 = 
pCur
->
aiIdx
[pCur->
iPage
];

37336 if( 
loc
==0 )

37339 
u16
 
szOld
;

37341 
rc
 = 
	`sqlite3PagerWrite
(
pPage
->
pDbPage
);

37342 if( 
rc
 )

37345 goto 
end_insert
;

37347 
oldCell
 = ((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
idx
)]))));

37348 if( !
pPage
->
leaf
 )

37351 
	`memcpy
(
newCell
, 
oldCell
, 4);

37353 
rc
 = 
	`clearCell
(
pPage
, 
oldCell
, &
szOld
);

37354 
	`dropCell
(
pPage
, 
idx
, 
szOld
, &
rc
);

37355 if( 
rc
 ) goto 
end_insert
;

37356 }else if( 
loc
<0 && 
pPage
->
nCell
>0 )

37360 
idx
 = ++
pCur
->
aiIdx
[pCur->
iPage
];

37364 
	`insertCell
(
pPage
, 
idx
, 
newCell
, 
szNew
, 0, 0, &
rc
);

37367 
pCur
->
info
.
nSize
 = 0;

37368 if( 
rc
==0 && 
pPage
->
nOverflow
 )

37371 
pCur
->
curFlags
 &= ~(0x02);

37372 
rc
 = 
	`balance
(
pCur
);

37378 
pCur
->
apPage
[pCur->
iPage
]->
nOverflow
 = 0;

37379 
pCur
->
eState
 = 0;

37383 
end_insert
:

37384 return 
rc
;

37385 
	}
}

37387 static int 
	$sqlite3BtreeDelete
(
BtCursor
 *
pCur
, 
u8
 
flags
)

37390 
Btree
 *
p
 = 
pCur
->
pBtree
;

37391 
BtShared
 *
pBt
 = 
p
->pBt;

37392 int 
rc
;

37393 
MemPage
 *
pPage
;

37394 unsigned char *
pCell
;

37395 int 
iCellIdx
;

37396 int 
iCellDepth
;

37397 
u16
 
szCell
;

37398 int 
bSkipnext
 = 0;

37399 
u8
 
bPreserve
 = 
flags
 & 0x02;

37411 
iCellDepth
 = 
pCur
->
iPage
;

37412 
iCellIdx
 = 
pCur
->
aiIdx
[
iCellDepth
];

37413 
pPage
 = 
pCur
->
apPage
[
iCellDepth
];

37414 
pCell
 = ((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
iCellIdx
)]))));

37416 if( !
pPage
->
leaf
 )

37419 int 
notUsed
 = 0;

37420 
rc
 = 
	`sqlite3BtreePrevious
(
pCur
, &
notUsed
);

37421 if( 
rc
 ) return rc;

37426 if( 
pCur
->
curFlags
 & 0x20 )

37429 
rc
 = 
	`saveAllCursors
(
pBt
, 
pCur
->
pgnoRoot
, pCur);

37430 if( 
rc
 ) return rc;

37435 if( 
pCur
->
pKeyInfo
==0 )

37438 
	`invalidateIncrblobCursors
(
p
, 
pCur
->
info
.
nKey
, 0);

37441 if( 
bPreserve
 )

37444 if( !
pPage
->
leaf


37445 || (
pPage
->
nFree
+
	`cellSizePtr
(pPage,
pCell
)+2)>(int)(
pBt
->
usableSize
*2/3)

37451 
rc
 = 
	`saveCursorKey
(
pCur
);

37452 if( 
rc
 ) return rc;

37454 
bSkipnext
 = 1;

37461 
rc
 = 
	`sqlite3PagerWrite
(
pPage
->
pDbPage
);

37462 if( 
rc
 ) return rc;

37463 
rc
 = 
	`clearCell
(
pPage
, 
pCell
, &
szCell
);

37464 
	`dropCell
(
pPage
, 
iCellIdx
, 
szCell
, &
rc
);

37465 if( 
rc
 ) return rc;

37472 if( !
pPage
->
leaf
 )

37475 
MemPage
 *
pLeaf
 = 
pCur
->
apPage
[pCur->
iPage
];

37476 int 
nCell
;

37477 
Pgno
 
n
 = 
pCur
->
apPage
[
iCellDepth
+1]->
pgno
;

37478 unsigned char *
pTmp
;

37480 
pCell
 = ((
pLeaf
)->
aData
 + ((pLeaf)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pLeaf)->
aCellIdx
[2*(pLeaf->
nCell
-1)]))));

37481 if( 
pCell
<&
pLeaf
->
aData
[4] ) return 
	`sqlite3CorruptError
(64012);

37482 
nCell
 = 
pLeaf
->
	`xCellSize
(pLeaf, 
pCell
);

37484 
pTmp
 = 
pBt
->
pTmpSpace
;

37486 
rc
 = 
	`sqlite3PagerWrite
(
pLeaf
->
pDbPage
);

37487 
	`insertCell
(
pPage
, 
iCellIdx
, 
pCell
-4, 
nCell
+4, 
pTmp
, 
n
, &
rc
);

37488 
	`dropCell
(
pLeaf
, pLeaf->
nCell
-1, nCell, &
rc
);

37489 if( 
rc
 ) return rc;

37492 
rc
 = 
	`balance
(
pCur
);

37493 if( 
rc
==0 && 
pCur
->
iPage
>
iCellDepth
 )

37496 while( 
pCur
->
iPage
>
iCellDepth
 )

37499 
	`releasePage
(
pCur
->
apPage
[pCur->
iPage
--]);

37501 
rc
 = 
	`balance
(
pCur
);

37504 if( 
rc
==0 )

37507 if( 
bSkipnext
 )

37513 
pCur
->
eState
 = 2;

37514 if( 
iCellIdx
>=
pPage
->
nCell
 )

37517 
pCur
->
skipNext
 = -1;

37518 
pCur
->
aiIdx
[
iCellDepth
] = 
pPage
->
nCell
-1;

37520 
pCur
->
skipNext
 = 1;

37523 
rc
 = 
	`moveToRoot
(
pCur
);

37524 if( 
bPreserve
 )

37527 
pCur
->
eState
 = 3;

37531 return 
rc
;

37532 
	}
}

37534 static int 
	$btreeCreateTable
(
Btree
 *
p
, int *
piTable
, int 
createTabFlags
)

37537 
BtShared
 *
pBt
 = 
p
->pBt;

37538 
MemPage
 *
pRoot
;

37539 
Pgno
 
pgnoRoot
;

37540 int 
rc
;

37541 int 
ptfFlags
;

37553 if( 
pBt
->
autoVacuum
 )

37556 
Pgno
 
pgnoMove
;

37557 
MemPage
 *
pPageMove
;

37564 
	`invalidateAllOverflowCache
(
pBt
);

37570 
	`sqlite3BtreeGetMeta
(
p
, 4, &
pgnoRoot
);

37571 
pgnoRoot
++;

37576 while( 
pgnoRoot
==
	`ptrmapPageno
(
pBt
, pgnoRoot) ||

37577 
pgnoRoot
==((
Pgno
)((
sqlite3PendingByte
/((
pBt
)->
pageSize
))+1)) )

37580 
pgnoRoot
++;

37589 
rc
 = 
	`allocateBtreePage
(
pBt
, &
pPageMove
, &
pgnoMove
, 
pgnoRoot
, 1);

37590 if( 
rc
!=0 )

37593 return 
rc
;

37596 if( 
pgnoMove
!=
pgnoRoot
 )

37605 
u8
 
eType
 = 0;

37606 
Pgno
 
iPtrPage
 = 0;

37611 
rc
 = 
	`saveAllCursors
(
pBt
, 0, 0);

37612 
	`releasePage
(
pPageMove
);

37613 if( 
rc
!=0 )

37616 return 
rc
;

37620 
rc
 = 
	`btreeGetPage
(
pBt
, 
pgnoRoot
, &
pRoot
, 0);

37621 if( 
rc
!=0 )

37624 return 
rc
;

37626 
rc
 = 
	`ptrmapGet
(
pBt
, 
pgnoRoot
, &
eType
, &
iPtrPage
);

37627 if( 
eType
==1 || eType==2 )

37630 
rc
 = 
	`sqlite3CorruptError
(64159);

37632 if( 
rc
!=0 )

37635 
	`releasePage
(
pRoot
);

37636 return 
rc
;

37640 
rc
 = 
	`relocatePage
(
pBt
, 
pRoot
, 
eType
, 
iPtrPage
, 
pgnoMove
, 0);

37641 
	`releasePage
(
pRoot
);

37644 if( 
rc
!=0 )

37647 return 
rc
;

37649 
rc
 = 
	`btreeGetPage
(
pBt
, 
pgnoRoot
, &
pRoot
, 0);

37650 if( 
rc
!=0 )

37653 return 
rc
;

37655 
rc
 = 
	`sqlite3PagerWrite
(
pRoot
->
pDbPage
);

37656 if( 
rc
!=0 )

37659 
	`releasePage
(
pRoot
);

37660 return 
rc
;

37663 
pRoot
 = 
pPageMove
;

37667 
	`ptrmapPut
(
pBt
, 
pgnoRoot
, 1, 0, &
rc
);

37668 if( 
rc
 )

37671 
	`releasePage
(
pRoot
);

37672 return 
rc
;

37680 
rc
 = 
	`sqlite3BtreeUpdateMeta
(
p
, 4, 
pgnoRoot
);

37681 if( (
rc
) )

37684 
	`releasePage
(
pRoot
);

37685 return 
rc
;

37689 
rc
 = 
	`allocateBtreePage
(
pBt
, &
pRoot
, &
pgnoRoot
, 1, 0);

37690 if( 
rc
 ) return rc;

37694 if( 
createTabFlags
 & 1 )

37697 
ptfFlags
 = 0x01 | 0x04 | 0x08;

37699 
ptfFlags
 = 0x02 | 0x08;

37701 
	`zeroPage
(
pRoot
, 
ptfFlags
);

37702 
	`sqlite3PagerUnref
(
pRoot
->
pDbPage
);

37704 *
piTable
 = (int)
pgnoRoot
;

37706 
	}
}

37707 static int 
	$sqlite3BtreeCreateTable
(
Btree
 *
p
, int *
piTable
, int 
flags
)

37710 int 
rc
;

37711 
	`sqlite3BtreeEnter
(
p
);

37712 
rc
 = 
	`btreeCreateTable
(
p
, 
piTable
, 
flags
);

37713 
	`sqlite3BtreeLeave
(
p
);

37714 return 
rc
;

37715 
	}
}

37721 static int 
	$clearDatabasePage
(

37722 
BtShared
 *
pBt
,

37723 
Pgno
 
pgno
,

37724 int 
freePageFlag
,

37725 int *
pnChange


37729 
MemPage
 *
pPage
;

37730 int 
rc
;

37731 unsigned char *
pCell
;

37732 int 
i
;

37733 int 
hdr
;

37734 
u16
 
szCell
;

37737 if( 
pgno
>
	`btreePagecount
(
pBt
) )

37740 return 
	`sqlite3CorruptError
(64249);

37742 
rc
 = 
	`getAndInitPage
(
pBt
, 
pgno
, &
pPage
, 0, 0);

37743 if( 
rc
 ) return rc;

37744 if( 
pPage
->
bBusy
 )

37747 
rc
 = 
	`sqlite3CorruptError
(64254);

37748 goto 
cleardatabasepage_out
;

37750 
pPage
->
bBusy
 = 1;

37751 
hdr
 = 
pPage
->
hdrOffset
;

37752 for(
i
=0; i<
pPage
->
nCell
; i++)

37755 
pCell
 = ((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
i
)]))));

37756 if( !
pPage
->
leaf
 )

37759 
rc
 = 
	`clearDatabasePage
(
pBt
, 
	`sqlite3Get4byte
(
pCell
), 1, 
pnChange
);

37760 if( 
rc
 ) goto 
cleardatabasepage_out
;

37762 
rc
 = 
	`clearCell
(
pPage
, 
pCell
, &
szCell
);

37763 if( 
rc
 ) goto 
cleardatabasepage_out
;

37765 if( !
pPage
->
leaf
 )

37768 
rc
 = 
	`clearDatabasePage
(
pBt
, 
	`sqlite3Get4byte
(&
pPage
->
aData
[
hdr
+8]), 1, 
pnChange
);

37769 if( 
rc
 ) goto 
cleardatabasepage_out
;

37770 }else if( 
pnChange
 )

37775 *
pnChange
 += 
pPage
->
nCell
;

37777 if( 
freePageFlag
 )

37780 
	`freePage
(
pPage
, &
rc
);

37781 }else if( (
rc
 = 
	`sqlite3PagerWrite
(
pPage
->
pDbPage
))==0 )

37784 
	`zeroPage
(
pPage
, pPage->
aData
[
hdr
] | 0x08);

37787 
cleardatabasepage_out
:

37788 
pPage
->
bBusy
 = 0;

37789 
	`releasePage
(
pPage
);

37790 return 
rc
;

37791 
	}
}

37793 static int 
	$sqlite3BtreeClearTable
(
Btree
 *
p
, int 
iTable
, int *
pnChange
)

37796 int 
rc
;

37797 
BtShared
 *
pBt
 = 
p
->pBt;

37798 
	`sqlite3BtreeEnter
(
p
);

37801 
rc
 = 
	`saveAllCursors
(
pBt
, (
Pgno
)
iTable
, 0);

37803 if( 0==
rc
 )

37809 
	`invalidateIncrblobCursors
(
p
, 0, 1);

37810 
rc
 = 
	`clearDatabasePage
(
pBt
, (
Pgno
)
iTable
, 0, 
pnChange
);

37812 
	`sqlite3BtreeLeave
(
p
);

37813 return 
rc
;

37814 
	}
}

37821 static int 
	$sqlite3BtreeClearTableOfCursor
(
BtCursor
 *
pCur
)

37824 return 
	`sqlite3BtreeClearTable
(
pCur
->
pBtree
, pCur->
pgnoRoot
, 0);

37825 
	}
}

37827 static int 
	$btreeDropTable
(
Btree
 *
p
, 
Pgno
 
iTable
, int *
piMoved
)

37830 int 
rc
;

37831 
MemPage
 *
pPage
 = 0;

37832 
BtShared
 *
pBt
 = 
p
->pBt;

37837 if( (
pBt
->
pCursor
) )

37848 if( (
iTable
<2) )

37851 return 
	`sqlite3CorruptError
(64375);

37854 
rc
 = 
	`btreeGetPage
(
pBt
, (
Pgno
)
iTable
, &
pPage
, 0);

37855 if( 
rc
 ) return rc;

37856 
rc
 = 
	`sqlite3BtreeClearTable
(
p
, 
iTable
, 0);

37857 if( 
rc
 )

37860 
	`releasePage
(
pPage
);

37861 return 
rc
;

37864 *
piMoved
 = 0;

37870 if( 
pBt
->
autoVacuum
 )

37873 
Pgno
 
maxRootPgno
;

37874 
	`sqlite3BtreeGetMeta
(
p
, 4, &
maxRootPgno
);

37876 if( 
iTable
==
maxRootPgno
 )

37882 
	`freePage
(
pPage
, &
rc
);

37883 
	`releasePage
(
pPage
);

37884 if( 
rc
!=0 )

37887 return 
rc
;

37894 
MemPage
 *
pMove
;

37895 
	`releasePage
(
pPage
);

37896 
rc
 = 
	`btreeGetPage
(
pBt
, 
maxRootPgno
, &
pMove
, 0);

37897 if( 
rc
!=0 )

37900 return 
rc
;

37902 
rc
 = 
	`relocatePage
(
pBt
, 
pMove
, 1, 0, 
iTable
, 0);

37903 
	`releasePage
(
pMove
);

37904 if( 
rc
!=0 )

37907 return 
rc
;

37909 
pMove
 = 0;

37910 
rc
 = 
	`btreeGetPage
(
pBt
, 
maxRootPgno
, &
pMove
, 0);

37911 
	`freePage
(
pMove
, &
rc
);

37912 
	`releasePage
(
pMove
);

37913 if( 
rc
!=0 )

37916 return 
rc
;

37918 *
piMoved
 = 
maxRootPgno
;

37926 
maxRootPgno
--;

37927 while( 
maxRootPgno
==((
Pgno
)((
sqlite3PendingByte
/((
pBt
)->
pageSize
))+1))

37928 || (
	`ptrmapPageno
((
pBt
), (
maxRootPgno
))==(maxRootPgno)) )

37931 
maxRootPgno
--;

37935 
rc
 = 
	`sqlite3BtreeUpdateMeta
(
p
, 4, 
maxRootPgno
);

37937 
	`freePage
(
pPage
, &
rc
);

37938 
	`releasePage
(
pPage
);

37941 return 
rc
;

37942 
	}
}

37943 static int 
	$sqlite3BtreeDropTable
(
Btree
 *
p
, int 
iTable
, int *
piMoved
)

37946 int 
rc
;

37947 
	`sqlite3BtreeEnter
(
p
);

37948 
rc
 = 
	`btreeDropTable
(
p
, 
iTable
, 
piMoved
);

37949 
	`sqlite3BtreeLeave
(
p
);

37950 return 
rc
;

37951 
	}
}

37953 static void 
	$sqlite3BtreeGetMeta
(
Btree
 *
p
, int 
idx
, 
u32
 *
pMeta
)

37956 
BtShared
 *
pBt
 = 
p
->pBt;

37958 
	`sqlite3BtreeEnter
(
p
);

37964 if( 
idx
==15 )

37967 *
pMeta
 = 
	`sqlite3PagerDataVersion
(
pBt
->
pPager
) + 
p
->
iDataVersion
;

37969 *
pMeta
 = 
	`sqlite3Get4byte
(&
pBt
->
pPage1
->
aData
[36 + 
idx
*4]);

37972 
	`sqlite3BtreeLeave
(
p
);

37973 
	}
}

37979 static int 
	$sqlite3BtreeUpdateMeta
(
Btree
 *
p
, int 
idx
, 
u32
 
iMeta
)

37982 
BtShared
 *
pBt
 = 
p
->pBt;

37983 unsigned char *
pP1
;

37984 int 
rc
;

37986 
	`sqlite3BtreeEnter
(
p
);

37989 
pP1
 = 
pBt
->
pPage1
->
aData
;

37990 
rc
 = 
	`sqlite3PagerWrite
(
pBt
->
pPage1
->
pDbPage
);

37991 if( 
rc
==0 )

37994 
	`sqlite3Put4byte
(&
pP1
[36 + 
idx
*4], 
iMeta
);

37996 if( 
idx
==7 )

38001 
pBt
->
incrVacuum
 = (
u8
)
iMeta
;

38005 
	`sqlite3BtreeLeave
(
p
);

38006 return 
rc
;

38007 
	}
}

38009 static int 
	$sqlite3BtreeCount
(
BtCursor
 *
pCur
, 
i64
 *
pnEntry
)

38012 
i64
 
nEntry
 = 0;

38013 int 
rc
;

38015 if( 
pCur
->
pgnoRoot
==0 )

38018 *
pnEntry
 = 0;

38021 
rc
 = 
	`moveToRoot
(
pCur
);

38026 while( 
rc
==0 )

38029 int 
iIdx
;

38030 
MemPage
 *
pPage
;

38036 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

38037 if( 
pPage
->
leaf
 || !pPage->
intKey
 )

38040 
nEntry
 += 
pPage
->
nCell
;

38043 if( 
pPage
->
leaf
 )

38047 if( 
pCur
->
iPage
==0 )

38051 *
pnEntry
 = 
nEntry
;

38052 return 
	`moveToRoot
(
pCur
);

38054 
	`moveToParent
(
pCur
);

38055 }while ( 
pCur
->
aiIdx
[pCur->
iPage
]>=pCur->
apPage
[pCur->iPage]->
nCell
 );

38057 
pCur
->
aiIdx
[pCur->
iPage
]++;

38058 
pPage
 = 
pCur
->
apPage
[pCur->
iPage
];

38064 
iIdx
 = 
pCur
->
aiIdx
[pCur->
iPage
];

38065 if( 
iIdx
==
pPage
->
nCell
 )

38068 
rc
 = 
	`moveToChild
(
pCur
, 
	`sqlite3Get4byte
(&
pPage
->
aData
[pPage->
hdrOffset
+8]));

38070 
rc
 = 
	`moveToChild
(
pCur
, 
	`sqlite3Get4byte
(((
pPage
)->
aData
 + ((pPage)->
maskPage
 & 
	`__builtin_bswap16
(*(
u16
*)(&(pPage)->
aCellIdx
[2*(
iIdx
)]))))));

38075 return 
rc
;

38076 
	}
}

38083 static 
Pager
 *
	$sqlite3BtreePager
(
Btree
 *
p
)

38086 return 
p
->
pBt
->
pPager
;

38087 
	}
}

38093 static void 
	$checkAppendMsg
(

38094 
IntegrityCk
 *
pCheck
,

38095 const char *
zFormat
,

38100 
va_list
 
ap
;

38101 if( !
pCheck
->
mxErr
 ) return;

38102 
pCheck
->
mxErr
--;

38103 
pCheck
->
nErr
++;

38104 
	`__builtin_va_start
(
ap
,
zFormat
);

38105 if( 
pCheck
->
errMsg
.
nChar
 )

38108 
	`sqlite3StrAccumAppend
(&
pCheck
->
errMsg
, "\n", 1);

38110 if( 
pCheck
->
zPfx
 )

38113 
	`sqlite3XPrintf
(&
pCheck
->
errMsg
, pCheck->
zPfx
, pCheck->
v1
, pCheck->
v2
);

38115 
	`sqlite3VXPrintf
(&
pCheck
->
errMsg
, 
zFormat
, 
ap
);

38116 
	`__builtin_va_end
(
ap
);

38117 if( 
pCheck
->
errMsg
.
accError
==1 )

38120 
pCheck
->
mallocFailed
 = 1;

38122 
	}
}

38124 static int 
	$getPageReferenced
(
IntegrityCk
 *
pCheck
, 
Pgno
 
iPg
)

38128 return (
pCheck
->
aPgRef
[
iPg
/8] & (1 << (iPg & 0x07)));

38129 
	}
}

38134 static void 
	$setPageReferenced
(
IntegrityCk
 *
pCheck
, 
Pgno
 
iPg
)

38138 
pCheck
->
aPgRef
[
iPg
/8] |= (1 << (iPg & 0x07));

38139 
	}
}

38141 static int 
	$checkRef
(
IntegrityCk
 *
pCheck
, 
Pgno
 
iPage
)

38144 if( 
iPage
==0 ) return 1;

38145 if( 
iPage
>
pCheck
->
nPage
 )

38148 
	`checkAppendMsg
(
pCheck
, "invalid page number %d", 
iPage
);

38151 if( 
	`getPageReferenced
(
pCheck
, 
iPage
) )

38154 
	`checkAppendMsg
(
pCheck
, "2nd reference to page %d", 
iPage
);

38157 
	`setPageReferenced
(
pCheck
, 
iPage
);

38159 
	}
}

38167 static void 
	$checkPtrmap
(

38168 
IntegrityCk
 *
pCheck
,

38169 
Pgno
 
iChild
,

38170 
u8
 
eType
,

38171 
Pgno
 
iParent


38175 int 
rc
;

38176 
u8
 
ePtrmapType
;

38177 
Pgno
 
iPtrmapParent
;

38179 
rc
 = 
	`ptrmapGet
(
pCheck
->
pBt
, 
iChild
, &
ePtrmapType
, &
iPtrmapParent
);

38180 if( 
rc
!=0 )

38183 if( 
rc
==7 || rc==(10 | (12<<8)) ) 
pCheck
->
mallocFailed
 = 1;

38184 
	`checkAppendMsg
(
pCheck
, "Failed to read ptrmap key=%d", 
iChild
);

38188 if( 
ePtrmapType
!=
eType
 || 
iPtrmapParent
!=
iParent
 )

38191 
	`checkAppendMsg
(
pCheck
,

38193 
iChild
, 
eType
, 
iParent
, 
ePtrmapType
, 
iPtrmapParent
);

38195 
	}
}

38202 static void 
	$checkList
(

38203 
IntegrityCk
 *
pCheck
,

38204 int 
isFreeList
,

38205 int 
iPage
,

38206 int 
N


38210 int 
i
;

38211 int 
expected
 = 
N
;

38212 int 
iFirst
 = 
iPage
;

38213 while( 
N
-- > 0 && 
pCheck
->
mxErr
 )

38216 
DbPage
 *
pOvflPage
;

38217 unsigned char *
pOvflData
;

38218 if( 
iPage
<1 )

38221 
	`checkAppendMsg
(
pCheck
,

38223 
N
+1, 
expected
, 
iFirst
);

38226 if( 
	`checkRef
(
pCheck
, 
iPage
) ) break;

38227 if( 
	`sqlite3PagerGet
(
pCheck
->
pPager
, (
Pgno
)
iPage
, &
pOvflPage
, 0) )

38230 
	`checkAppendMsg
(
pCheck
, "failed to get page %d", 
iPage
);

38233 
pOvflData
 = (unsigned char *)
	`sqlite3PagerGetData
(
pOvflPage
);

38234 if( 
isFreeList
 )

38237 int 
n
 = 
	`sqlite3Get4byte
(&
pOvflData
[4]);

38239 if( 
pCheck
->
pBt
->
autoVacuum
 )

38242 
	`checkPtrmap
(
pCheck
, 
iPage
, 2, 0);

38245 if( 
n
>(int)
pCheck
->
pBt
->
usableSize
/4-2 )

38248 
	`checkAppendMsg
(
pCheck
,

38249 "freelist leaf count too big on page %d", 
iPage
);

38250 
N
--;

38252 for(
i
=0; i<
n
; i++)

38255 
Pgno
 
iFreePage
 = 
	`sqlite3Get4byte
(&
pOvflData
[8+
i
*4]);

38257 if( 
pCheck
->
pBt
->
autoVacuum
 )

38260 
	`checkPtrmap
(
pCheck
, 
iFreePage
, 2, 0);

38263 
	`checkRef
(
pCheck
, 
iFreePage
);

38265 
N
 -= 
n
;

38274 if( 
pCheck
->
pBt
->
autoVacuum
 && 
N
>0 )

38277 
i
 = 
	`sqlite3Get4byte
(
pOvflData
);

38278 
	`checkPtrmap
(
pCheck
, 
i
, 4, 
iPage
);

38282 
iPage
 = 
	`sqlite3Get4byte
(
pOvflData
);

38283 
	`sqlite3PagerUnref
(
pOvflPage
);

38285 if( 
isFreeList
 && 
N
<(
iPage
!=0) )

38288 
	`checkAppendMsg
(
pCheck
, "free-page count in header is too small");

38291 
	}
}

38293 static void 
	$btreeHeapInsert
(
u32
 *
aHeap
, u32 
x
)

38296 
u32
 
j
, 
i
 = ++
aHeap
[0];

38297 
aHeap
[
i
] = 
x
;

38298 while( (
j
 = 
i
/2)>0 && 
aHeap
[j]>aHeap[i] )

38301 
x
 = 
aHeap
[
j
];

38302 
aHeap
[
j
] = aHeap[
i
];

38303 
aHeap
[
i
] = 
x
;

38304 
i
 = 
j
;

38306 
	}
}

38307 static int 
	$btreeHeapPull
(
u32
 *
aHeap
, u32 *
pOut
)

38310 
u32
 
j
, 
i
, 
x
;

38311 if( (
x
 = 
aHeap
[0])==0 ) return 0;

38312 *
pOut
 = 
aHeap
[1];

38313 
aHeap
[1] = aHeap[
x
];

38314 
aHeap
[
x
] = 0xffffffff;

38315 
aHeap
[0]--;

38316 
i
 = 1;

38317 while( (
j
 = 
i
*2)<=
aHeap
[0] )

38320 if( 
aHeap
[
j
]>aHeap[j+1] ) j++;

38321 if( 
aHeap
[
i
]<aHeap[
j
] ) break;

38322 
x
 = 
aHeap
[
i
];

38323 
aHeap
[
i
] = aHeap[
j
];

38324 
aHeap
[
j
] = 
x
;

38325 
i
 = 
j
;

38328 
	}
}

38330 static int 
	$checkTreePage
(

38331 
IntegrityCk
 *
pCheck
,

38332 int 
iPage
,

38333 
i64
 *
piMinKey
,

38334 
i64
 
maxKey


38338 
MemPage
 *
pPage
 = 0;

38339 int 
i
;

38340 int 
rc
;

38341 int 
depth
 = -1, 
d2
;

38342 int 
pgno
;

38343 int 
nFrag
;

38344 int 
hdr
;

38345 int 
cellStart
;

38346 int 
nCell
;

38347 int 
doCoverageCheck
 = 1;

38348 int 
keyCanBeEqual
 = 1;

38350 
u8
 *
data
;

38351 
u8
 *
pCell
;

38352 
u8
 *
pCellIdx
;

38353 
BtShared
 *
pBt
;

38354 
u32
 
pc
;

38355 
u32
 
usableSize
;

38356 
u32
 
contentOffset
;

38357 
u32
 *
heap
 = 0;

38358 
u32
 
x
, 
prev
 = 0;

38359 const char *
saved_zPfx
 = 
pCheck
->
zPfx
;

38360 int 
saved_v1
 = 
pCheck
->
v1
;

38361 int 
saved_v2
 = 
pCheck
->
v2
;

38362 
u8
 
savedIsInit
 = 0;

38366 
pBt
 = 
pCheck
->pBt;

38367 
usableSize
 = 
pBt
->usableSize;

38368 if( 
iPage
==0 ) return 0;

38369 if( 
	`checkRef
(
pCheck
, 
iPage
) ) return 0;

38370 
pCheck
->
zPfx
 = "Page %d: ";

38371 
pCheck
->
v1
 = 
iPage
;

38372 if( (
rc
 = 
	`btreeGetPage
(
pBt
, (
Pgno
)
iPage
, &
pPage
, 0))!=0 )

38375 
	`checkAppendMsg
(
pCheck
,

38376 "unable to get the page. error code=%d", 
rc
);

38377 goto 
end_of_check
;

38382 
savedIsInit
 = 
pPage
->
isInit
;

38383 
pPage
->
isInit
 = 0;

38384 if( (
rc
 = 
	`btreeInitPage
(
pPage
))!=0 )

38388 
	`checkAppendMsg
(
pCheck
,

38389 "btreeInitPage() returns error code %d", 
rc
);

38390 goto 
end_of_check
;

38392 
data
 = 
pPage
->
aData
;

38393 
hdr
 = 
pPage
->
hdrOffset
;

38396 
pCheck
->
zPfx
 = "On tree page %d cell %d: ";

38397 
contentOffset
 = (((((int)((&
data
[
hdr
+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);

38402 
nCell
 = ((&
data
[
hdr
+3])[0]<<8 | (&data[hdr+3])[1]);

38407 
cellStart
 = 
hdr
 + 12 - 4*
pPage
->
leaf
;

38409 
pCellIdx
 = &
data
[
cellStart
 + 2*(
nCell
-1)];

38411 if( !
pPage
->
leaf
 )

38415 
pgno
 = 
	`sqlite3Get4byte
(&
data
[
hdr
+8]);

38417 if( 
pBt
->
autoVacuum
 )

38420 
pCheck
->
zPfx
 = "On page %d at right child: ";

38421 
	`checkPtrmap
(
pCheck
, 
pgno
, 5, 
iPage
);

38424 
depth
 = 
	`checkTreePage
(
pCheck
, 
pgno
, &
maxKey
, maxKey);

38425 
keyCanBeEqual
 = 0;

38429 
heap
 = 
pCheck
->heap;

38430 
heap
[0] = 0;

38435 for(
i
=
nCell
-1; i>=0 && 
pCheck
->
mxErr
; i--)

38438 
CellInfo
 
info
;

38441 
pCheck
->
v2
 = 
i
;

38443 
pc
 = 
	`__builtin_bswap16
(*(
u16
*)(
pCellIdx
));

38444 
pCellIdx
 -= 2;

38445 if( 
pc
<
contentOffset
 || pc>
usableSize
-4 )

38448 
	`checkAppendMsg
(
pCheck
, "Offset %d out of range %d..%d",

38449 
pc
, 
contentOffset
, 
usableSize
-4);

38450 
doCoverageCheck
 = 0;

38453 
pCell
 = &
data
[
pc
];

38454 
pPage
->
	`xParseCell
(pPage, 
pCell
, &
info
);

38455 if( 
pc
+
info
.
nSize
>
usableSize
 )

38458 
	`checkAppendMsg
(
pCheck
, "Extends off end of page");

38459 
doCoverageCheck
 = 0;

38464 if( 
pPage
->
intKey
 )

38467 if( 
keyCanBeEqual
 ? (
info
.
nKey
 > 
maxKey
) : (info.nKey >= maxKey) )

38470 
	`checkAppendMsg
(
pCheck
, "Rowid %lld out of order", 
info
.
nKey
);

38472 
maxKey
 = 
info
.
nKey
;

38476 if( 
info
.
nPayload
>info.
nLocal
 )

38479 int 
nPage
;

38480 
Pgno
 
pgnoOvfl
;

38482 
nPage
 = (
info
.
nPayload
 - info.
nLocal
 + 
usableSize
 - 5)/(usableSize - 4);

38483 
pgnoOvfl
 = 
	`sqlite3Get4byte
(&
pCell
[
info
.
nSize
 - 4]);

38485 if( 
pBt
->
autoVacuum
 )

38488 
	`checkPtrmap
(
pCheck
, 
pgnoOvfl
, 3, 
iPage
);

38491 
	`checkList
(
pCheck
, 0, 
pgnoOvfl
, 
nPage
);

38494 if( !
pPage
->
leaf
 )

38498 
pgno
 = 
	`sqlite3Get4byte
(
pCell
);

38500 if( 
pBt
->
autoVacuum
 )

38503 
	`checkPtrmap
(
pCheck
, 
pgno
, 5, 
iPage
);

38506 
d2
 = 
	`checkTreePage
(
pCheck
, 
pgno
, &
maxKey
, maxKey);

38507 
keyCanBeEqual
 = 0;

38508 if( 
d2
!=
depth
 )

38511 
	`checkAppendMsg
(
pCheck
, "Child page depth differs");

38512 
depth
 = 
d2
;

38516 
	`btreeHeapInsert
(
heap
, (
pc
<<16)|(pc+
info
.
nSize
-1));

38519 *
piMinKey
 = 
maxKey
;

38523 
pCheck
->
zPfx
 = 0;

38524 if( 
doCoverageCheck
 && 
pCheck
->
mxErr
>0 )

38530 if( !
pPage
->
leaf
 )

38533 
heap
 = 
pCheck
->heap;

38534 
heap
[0] = 0;

38535 for(
i
=
nCell
-1; i>=0; i--)

38538 
u32
 
size
;

38539 
pc
 = 
	`__builtin_bswap16
(*(
u16
*)(&
data
[
cellStart
+
i
*2]));

38540 
size
 = 
pPage
->
	`xCellSize
(pPage, &
data
[
pc
]);

38541 
	`btreeHeapInsert
(
heap
, (
pc
<<16)|(pc+
size
-1));

38550 
i
 = ((&
data
[
hdr
+1])[0]<<8 | (&data[hdr+1])[1]);

38551 while( 
i
>0 )

38554 int 
size
, 
j
;

38556 
size
 = ((&
data
[
i
+2])[0]<<8 | (&data[i+2])[1]);

38558 
	`btreeHeapInsert
(
heap
, (((
u32
)
i
)<<16)|(i+
size
-1));

38563 
j
 = ((&
data
[
i
])[0]<<8 | (&data[i])[1]);

38568 
i
 = 
j
;

38571 
nFrag
 = 0;

38572 
prev
 = 
contentOffset
 - 1;

38573 while( 
	`btreeHeapPull
(
heap
,&
x
) )

38576 if( (
prev
&0xffff)>=(
x
>>16) )

38579 
	`checkAppendMsg
(
pCheck
,

38580 "Multiple uses for byte %u of page %d", 
x
>>16, 
iPage
);

38583 
nFrag
 += (
x
>>16) - (
prev
&0xffff) - 1;

38584 
prev
 = 
x
;

38587 
nFrag
 += 
usableSize
 - (
prev
&0xffff) - 1;

38593 if( 
heap
[0]==0 && 
nFrag
!=
data
[
hdr
+7] )

38596 
	`checkAppendMsg
(
pCheck
,

38598 
nFrag
, 
data
[
hdr
+7], 
iPage
);

38602 
end_of_check
:

38603 if( !
doCoverageCheck
 ) 
pPage
->
isInit
 = 
savedIsInit
;

38604 
	`releasePage
(
pPage
);

38605 
pCheck
->
zPfx
 = 
saved_zPfx
;

38606 
pCheck
->
v1
 = 
saved_v1
;

38607 
pCheck
->
v2
 = 
saved_v2
;

38608 return 
depth
+1;

38609 
	}
}

38611 static char *
	$sqlite3BtreeIntegrityCheck
(

38612 
Btree
 *
p
,

38613 int *
aRoot
,

38614 int 
nRoot
,

38615 int 
mxErr
,

38616 int *
pnErr


38620 
Pgno
 
i
;

38621 
IntegrityCk
 
sCheck
;

38622 
BtShared
 *
pBt
 = 
p
->pBt;

38623 int 
savedDbFlags
 = 
pBt
->
db
->
flags
;

38624 char 
zErr
[100];

38627 
	`sqlite3BtreeEnter
(
p
);

38631 
sCheck
.
pBt
 = pBt;

38632 
sCheck
.
pPager
 = 
pBt
->pPager;

38633 
sCheck
.
nPage
 = 
	`btreePagecount
(sCheck.
pBt
);

38634 
sCheck
.
mxErr
 = mxErr;

38635 
sCheck
.
nErr
 = 0;

38636 
sCheck
.
mallocFailed
 = 0;

38637 
sCheck
.
zPfx
 = 0;

38638 
sCheck
.
v1
 = 0;

38639 
sCheck
.
v2
 = 0;

38640 
sCheck
.
aPgRef
 = 0;

38641 
sCheck
.
heap
 = 0;

38642 
	`sqlite3StrAccumInit
(&
sCheck
.
errMsg
, 0, 
zErr
, sizeof(zErr), 1000000000);

38643 
sCheck
.
errMsg
.
printfFlags
 = 0x01;

38644 if( 
sCheck
.
nPage
==0 )

38647 goto 
integrity_ck_cleanup
;

38650 
sCheck
.
aPgRef
 = 
	`sqlite3MallocZero
((sCheck.
nPage
 / 8)+ 1);

38651 if( !
sCheck
.
aPgRef
 )

38654 
sCheck
.
mallocFailed
 = 1;

38655 goto 
integrity_ck_cleanup
;

38657 
sCheck
.
heap
 = (
u32
*)
	`sqlite3PageMalloc
( 
pBt
->
pageSize
 );

38658 if( 
sCheck
.
heap
==0 )

38661 
sCheck
.
mallocFailed
 = 1;

38662 goto 
integrity_ck_cleanup
;

38665 
i
 = ((
Pgno
)((
sqlite3PendingByte
/((
pBt
)->
pageSize
))+1));

38666 if( 
i
<=
sCheck
.
nPage
 ) 
	`setPageReferenced
(&sCheck, i);

38670 
sCheck
.
zPfx
 = "Main freelist: ";

38671 
	`checkList
(&
sCheck
, 1, 
	`sqlite3Get4byte
(&
pBt
->
pPage1
->
aData
[32]),

38672 
	`sqlite3Get4byte
(&
pBt
->
pPage1
->
aData
[36]));

38673 
sCheck
.
zPfx
 = 0;

38678 
pBt
->
db
->
flags
 &= ~0x10000000;

38679 for(
i
=0; (int)i<
nRoot
 && 
sCheck
.
mxErr
; i++)

38682 
i64
 
notUsed
;

38683 if( 
aRoot
[
i
]==0 ) continue;

38685 if( 
pBt
->
autoVacuum
 && 
aRoot
[
i
]>1 )

38688 
	`checkPtrmap
(&
sCheck
, 
aRoot
[
i
], 1, 0);

38691 
	`checkTreePage
(&
sCheck
, 
aRoot
[
i
], &
notUsed
, (0xffffffff|(((
i64
)0x7fffffff)<<32)));

38693 
pBt
->
db
->
flags
 = 
savedDbFlags
;

38697 for(
i
=1; i<=
sCheck
.
nPage
 && sCheck.
mxErr
; i++)

38701 if( 
	`getPageReferenced
(&
sCheck
, 
i
)==0 &&

38702 (
	`ptrmapPageno
(
pBt
, 
i
)!=i || !pBt->
autoVacuum
) )

38705 
	`checkAppendMsg
(&
sCheck
, "Page %d is never used", 
i
);

38707 if( 
	`getPageReferenced
(&
sCheck
, 
i
)!=0 &&

38708 (
	`ptrmapPageno
(
pBt
, 
i
)==i && pBt->
autoVacuum
) )

38711 
	`checkAppendMsg
(&
sCheck
, "Pointer map page %d is referenced", 
i
);

38718 
integrity_ck_cleanup
:

38719 
	`sqlite3PageFree
(
sCheck
.
heap
);

38720 
	`sqlite3_free
(
sCheck
.
aPgRef
);

38721 if( 
sCheck
.
mallocFailed
 )

38724 
	`sqlite3StrAccumReset
(&
sCheck
.
errMsg
);

38725 
sCheck
.
nErr
++;

38727 *
pnErr
 = 
sCheck
.
nErr
;

38728 if( 
sCheck
.
nErr
==0 ) 
	`sqlite3StrAccumReset
(&sCheck.
errMsg
);

38731 
	`sqlite3BtreeLeave
(
p
);

38732 return 
	`sqlite3StrAccumFinish
(&
sCheck
.
errMsg
);

38733 
	}
}

38735 static const char *
	$sqlite3BtreeGetFilename
(
Btree
 *
p
)

38739 return 
	`sqlite3PagerFilename
(
p
->
pBt
->
pPager
, 1);

38740 
	}
}

38742 static const char *
	$sqlite3BtreeGetJournalname
(
Btree
 *
p
)

38746 return 
	`sqlite3PagerJournalname
(
p
->
pBt
->
pPager
);

38747 
	}
}

38752 static int 
	$sqlite3BtreeIsInTrans
(
Btree
 *
p
)

38756 return (
p
 && (p->
inTrans
==2));

38757 
	}
}

38759 static int 
	$sqlite3BtreeCheckpoint
(
Btree
 *
p
, int 
eMode
, int *
pnLog
, int *
pnCkpt
)

38762 int 
rc
 = 0;

38763 if( 
p
 )

38766 
BtShared
 *
pBt
 = 
p
->pBt;

38767 
	`sqlite3BtreeEnter
(
p
);

38768 if( 
pBt
->
inTransaction
!=0 )

38771 
rc
 = 6;

38773 
rc
 = 
	`sqlite3PagerCheckpoint
(
pBt
->
pPager
, 
eMode
, 
pnLog
, 
pnCkpt
);

38775 
	`sqlite3BtreeLeave
(
p
);

38777 return 
rc
;

38778 
	}
}

38784 static int 
	$sqlite3BtreeIsInReadTrans
(
Btree
 *
p
)

38789 return 
p
->
inTrans
!=0;

38790 
	}
}

38792 static int 
	$sqlite3BtreeIsInBackup
(
Btree
 *
p
)

38797 return 
p
->
nBackup
!=0;

38798 
	}
}

38800 static void *
sqlite3BtreeSchema
(
Btree
 *
p
, int 
nBytes
, void(*
xFree
)(void *))

38803 
BtShared
 *
pBt
 = 
p
->pBt;

38804 
	`sqlite3BtreeEnter
(
p
);

38805 if( !
pBt
->
pSchema
 && 
nBytes
 )

38808 
pBt
->
pSchema
 = 
	`sqlite3DbMallocZero
(0, 
nBytes
);

38809 
pBt
->
xFreeSchema
 = 
xFree
;

38811 
	`sqlite3BtreeLeave
(
p
);

38812 return 
pBt
->
pSchema
;

38813 
	}
}

38820 static int 
	$sqlite3BtreeSchemaLocked
(
Btree
 *
p
)

38823 int 
rc
;

38825 
	`sqlite3BtreeEnter
(
p
);

38826 
rc
 = 
	`querySharedCacheTableLock
(
p
, 1, 1);

38828 
	`sqlite3BtreeLeave
(
p
);

38829 return 
rc
;

38830 
	}
}

38832 static int 
	$sqlite3BtreeLockTable
(
Btree
 *
p
, int 
iTab
, 
u8
 
isWriteLock
)

38835 int 
rc
 = 0;

38837 if( 
p
->
sharable
 )

38840 
u8
 
lockType
 = 1 + 
isWriteLock
;

38844 
	`sqlite3BtreeEnter
(
p
);

38845 
rc
 = 
	`querySharedCacheTableLock
(
p
, 
iTab
, 
lockType
);

38846 if( 
rc
==0 )

38849 
rc
 = 
	`setSharedCacheTableLock
(
p
, 
iTab
, 
lockType
);

38851 
	`sqlite3BtreeLeave
(
p
);

38853 return 
rc
;

38854 
	}
}

38856 static int 
	$sqlite3BtreePutData
(
BtCursor
 *
pCsr
, 
u32
 
offset
, u32 
amt
, void *
z
)

38859 int 
rc
;

38864 
rc
 = (
pCsr
->
eState
>=3 ? 
	`btreeRestoreCursorPosition
(pCsr) : 0);

38865 if( 
rc
!=0 )

38868 return 
rc
;

38871 if( 
pCsr
->
eState
!=1 )

38877 
	`saveAllCursors
(
pCsr
->
pBt
, pCsr->
pgnoRoot
, pCsr);

38880 if( (
pCsr
->
curFlags
 & 0x01)==0 )

38891 return 
	`accessPayload
(
pCsr
, 
offset
, 
amt
, (unsigned char *)
z
, 1);

38892 
	}
}

38897 static void 
	$sqlite3BtreeIncrblobCursor
(
BtCursor
 *
pCur
)

38900 
pCur
->
curFlags
 |= 0x10;

38901 
pCur
->
pBtree
->
hasIncrblobCur
 = 1;

38902 
	}
}

38910 static int 
	$sqlite3BtreeSetVersion
(
Btree
 *
pBtree
, int 
iVersion
)

38913 
BtShared
 *
pBt
 = 
pBtree
->pBt;

38914 int 
rc
;

38921 
pBt
->
btsFlags
 &= ~0x0010;

38922 if( 
iVersion
==1 ) 
pBt
->
btsFlags
 |= 0x0010;

38924 
rc
 = 
	`sqlite3BtreeBeginTrans
(
pBtree
, 0);

38925 if( 
rc
==0 )

38928 
u8
 *
aData
 = 
pBt
->
pPage1
->aData;

38929 if( 
aData
[18]!=(
u8
)
iVersion
 || aData[19]!=(u8)iVersion )

38932 
rc
 = 
	`sqlite3BtreeBeginTrans
(
pBtree
, 2);

38933 if( 
rc
==0 )

38936 
rc
 = 
	`sqlite3PagerWrite
(
pBt
->
pPage1
->
pDbPage
);

38937 if( 
rc
==0 )

38940 
aData
[18] = (
u8
)
iVersion
;

38941 
aData
[19] = (
u8
)
iVersion
;

38947 
pBt
->
btsFlags
 &= ~0x0010;

38948 return 
rc
;

38949 
	}
}

38955 static int 
	$sqlite3BtreeCursorHasHint
(
BtCursor
 *
pCsr
, unsigned int 
mask
)

38958 return (
pCsr
->
hints
 & 
mask
)!=0;

38959 
	}
}

38964 static int 
	$sqlite3BtreeIsReadonly
(
Btree
 *
p
)

38967 return (
p
->
pBt
->
btsFlags
 & 0x0001)!=0;

38968 
	}
}

38973 static int 
	$sqlite3HeaderSizeBtree
(void)

38975 return (((sizeof(
MemPage
))+7)&~7); 
	}
}

38981 static int 
	$sqlite3BtreeSharable
(
Btree
 *
p
)

38984 return 
p
->
sharable
;

38985 
	}
}

38987 struct 
	ssqlite3_backup
 {

38988 
sqlite3
* 
	mpDestDb
;

38989 
Btree
 *
	mpDest
;

38990 
u32
 
	miDestSchema
;

38991 int 
	mbDestLocked
;

38993 
Pgno
 
	miNext
;

38994 
sqlite3
* 
	mpSrcDb
;

38995 
Btree
 *
	mpSrc
;

38997 int 
	mrc
;

39002 
Pgno
 
	mnRemaining
;

39003 
Pgno
 
	mnPagecount
;

39005 int 
	misAttached
;

39006 
sqlite3_backup
 *
	mpNext
;

39009 static 
Btree
 *
	$findBtree
(
sqlite3
 *
pErrorDb
, sqlite3 *
pDb
, const char *
zDb
)

39012 int 
i
 = 
	`sqlite3FindDbName
(
pDb
, 
zDb
);

39014 if( 
i
==1 )

39017 
Parse
 *
pParse
;

39018 int 
rc
 = 0;

39019 
pParse
 = 
	`sqlite3DbMallocZero
(
pErrorDb
,sizeof(*pParse));

39020 if( 
pParse
==0 )

39023 
	`sqlite3ErrorWithMsg
(
pErrorDb
, 7, "out of memory");

39024 
rc
 = 7;

39026 
pParse
->
db
 = 
pDb
;

39027 if( 
	`sqlite3OpenTempDatabase
(
pParse
) )

39030 
	`sqlite3ErrorWithMsg
(
pErrorDb
, 
pParse
->
rc
, "%s", pParse->
zErrMsg
);

39031 
rc
 = 1;

39033 
	`sqlite3DbFree
(
pErrorDb
, 
pParse
->
zErrMsg
);

39034 
	`sqlite3ParserReset
(
pParse
);

39035 
	`sqlite3DbFree
(
pErrorDb
,
pParse
);

39037 if( 
rc
 )

39044 if( 
i
<0 )

39047 
	`sqlite3ErrorWithMsg
(
pErrorDb
, 1, "unknown database %s", 
zDb
);

39051 return 
pDb
->
aDb
[
i
].
pBt
;

39052 
	}
}

39058 static int 
	$setDestPgsz
(
sqlite3_backup
 *
p
)

39061 int 
rc
;

39062 
rc
 = 
	`sqlite3BtreeSetPageSize
(
p
->
pDest
,
	`sqlite3BtreeGetPageSize
(p->
pSrc
),-1,0);

39063 return 
rc
;

39064 
	}
}

39072 static int 
	$checkReadTransaction
(
sqlite3
 *
db
, 
Btree
 *
p
)

39075 if( 
	`sqlite3BtreeIsInReadTrans
(
p
) )

39078 
	`sqlite3ErrorWithMsg
(
db
, 1, "destination database is in use");

39082 
	}
}

39084 
sqlite3_backup
 * 
	$sqlite3_backup_init
(

39085 
sqlite3
* 
pDestDb
,

39086 const char *
zDestDb
,

39087 
sqlite3
* 
pSrcDb
,

39088 const char *
zSrcDb


39092 
sqlite3_backup
 *
p
;

39094 
	`sqlite3_mutex_enter
(
pSrcDb
->
mutex
);

39095 
	`sqlite3_mutex_enter
(
pDestDb
->
mutex
);

39097 if( 
pSrcDb
==
pDestDb
 )

39100 
	`sqlite3ErrorWithMsg
(

39101 
pDestDb
, 1, "source and destination must be distinct"

39103 
p
 = 0;

39109 
p
 = (
sqlite3_backup
 *)
	`sqlite3MallocZero
(sizeof(sqlite3_backup));

39110 if( !
p
 )

39113 
	`sqlite3Error
(
pDestDb
, 7);

39118 if( 
p
 )

39121 
p
->
pSrc
 = 
	`findBtree
(
pDestDb
, 
pSrcDb
, 
zSrcDb
);

39122 
p
->
pDest
 = 
	`findBtree
(
pDestDb
, pDestDb, 
zDestDb
);

39123 
p
->
pDestDb
 = pDestDb;

39124 
p
->
pSrcDb
 = pSrcDb;

39125 
p
->
iNext
 = 1;

39126 
p
->
isAttached
 = 0;

39128 if( 0==
p
->
pSrc
 || 0==p->
pDest


39129 || 
	`setDestPgsz
(
p
)==7

39130 || 
	`checkReadTransaction
(
pDestDb
, 
p
->
pDest
)!=0

39139 
	`sqlite3_free
(
p
);

39140 
p
 = 0;

39143 if( 
p
 )

39146 
p
->
pSrc
->
nBackup
++;

39149 
	`sqlite3_mutex_leave
(
pDestDb
->
mutex
);

39150 
	`sqlite3_mutex_leave
(
pSrcDb
->
mutex
);

39151 return 
p
;

39152 
	}
}

39159 static int 
	$isFatalError
(int 
rc
)

39162 return (
rc
!=0 && rc!=5 && (rc!=6));

39163 
	}
}

39170 static int 
	$backupOnePage
(

39171 
sqlite3_backup
 *
p
,

39172 
Pgno
 
iSrcPg
,

39173 const 
u8
 *
zSrcData
,

39174 int 
bUpdate


39178 
Pager
 * const 
pDestPager
 = 
	`sqlite3BtreePager
(
p
->
pDest
);

39179 const int 
nSrcPgsz
 = 
	`sqlite3BtreeGetPageSize
(
p
->
pSrc
);

39180 int 
nDestPgsz
 = 
	`sqlite3BtreeGetPageSize
(
p
->
pDest
);

39181 const int 
nCopy
 = ((
nSrcPgsz
)<(
nDestPgsz
)?(nSrcPgsz):(nDestPgsz));

39182 const 
i64
 
iEnd
 = (i64)
iSrcPg
*(i64)
nSrcPgsz
;

39190 int 
rc
 = 0;

39191 
i64
 
iOff
;

39202 if( 
nSrcPgsz
!=
nDestPgsz
 && 
	`sqlite3PagerIsMemdb
(
pDestPager
) )

39205 
rc
 = 8;

39208 for(
iOff
=
iEnd
-(
i64
)
nSrcPgsz
; 
rc
==0 && iOff<iEnd; iOff+=
nDestPgsz
)

39211 
DbPage
 *
pDestPg
 = 0;

39212 
Pgno
 
iDest
 = (Pgno)(
iOff
/
nDestPgsz
)+1;

39213 if( 
iDest
==((
Pgno
)((
sqlite3PendingByte
/((
p
->
pDest
->
pBt
)->
pageSize
))+1)) ) continue;

39214 if( 0==(
rc
 = 
	`sqlite3PagerGet
(
pDestPager
, 
iDest
, &
pDestPg
, 0))

39215 && 0==(
rc
 = 
	`sqlite3PagerWrite
(
pDestPg
))

39219 const 
u8
 *
zIn
 = &
zSrcData
[
iOff
%
nSrcPgsz
];

39220 
u8
 *
zDestData
 = 
	`sqlite3PagerGetData
(
pDestPg
);

39221 
u8
 *
zOut
 = &
zDestData
[
iOff
%
nDestPgsz
];

39223 
	`memcpy
(
zOut
, 
zIn
, 
nCopy
);

39224 ((
u8
 *)
	`sqlite3PagerGetExtra
(
pDestPg
))[0] = 0;

39225 if( 
iOff
==0 && 
bUpdate
==0 )

39228 
	`sqlite3Put4byte
(&
zOut
[28], 
	`sqlite3BtreeLastPage
(
p
->
pSrc
));

39231 
	`sqlite3PagerUnref
(
pDestPg
);

39234 return 
rc
;

39235 
	}
}

39237 static int 
	$backupTruncateFile
(
sqlite3_file
 *
pFile
, 
i64
 
iSize
)

39240 
i64
 
iCurrent
;

39241 int 
rc
 = 
	`sqlite3OsFileSize
(
pFile
, &
iCurrent
);

39242 if( 
rc
==0 && 
iCurrent
>
iSize
 )

39245 
rc
 = 
	`sqlite3OsTruncate
(
pFile
, 
iSize
);

39247 return 
rc
;

39248 
	}
}

39254 static void 
	$attachBackupObject
(
sqlite3_backup
 *
p
)

39257 
sqlite3_backup
 **
pp
;

39259 
pp
 = 
	`sqlite3PagerBackupPtr
(
	`sqlite3BtreePager
(
p
->
pSrc
));

39260 
p
->
pNext
 = *
pp
;

39261 *
pp
 = 
p
;

39262 
p
->
isAttached
 = 1;

39263 
	}
}

39268 int 
	$sqlite3_backup_step
(
sqlite3_backup
 *
p
, int 
nPage
)

39271 int 
rc
;

39272 int 
destMode
;

39273 int 
pgszSrc
 = 0;

39274 int 
pgszDest
 = 0;

39279 
	`sqlite3_mutex_enter
(
p
->
pSrcDb
->
mutex
);

39280 
	`sqlite3BtreeEnter
(
p
->
pSrc
);

39281 if( 
p
->
pDestDb
 )

39284 
	`sqlite3_mutex_enter
(
p
->
pDestDb
->
mutex
);

39287 
rc
 = 
p
->rc;

39288 if( !
	`isFatalError
(
rc
) )

39291 
Pager
 * const 
pSrcPager
 = 
	`sqlite3BtreePager
(
p
->
pSrc
);

39292 
Pager
 * const 
pDestPager
 = 
	`sqlite3BtreePager
(
p
->
pDest
);

39293 int 
ii
;

39294 int 
nSrcPage
 = -1;

39295 int 
bCloseTrans
 = 0;

39300 if( 
p
->
pDestDb
 && p->
pSrc
->
pBt
->
inTransaction
==2 )

39303 
rc
 = 5;

39305 
rc
 = 0;

39309 if( 0==
rc
 && 
p
->
bDestLocked
==0

39310 && 0==(
rc
 = 
	`sqlite3BtreeBeginTrans
(
p
->
pDest
, 2))

39314 
p
->
bDestLocked
 = 1;

39315 
	`sqlite3BtreeGetMeta
(
p
->
pDest
, 1, &p->
iDestSchema
);

39322 if( 
rc
==0 && 0==
	`sqlite3BtreeIsInReadTrans
(
p
->
pSrc
) )

39325 
rc
 = 
	`sqlite3BtreeBeginTrans
(
p
->
pSrc
, 0);

39326 
bCloseTrans
 = 1;

39331 
pgszSrc
 = 
	`sqlite3BtreeGetPageSize
(
p
->
pSrc
);

39332 
pgszDest
 = 
	`sqlite3BtreeGetPageSize
(
p
->
pDest
);

39333 
destMode
 = 
	`sqlite3PagerGetJournalMode
(
	`sqlite3BtreePager
(
p
->
pDest
));

39334 if( 0==
rc
 && 
destMode
==5 && 
pgszSrc
!=
pgszDest
 )

39337 
rc
 = 8;

39343 
nSrcPage
 = (int)
	`sqlite3BtreeLastPage
(
p
->
pSrc
);

39345 for(
ii
=0; (
nPage
<0 || ii<nPage) && 
p
->
iNext
<=(
Pgno
)
nSrcPage
 && !
rc
; ii++)

39348 const 
Pgno
 
iSrcPg
 = 
p
->
iNext
;

39349 if( 
iSrcPg
!=((
Pgno
)((
sqlite3PendingByte
/((
p
->
pSrc
->
pBt
)->
pageSize
))+1)) )

39352 
DbPage
 *
pSrcPg
;

39353 
rc
 = 
	`sqlite3PagerGet
(
pSrcPager
, 
iSrcPg
, &
pSrcPg
,0x02);

39354 if( 
rc
==0 )

39357 
rc
 = 
	`backupOnePage
(
p
, 
iSrcPg
, 
	`sqlite3PagerGetData
(
pSrcPg
), 0);

39358 
	`sqlite3PagerUnref
(
pSrcPg
);

39361 
p
->
iNext
++;

39363 if( 
rc
==0 )

39366 
p
->
nPagecount
 = 
nSrcPage
;

39367 
p
->
nRemaining
 = 
nSrcPage
+1-p->
iNext
;

39368 if( 
p
->
iNext
>(
Pgno
)
nSrcPage
 )

39371 
rc
 = 101;

39372 }else if( !
p
->
isAttached
 )

39375 
	`attachBackupObject
(
p
);

39384 if( 
rc
==101 )

39387 if( 
nSrcPage
==0 )

39390 
rc
 = 
	`sqlite3BtreeNewDb
(
p
->
pDest
);

39391 
nSrcPage
 = 1;

39393 if( 
rc
==0 || rc==101 )

39396 
rc
 = 
	`sqlite3BtreeUpdateMeta
(
p
->
pDest
,1,p->
iDestSchema
+1);

39398 if( 
rc
==0 )

39401 if( 
p
->
pDestDb
 )

39404 
	`sqlite3ResetAllSchemasOfConnection
(
p
->
pDestDb
);

39406 if( 
destMode
==5 )

39409 
rc
 = 
	`sqlite3BtreeSetVersion
(
p
->
pDest
, 2);

39412 if( 
rc
==0 )

39415 int 
nDestTruncate
;

39419 if( 
pgszSrc
<
pgszDest
 )

39422 int 
ratio
 = 
pgszDest
/
pgszSrc
;

39423 
nDestTruncate
 = (
nSrcPage
+
ratio
-1)/ratio;

39424 if( 
nDestTruncate
==(int)((
Pgno
)((
sqlite3PendingByte
/((
p
->
pDest
->
pBt
)->
pageSize
))+1)) )

39427 
nDestTruncate
--;

39430 
nDestTruncate
 = 
nSrcPage
 * (
pgszSrc
/
pgszDest
);

39434 if( 
pgszSrc
<
pgszDest
 )

39438 const 
i64
 
iSize
 = (i64)
pgszSrc
 * (i64)
nSrcPage
;

39439 
sqlite3_file
 * const 
pFile
 = 
	`sqlite3PagerFile
(
pDestPager
);

39440 
Pgno
 
iPg
;

39441 int 
nDstPage
;

39442 
i64
 
iOff
;

39443 
i64
 
iEnd
;

39458 
	`sqlite3PagerPagecount
(
pDestPager
, &
nDstPage
);

39459 for(
iPg
=
nDestTruncate
; 
rc
==0 && iPg<=(
Pgno
)
nDstPage
; iPg++)

39462 if( 
iPg
!=((
Pgno
)((
sqlite3PendingByte
/((
p
->
pDest
->
pBt
)->
pageSize
))+1)) )

39465 
DbPage
 *
pPg
;

39466 
rc
 = 
	`sqlite3PagerGet
(
pDestPager
, 
iPg
, &
pPg
, 0);

39467 if( 
rc
==0 )

39470 
rc
 = 
	`sqlite3PagerWrite
(
pPg
);

39471 
	`sqlite3PagerUnref
(
pPg
);

39475 if( 
rc
==0 )

39478 
rc
 = 
	`sqlite3PagerCommitPhaseOne
(
pDestPager
, 0, 1);

39482 
iEnd
 = ((
sqlite3PendingByte
 + 
pgszDest
)<(
iSize
)?(sqlite3PendingByte + pgszDest):(iSize));

39484 
iOff
=
sqlite3PendingByte
+
pgszSrc
;

39485 
rc
==0 && 
iOff
<
iEnd
;

39486 
iOff
+=
pgszSrc


39490 
PgHdr
 *
pSrcPg
 = 0;

39491 const 
Pgno
 
iSrcPg
 = (Pgno)((
iOff
/
pgszSrc
)+1);

39492 
rc
 = 
	`sqlite3PagerGet
(
pSrcPager
, 
iSrcPg
, &
pSrcPg
, 0);

39493 if( 
rc
==0 )

39496 
u8
 *
zData
 = 
	`sqlite3PagerGetData
(
pSrcPg
);

39497 
rc
 = 
	`sqlite3OsWrite
(
pFile
, 
zData
, 
pgszSrc
, 
iOff
);

39499 
	`sqlite3PagerUnref
(
pSrcPg
);

39501 if( 
rc
==0 )

39504 
rc
 = 
	`backupTruncateFile
(
pFile
, 
iSize
);

39508 if( 
rc
==0 )

39511 
rc
 = 
	`sqlite3PagerSync
(
pDestPager
, 0);

39514 
	`sqlite3PagerTruncateImage
(
pDestPager
, 
nDestTruncate
);

39515 
rc
 = 
	`sqlite3PagerCommitPhaseOne
(
pDestPager
, 0, 0);

39519 if( 0==
rc


39520 && 0==(
rc
 = 
	`sqlite3BtreeCommitPhaseTwo
(
p
->
pDest
, 0))

39524 
rc
 = 101;

39534 if( 
bCloseTrans
 )

39538 
	`sqlite3BtreeCommitPhaseOne
(
p
->
pSrc
, 0);

39539 
	`sqlite3BtreeCommitPhaseTwo
(
p
->
pSrc
, 0);

39543 if( 
rc
==(10 | (12<<8)) )

39546 
rc
 = 7;

39548 
p
->
rc
 = rc;

39550 if( 
p
->
pDestDb
 )

39553 
	`sqlite3_mutex_leave
(
p
->
pDestDb
->
mutex
);

39555 
	`sqlite3BtreeLeave
(
p
->
pSrc
);

39556 
	`sqlite3_mutex_leave
(
p
->
pSrcDb
->
mutex
);

39557 return 
rc
;

39558 
	}
}

39563 int 
	$sqlite3_backup_finish
(
sqlite3_backup
 *
p
)

39566 
sqlite3_backup
 **
pp
;

39567 
sqlite3
 *
pSrcDb
;

39568 int 
rc
;

39571 if( 
p
==0 ) return 0;

39572 
pSrcDb
 = 
p
->pSrcDb;

39573 
	`sqlite3_mutex_enter
(
pSrcDb
->
mutex
);

39574 
	`sqlite3BtreeEnter
(
p
->
pSrc
);

39575 if( 
p
->
pDestDb
 )

39578 
	`sqlite3_mutex_enter
(
p
->
pDestDb
->
mutex
);

39582 if( 
p
->
pDestDb
 )

39585 
p
->
pSrc
->
nBackup
--;

39587 if( 
p
->
isAttached
 )

39590 
pp
 = 
	`sqlite3PagerBackupPtr
(
	`sqlite3BtreePager
(
p
->
pSrc
));

39591 while( *
pp
!=
p
 )

39594 
pp
 = &(*pp)->
pNext
;

39596 *
pp
 = 
p
->
pNext
;

39600 
	`sqlite3BtreeRollback
(
p
->
pDest
, 0, 0);

39603 
rc
 = (
p
->rc==101) ? 0 : p->rc;

39604 if( 
p
->
pDestDb
 )

39607 
	`sqlite3Error
(
p
->
pDestDb
, 
rc
);

39610 
	`sqlite3LeaveMutexAndCloseZombie
(
p
->
pDestDb
);

39612 
	`sqlite3BtreeLeave
(
p
->
pSrc
);

39613 if( 
p
->
pDestDb
 )

39619 
	`sqlite3_free
(
p
);

39621 
	`sqlite3LeaveMutexAndCloseZombie
(
pSrcDb
);

39622 return 
rc
;

39623 
	}
}

39629 int 
	$sqlite3_backup_remaining
(
sqlite3_backup
 *
p
)

39638 return 
p
->
nRemaining
;

39639 
	}
}

39645 int 
	$sqlite3_backup_pagecount
(
sqlite3_backup
 *
p
)

39654 return 
p
->
nPagecount
;

39655 
	}
}

39657 static 
__attribute__
((
noinline
)) void 
	$backupUpdate
(

39658 
sqlite3_backup
 *
p
,

39659 
Pgno
 
iPage
,

39660 const 
u8
 *
aData


39667 if( !
	`isFatalError
(
p
->
rc
) && 
iPage
<p->
iNext
 )

39674 int 
rc
;

39676 
	`sqlite3_mutex_enter
(
p
->
pDestDb
->
mutex
);

39677 
rc
 = 
	`backupOnePage
(
p
, 
iPage
, 
aData
, 1);

39678 
	`sqlite3_mutex_leave
(
p
->
pDestDb
->
mutex
);

39680 if( 
rc
!=0 )

39683 
p
->
rc
 = rc;

39686 }while( (
p
 = p->
pNext
)!=0 );

39687 
	}
}

39688 static void 
	$sqlite3BackupUpdate
(
sqlite3_backup
 *
pBackup
, 
Pgno
 
iPage
, const 
u8
 *
aData
)

39691 if( 
pBackup
 ) 
	`backupUpdate
(pBackup, 
iPage
, 
aData
);

39692 
	}
}

39694 static void 
	$sqlite3BackupRestart
(
sqlite3_backup
 *
pBackup
)

39697 
sqlite3_backup
 *
p
;

39698 for(
p
=
pBackup
; p; p=p->
pNext
)

39702 
p
->
iNext
 = 1;

39704 
	}
}

39706 static int 
	$sqlite3BtreeCopyFile
(
Btree
 *
pTo
, Btree *
pFrom
)

39709 int 
rc
;

39710 
sqlite3_file
 *
pFd
;

39711 
sqlite3_backup
 
b
;

39712 
	`sqlite3BtreeEnter
(
pTo
);

39713 
	`sqlite3BtreeEnter
(
pFrom
);

39716 
pFd
 = 
	`sqlite3PagerFile
(
	`sqlite3BtreePager
(
pTo
));

39717 if( 
pFd
->
pMethods
 )

39720 
i64
 
nByte
 = 
	`sqlite3BtreeGetPageSize
(
pFrom
)*(i64)
	`sqlite3BtreeLastPage
(pFrom);

39721 
rc
 = 
	`sqlite3OsFileControl
(
pFd
, 11, &
nByte
);

39722 if( 
rc
==12 ) rc = 0;

39723 if( 
rc
 ) goto 
copy_finished
;

39731 
	`memset
(&
b
, 0, sizeof(b));

39732 
b
.
pSrcDb
 = 
pFrom
->
db
;

39733 
b
.
pSrc
 = 
pFrom
;

39734 
b
.
pDest
 = 
pTo
;

39735 
b
.
iNext
 = 1;

39737 
	`sqlite3_backup_step
(&
b
, 0x7FFFFFFF);

39739 
rc
 = 
	`sqlite3_backup_finish
(&
b
);

39740 if( 
rc
==0 )

39743 
pTo
->
pBt
->
btsFlags
 &= ~0x0002;

39745 
	`sqlite3PagerClearCache
(
	`sqlite3BtreePager
(
b
.
pDest
));

39749 
copy_finished
:

39750 
	`sqlite3BtreeLeave
(
pFrom
);

39751 
	`sqlite3BtreeLeave
(
pTo
);

39752 return 
rc
;

39753 
	}
}

39755 static int 
	$sqlite3VdbeChangeEncoding
(
Mem
 *
pMem
, int 
desiredEnc
)

39759 int 
rc
;

39764 if( !(
pMem
->
flags
&0x0002) || pMem->
enc
==
desiredEnc
 )

39777 
rc
 = 
	`sqlite3VdbeMemTranslate
(
pMem
, (
u8
)
desiredEnc
);

39781 return 
rc
;

39783 
	}
}

39785 static 
__attribute__
((
noinline
)) int 
	$sqlite3VdbeMemGrow
(
Mem
 *
pMem
, int 
n
, int 
bPreserve
)

39799 if( 
pMem
->
szMalloc
<
n
 )

39802 if( 
n
<32 ) n = 32;

39803 if( 
bPreserve
 && 
pMem
->
szMalloc
>0 && pMem->
z
==pMem->
zMalloc
 )

39806 
pMem
->
z
 = pMem->
zMalloc
 = 
	`sqlite3DbReallocOrFree
(pMem->
db
, pMem->z, 
n
);

39807 
bPreserve
 = 0;

39809 if( 
pMem
->
szMalloc
>0 ) 
	`sqlite3DbFree
(pMem->
db
, pMem->
zMalloc
);

39810 
pMem
->
zMalloc
 = 
	`sqlite3DbMallocRaw
(pMem->
db
, 
n
);

39812 if( 
pMem
->
zMalloc
==0 )

39815 
	`sqlite3VdbeMemSetNull
(
pMem
);

39816 
pMem
->
z
 = 0;

39817 
pMem
->
szMalloc
 = 0;

39820 
pMem
->
szMalloc
 = 
	`sqlite3DbMallocSize
(pMem->
db
, pMem->
zMalloc
);

39824 if( 
bPreserve
 && 
pMem
->
z
 && pMem->z!=pMem->
zMalloc
 )

39827 
	`memcpy
(
pMem
->
zMalloc
, pMem->
z
, pMem->
n
);

39829 if( (
pMem
->
flags
&0x0400)!=0 )

39833 
pMem
->
	`xDel
((void *)(pMem->
z
));

39836 
pMem
->
z
 = pMem->
zMalloc
;

39837 
pMem
->
flags
 &= ~(0x0400|0x1000|0x0800);

39839 
	}
}

39841 static int 
	$sqlite3VdbeMemClearAndResize
(
Mem
 *
pMem
, int 
szNew
)

39846 if( 
pMem
->
szMalloc
<
szNew
 )

39849 return 
	`sqlite3VdbeMemGrow
(
pMem
, 
szNew
, 0);

39852 
pMem
->
z
 = pMem->
zMalloc
;

39853 
pMem
->
flags
 &= (0x0001|0x0004|0x0008);

39855 
	}
}

39863 static int 
	$sqlite3VdbeMemMakeWriteable
(
Mem
 *
pMem
)

39866 int 
f
;

39869 (((
pMem
)->
flags
&0x4000)?
	`sqlite3VdbeMemExpandBlob
(pMem):0);

39870 
f
 = 
pMem
->
flags
;

39871 if( (
f
&(0x0002|0x0010)) && (
pMem
->
szMalloc
==0 || pMem->
z
!=pMem->
zMalloc
) )

39874 if( 
	`sqlite3VdbeMemGrow
(
pMem
, pMem->
n
 + 2, 1) )

39879 
pMem
->
z
[pMem->
n
] = 0;

39880 
pMem
->
z
[pMem->
n
+1] = 0;

39881 
pMem
->
flags
 |= 0x0200;

39883 
pMem
->
flags
 &= ~0x1000;

39889 
	}
}

39896 static int 
	$sqlite3VdbeMemExpandBlob
(
Mem
 *
pMem
)

39899 if( 
pMem
->
flags
 & 0x4000 )

39902 int 
nByte
;

39908 
nByte
 = 
pMem
->
n
 + pMem->
u
.
nZero
;

39909 if( 
nByte
<=0 )

39912 
nByte
 = 1;

39914 if( 
	`sqlite3VdbeMemGrow
(
pMem
, 
nByte
, 1) )

39920 
	`memset
(&
pMem
->
z
[pMem->
n
], 0, pMem->
u
.
nZero
);

39921 
pMem
->
n
 += pMem->
u
.
nZero
;

39922 
pMem
->
flags
 &= ~(0x4000|0x0200);

39925 
	}
}

39932 static 
__attribute__
((
noinline
)) int 
	$vdbeMemAddTerminator
(
Mem
 *
pMem
)

39935 if( 
	`sqlite3VdbeMemGrow
(
pMem
, pMem->
n
+2, 1) )

39940 
pMem
->
z
[pMem->
n
] = 0;

39941 
pMem
->
z
[pMem->
n
+1] = 0;

39942 
pMem
->
flags
 |= 0x0200;

39944 
	}
}

39949 static int 
	$sqlite3VdbeMemNulTerminate
(
Mem
 *
pMem
)

39955 if( (
pMem
->
flags
 & (0x0200|0x0002))!=0x0002 )

39960 return 
	`vdbeMemAddTerminator
(
pMem
);

39962 
	}
}

39964 static int 
	$sqlite3VdbeMemStringify
(
Mem
 *
pMem
, 
u8
 
enc
, u8 
bForce
)

39967 int 
fg
 = 
pMem
->
flags
;

39968 const int 
nByte
 = 32;

39978 if( 
	`sqlite3VdbeMemClearAndResize
(
pMem
, 
nByte
) )

39990 if( 
fg
 & 0x0004 )

39993 
	`sqlite3_snprintf
(
nByte
, 
pMem
->
z
, "%lld", pMem->
u
.
i
);

39996 
	`sqlite3_snprintf
(
nByte
, 
pMem
->
z
, "%!.15g", pMem->
u
.
r
);

39998 
pMem
->
n
 = 
	`sqlite3Strlen30
(pMem->
z
);

39999 
pMem
->
enc
 = 1;

40000 
pMem
->
flags
 |= 0x0002|0x0200;

40001 if( 
bForce
 ) 
pMem
->
flags
 &= ~(0x0004|0x0008);

40002 
	`sqlite3VdbeChangeEncoding
(
pMem
, 
enc
);

40004 
	}
}

40006 static int 
	$sqlite3VdbeMemFinalize
(
Mem
 *
pMem
, 
FuncDef
 *
pFunc
)

40009 int 
rc
 = 0;

40010 if( (
pFunc
 && pFunc->
xFinalize
) )

40013 
sqlite3_context
 
ctx
;

40014 
Mem
 
t
;

40017 
	`memset
(&
ctx
, 0, sizeof(ctx));

40018 
	`memset
(&
t
, 0, sizeof(t));

40019 
t
.
flags
 = 0x0001;

40020 
t
.
db
 = 
pMem
->db;

40021 
ctx
.
pOut
 = &
t
;

40022 
ctx
.
pMem
 = pMem;

40023 
ctx
.
pFunc
 = pFunc;

40024 
pFunc
->
	`xFinalize
(&
ctx
);

40026 if( 
pMem
->
szMalloc
>0 ) 
	`sqlite3DbFree
(pMem->
db
, pMem->
zMalloc
);

40027 
	`memcpy
(
pMem
, &
t
, sizeof(t));

40028 
rc
 = 
ctx
.
isError
;

40030 return 
rc
;

40031 
	}
}

40033 static 
__attribute__
((
noinline
)) void 
	$vdbeMemClearExternAndSetNull
(
Mem
 *
p
)

40038 if( 
p
->
flags
&0x2000 )

40041 
	`sqlite3VdbeMemFinalize
(
p
, p->
u
.
pDef
);

40045 if( 
p
->
flags
&0x0400 )

40050 
p
->
	`xDel
((void *)p->
z
);

40051 }else if( 
p
->
flags
&0x0020 )

40054 
	`sqlite3RowSetClear
(
p
->
u
.
pRowSet
);

40055 }else if( 
p
->
flags
&0x0040 )

40058 
VdbeFrame
 *
pFrame
 = 
p
->
u
.pFrame;

40059 
pFrame
->
pParent
 = pFrame->
v
->
pDelFrame
;

40060 
pFrame
->
v
->
pDelFrame
 = pFrame;

40062 
p
->
flags
 = 0x0001;

40063 
	}
}

40065 static 
__attribute__
((
noinline
)) void 
	$vdbeMemClear
(
Mem
 *
p
)

40068 if( (((
p
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) )

40071 
	`vdbeMemClearExternAndSetNull
(
p
);

40073 if( 
p
->
szMalloc
 )

40076 
	`sqlite3DbFree
(
p
->
db
, p->
zMalloc
);

40077 
p
->
szMalloc
 = 0;

40079 
p
->
z
 = 0;

40080 
	}
}

40082 static void 
	$sqlite3VdbeMemRelease
(
Mem
 *
p
)

40086 if( (((
p
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) || p->
szMalloc
 )

40089 
	`vdbeMemClear
(
p
);

40091 
	}
}

40098 static 
i64
 
	$doubleToInt64
(double 
r
)

40102 static const 
i64
 
maxInt
 = (0xffffffff|(((i64)0x7fffffff)<<32));

40103 static const 
i64
 
minInt
 = (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));

40105 if( 
r
<=(double)
minInt
 )

40108 return 
minInt
;

40109 }else if( 
r
>=(double)
maxInt
 )

40112 return 
maxInt
;

40114 return (
i64
)
r
;

40117 
	}
}

40119 static 
i64
 
	$sqlite3VdbeIntValue
(
Mem
 *
pMem
)

40122 int 
flags
;

40125 
flags
 = 
pMem
->flags;

40126 if( 
flags
 & 0x0004 )

40129 return 
pMem
->
u
.
i
;

40130 }else if( 
flags
 & 0x0008 )

40133 return 
	`doubleToInt64
(
pMem
->
u
.
r
);

40134 }else if( 
flags
 & (0x0002|0x0010) )

40137 
i64
 
value
 = 0;

40139 
	`sqlite3Atoi64
(
pMem
->
z
, &
value
, pMem->
n
, pMem->
enc
);

40140 return 
value
;

40144 
	}
}

40152 static double 
	$sqlite3VdbeRealValue
(
Mem
 *
pMem
)

40157 if( 
pMem
->
flags
 & 0x0008 )

40160 return 
pMem
->
u
.
r
;

40161 }else if( 
pMem
->
flags
 & 0x0004 )

40164 return (double)
pMem
->
u
.
i
;

40165 }else if( 
pMem
->
flags
 & (0x0002|0x0010) )

40169 double 
val
 = (double)0;

40170 
	`sqlite3AtoF
(
pMem
->
z
, &
val
, pMem->
n
, pMem->
enc
);

40171 return 
val
;

40176 
	}
}

40182 static void 
	$sqlite3VdbeIntegerAffinity
(
Mem
 *
pMem
)

40185 
i64
 
ix
;

40191 
ix
 = 
	`doubleToInt64
(
pMem
->
u
.
r
);

40193 if( 
pMem
->
u
.
r
==
ix
 && ix>(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) && ix<(0xffffffff|(((i64)0x7fffffff)<<32)) )

40196 
pMem
->
u
.
i
 = 
ix
;

40197 ((
pMem
)->
flags
 = ((pMem)->flags&~(0x81ff|0x4000))|0x0004);

40199 
	}
}

40204 static int 
	$sqlite3VdbeMemIntegerify
(
Mem
 *
pMem
)

40211 
pMem
->
u
.
i
 = 
	`sqlite3VdbeIntValue
(pMem);

40212 ((
pMem
)->
flags
 = ((pMem)->flags&~(0x81ff|0x4000))|0x0004);

40214 
	}
}

40220 static int 
	$sqlite3VdbeMemRealify
(
Mem
 *
pMem
)

40226 
pMem
->
u
.
r
 = 
	`sqlite3VdbeRealValue
(pMem);

40227 ((
pMem
)->
flags
 = ((pMem)->flags&~(0x81ff|0x4000))|0x0008);

40229 
	}
}

40231 static int 
	$sqlite3VdbeMemNumerify
(
Mem
 *
pMem
)

40234 if( (
pMem
->
flags
 & (0x0004|0x0008|0x0001))==0 )

40239 if( 0==
	`sqlite3Atoi64
(
pMem
->
z
, &pMem->
u
.
i
, pMem->
n
, pMem->
enc
) )

40242 ((
pMem
)->
flags
 = ((pMem)->flags&~(0x81ff|0x4000))|0x0004);

40244 
pMem
->
u
.
r
 = 
	`sqlite3VdbeRealValue
(pMem);

40245 ((
pMem
)->
flags
 = ((pMem)->flags&~(0x81ff|0x4000))|0x0008);

40246 
	`sqlite3VdbeIntegerAffinity
(
pMem
);

40250 
pMem
->
flags
 &= ~(0x0002|0x0010);

40252 
	}
}

40254 static void 
	$sqlite3VdbeMemCast
(
Mem
 *
pMem
, 
u8
 
aff
, u8 
encoding
)

40257 if( 
pMem
->
flags
 & 0x0001 ) return;

40258 switch( 
aff
 )

40262 if( (
pMem
->
flags
 & 0x0010)==0 )

40265 
	`sqlite3ValueApplyAffinity
(
pMem
, 'B', 
encoding
);

40267 ((
pMem
)->
flags
 = ((pMem)->flags&~(0x81ff|0x4000))|0x0010);

40269 
pMem
->
flags
 &= ~(0x81ff&~0x0010);

40274 
	`sqlite3VdbeMemNumerify
(
pMem
);

40278 
	`sqlite3VdbeMemIntegerify
(
pMem
);

40282 
	`sqlite3VdbeMemRealify
(
pMem
);

40288 
pMem
->
flags
 |= (pMem->flags&0x0010)>>3;

40289 
	`sqlite3ValueApplyAffinity
(
pMem
, 'B', 
encoding
);

40291 
pMem
->
flags
 &= ~(0x0004|0x0008|0x0010|0x4000);

40295 
	}
}

40302 static void 
	$sqlite3VdbeMemInit
(
Mem
 *
pMem
, 
sqlite3
 *
db
, 
u16
 
flags
)

40306 
pMem
->
flags
 = flags;

40307 
pMem
->
db
 = db;

40308 
pMem
->
szMalloc
 = 0;

40309 
	}
}

40311 static void 
	$sqlite3VdbeMemSetNull
(
Mem
 *
pMem
)

40314 if( (((
pMem
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) )

40317 
	`vdbeMemClearExternAndSetNull
(
pMem
);

40319 
pMem
->
flags
 = 0x0001;

40321 
	}
}

40322 static void 
	$sqlite3ValueSetNull
(
sqlite3_value
 *
p
)

40325 
	`sqlite3VdbeMemSetNull
((
Mem
*)
p
);

40326 
	}
}

40332 static void 
	$sqlite3VdbeMemSetZeroBlob
(
Mem
 *
pMem
, int 
n
)

40335 
	`sqlite3VdbeMemRelease
(
pMem
);

40336 
pMem
->
flags
 = 0x0010|0x4000;

40337 
pMem
->
n
 = 0;

40338 if( 
n
<0 ) n = 0;

40339 
pMem
->
u
.
nZero
 = 
n
;

40340 
pMem
->
enc
 = 1;

40341 
pMem
->
z
 = 0;

40342 
	}
}

40349 static 
__attribute__
((
noinline
)) void 
	$vdbeReleaseAndSetInt64
(
Mem
 *
pMem
, 
i64
 
val
)

40352 
	`sqlite3VdbeMemSetNull
(
pMem
);

40353 
pMem
->
u
.
i
 = 
val
;

40354 
pMem
->
flags
 = 0x0004;

40355 
	}
}

40361 static void 
	$sqlite3VdbeMemSetInt64
(
Mem
 *
pMem
, 
i64
 
val
)

40364 if( (((
pMem
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) )

40367 
	`vdbeReleaseAndSetInt64
(
pMem
, 
val
);

40369 
pMem
->
u
.
i
 = 
val
;

40370 
pMem
->
flags
 = 0x0004;

40372 
	}
}

40379 static void 
	$sqlite3VdbeMemSetDouble
(
Mem
 *
pMem
, double 
val
)

40382 
	`sqlite3VdbeMemSetNull
(
pMem
);

40383 if( !
	`sqlite3IsNaN
(
val
) )

40386 
pMem
->
u
.
r
 = 
val
;

40387 
pMem
->
flags
 = 0x0008;

40389 
	}
}

40396 static void 
	$sqlite3VdbeMemSetRowSet
(
Mem
 *
pMem
)

40399 
sqlite3
 *
db
 = 
pMem
->db;

40402 
	`sqlite3VdbeMemRelease
(
pMem
);

40403 
pMem
->
zMalloc
 = 
	`sqlite3DbMallocRawNN
(
db
, 64);

40404 if( 
db
->
mallocFailed
 )

40407 
pMem
->
flags
 = 0x0001;

40408 
pMem
->
szMalloc
 = 0;

40411 
pMem
->
szMalloc
 = 
	`sqlite3DbMallocSize
(
db
, pMem->
zMalloc
);

40412 
pMem
->
u
.
pRowSet
 = 
	`sqlite3RowSetInit
(
db
, pMem->
zMalloc
, pMem->
szMalloc
);

40414 
pMem
->
flags
 = 0x0020;

40416 
	}
}

40422 static int 
	$sqlite3VdbeMemTooBig
(
Mem
 *
p
)

40426 if( 
p
->
flags
 & (0x0002|0x0010) )

40429 int 
n
 = 
p
->n;

40430 if( 
p
->
flags
 & 0x4000 )

40433 
n
 += 
p
->
u
.
nZero
;

40435 return 
n
>
p
->
db
->
aLimit
[0];

40438 
	}
}

40440 static 
__attribute__
((
noinline
)) void 
	$vdbeClrCopy
(
Mem
 *
pTo
, const Mem *
pFrom
, int 
eType
)

40443 
	`vdbeMemClearExternAndSetNull
(
pTo
);

40445 
	`sqlite3VdbeMemShallowCopy
(
pTo
, 
pFrom
, 
eType
);

40446 
	}
}

40447 static void 
	$sqlite3VdbeMemShallowCopy
(
Mem
 *
pTo
, const Mem *
pFrom
, int 
srcType
)

40452 if( (((
pTo
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) )

40454 
	`vdbeClrCopy
(
pTo
,
pFrom
,
srcType
); return; }

40455 
	`memcpy
(
pTo
, 
pFrom
, 
	`__builtin_offsetof
 (
Mem
, 
zMalloc
));

40456 if( (
pFrom
->
flags
&0x0800)==0 )

40459 
pTo
->
flags
 &= ~(0x0400|0x0800|0x1000);

40461 
pTo
->
flags
 |= 
srcType
;

40463 
	}
}

40469 static int 
	$sqlite3VdbeMemCopy
(
Mem
 *
pTo
, const Mem *
pFrom
)

40472 int 
rc
 = 0;

40479 if( (((
pTo
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) ) 
	`vdbeMemClearExternAndSetNull
(pTo);

40480 
	`memcpy
(
pTo
, 
pFrom
, 
	`__builtin_offsetof
 (
Mem
, 
zMalloc
));

40481 
pTo
->
flags
 &= ~0x0400;

40482 if( 
pTo
->
flags
&(0x0002|0x0010) )

40485 if( 0==(
pFrom
->
flags
&0x0800) )

40488 
pTo
->
flags
 |= 0x1000;

40489 
rc
 = 
	`sqlite3VdbeMemMakeWriteable
(
pTo
);

40493 return 
rc
;

40494 
	}
}

40502 static void 
	$sqlite3VdbeMemMove
(
Mem
 *
pTo
, Mem *
pFrom
)

40509 
	`sqlite3VdbeMemRelease
(
pTo
);

40510 
	`memcpy
(
pTo
, 
pFrom
, sizeof(
Mem
));

40511 
pFrom
->
flags
 = 0x0001;

40512 
pFrom
->
szMalloc
 = 0;

40513 
	}
}

40515 static int 
sqlite3VdbeMemSetStr
(

40516 
Mem
 *
pMem
,

40517 const char *
z
,

40518 int 
n
,

40519 
u8
 
enc
,

40520 void (*
xDel
)(void*)

40524 int 
nByte
 = 
n
;

40525 int 
iLimit
;

40526 
u16
 
flags
 = 0;

40532 if( !
z
 )

40535 
	`sqlite3VdbeMemSetNull
(
pMem
);

40539 if( 
pMem
->
db
 )

40542 
iLimit
 = 
pMem
->
db
->
aLimit
[0];

40544 
iLimit
 = 1000000000;

40546 
flags
 = (
enc
==0?0x0010:0x0002);

40547 if( 
nByte
<0 )

40551 if( 
enc
==1 )

40554 
nByte
 = 
	`sqlite3Strlen30
(
z
);

40555 if( 
nByte
>
iLimit
 ) nByte = iLimit+1;

40557 for(
nByte
=0; nByte<=
iLimit
 && (
z
[nByte] | z[nByte+1]); nByte+=2)

40561 
flags
 |= 0x0200;

40568 if( 
xDel
==((
sqlite3_destructor_type
)-1) )

40571 int 
nAlloc
 = 
nByte
;

40572 if( 
flags
&0x0200 )

40575 
nAlloc
 += (
enc
==1?1:2);

40577 if( 
nByte
>
iLimit
 )

40585 if( 
	`sqlite3VdbeMemClearAndResize
(
pMem
, ((
nAlloc
)>(32)?(nAlloc):(32))) )

40590 
	`memcpy
(
pMem
->
z
, z, 
nAlloc
);

40591 }else if( 
xDel
==((
sqlite3_destructor_type
)
sqlite3MallocSize
) )

40594 
	`sqlite3VdbeMemRelease
(
pMem
);

40595 
pMem
->
zMalloc
 = pMem->
z
 = (char *)z;

40596 
pMem
->
szMalloc
 = 
	`sqlite3DbMallocSize
(pMem->
db
, pMem->
zMalloc
);

40598 
	`sqlite3VdbeMemRelease
(
pMem
);

40599 
pMem
->
z
 = (char *)z;

40600 
pMem
->
xDel
 = xDel;

40601 
flags
 |= ((
xDel
==((
sqlite3_destructor_type
)0))?0x0800:0x0400);

40604 
pMem
->
n
 = 
nByte
;

40605 
pMem
->
flags
 = flags;

40606 
pMem
->
enc
 = (enc==0 ? 1 : enc);

40609 if( 
pMem
->
enc
!=1 && 
	`sqlite3VdbeMemHandleBom
(pMem) )

40616 if( 
nByte
>
iLimit
 )

40623 
	}
}

40625 static 
__attribute__
((
noinline
)) int 
	$vdbeMemFromBtreeResize
(

40626 
BtCursor
 *
pCur
,

40627 
u32
 
offset
,

40628 
u32
 
amt
,

40629 int 
key
,

40630 
Mem
 *
pMem


40634 int 
rc
;

40635 
pMem
->
flags
 = 0x0001;

40636 if( 0==(
rc
 = 
	`sqlite3VdbeMemClearAndResize
(
pMem
, 
amt
+2)) )

40639 if( 
key
 )

40642 
rc
 = 
	`sqlite3BtreeKey
(
pCur
, 
offset
, 
amt
, 
pMem
->
z
);

40644 
rc
 = 
	`sqlite3BtreeData
(
pCur
, 
offset
, 
amt
, 
pMem
->
z
);

40646 if( 
rc
==0 )

40649 
pMem
->
z
[
amt
] = 0;

40650 
pMem
->
z
[
amt
+1] = 0;

40651 
pMem
->
flags
 = 0x0010|0x0200;

40652 
pMem
->
n
 = (int)
amt
;

40654 
	`sqlite3VdbeMemRelease
(
pMem
);

40657 return 
rc
;

40658 
	}
}

40659 static int 
	$sqlite3VdbeMemFromBtree
(

40660 
BtCursor
 *
pCur
,

40661 
u32
 
offset
,

40662 
u32
 
amt
,

40663 int 
key
,

40664 
Mem
 *
pMem


40668 char *
zData
;

40669 
u32
 
available
 = 0;

40670 int 
rc
 = 0;

40678 if( 
key
 )

40681 
zData
 = (char *)
	`sqlite3BtreeKeyFetch
(
pCur
, &
available
);

40683 
zData
 = (char *)
	`sqlite3BtreeDataFetch
(
pCur
, &
available
);

40687 if( 
offset
+
amt
<=
available
 )

40690 
pMem
->
z
 = &
zData
[
offset
];

40691 
pMem
->
flags
 = 0x0010|0x1000;

40692 
pMem
->
n
 = (int)
amt
;

40694 
rc
 = 
	`vdbeMemFromBtreeResize
(
pCur
, 
offset
, 
amt
, 
key
, 
pMem
);

40697 return 
rc
;

40698 
	}
}

40705 static 
__attribute__
((
noinline
)) const void *
	$valueToText
(
sqlite3_value
* 
pVal
, 
u8
 
enc
)

40713 if( 
pVal
->
flags
 & (0x0010|0x0002) )

40716 
pVal
->
flags
 |= 0x0002;

40717 if( 
pVal
->
flags
 & 0x4000 )

40720 
	`sqlite3VdbeMemExpandBlob
(
pVal
);

40722 if( 
pVal
->
enc
 != (enc & ~8) )

40725 
	`sqlite3VdbeChangeEncoding
(
pVal
, 
enc
 & ~8);

40727 if( (
enc
 & 8)!=0 && 1==(1&((int)(long int)(
pVal
->
z
))) )

40731 if( 
	`sqlite3VdbeMemMakeWriteable
(
pVal
)!=0 )

40737 
	`sqlite3VdbeMemNulTerminate
(
pVal
);

40739 
	`sqlite3VdbeMemStringify
(
pVal
, 
enc
, 0);

40744 if( 
pVal
->
enc
==(enc & ~8) )

40747 return 
pVal
->
z
;

40751 
	}
}

40753 static const void *
	$sqlite3ValueText
(
sqlite3_value
* 
pVal
, 
u8
 
enc
)

40756 if( !
pVal
 ) return 0;

40760 if( (
pVal
->
flags
&(0x0002|0x0200))==(0x0002|0x0200) && pVal->
enc
==enc )

40763 return 
pVal
->
z
;

40765 if( 
pVal
->
flags
&0x0001 )

40770 return 
	`valueToText
(
pVal
, 
enc
);

40771 
	}
}

40776 static 
sqlite3_value
 *
	$sqlite3ValueNew
(
sqlite3
 *
db
)

40779 
Mem
 *
p
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(*p));

40780 if( 
p
 )

40783 
p
->
flags
 = 0x0001;

40784 
p
->
db
 = db;

40786 return 
p
;

40787 
	}
}

40793 struct 
	sValueNewStat4Ctx
 {

40794 
Parse
 *
	mpParse
;

40795 
Index
 *
	mpIdx
;

40796 
UnpackedRecord
 **
	mppRec
;

40797 int 
	miVal
;

40800 static 
sqlite3_value
 *
	$valueNew
(
sqlite3
 *
db
, struct 
ValueNewStat4Ctx
 *
p
)

40804 (void)(
p
);

40806 return 
	`sqlite3ValueNew
(
db
);

40807 
	}
}

40809 static int 
	$valueFromExpr
(

40810 
sqlite3
 *
db
,

40811 
Expr
 *
pExpr
,

40812 
u8
 
enc
,

40813 
u8
 
affinity
,

40814 
sqlite3_value
 **
ppVal
,

40815 struct 
ValueNewStat4Ctx
 *
pCtx


40819 int 
op
;

40820 char *
zVal
 = 0;

40821 
sqlite3_value
 *
pVal
 = 0;

40822 int 
negInt
 = 1;

40823 const char *
zNeg
 = "";

40824 int 
rc
 = 0;

40826 if( !
pExpr
 )

40829 *
ppVal
 = 0;

40832 while( (
op
 = 
pExpr
->op)==156 || op==159 ) pExpr = pExpr->
pLeft
;

40833 if( (
op
==157) ) op = 
pExpr
->
op2
;

40841 if( 
op
==38 )

40844 
u8
 
aff
 = 
	`sqlite3AffinityType
(
pExpr
->
u
.
zToken
,0);

40845 
rc
 = 
	`valueFromExpr
(
db
, 
pExpr
->
pLeft
, 
enc
, 
aff
, 
ppVal
, 
pCtx
);

40847 if( *
ppVal
 )

40850 
	`sqlite3VdbeMemCast
(*
ppVal
, 
aff
, 1);

40851 
	`sqlite3ValueApplyAffinity
(*
ppVal
, 
affinity
, 1);

40853 return 
rc
;

40859 if( 
op
==155

40860 && (
pExpr
->
pLeft
->
op
==132 || pExpr->pLeft->op==133) )

40863 
pExpr
 = pExpr->
pLeft
;

40864 
op
 = 
pExpr
->op;

40865 
negInt
 = -1;

40866 
zNeg
 = "-";

40869 if( 
op
==97 || op==133 || op==132 )

40872 
pVal
 = 
	`valueNew
(
db
, 
pCtx
);

40873 if( 
pVal
==0 ) goto 
no_mem
;

40874 if( (((
pExpr
)->
flags
&(0x000400))!=0) )

40877 
	`sqlite3VdbeMemSetInt64
(
pVal
, (
i64
)
pExpr
->
u
.
iValue
*
negInt
);

40879 
zVal
 = 
	`sqlite3MPrintf
(
db
, "%s%s", 
zNeg
, 
pExpr
->
u
.
zToken
);

40880 if( 
zVal
==0 ) goto 
no_mem
;

40881 
	`sqlite3ValueSetStr
(
pVal
, -1, 
zVal
, 1, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

40883 if( (
op
==132 || op==133 ) && 
affinity
=='A' )

40886 
	`sqlite3ValueApplyAffinity
(
pVal
, 'C', 1);

40888 
	`sqlite3ValueApplyAffinity
(
pVal
, 
affinity
, 1);

40890 if( 
pVal
->
flags
 & (0x0004|0x0008) ) pVal->flags &= ~0x0002;

40891 if( 
enc
!=1 )

40894 
rc
 = 
	`sqlite3VdbeChangeEncoding
(
pVal
, 
enc
);

40896 }else if( 
op
==155 ) {

40898 if( 0==
	`sqlite3ValueFromExpr
(
db
,
pExpr
->
pLeft
,
enc
,
affinity
,&
pVal
)

40899 && 
pVal
!=0

40903 
	`sqlite3VdbeMemNumerify
(
pVal
);

40904 if( 
pVal
->
flags
 & 0x0008 )

40907 
pVal
->
u
.
r
 = -pVal->u.r;

40908 }else if( 
pVal
->
u
.
i
==(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) )

40911 
pVal
->
u
.
r
 = -(double)(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));

40912 ((
pVal
)->
flags
 = ((pVal)->flags&~(0x81ff|0x4000))|0x0008);

40914 
pVal
->
u
.
i
 = -pVal->u.i;

40916 
	`sqlite3ValueApplyAffinity
(
pVal
, 
affinity
, 
enc
);

40918 }else if( 
op
==101 )

40921 
pVal
 = 
	`valueNew
(
db
, 
pCtx
);

40922 if( 
pVal
==0 ) goto 
no_mem
;

40925 else if( 
op
==134 )

40928 int 
nVal
;

40931 
pVal
 = 
	`valueNew
(
db
, 
pCtx
);

40932 if( !
pVal
 ) goto 
no_mem
;

40933 
zVal
 = &
pExpr
->
u
.
zToken
[2];

40934 
nVal
 = 
	`sqlite3Strlen30
(
zVal
)-1;

40936 
	`sqlite3VdbeMemSetStr
(
pVal
, 
	`sqlite3HexToBlob
(
db
, 
zVal
, 
nVal
), nVal/2,

40937 0, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

40940 *
ppVal
 = 
pVal
;

40941 return 
rc
;

40943 
no_mem
:

40944 
	`sqlite3OomFault
(
db
);

40945 
	`sqlite3DbFree
(
db
, 
zVal
);

40950 ((void) (0)); 
	`sqlite3ValueFree
(
pVal
);

40953 
	}
}

40955 static int 
	$sqlite3ValueFromExpr
(

40956 
sqlite3
 *
db
,

40957 
Expr
 *
pExpr
,

40958 
u8
 
enc
,

40959 
u8
 
affinity
,

40960 
sqlite3_value
 **
ppVal


40964 return 
	`valueFromExpr
(
db
, 
pExpr
, 
enc
, 
affinity
, 
ppVal
, 0);

40965 
	}
}

40967 static void 
sqlite3ValueSetStr
(

40968 
sqlite3_value
 *
v
,

40969 int 
n
,

40970 const void *
z
,

40971 
u8
 
enc
,

40972 void (*
xDel
)(void*)

40976 if( 
v
 ) 
	`sqlite3VdbeMemSetStr
((
Mem
 *)v, 
z
, 
n
, 
enc
, 
xDel
);

40977 
	}
}

40982 static void 
	$sqlite3ValueFree
(
sqlite3_value
 *
v
)

40985 if( !
v
 ) return;

40986 
	`sqlite3VdbeMemRelease
((
Mem
 *)
v
);

40987 
	`sqlite3DbFree
(((
Mem
*)
v
)->
db
, v);

40988 
	}
}

40995 static 
__attribute__
((
noinline
)) int 
	$valueBytes
(
sqlite3_value
 *
pVal
, 
u8
 
enc
)

40998 return 
	`valueToText
(
pVal
, 
enc
)!=0 ? pVal->
n
 : 0;

40999 
	}
}

41000 static int 
	$sqlite3ValueBytes
(
sqlite3_value
 *
pVal
, 
u8
 
enc
)

41003 
Mem
 *
p
 = (Mem*)
pVal
;

41005 if( (
p
->
flags
 & 0x0002)!=0 && 
pVal
->
enc
==enc )

41008 return 
p
->
n
;

41010 if( (
p
->
flags
 & 0x0010)!=0 )

41013 if( 
p
->
flags
 & 0x4000 )

41016 return 
p
->
n
 + p->
u
.
nZero
;

41018 return 
p
->
n
;

41021 if( 
p
->
flags
 & 0x0001 ) return 0;

41022 return 
	`valueBytes
(
pVal
, 
enc
);

41023 
	}
}

41025 static 
Vdbe
 *
	$sqlite3VdbeCreate
(
Parse
 *
pParse
)

41028 
sqlite3
 *
db
 = 
pParse
->db;

41029 
Vdbe
 *
p
;

41030 
p
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
Vdbe
) );

41031 if( 
p
==0 ) return 0;

41032 
p
->
db
 = db;

41033 if( 
db
->
pVdbe
 )

41036 
db
->
pVdbe
->
pPrev
 = 
p
;

41038 
p
->
pNext
 = 
db
->
pVdbe
;

41039 
p
->
pPrev
 = 0;

41040 
db
->
pVdbe
 = 
p
;

41041 
p
->
magic
 = 0x26bceaa5;

41042 
p
->
pParse
 = pParse;

41047 return 
p
;

41048 
	}
}

41053 static void 
	$sqlite3VdbeError
(
Vdbe
 *
p
, const char *
zFormat
, ...)

41056 
va_list
 
ap
;

41057 
	`sqlite3DbFree
(
p
->
db
, p->
zErrMsg
);

41058 
	`__builtin_va_start
(
ap
,
zFormat
);

41059 
p
->
zErrMsg
 = 
	`sqlite3VMPrintf
(p->
db
, 
zFormat
, 
ap
);

41060 
	`__builtin_va_end
(
ap
);

41061 
	}
}

41066 static void 
	$sqlite3VdbeSetSql
(
Vdbe
 *
p
, const char *
z
, int 
n
, int 
isPrepareV2
)

41070 if( 
p
==0 ) return;

41075 
p
->
zSql
 = 
	`sqlite3DbStrNDup
(p->
db
, 
z
, 
n
);

41076 
p
->
isPrepareV2
 = (
u8
)isPrepareV2;

41077 
	}
}

41082 const char * 
	$sqlite3_sql
(
sqlite3_stmt
 *
pStmt
)

41085 
Vdbe
 *
p
 = (Vdbe *)
pStmt
;

41086 return 
p
 ? p->
zSql
 : 0;

41087 
	}
}

41092 static void 
	$sqlite3VdbeSwap
(
Vdbe
 *
pA
, Vdbe *
pB
)

41095 
Vdbe
 
tmp
, *
pTmp
;

41096 char *
zTmp
;

41097 
tmp
 = *
pA
;

41098 *
pA
 = *
pB
;

41099 *
pB
 = 
tmp
;

41100 
pTmp
 = 
pA
->
pNext
;

41101 
pA
->
pNext
 = 
pB
->pNext;

41102 
pB
->
pNext
 = 
pTmp
;

41103 
pTmp
 = 
pA
->
pPrev
;

41104 
pA
->
pPrev
 = 
pB
->pPrev;

41105 
pB
->
pPrev
 = 
pTmp
;

41106 
zTmp
 = 
pA
->
zSql
;

41107 
pA
->
zSql
 = 
pB
->zSql;

41108 
pB
->
zSql
 = 
zTmp
;

41109 
pB
->
isPrepareV2
 = 
pA
->isPrepareV2;

41110 
	}
}

41112 static int 
	$growOpArray
(
Vdbe
 *
v
, int 
nOp
)

41115 
VdbeOp
 *
pNew
;

41116 
Parse
 *
p
 = 
v
->
pParse
;

41118 int 
nNew
 = (
p
->
nOpAlloc
 ? p->nOpAlloc*2 : (int)(1024/sizeof(
Op
)));

41119 (void)(
nOp
);

41124 
pNew
 = 
	`sqlite3DbRealloc
(
p
->
db
, 
v
->
aOp
, 
nNew
*sizeof(
Op
));

41125 if( 
pNew
 )

41128 
p
->
szOpAlloc
 = 
	`sqlite3DbMallocSize
(p->
db
, 
pNew
);

41129 
p
->
nOpAlloc
 = p->
szOpAlloc
/sizeof(
Op
);

41130 
v
->
aOp
 = 
pNew
;

41132 return (
pNew
 ? 0 : 7);

41133 
	}
}

41135 static 
__attribute__
((
noinline
)) int 
	$growOp3
(
Vdbe
 *
p
, int 
op
, int 
p1
, int 
p2
, int 
p3
)

41139 if( 
	`growOpArray
(
p
, 1) ) return 1;

41141 return 
	`sqlite3VdbeAddOp3
(
p
, 
op
, 
p1
, 
p2
, 
p3
);

41142 
	}
}

41143 static int 
	$sqlite3VdbeAddOp3
(
Vdbe
 *
p
, int 
op
, int 
p1
, int 
p2
, int 
p3
)

41146 int 
i
;

41147 
VdbeOp
 *
pOp
;

41149 
i
 = 
p
->
nOp
;

41152 if( 
p
->
pParse
->
nOpAlloc
<=
i
 )

41155 return 
	`growOp3
(
p
, 
op
, 
p1
, 
p2
, 
p3
);

41157 
p
->
nOp
++;

41158 
pOp
 = &
p
->
aOp
[
i
];

41159 
pOp
->
opcode
 = (
u8
)
op
;

41160 
pOp
->
p5
 = 0;

41161 
pOp
->
p1
 = p1;

41162 
pOp
->
p2
 = p2;

41163 
pOp
->
p3
 = p3;

41164 
pOp
->
p4
.
p
 = 0;

41165 
pOp
->
p4type
 = 0;

41167 return 
i
;

41168 
	}
}

41169 static int 
	$sqlite3VdbeAddOp0
(
Vdbe
 *
p
, int 
op
)

41172 return 
	`sqlite3VdbeAddOp3
(
p
, 
op
, 0, 0, 0);

41173 
	}
}

41174 static int 
	$sqlite3VdbeAddOp1
(
Vdbe
 *
p
, int 
op
, int 
p1
)

41177 return 
	`sqlite3VdbeAddOp3
(
p
, 
op
, 
p1
, 0, 0);

41178 
	}
}

41179 static int 
	$sqlite3VdbeAddOp2
(
Vdbe
 *
p
, int 
op
, int 
p1
, int 
p2
)

41182 return 
	`sqlite3VdbeAddOp3
(
p
, 
op
, 
p1
, 
p2
, 0);

41183 
	}
}

41187 static int 
	$sqlite3VdbeGoto
(
Vdbe
 *
p
, int 
iDest
)

41190 return 
	`sqlite3VdbeAddOp3
(
p
, 13, 0, 
iDest
, 0);

41191 
	}
}

41196 static int 
	$sqlite3VdbeLoadString
(
Vdbe
 *
p
, int 
iDest
, const char *
zStr
)

41199 return 
	`sqlite3VdbeAddOp4
(
p
, 97, 0, 
iDest
, 0, 
zStr
, 0);

41200 
	}
}

41202 static void 
	$sqlite3VdbeMultiLoad
(
Vdbe
 *
p
, int 
iDest
, const char *
zTypes
, ...)

41205 
va_list
 
ap
;

41206 int 
i
;

41207 char 
c
;

41208 
	`__builtin_va_start
(
ap
,
zTypes
);

41209 for(
i
=0; (
c
 = 
zTypes
[i])!=0; i++)

41212 if( 
c
=='s' )

41215 const char *
z
 = 
	`__builtin_va_arg
(
ap
,const char*);

41216 
	`sqlite3VdbeAddOp4
(
p
, 
z
==0 ? 25 : 97, 0, 
iDest
++, 0, z, 0);

41219 
	`sqlite3VdbeAddOp2
(
p
, 22, 
	`__builtin_va_arg
(
ap
,int), 
iDest
++);

41222 
	`__builtin_va_end
(
ap
);

41223 
	}
}

41228 static int 
	$sqlite3VdbeAddOp4
(

41229 
Vdbe
 *
p
,

41230 int 
op
,

41231 int 
p1
,

41232 int 
p2
,

41233 int 
p3
,

41234 const char *
zP4
,

41235 int 
p4type


41239 int 
addr
 = 
	`sqlite3VdbeAddOp3
(
p
, 
op
, 
p1
, 
p2
, 
p3
);

41240 
	`sqlite3VdbeChangeP4
(
p
, 
addr
, 
zP4
, 
p4type
);

41241 return 
addr
;

41242 
	}
}

41248 static int 
	$sqlite3VdbeAddOp4Dup8
(

41249 
Vdbe
 *
p
,

41250 int 
op
,

41251 int 
p1
,

41252 int 
p2
,

41253 int 
p3
,

41254 const 
u8
 *
zP4
,

41255 int 
p4type


41259 char *
p4copy
 = 
	`sqlite3DbMallocRawNN
(
	`sqlite3VdbeDb
(
p
), 8);

41260 if( 
p4copy
 ) 
	`memcpy
(p4copy, 
zP4
, 8);

41261 return 
	`sqlite3VdbeAddOp4
(
p
, 
op
, 
p1
, 
p2
, 
p3
, 
p4copy
, 
p4type
);

41262 
	}
}

41264 static void 
	$sqlite3VdbeAddParseSchemaOp
(
Vdbe
 *
p
, int 
iDb
, char *
zWhere
)

41267 int 
j
;

41268 
	`sqlite3VdbeAddOp4
(
p
, 123, 
iDb
, 0, 0, 
zWhere
, (-1));

41269 for(
j
=0; j<
p
->
db
->
nDb
; j++) 
	`sqlite3VdbeUsesBtree
(p, j);

41270 
	}
}

41275 static int 
	$sqlite3VdbeAddOp4Int
(

41276 
Vdbe
 *
p
,

41277 int 
op
,

41278 int 
p1
,

41279 int 
p2
,

41280 int 
p3
,

41281 int 
p4


41285 int 
addr
 = 
	`sqlite3VdbeAddOp3
(
p
, 
op
, 
p1
, 
p2
, 
p3
);

41286 
	`sqlite3VdbeChangeP4
(
p
, 
addr
, ((void*)(long int)(
p4
)), (-14));

41287 return 
addr
;

41288 
	}
}

41292 static void 
	$sqlite3VdbeEndCoroutine
(
Vdbe
 *
v
, int 
regYield
)

41295 
	`sqlite3VdbeAddOp1
(
v
, 17, 
regYield
);

41303 
v
->
pParse
->
nTempReg
 = 0;

41304 
v
->
pParse
->
nRangeReg
 = 0;

41305 
	}
}

41307 static int 
	$sqlite3VdbeMakeLabel
(
Vdbe
 *
v
)

41310 
Parse
 *
p
 = 
v
->
pParse
;

41311 int 
i
 = 
p
->
nLabel
++;

41313 if( (
i
 & (i-1))==0 )

41316 
p
->
aLabel
 = 
	`sqlite3DbReallocOrFree
(p->
db
, p->aLabel,

41317 (
i
*2+1)*sizeof(
p
->
aLabel
[0]));

41319 if( 
p
->
aLabel
 )

41322 
p
->
aLabel
[
i
] = -1;

41324 return (-1-(
i
));

41325 
	}
}

41332 static void 
	$sqlite3VdbeResolveLabel
(
Vdbe
 *
v
, int 
x
)

41335 
Parse
 *
p
 = 
v
->
pParse
;

41336 int 
j
 = (-1-(
x
));

41340 if( 
p
->
aLabel
 )

41343 
p
->
aLabel
[
j
] = 
v
->
nOp
;

41345 
p
->
iFixedOp
 = 
v
->
nOp
 - 1;

41346 
	}
}

41351 static void 
	$sqlite3VdbeRunOnlyOnce
(
Vdbe
 *
p
)

41354 
p
->
runOnlyOnce
 = 1;

41355 
	}
}

41360 static void 
	$sqlite3VdbeReusable
(
Vdbe
 *
p
)

41363 
p
->
runOnlyOnce
 = 0;

41364 
	}
}

41366 static void 
	$resolveP2Values
(
Vdbe
 *
p
, int *
pMaxFuncArgs
)

41369 int 
i
;

41370 int 
nMaxArgs
 = *
pMaxFuncArgs
;

41371 
Op
 *
pOp
;

41372 
Parse
 *
pParse
 = 
p
->pParse;

41373 int *
aLabel
 = 
pParse
->aLabel;

41374 
p
->
readOnly
 = 1;

41375 
p
->
bIsReader
 = 0;

41376 for(
pOp
=
p
->
aOp
, 
i
=p->
nOp
-1; i>=0; i--, pOp++)

41379 
u8
 
opcode
 = 
pOp
->opcode;

41383 switch( 
opcode
 )

41387 if( 
pOp
->
p2
!=0 ) 
p
->
readOnly
 = 0;

41392 
p
->
bIsReader
 = 1;

41400 
p
->
readOnly
 = 0;

41401 
p
->
bIsReader
 = 1;

41406 if( 
pOp
->
p2
>
nMaxArgs
 ) nMaxArgs = pOp->p2;

41410 int 
n
;

41413 
n
 = 
pOp
[-1].
p1
;

41414 if( 
n
>
nMaxArgs
 ) nMaxArgs = n;

41421 
pOp
->
p4
.
xAdvance
 = 
sqlite3BtreeNext
;

41422 
pOp
->
p4type
 = (-19);

41427 
pOp
->
p4
.
xAdvance
 = 
sqlite3BtreePrevious
;

41428 
pOp
->
p4type
 = (-19);

41433 
pOp
->
opflags
 = 
sqlite3OpcodeProperty
[
opcode
];

41434 if( (
pOp
->
opflags
 & 0x01)!=0 && pOp->
p2
<0 )

41438 
pOp
->
p2
 = 
aLabel
[(-1-(pOp->p2))];

41441 
	`sqlite3DbFree
(
p
->
db
, 
pParse
->
aLabel
);

41442 
pParse
->
aLabel
 = 0;

41443 
pParse
->
nLabel
 = 0;

41444 *
pMaxFuncArgs
 = 
nMaxArgs
;

41446 
	}
}

41451 static int 
	$sqlite3VdbeCurrentAddr
(
Vdbe
 *
p
)

41455 return 
p
->
nOp
;

41456 
	}
}

41458 static 
VdbeOp
 *
	$sqlite3VdbeTakeOpArray
(
Vdbe
 *
p
, int *
pnOp
, int *
pnMaxArg
)

41461 
VdbeOp
 *
aOp
 = 
p
->aOp;

41467 
	`resolveP2Values
(
p
, 
pnMaxArg
);

41468 *
pnOp
 = 
p
->
nOp
;

41469 
p
->
aOp
 = 0;

41470 return 
aOp
;

41471 
	}
}

41473 static 
VdbeOp
 *
	$sqlite3VdbeAddOpList
(

41474 
Vdbe
 *
p
,

41475 int 
nOp
,

41476 
VdbeOpList
 const *
aOp
,

41477 int 
iLineno


41481 int 
i
;

41482 
VdbeOp
 *
pOut
, *
pFirst
;

41485 if( 
p
->
nOp
 + nOp > p->
pParse
->
nOpAlloc
 && 
	`growOpArray
(p, nOp) )

41490 
pFirst
 = 
pOut
 = &
p
->
aOp
[p->
nOp
];

41491 for(
i
=0; i<
nOp
; i++, 
aOp
++, 
pOut
++)

41494 
pOut
->
opcode
 = 
aOp
->opcode;

41495 
pOut
->
p1
 = 
aOp
->p1;

41496 
pOut
->
p2
 = 
aOp
->p2;

41498 if( (
sqlite3OpcodeProperty
[
aOp
->
opcode
] & 0x01)!=0 && aOp->
p2
>0 )

41501 
pOut
->
p2
 += 
p
->
nOp
;

41503 
pOut
->
p3
 = 
aOp
->p3;

41504 
pOut
->
p4type
 = 0;

41505 
pOut
->
p4
.
p
 = 0;

41506 
pOut
->
p5
 = 0;

41513 (void)
iLineno
;

41521 
p
->
nOp
 += nOp;

41522 return 
pFirst
;

41523 
	}
}

41525 static void 
	$sqlite3VdbeChangeOpcode
(
Vdbe
 *
p
, 
u32
 
addr
, 
u8
 
iNewOpcode
)

41528 
	`sqlite3VdbeGetOp
(
p
,
addr
)->
opcode
 = 
iNewOpcode
;

41529 
	}
}

41530 static void 
	$sqlite3VdbeChangeP1
(
Vdbe
 *
p
, 
u32
 
addr
, int 
val
)

41533 
	`sqlite3VdbeGetOp
(
p
,
addr
)->
p1
 = 
val
;

41534 
	}
}

41535 static void 
	$sqlite3VdbeChangeP2
(
Vdbe
 *
p
, 
u32
 
addr
, int 
val
)

41538 
	`sqlite3VdbeGetOp
(
p
,
addr
)->
p2
 = 
val
;

41539 
	}
}

41540 static void 
	$sqlite3VdbeChangeP3
(
Vdbe
 *
p
, 
u32
 
addr
, int 
val
)

41543 
	`sqlite3VdbeGetOp
(
p
,
addr
)->
p3
 = 
val
;

41544 
	}
}

41545 static void 
	$sqlite3VdbeChangeP5
(
Vdbe
 *
p
, 
u8
 
p5
)

41548 if( !
p
->
db
->
mallocFailed
 ) p->
aOp
[p->
nOp
-1].
p5
 = p5;

41549 
	}
}

41555 static void 
	$sqlite3VdbeJumpHere
(
Vdbe
 *
p
, int 
addr
)

41558 
p
->
pParse
->
iFixedOp
 = p->
nOp
 - 1;

41559 
	`sqlite3VdbeChangeP2
(
p
, 
addr
, p->
nOp
);

41560 
	}
}

41567 static void 
	$freeEphemeralFunction
(
sqlite3
 *
db
, 
FuncDef
 *
pDef
)

41570 if( (
pDef
) && (pDef->
funcFlags
 & 0x0010)!=0 )

41573 
	`sqlite3DbFree
(
db
, 
pDef
);

41575 
	}
}

41577 static void 
vdbeFreeOpArray
(
sqlite3
 *, 
Op
 *, int);

41582 static void 
	$freeP4
(
sqlite3
 *
db
, int 
p4type
, void *
p4
)

41585 if( 
p4
 )

41589 switch( 
p4type
 )

41593 
	`freeEphemeralFunction
(
db
, ((
sqlite3_context
*)
p4
)->
pFunc
);

41600 
	`sqlite3DbFree
(
db
, 
p4
);

41604 if( 
db
->
pnBytesFreed
==0 ) 
	`sqlite3KeyInfoUnref
((
KeyInfo
*)
p4
);

41614 if( 
db
->
pnBytesFreed
==0 ) 
	`sqlite3_free
(
p4
);

41618 
	`freeEphemeralFunction
(
db
, (
FuncDef
*)
p4
);

41622 if( 
db
->
pnBytesFreed
==0 )

41625 
	`sqlite3ValueFree
((
sqlite3_value
*)
p4
);

41627 
Mem
 *
p
 = (Mem*)
p4
;

41628 if( 
p
->
szMalloc
 ) 
	`sqlite3DbFree
(
db
, p->
zMalloc
);

41629 
	`sqlite3DbFree
(
db
, 
p
);

41634 if( 
db
->
pnBytesFreed
==0 ) 
	`sqlite3VtabUnlock
((
VTable
 *)
p4
);

41639 
	}
}

41646 static void 
	$vdbeFreeOpArray
(
sqlite3
 *
db
, 
Op
 *
aOp
, int 
nOp
)

41649 if( 
aOp
 )

41652 
Op
 *
pOp
;

41653 for(
pOp
=
aOp
; pOp<&aOp[
nOp
]; pOp++)

41656 if( 
pOp
->
p4type
 ) 
	`freeP4
(
db
, pOp->p4type, pOp->
p4
.
p
);

41662 
	`sqlite3DbFree
(
db
, 
aOp
);

41663 
	}
}

41670 static void 
	$sqlite3VdbeLinkSubProgram
(
Vdbe
 *
pVdbe
, 
SubProgram
 *
p
)

41673 
p
->
pNext
 = 
pVdbe
->
pProgram
;

41674 
pVdbe
->
pProgram
 = 
p
;

41675 
	}
}

41680 static int 
	$sqlite3VdbeChangeToNoop
(
Vdbe
 *
p
, int 
addr
)

41683 
VdbeOp
 *
pOp
;

41684 if( 
p
->
db
->
mallocFailed
 ) return 0;

41686 
pOp
 = &
p
->
aOp
[
addr
];

41687 
	`freeP4
(
p
->
db
, 
pOp
->
p4type
, pOp->
p4
.p);

41688 
pOp
->
p4type
 = 0;

41689 
pOp
->
p4
.
z
 = 0;

41690 
pOp
->
opcode
 = 160;

41692 
	}
}

41698 static int 
	$sqlite3VdbeDeletePriorOpcode
(
Vdbe
 *
p
, 
u8
 
op
)

41701 if( (
p
->
nOp
-1)>(p->
pParse
->
iFixedOp
) && p->
aOp
[p->nOp-1].
opcode
==
op
 )

41704 return 
	`sqlite3VdbeChangeToNoop
(
p
, p->
nOp
-1);

41708 
	}
}

41710 static void 
__attribute__
((
noinline
)) 
	$vdbeChangeP4Full
(

41711 
Vdbe
 *
p
,

41712 
Op
 *
pOp
,

41713 const char *
zP4
,

41714 int 
n


41718 if( 
pOp
->
p4type
 )

41721 
	`freeP4
(
p
->
db
, 
pOp
->
p4type
, pOp->
p4
.p);

41722 
pOp
->
p4type
 = 0;

41723 
pOp
->
p4
.
p
 = 0;

41725 if( 
n
<0 )

41728 
	`sqlite3VdbeChangeP4
(
p
, (int)(
pOp
 - p->
aOp
), 
zP4
, 
n
);

41730 if( 
n
==0 ) n = 
	`sqlite3Strlen30
(
zP4
);

41731 
pOp
->
p4
.
z
 = 
	`sqlite3DbStrNDup
(
p
->
db
, 
zP4
, 
n
);

41732 
pOp
->
p4type
 = (-1);

41734 
	}
}

41735 static void 
	$sqlite3VdbeChangeP4
(
Vdbe
 *
p
, int 
addr
, const char *
zP4
, int 
n
)

41738 
Op
 *
pOp
;

41739 
sqlite3
 *
db
;

41741 
db
 = 
p
->db;

41744 if( 
db
->
mallocFailed
 )

41747 if( 
n
!=(-10) ) 
	`freeP4
(
db
, n, (void*)*(char**)&
zP4
);

41752 if( 
addr
<0 )

41755 
addr
 = 
p
->
nOp
 - 1;

41757 
pOp
 = &
p
->
aOp
[
addr
];

41758 if( 
n
>=0 || 
pOp
->
p4type
 )

41761 
	`vdbeChangeP4Full
(
p
, 
pOp
, 
zP4
, 
n
);

41764 if( 
n
==(-14) )

41769 
pOp
->
p4
.
i
 = ((int)(long int)(
zP4
));

41770 
pOp
->
p4type
 = (-14);

41771 }else if( 
zP4
!=0 )

41775 
pOp
->
p4
.
p
 = (void*)
zP4
;

41776 
pOp
->
p4type
 = (signed char)
n
;

41777 if( 
n
==(-10) ) 
	`sqlite3VtabLock
((
VTable
*)
zP4
);

41779 
	}
}

41785 static void 
	$sqlite3VdbeSetP4KeyInfo
(
Parse
 *
pParse
, 
Index
 *
pIdx
)

41788 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

41791 
	`sqlite3VdbeChangeP4
(
v
, -1, (char*)
	`sqlite3KeyInfoOfIndex
(
pParse
, 
pIdx
),

41793 
	}
}

41795 static 
VdbeOp
 *
	$sqlite3VdbeGetOp
(
Vdbe
 *
p
, int 
addr
)

41800 static 
VdbeOp
 
dummy
;

41802 if( 
addr
<0 )

41805 
addr
 = 
p
->
nOp
 - 1;

41808 if( 
p
->
db
->
mallocFailed
 )

41811 return (
VdbeOp
*)&
dummy
;

41813 return &
p
->
aOp
[
addr
];

41815 
	}
}

41817 static char *
	$displayP4
(
Op
 *
pOp
, char *
zTemp
, int 
nTemp
)

41820 char *
zP4
 = 
zTemp
;

41821 
StrAccum
 
x
;

41823 
	`sqlite3StrAccumInit
(&
x
, 0, 
zTemp
, 
nTemp
, 0);

41824 switch( 
pOp
->
p4type
 )

41828 int 
j
;

41829 
KeyInfo
 *
pKeyInfo
 = 
pOp
->
p4
.pKeyInfo;

41831 
	`sqlite3XPrintf
(&
x
, "k(%d", 
pKeyInfo
->
nField
);

41832 for(
j
=0; j<
pKeyInfo
->
nField
; j++)

41835 
CollSeq
 *
pColl
 = 
pKeyInfo
->
aColl
[
j
];

41836 const char *
zColl
 = 
pColl
 ? pColl->
zName
 : "";

41837 if( 
	`strcmp
(
zColl
, "BINARY")==0 ) zColl = "B";

41838 
	`sqlite3XPrintf
(&
x
, ",%s%s", 
pKeyInfo
->
aSortOrder
[
j
] ? "-" : "", 
zColl
);

41840 
	`sqlite3StrAccumAppend
(&
x
, ")", 1);

41850 
CollSeq
 *
pColl
 = 
pOp
->
p4
.pColl;

41851 
	`sqlite3XPrintf
(&
x
, "(%.20s)", 
pColl
->
zName
);

41855 
FuncDef
 *
pDef
 = 
pOp
->
p4
.
pFunc
;

41856 
	`sqlite3XPrintf
(&
x
, "%s(%d)", 
pDef
->
zName
, pDef->
nArg
);

41867 
	`sqlite3XPrintf
(&
x
, "%lld", *
pOp
->
p4
.
pI64
);

41871 
	`sqlite3XPrintf
(&
x
, "%d", 
pOp
->
p4
.
i
);

41875 
	`sqlite3XPrintf
(&
x
, "%.16g", *
pOp
->
p4
.
pReal
);

41879 
Mem
 *
pMem
 = 
pOp
->
p4
.pMem;

41880 if( 
pMem
->
flags
 & 0x0002 )

41883 
zP4
 = 
pMem
->
z
;

41884 }else if( 
pMem
->
flags
 & 0x0004 )

41887 
	`sqlite3XPrintf
(&
x
, "%lld", 
pMem
->
u
.
i
);

41888 }else if( 
pMem
->
flags
 & 0x0008 )

41891 
	`sqlite3XPrintf
(&
x
, "%.16g", 
pMem
->
u
.
r
);

41892 }else if( 
pMem
->
flags
 & 0x0001 )

41895 
zP4
 = "NULL";

41898 
zP4
 = "(blob)";

41904 
sqlite3_vtab
 *
pVtab
 = 
pOp
->
p4
.pVtab->pVtab;

41905 
	`sqlite3XPrintf
(&
x
, "vtab:%p", 
pVtab
);

41910 int 
i
;

41911 int *
ai
 = 
pOp
->
p4
.ai;

41912 int 
n
 = 
ai
[0];

41914 for(
i
=1; i<
n
; i++)

41917 
	`sqlite3XPrintf
(&
x
, ",%d", 
ai
[
i
]);

41919 
zTemp
[0] = '[';

41920 
	`sqlite3StrAccumAppend
(&
x
, "]", 1);

41924 
	`sqlite3XPrintf
(&
x
, "program");

41928 
zTemp
[0] = 0;

41932 
zP4
 = 
pOp
->
p4
.
z
;

41933 if( 
zP4
==0 )

41936 
zP4
 = 
zTemp
;

41937 
zTemp
[0] = 0;

41941 
	`sqlite3StrAccumFinish
(&
x
);

41943 return 
zP4
;

41944 
	}
}

41946 static void 
	$sqlite3VdbeUsesBtree
(
Vdbe
 *
p
, int 
i
)

41951 (
p
->
btreeMask
)|=(((
yDbMask
)1)<<(
i
));

41952 if( 
i
!=1 && 
	`sqlite3BtreeSharable
(
p
->
db
->
aDb
[i].
pBt
) )

41955 (
p
->
lockMask
)|=(((
yDbMask
)1)<<(
i
));

41957 
	}
}

41959 static void 
	$sqlite3VdbeEnter
(
Vdbe
 *
p
)

41962 int 
i
;

41963 
sqlite3
 *
db
;

41964 
Db
 *
aDb
;

41965 int 
nDb
;

41966 if( (
p
->
lockMask
)==0 ) return;

41967 
db
 = 
p
->db;

41968 
aDb
 = 
db
->aDb;

41969 
nDb
 = 
db
->nDb;

41970 for(
i
=0; i<
nDb
; i++)

41973 if( 
i
!=1 && (((
p
->
lockMask
)&(((
yDbMask
)1)<<(i)))!=0) && (
aDb
[i].
pBt
!=0) )

41976 
	`sqlite3BtreeEnter
(
aDb
[
i
].
pBt
);

41979 
	}
}

41986 static 
__attribute__
((
noinline
)) void 
	$vdbeLeave
(
Vdbe
 *
p
)

41989 int 
i
;

41990 
sqlite3
 *
db
;

41991 
Db
 *
aDb
;

41992 int 
nDb
;

41993 
db
 = 
p
->db;

41994 
aDb
 = 
db
->aDb;

41995 
nDb
 = 
db
->nDb;

41996 for(
i
=0; i<
nDb
; i++)

41999 if( 
i
!=1 && (((
p
->
lockMask
)&(((
yDbMask
)1)<<(i)))!=0) && (
aDb
[i].
pBt
!=0) )

42002 
	`sqlite3BtreeLeave
(
aDb
[
i
].
pBt
);

42005 
	}
}

42006 static void 
	$sqlite3VdbeLeave
(
Vdbe
 *
p
)

42009 if( (
p
->
lockMask
)==0 ) return;

42010 
	`vdbeLeave
(
p
);

42011 
	}
}

42013 static void 
	$releaseMemArray
(
Mem
 *
p
, int 
N
)

42016 if( 
p
 && 
N
 )

42019 
Mem
 *
pEnd
 = &
p
[
N
];

42020 
sqlite3
 *
db
 = 
p
->db;

42021 if( 
db
->
pnBytesFreed
 )

42025 if( 
p
->
szMalloc
 ) 
	`sqlite3DbFree
(
db
, p->
zMalloc
);

42026 }while( (++
p
)<
pEnd
 );

42037 if( 
p
->
flags
&(0x2000|0x0400|0x0040|0x0020) )

42040 
	`sqlite3VdbeMemRelease
(
p
);

42041 }else if( 
p
->
szMalloc
 )

42044 
	`sqlite3DbFree
(
db
, 
p
->
zMalloc
);

42045 
p
->
szMalloc
 = 0;

42048 
p
->
flags
 = 0x0080;

42049 }while( (++
p
)<
pEnd
 );

42051 
	}
}

42057 static void 
	$sqlite3VdbeFrameDelete
(
VdbeFrame
 *
p
)

42060 int 
i
;

42061 
Mem
 *
aMem
 = ((Mem *)&((
u8
 *)
p
)[(((sizeof(
VdbeFrame
))+7)&~7)]);

42062 
VdbeCursor
 **
apCsr
 = (VdbeCursor **)&
aMem
[
p
->
nChildMem
];

42063 for(
i
=0; i<
p
->
nChildCsr
; i++)

42066 
	`sqlite3VdbeFreeCursor
(
p
->
v
, 
apCsr
[
i
]);

42068 
	`releaseMemArray
(
aMem
, 
p
->
nChildMem
);

42069 
	`sqlite3VdbeDeleteAuxData
(
p
->
v
->
db
, &p->
pAuxData
, -1, 0);

42070 
	`sqlite3DbFree
(
p
->
v
->
db
, p);

42071 
	}
}

42073 static int 
	$sqlite3VdbeList
(

42074 
Vdbe
 *
p


42078 int 
nRow
;

42079 int 
nSub
 = 0;

42080 
SubProgram
 **
apSub
 = 0;

42081 
Mem
 *
pSub
 = 0;

42082 
sqlite3
 *
db
 = 
p
->db;

42083 int 
i
;

42084 int 
rc
 = 0;

42085 
Mem
 *
pMem
 = &
p
->
aMem
[1];

42095 
	`releaseMemArray
(
pMem
, 8);

42096 
p
->
pResultSet
 = 0;

42098 if( 
p
->
rc
==7 )

42103 
	`sqlite3OomFault
(
db
);

42107 
nRow
 = 
p
->
nOp
;

42108 if( 
p
->
explain
==1 )

42116 
pSub
 = &
p
->
aMem
[9];

42117 if( 
pSub
->
flags
&0x0010 )

42122 
nSub
 = 
pSub
->
n
/sizeof(
Vdbe
*);

42123 
apSub
 = (
SubProgram
 **)
pSub
->
z
;

42125 for(
i
=0; i<
nSub
; i++)

42128 
nRow
 += 
apSub
[
i
]->
nOp
;

42133 
i
 = 
p
->
pc
++;

42134 }while( 
i
<
nRow
 && 
p
->
explain
==2 && p->
aOp
[i].
opcode
!=161 );

42135 if( 
i
>=
nRow
 )

42138 
p
->
rc
 = 0;

42139 
rc
 = 101;

42140 }else if( 
db
->
u1
.
isInterrupted
 )

42143 
p
->
rc
 = 9;

42144 
rc
 = 1;

42145 
	`sqlite3VdbeError
(
p
, 
	`sqlite3ErrStr
(p->
rc
));

42147 char *
zP4
;

42148 
Op
 *
pOp
;

42149 if( 
i
<
p
->
nOp
 )

42154 
pOp
 = &
p
->
aOp
[
i
];

42158 int 
j
;

42159 
i
 -= 
p
->
nOp
;

42160 for(
j
=0; 
i
>=
apSub
[j]->
nOp
; j++)

42163 
i
 -= 
apSub
[
j
]->
nOp
;

42165 
pOp
 = &
apSub
[
j
]->
aOp
[
i
];

42167 if( 
p
->
explain
==1 )

42170 
pMem
->
flags
 = 0x0004;

42171 
pMem
->
u
.
i
 = i;

42172 
pMem
++;

42174 
pMem
->
flags
 = 0x0800|0x0002|0x0200;

42175 
pMem
->
z
 = (char*)
	`sqlite3OpcodeName
(
pOp
->
opcode
);

42177 
pMem
->
n
 = 
	`sqlite3Strlen30
(pMem->
z
);

42178 
pMem
->
enc
 = 1;

42179 
pMem
++;

42186 if( 
pOp
->
p4type
==(-18) )

42189 int 
nByte
 = (
nSub
+1)*sizeof(
SubProgram
*);

42190 int 
j
;

42191 for(
j
=0; j<
nSub
; j++)

42194 if( 
apSub
[
j
]==
pOp
->
p4
.
pProgram
 ) break;

42196 if( 
j
==
nSub
 && 0==
	`sqlite3VdbeMemGrow
(
pSub
, 
nByte
, nSub!=0) )

42199 
apSub
 = (
SubProgram
 **)
pSub
->
z
;

42200 
apSub
[
nSub
++] = 
pOp
->
p4
.
pProgram
;

42201 
pSub
->
flags
 |= 0x0010;

42202 
pSub
->
n
 = 
nSub
*sizeof(
SubProgram
*);

42207 
pMem
->
flags
 = 0x0004;

42208 
pMem
->
u
.
i
 = 
pOp
->
p1
;

42209 
pMem
++;

42211 
pMem
->
flags
 = 0x0004;

42212 
pMem
->
u
.
i
 = 
pOp
->
p2
;

42213 
pMem
++;

42215 
pMem
->
flags
 = 0x0004;

42216 
pMem
->
u
.
i
 = 
pOp
->
p3
;

42217 
pMem
++;

42219 if( 
	`sqlite3VdbeMemClearAndResize
(
pMem
, 100) )

42225 
pMem
->
flags
 = 0x0002|0x0200;

42226 
zP4
 = 
	`displayP4
(
pOp
, 
pMem
->
z
, pMem->
szMalloc
);

42227 if( 
zP4
!=
pMem
->
z
 )

42230 
	`sqlite3VdbeMemSetStr
(
pMem
, 
zP4
, -1, 1, 0);

42233 
pMem
->
n
 = 
	`sqlite3Strlen30
(pMem->
z
);

42234 
pMem
->
enc
 = 1;

42236 
pMem
++;

42238 if( 
p
->
explain
==1 )

42241 if( 
	`sqlite3VdbeMemClearAndResize
(
pMem
, 4) )

42247 
pMem
->
flags
 = 0x0002|0x0200;

42248 
pMem
->
n
 = 2;

42249 
	`sqlite3_snprintf
(3, 
pMem
->
z
, "%.2x", 
pOp
->
p5
);

42250 
pMem
->
enc
 = 1;

42251 
pMem
++;

42253 
pMem
->
flags
 = 0x0001;

42257 
p
->
nResColumn
 = 8 - 4*(p->
explain
-1);

42258 
p
->
pResultSet
 = &p->
aMem
[1];

42259 
p
->
rc
 = 0;

42260 
rc
 = 100;

42262 return 
rc
;

42263 
	}
}

42265 struct 
	sReusableSpace
 {

42266 
u8
 *
	mpSpace
;

42267 int 
	mnFree
;

42268 int 
	mnNeeded
;

42271 static void *
	$allocSpace
(

42272 struct 
ReusableSpace
 *
p
,

42273 void *
pBuf
,

42274 int 
nByte


42279 if( 
pBuf
==0 )

42282 
nByte
 = (((nByte)+7)&~7);

42283 if( 
nByte
 <= 
p
->
nFree
 )

42286 
p
->
nFree
 -= 
nByte
;

42287 
pBuf
 = &
p
->
pSpace
[p->
nFree
];

42289 
p
->
nNeeded
 += 
nByte
;

42293 return 
pBuf
;

42294 
	}
}

42300 static void 
	$sqlite3VdbeRewind
(
Vdbe
 *
p
)

42314 
p
->
magic
 = 0xbdf20da3;

42321 
p
->
pc
 = -1;

42322 
p
->
rc
 = 0;

42323 
p
->
errorAction
 = 2;

42324 
p
->
nChange
 = 0;

42325 
p
->
cacheCtr
 = 1;

42326 
p
->
minWriteFileFormat
 = 255;

42327 
p
->
iStatement
 = 0;

42328 
p
->
nFkConstraint
 = 0;

42335 
	}
}

42337 static void 
	$sqlite3VdbeMakeReady
(

42338 
Vdbe
 *
p
,

42339 
Parse
 *
pParse


42343 
sqlite3
 *
db
;

42344 int 
nVar
;

42345 int 
nMem
;

42346 int 
nCursor
;

42347 int 
nArg
;

42348 int 
nOnce
;

42349 int 
n
;

42350 struct 
ReusableSpace
 
x
;

42357 
db
 = 
p
->db;

42359 
nVar
 = 
pParse
->nVar;

42360 
nMem
 = 
pParse
->nMem;

42361 
nCursor
 = 
pParse
->
nTab
;

42362 
nArg
 = 
pParse
->
nMaxArg
;

42363 
nOnce
 = 
pParse
->nOnce;

42364 if( 
nOnce
==0 ) nOnce = 1;

42371 
nMem
 += 
nCursor
;

42372 if( 
nCursor
==0 && 
nMem
>0 ) nMem++;

42378 
n
 = (((sizeof(
Op
)*
p
->
nOp
)+7)&~7);

42379 
x
.
pSpace
 = &((
u8
*)
p
->
aOp
)[
n
];

42381 
x
.
nFree
 = ((
pParse
->
szOpAlloc
 - 
n
)&~7);

42383 if( 
x
.
nFree
>0 )

42386 
	`memset
(
x
.
pSpace
, 0, x.
nFree
);

42390 
	`resolveP2Values
(
p
, &
nArg
);

42391 
p
->
usesStmtJournal
 = (
u8
)(
pParse
->
isMultiWrite
 && pParse->
mayAbort
);

42392 if( 
pParse
->
explain
 && 
nMem
<10 )

42395 
nMem
 = 10;

42397 
p
->
expired
 = 0;

42400 
x
.
nNeeded
 = 0;

42401 
p
->
aMem
 = 
	`allocSpace
(&
x
, p->aMem, 
nMem
*sizeof(
Mem
));

42402 
p
->
aVar
 = 
	`allocSpace
(&
x
, p->aVar, 
nVar
*sizeof(
Mem
));

42403 
p
->
apArg
 = 
	`allocSpace
(&
x
, p->apArg, 
nArg
*sizeof(
Mem
*));

42404 
p
->
apCsr
 = 
	`allocSpace
(&
x
, p->apCsr, 
nCursor
*sizeof(
VdbeCursor
*));

42405 
p
->
aOnceFlag
 = 
	`allocSpace
(&
x
, p->aOnceFlag, 
nOnce
);

42409 if( 
x
.
nNeeded
==0 ) break;

42410 
x
.
pSpace
 = 
p
->
pFree
 = 
	`sqlite3DbMallocZero
(
db
, x.
nNeeded
);

42411 
x
.
nFree
 = x.
nNeeded
;

42412 }while( !
db
->
mallocFailed
 );

42414 
p
->
nCursor
 = nCursor;

42415 
p
->
nOnceFlag
 = 
nOnce
;

42416 if( 
p
->
aVar
 )

42419 
p
->
nVar
 = (
ynVar
)nVar;

42420 for(
n
=0; n<
nVar
; n++)

42423 
p
->
aVar
[
n
].
flags
 = 0x0001;

42424 
p
->
aVar
[
n
].
db
 = db;

42427 
p
->
nzVar
 = 
pParse
->nzVar;

42428 
p
->
azVar
 = 
pParse
->azVar;

42429 
pParse
->
nzVar
 = 0;

42430 
pParse
->
azVar
 = 0;

42431 if( 
p
->
aMem
 )

42434 
p
->
nMem
 = nMem;

42435 for(
n
=0; n<
nMem
; n++)

42438 
p
->
aMem
[
n
].
flags
 = 0x0080;

42439 
p
->
aMem
[
n
].
db
 = db;

42442 
p
->
explain
 = 
pParse
->explain;

42443 
	`sqlite3VdbeRewind
(
p
);

42444 
	}
}

42450 static void 
	$sqlite3VdbeFreeCursor
(
Vdbe
 *
p
, 
VdbeCursor
 *
pCx
)

42453 if( 
pCx
==0 )

42459 switch( 
pCx
->
eCurType
 )

42463 
	`sqlite3VdbeSorterClose
(
p
->
db
, 
pCx
);

42467 if( 
pCx
->
pBt
 )

42470 
	`sqlite3BtreeClose
(
pCx
->
pBt
);

42475 
	`sqlite3BtreeCloseCursor
(
pCx
->
uc
.
pCursor
);

42481 
sqlite3_vtab_cursor
 *
pVCur
 = 
pCx
->
uc
.pVCur;

42482 const 
sqlite3_module
 *
pModule
 = 
pVCur
->
pVtab
->pModule;

42484 
pVCur
->
pVtab
->
nRef
--;

42485 
pModule
->
	`xClose
(
pVCur
);

42490 
	}
}

42495 static void 
	$closeCursorsInFrame
(
Vdbe
 *
p
)

42498 if( 
p
->
apCsr
 )

42501 int 
i
;

42502 for(
i
=0; i<
p
->
nCursor
; i++)

42505 
VdbeCursor
 *
pC
 = 
p
->
apCsr
[
i
];

42506 if( 
pC
 )

42509 
	`sqlite3VdbeFreeCursor
(
p
, 
pC
);

42510 
p
->
apCsr
[
i
] = 0;

42514 
	}
}

42521 static int 
	$sqlite3VdbeFrameRestore
(
VdbeFrame
 *
pFrame
)

42524 
Vdbe
 *
v
 = 
pFrame
->v;

42525 
	`closeCursorsInFrame
(
v
);

42529 
v
->
aOnceFlag
 = 
pFrame
->aOnceFlag;

42530 
v
->
nOnceFlag
 = 
pFrame
->nOnceFlag;

42531 
v
->
aOp
 = 
pFrame
->aOp;

42532 
v
->
nOp
 = 
pFrame
->nOp;

42533 
v
->
aMem
 = 
pFrame
->aMem;

42534 
v
->
nMem
 = 
pFrame
->nMem;

42535 
v
->
apCsr
 = 
pFrame
->apCsr;

42536 
v
->
nCursor
 = 
pFrame
->nCursor;

42537 
v
->
db
->
lastRowid
 = 
pFrame
->lastRowid;

42538 
v
->
nChange
 = 
pFrame
->nChange;

42539 
v
->
db
->
nChange
 = 
pFrame
->
nDbChange
;

42540 
	`sqlite3VdbeDeleteAuxData
(
v
->
db
, &v->
pAuxData
, -1, 0);

42541 
v
->
pAuxData
 = 
pFrame
->pAuxData;

42542 
pFrame
->
pAuxData
 = 0;

42543 return 
pFrame
->
pc
;

42544 
	}
}

42546 static void 
	$closeAllCursors
(
Vdbe
 *
p
)

42549 if( 
p
->
pFrame
 )

42552 
VdbeFrame
 *
pFrame
;

42553 for(
pFrame
=
p
->pFrame; pFrame->
pParent
; pFrame=pFrame->pParent);

42554 
	`sqlite3VdbeFrameRestore
(
pFrame
);

42555 
p
->
pFrame
 = 0;

42556 
p
->
nFrame
 = 0;

42559 
	`closeCursorsInFrame
(
p
);

42560 if( 
p
->
aMem
 )

42563 
	`releaseMemArray
(
p
->
aMem
, p->
nMem
);

42565 while( 
p
->
pDelFrame
 )

42568 
VdbeFrame
 *
pDel
 = 
p
->
pDelFrame
;

42569 
p
->
pDelFrame
 = 
pDel
->
pParent
;

42570 
	`sqlite3VdbeFrameDelete
(
pDel
);

42574 if( 
p
->
pAuxData
 ) 
	`sqlite3VdbeDeleteAuxData
(p->
db
, &p->pAuxData, -1, 0);

42576 
	}
}

42581 static void 
	$Cleanup
(
Vdbe
 *
p
)

42584 
sqlite3
 *
db
 = 
p
->db;

42586 
	`sqlite3DbFree
(
db
, 
p
->
zErrMsg
);

42587 
p
->
zErrMsg
 = 0;

42588 
p
->
pResultSet
 = 0;

42589 
	}
}

42597 static void 
	$sqlite3VdbeSetNumCols
(
Vdbe
 *
p
, int 
nResColumn
)

42600 
Mem
 *
pColName
;

42601 int 
n
;

42602 
sqlite3
 *
db
 = 
p
->db;

42604 
	`releaseMemArray
(
p
->
aColName
, p->
nResColumn
*2);

42605 
	`sqlite3DbFree
(
db
, 
p
->
aColName
);

42606 
n
 = 
nResColumn
*2;

42607 
p
->
nResColumn
 = (
u16
)nResColumn;

42608 
p
->
aColName
 = 
pColName
 = (
Mem
*)
	`sqlite3DbMallocZero
(
db
, sizeof(Mem)*
n
 );

42609 if( 
p
->
aColName
==0 ) return;

42610 while( 
n
-- > 0 )

42613 
pColName
->
flags
 = 0x0001;

42614 
pColName
->
db
 = 
p
->db;

42615 
pColName
++;

42617 
	}
}

42619 static int 
sqlite3VdbeSetColName
(

42620 
Vdbe
 *
p
,

42621 int 
idx
,

42622 int 
var
,

42623 const char *
zName
,

42624 void (*
xDel
)(void*)

42628 int 
rc
;

42629 
Mem
 *
pColName
;

42632 if( 
p
->
db
->
mallocFailed
 )

42639 
pColName
 = &(
p
->
aColName
[
idx
+
var
*p->
nResColumn
]);

42640 
rc
 = 
	`sqlite3VdbeMemSetStr
(
pColName
, 
zName
, -1, 1, 
xDel
);

42642 return 
rc
;

42643 
	}
}

42651 static int 
	$vdbeCommit
(
sqlite3
 *
db
, 
Vdbe
 *
p
)

42654 int 
i
;

42655 int 
nTrans
 = 0;

42658 int 
rc
 = 0;

42659 int 
needXcommit
 = 0;

42661 
rc
 = 
	`sqlite3VtabSync
(
db
, 
p
);

42669 for(
i
=0; 
rc
==0 && i<
db
->
nDb
; i++)

42672 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

42673 if( 
	`sqlite3BtreeIsInTrans
(
pBt
) )

42679 static const 
u8
 
aMJNeeded
[] = {

42687 
Pager
 *
pPager
;

42688 
needXcommit
 = 1;

42689 
	`sqlite3BtreeEnter
(
pBt
);

42690 
pPager
 = 
	`sqlite3BtreePager
(
pBt
);

42691 if( 
db
->
aDb
[
i
].
safety_level
!=0x01

42692 && 
aMJNeeded
[
	`sqlite3PagerGetJournalMode
(
pPager
)]

42697 
nTrans
++;

42699 
rc
 = 
	`sqlite3PagerExclusiveLock
(
pPager
);

42700 
	`sqlite3BtreeLeave
(
pBt
);

42703 if( 
rc
!=0 )

42706 return 
rc
;

42710 if( 
needXcommit
 && 
db
->
xCommitCallback
 )

42713 
rc
 = 
db
->
	`xCommitCallback
(db->
pCommitArg
);

42714 if( 
rc
 )

42721 if( 0==
	`sqlite3Strlen30
(
	`sqlite3BtreeGetFilename
(
db
->
aDb
[0].
pBt
))

42722 || 
nTrans
<=1

42726 for(
i
=0; 
rc
==0 && i<
db
->
nDb
; i++)

42729 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

42730 if( 
pBt
 )

42733 
rc
 = 
	`sqlite3BtreeCommitPhaseOne
(
pBt
, 0);

42742 for(
i
=0; 
rc
==0 && i<
db
->
nDb
; i++)

42745 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

42746 if( 
pBt
 )

42749 
rc
 = 
	`sqlite3BtreeCommitPhaseTwo
(
pBt
, 0);

42752 if( 
rc
==0 )

42755 
	`sqlite3VtabCommit
(
db
);

42765 
sqlite3_vfs
 *
pVfs
 = 
db
->pVfs;

42766 char *
zMaster
 = 0;

42767 char const *
zMainFile
 = 
	`sqlite3BtreeGetFilename
(
db
->
aDb
[0].
pBt
);

42768 
sqlite3_file
 *
pMaster
 = 0;

42769 
i64
 
offset
 = 0;

42770 int 
res
;

42771 int 
retryCount
 = 0;

42772 int 
nMainFile
;

42775 
nMainFile
 = 
	`sqlite3Strlen30
(
zMainFile
);

42776 
zMaster
 = 
	`sqlite3MPrintf
(
db
, "%s-mjXXXXXX9XXz", 
zMainFile
);

42777 if( 
zMaster
==0 ) return 7;

42779 
u32
 
iRandom
;

42780 if( 
retryCount
 )

42783 if( 
retryCount
>100 )

42786 
	`sqlite3_log
(13, "MJ delete: %s", 
zMaster
);

42787 
	`sqlite3OsDelete
(
pVfs
, 
zMaster
, 0);

42789 }else if( 
retryCount
==1 )

42792 
	`sqlite3_log
(13, "MJ collide: %s", 
zMaster
);

42795 
retryCount
++;

42796 
	`sqlite3_randomness
(sizeof(
iRandom
), &iRandom);

42797 
	`sqlite3_snprintf
(13, &
zMaster
[
nMainFile
], "-mj%06X9%02X",

42798 (
iRandom
>>8)&0xffffff, iRandom&0xff);

42803 
rc
 = 
	`sqlite3OsAccess
(
pVfs
, 
zMaster
, 0, &
res
);

42804 }while( 
rc
==0 && 
res
 );

42805 if( 
rc
==0 )

42809 
rc
 = 
	`sqlite3OsOpenMalloc
(
pVfs
, 
zMaster
, &
pMaster
,

42814 if( 
rc
!=0 )

42817 
	`sqlite3DbFree
(
db
, 
zMaster
);

42818 return 
rc
;

42827 for(
i
=0; i<
db
->
nDb
; i++)

42830 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

42831 if( 
	`sqlite3BtreeIsInTrans
(
pBt
) )

42834 char const *
zFile
 = 
	`sqlite3BtreeGetJournalname
(
pBt
);

42835 if( 
zFile
==0 )

42841 
rc
 = 
	`sqlite3OsWrite
(
pMaster
, 
zFile
, 
	`sqlite3Strlen30
(zFile)+1, 
offset
);

42842 
offset
 += 
	`sqlite3Strlen30
(
zFile
)+1;

42843 if( 
rc
!=0 )

42846 
	`sqlite3OsCloseFree
(
pMaster
);

42847 
	`sqlite3OsDelete
(
pVfs
, 
zMaster
, 0);

42848 
	`sqlite3DbFree
(
db
, 
zMaster
);

42849 return 
rc
;

42857 if( 0==(
	`sqlite3OsDeviceCharacteristics
(
pMaster
)&0x00000400)

42858 && 0!=(
rc
 = 
	`sqlite3OsSync
(
pMaster
, 0x00002))

42862 
	`sqlite3OsCloseFree
(
pMaster
);

42863 
	`sqlite3OsDelete
(
pVfs
, 
zMaster
, 0);

42864 
	`sqlite3DbFree
(
db
, 
zMaster
);

42865 return 
rc
;

42868 for(
i
=0; 
rc
==0 && i<
db
->
nDb
; i++)

42871 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

42872 if( 
pBt
 )

42875 
rc
 = 
	`sqlite3BtreeCommitPhaseOne
(
pBt
, 
zMaster
);

42878 
	`sqlite3OsCloseFree
(
pMaster
);

42880 if( 
rc
!=0 )

42883 
	`sqlite3DbFree
(
db
, 
zMaster
);

42884 return 
rc
;

42891 
rc
 = 
	`sqlite3OsDelete
(
pVfs
, 
zMaster
, 1);

42892 
	`sqlite3DbFree
(
db
, 
zMaster
);

42893 
zMaster
 = 0;

42894 if( 
rc
 )

42897 return 
rc
;

42901 
	`sqlite3BeginBenignMalloc
();

42902 for(
i
=0; i<
db
->
nDb
; i++)

42905 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

42906 if( 
pBt
 )

42909 
	`sqlite3BtreeCommitPhaseTwo
(
pBt
, 1);

42912 
	`sqlite3EndBenignMalloc
();

42915 
	`sqlite3VtabCommit
(
db
);

42919 return 
rc
;

42920 
	}
}

42922 static int 
	$sqlite3VdbeCloseStatement
(
Vdbe
 *
p
, int 
eOp
)

42925 
sqlite3
 *const 
db
 = 
p
->db;

42926 int 
rc
 = 0;

42933 if( 
db
->
nStatement
 && 
p
->
iStatement
 )

42936 int 
i
;

42937 const int 
iSavepoint
 = 
p
->
iStatement
-1;

42943 for(
i
=0; i<
db
->
nDb
; i++)

42946 int 
rc2
 = 0;

42947 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

42948 if( 
pBt
 )

42951 if( 
eOp
==2 )

42954 
rc2
 = 
	`sqlite3BtreeSavepoint
(
pBt
, 2, 
iSavepoint
);

42956 if( 
rc2
==0 )

42959 
rc2
 = 
	`sqlite3BtreeSavepoint
(
pBt
, 1, 
iSavepoint
);

42961 if( 
rc
==0 )

42964 
rc
 = 
rc2
;

42968 
db
->
nStatement
--;

42969 
p
->
iStatement
 = 0;

42971 if( 
rc
==0 )

42974 if( 
eOp
==2 )

42977 
rc
 = 
	`sqlite3VtabSavepoint
(
db
, 2, 
iSavepoint
);

42979 if( 
rc
==0 )

42982 
rc
 = 
	`sqlite3VtabSavepoint
(
db
, 1, 
iSavepoint
);

42989 if( 
eOp
==2 )

42992 
db
->
nDeferredCons
 = 
p
->
nStmtDefCons
;

42993 
db
->
nDeferredImmCons
 = 
p
->
nStmtDefImmCons
;

42996 return 
rc
;

42997 
	}
}

42999 static int 
	$sqlite3VdbeCheckFk
(
Vdbe
 *
p
, int 
deferred
)

43002 
sqlite3
 *
db
 = 
p
->db;

43003 if( (
deferred
 && (
db
->
nDeferredCons
+db->
nDeferredImmCons
)>0)

43004 || (!
deferred
 && 
p
->
nFkConstraint
>0)

43008 
p
->
rc
 = (19 | (3<<8));

43009 
p
->
errorAction
 = 2;

43010 
	`sqlite3VdbeError
(
p
, "FOREIGN KEY constraint failed");

43014 
	}
}

43016 static int 
	$sqlite3VdbeHalt
(
Vdbe
 *
p
)

43019 int 
rc
;

43020 
sqlite3
 *
db
 = 
p
->db;

43022 if( 
db
->
mallocFailed
 )

43025 
p
->
rc
 = 7;

43027 if( 
p
->
aOnceFlag
 ) 
	`memset
(p->aOnceFlag, 0, p->
nOnceFlag
);

43028 
	`closeAllCursors
(
p
);

43029 if( 
p
->
magic
!=0xbdf20da3 )

43038 if( 
p
->
pc
>=0 && p->
bIsReader
 )

43041 int 
mrc
;

43042 int 
eStatementOp
 = 0;

43043 int 
isSpecialError
;

43046 
	`sqlite3VdbeEnter
(
p
);

43049 
mrc
 = 
p
->
rc
 & 0xff;

43050 
isSpecialError
 = 
mrc
==7 || mrc==10

43051 || 
mrc
==9 || mrc==13;

43052 if( 
isSpecialError
 )

43056 if( !
p
->
readOnly
 || 
mrc
!=9 )

43059 if( (
mrc
==7 || mrc==13) && 
p
->
usesStmtJournal
 )

43062 
eStatementOp
 = 2;

43067 
	`sqlite3RollbackAll
(
db
, (4 | (2<<8)));

43068 
	`sqlite3CloseSavepoints
(
db
);

43069 
db
->
autoCommit
 = 1;

43070 
p
->
nChange
 = 0;

43076 if( 
p
->
rc
==0 )

43079 
	`sqlite3VdbeCheckFk
(
p
, 0);

43088 if( !((
db
)->
nVTrans
>0 && (db)->
aVTrans
==0)

43089 && 
db
->
autoCommit


43090 && 
db
->
nVdbeWrite
==(
p
->
readOnly
==0)

43094 if( 
p
->
rc
==0 || (p->
errorAction
==3 && !
isSpecialError
) )

43097 
rc
 = 
	`sqlite3VdbeCheckFk
(
p
, 1);

43098 if( 
rc
!=0 )

43101 if( (
p
->
readOnly
) )

43104 
	`sqlite3VdbeLeave
(
p
);

43107 
rc
 = (19 | (3<<8));

43113 
rc
 = 
	`vdbeCommit
(
db
, 
p
);

43115 if( 
rc
==5 && 
p
->
readOnly
 )

43118 
	`sqlite3VdbeLeave
(
p
);

43120 }else if( 
rc
!=0 )

43123 
p
->
rc
 = rc;

43124 
	`sqlite3RollbackAll
(
db
, 0);

43125 
p
->
nChange
 = 0;

43127 
db
->
nDeferredCons
 = 0;

43128 
db
->
nDeferredImmCons
 = 0;

43129 
db
->
flags
 &= ~0x01000000;

43130 
	`sqlite3CommitInternalChanges
(
db
);

43133 
	`sqlite3RollbackAll
(
db
, 0);

43134 
p
->
nChange
 = 0;

43136 
db
->
nStatement
 = 0;

43137 }else if( 
eStatementOp
==0 )

43140 if( 
p
->
rc
==0 || p->
errorAction
==3 )

43143 
eStatementOp
 = 1;

43144 }else if( 
p
->
errorAction
==2 )

43147 
eStatementOp
 = 2;

43149 
	`sqlite3RollbackAll
(
db
, (4 | (2<<8)));

43150 
	`sqlite3CloseSavepoints
(
db
);

43151 
db
->
autoCommit
 = 1;

43152 
p
->
nChange
 = 0;

43162 if( 
eStatementOp
 )

43165 
rc
 = 
	`sqlite3VdbeCloseStatement
(
p
, 
eStatementOp
);

43166 if( 
rc
 )

43169 if( 
p
->
rc
==0 || (p->rc&0xff)==19 )

43172 
p
->
rc
 = rc;

43173 
	`sqlite3DbFree
(
db
, 
p
->
zErrMsg
);

43174 
p
->
zErrMsg
 = 0;

43176 
	`sqlite3RollbackAll
(
db
, (4 | (2<<8)));

43177 
	`sqlite3CloseSavepoints
(
db
);

43178 
db
->
autoCommit
 = 1;

43179 
p
->
nChange
 = 0;

43186 if( 
p
->
changeCntOn
 )

43189 if( 
eStatementOp
!=2 )

43192 
	`sqlite3VdbeSetChanges
(
db
, 
p
->
nChange
);

43194 
	`sqlite3VdbeSetChanges
(
db
, 0);

43196 
p
->
nChange
 = 0;

43200 
	`sqlite3VdbeLeave
(
p
);

43204 if( 
p
->
pc
>=0 )

43207 
db
->
nVdbeActive
--;

43208 if( !
p
->
readOnly
 ) 
db
->
nVdbeWrite
--;

43209 if( 
p
->
bIsReader
 ) 
db
->
nVdbeRead
--;

43214 
p
->
magic
 = 0x519c2973;

43216 if( 
db
->
mallocFailed
 )

43219 
p
->
rc
 = 7;

43226 if( 
db
->
autoCommit
 )

43233 return (
p
->
rc
==5 ? 5 : 0);

43234 
	}
}

43241 static void 
	$sqlite3VdbeResetStepResult
(
Vdbe
 *
p
)

43244 
p
->
rc
 = 0;

43245 
	}
}

43247 static int 
	$sqlite3VdbeTransferError
(
Vdbe
 *
p
)

43250 
sqlite3
 *
db
 = 
p
->db;

43251 int 
rc
 = 
p
->rc;

43252 if( 
p
->
zErrMsg
 )

43255 
db
->
bBenignMalloc
++;

43256 
	`sqlite3BeginBenignMalloc
();

43257 if( 
db
->
pErr
==0 ) db->pErr = 
	`sqlite3ValueNew
(db);

43258 
	`sqlite3ValueSetStr
(
db
->
pErr
, -1, 
p
->
zErrMsg
, 1, ((
sqlite3_destructor_type
)-1));

43259 
	`sqlite3EndBenignMalloc
();

43260 
db
->
bBenignMalloc
--;

43261 
db
->
errCode
 = 
rc
;

43263 
	`sqlite3Error
(
db
, 
rc
);

43265 return 
rc
;

43266 
	}
}

43268 static int 
	$sqlite3VdbeReset
(
Vdbe
 *
p
)

43271 
sqlite3
 *
db
;

43272 
db
 = 
p
->db;

43278 
	`sqlite3VdbeHalt
(
p
);

43285 if( 
p
->
pc
>=0 )

43289 
	`sqlite3VdbeTransferError
(
p
);

43290 
	`sqlite3DbFree
(
db
, 
p
->
zErrMsg
);

43291 
p
->
zErrMsg
 = 0;

43292 if( 
p
->
runOnlyOnce
 ) p->
expired
 = 1;

43293 }else if( 
p
->
rc
 && p->
expired
 )

43300 
	`sqlite3ErrorWithMsg
(
db
, 
p
->
rc
, p->
zErrMsg
 ? "%s" : 0, p->zErrMsg);

43301 
	`sqlite3DbFree
(
db
, 
p
->
zErrMsg
);

43302 
p
->
zErrMsg
 = 0;

43307 
	`Cleanup
(
p
);

43309 
p
->
iCurrentTime
 = 0;

43310 
p
->
magic
 = 0x26bceaa5;

43311 return 
p
->
rc
 & 
db
->
errMask
;

43312 
	}
}

43318 static int 
	$sqlite3VdbeFinalize
(
Vdbe
 *
p
)

43321 int 
rc
 = 0;

43322 if( 
p
->
magic
==0xbdf20da3 || p->magic==0x519c2973 )

43325 
rc
 = 
	`sqlite3VdbeReset
(
p
);

43328 
	`sqlite3VdbeDelete
(
p
);

43329 return 
rc
;

43330 
	}
}

43332 static void 
	$sqlite3VdbeDeleteAuxData
(
sqlite3
 *
db
, 
AuxData
 **
pp
, int 
iOp
, int 
mask
)

43335 while( *
pp
 )

43338 
AuxData
 *
pAux
 = *
pp
;

43339 if( (
iOp
<0)

43340 || (
pAux
->
iOp
==iOp && (pAux->
iArg
>31 || !(
mask
 & (((unsigned int)1)<<(pAux->iArg)))))

43345 if( 
pAux
->
xDelete
 )

43348 
pAux
->
	`xDelete
(pAux->pAux);

43350 *
pp
 = 
pAux
->
pNext
;

43351 
	`sqlite3DbFree
(
db
, 
pAux
);

43353 
pp
= &
pAux
->
pNext
;

43356 
	}
}

43358 static void 
	$sqlite3VdbeClearObject
(
sqlite3
 *
db
, 
Vdbe
 *
p
)

43361 
SubProgram
 *
pSub
, *
pNext
;

43362 int 
i
;

43364 
	`releaseMemArray
(
p
->
aVar
, p->
nVar
);

43365 
	`releaseMemArray
(
p
->
aColName
, p->
nResColumn
*2);

43366 for(
pSub
=
p
->
pProgram
; pSub; pSub=
pNext
)

43369 
pNext
 = 
pSub
->pNext;

43370 
	`vdbeFreeOpArray
(
db
, 
pSub
->
aOp
, pSub->
nOp
);

43371 
	`sqlite3DbFree
(
db
, 
pSub
);

43373 for(
i
=
p
->
nzVar
-1; i>=0; i--) 
	`sqlite3DbFree
(
db
, p->
azVar
[i]);

43374 
	`sqlite3DbFree
(
db
, 
p
->
azVar
);

43375 
	`vdbeFreeOpArray
(
db
, 
p
->
aOp
, p->
nOp
);

43376 
	`sqlite3DbFree
(
db
, 
p
->
aColName
);

43377 
	`sqlite3DbFree
(
db
, 
p
->
zSql
);

43378 
	`sqlite3DbFree
(
db
, 
p
->
pFree
);

43385 
	}
}

43390 static void 
	$sqlite3VdbeDelete
(
Vdbe
 *
p
)

43393 
sqlite3
 *
db
;

43395 if( (
p
==0) ) return;

43396 
db
 = 
p
->db;

43398 
	`sqlite3VdbeClearObject
(
db
, 
p
);

43399 if( 
p
->
pPrev
 )

43402 
p
->
pPrev
->
pNext
 = p->pNext;

43405 
db
->
pVdbe
 = 
p
->
pNext
;

43407 if( 
p
->
pNext
 )

43410 
p
->
pNext
->
pPrev
 = p->pPrev;

43412 
p
->
magic
 = 0xb606c3c8;

43413 
p
->
db
 = 0;

43414 
	`sqlite3DbFree
(
db
, 
p
);

43415 
	}
}

43422 static int 
__attribute__
((
noinline
)) 
	$handleDeferredMoveto
(
VdbeCursor
 *
p
)

43425 int 
res
, 
rc
;

43432 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
p
->
uc
.
pCursor
, 0, p->
movetoTarget
, 0, &
res
);

43433 if( 
rc
 ) return rc;

43434 if( 
res
!=0 ) return 
	`sqlite3CorruptError
(71015);

43438 
p
->
deferredMoveto
 = 0;

43439 
p
->
cacheStatus
 = 0;

43441 
	}
}

43443 static int 
__attribute__
((
noinline
)) 
	$handleMovedCursor
(
VdbeCursor
 *
p
)

43446 int 
isDifferentRow
, 
rc
;

43450 
rc
 = 
	`sqlite3BtreeCursorRestore
(
p
->
uc
.
pCursor
, &
isDifferentRow
);

43451 
p
->
cacheStatus
 = 0;

43452 if( 
isDifferentRow
 ) 
p
->
nullRow
 = 1;

43453 return 
rc
;

43454 
	}
}

43460 static int 
	$sqlite3VdbeCursorRestore
(
VdbeCursor
 *
p
)

43464 if( 
	`sqlite3BtreeCursorHasMoved
(
p
->
uc
.
pCursor
) )

43467 return 
	`handleMovedCursor
(
p
);

43470 
	}
}

43472 static int 
	$sqlite3VdbeCursorMoveto
(
VdbeCursor
 **
pp
, int *
piCol
)

43475 
VdbeCursor
 *
p
 = *
pp
;

43476 if( 
p
->
eCurType
==0 )

43479 if( 
p
->
deferredMoveto
 )

43482 int 
iMap
;

43483 if( 
p
->
aAltMap
 && (
iMap
 = p->aAltMap[1+*
piCol
])>0 )

43486 *
pp
 = 
p
->
pAltCursor
;

43487 *
piCol
 = 
iMap
 - 1;

43490 return 
	`handleDeferredMoveto
(
p
);

43492 if( 
	`sqlite3BtreeCursorHasMoved
(
p
->
uc
.
pCursor
) )

43495 return 
	`handleMovedCursor
(
p
);

43499 
	}
}

43501 static 
u32
 
	$sqlite3VdbeSerialType
(
Mem
 *
pMem
, int 
file_format
, 
u32
 *
pLen
)

43504 int 
flags
 = 
pMem
->flags;

43505 
u32
 
n
;

43508 if( 
flags
&0x0001 )

43511 *
pLen
 = 0;

43514 if( 
flags
&0x0004 )

43519 
i64
 
i
 = 
pMem
->
u
.i;

43520 
u64
 
u
;

43521 if( 
i
<0 )

43524 
u
 = ~
i
;

43526 
u
 = 
i
;

43528 if( 
u
<=127 )

43531 if( (
i
&1)==i && 
file_format
>=4 )

43534 *
pLen
 = 0;

43535 return 8+(
u32
)
u
;

43537 *
pLen
 = 1;

43541 if( 
u
<=32767 )

43543 *
pLen
 = 2; return 2; }

43544 if( 
u
<=8388607 )

43546 *
pLen
 = 3; return 3; }

43547 if( 
u
<=2147483647 )

43549 *
pLen
 = 4; return 4; }

43550 if( 
u
<=((((
i64
)0x00008000)<<32)-1) )

43552 *
pLen
 = 6; return 5; }

43553 *
pLen
 = 8;

43556 if( 
flags
&0x0008 )

43559 *
pLen
 = 8;

43564 
n
 = (
u32
)
pMem
->n;

43565 if( 
flags
 & 0x4000 )

43568 
n
 += 
pMem
->
u
.
nZero
;

43570 *
pLen
 = 
n
;

43571 return ((
n
*2) + 12 + ((
flags
&0x0002)!=0));

43572 
	}
}

43577 static const 
u8
 
	gsqlite3SmallTypeSizes
[] = {

43597 static 
u32
 
	$sqlite3VdbeSerialTypeLen
(
u32
 
serial_type
)

43600 if( 
serial_type
>=128 )

43603 return (
serial_type
-12)/2;

43607 return 
sqlite3SmallTypeSizes
[
serial_type
];

43609 
	}
}

43610 static 
u8
 
	$sqlite3VdbeOneByteSerialTypeLen
(
u8
 
serial_type
)

43614 return 
sqlite3SmallTypeSizes
[
serial_type
];

43615 
	}
}

43617 static 
u32
 
	$sqlite3VdbeSerialPut
(
u8
 *
buf
, 
Mem
 *
pMem
, 
u32
 
serial_type
)

43620 
u32
 
len
;

43623 if( 
serial_type
<=7 && serial_type>0 )

43626 
u64
 
v
;

43627 
u32
 
i
;

43628 if( 
serial_type
==7 )

43632 
	`memcpy
(&
v
, &
pMem
->
u
.
r
, sizeof(v));

43635 
v
 = 
pMem
->
u
.
i
;

43637 
len
 = 
i
 = 
sqlite3SmallTypeSizes
[
serial_type
];

43640 
buf
[--
i
] = (
u8
)(
v
&0xFF);

43641 
v
 >>= 8;

43642 }while( 
i
 );

43643 return 
len
;

43647 if( 
serial_type
>=12 )

43652 
len
 = 
pMem
->
n
;

43653 if( 
len
>0 ) 
	`memcpy
(
buf
, 
pMem
->
z
, len);

43654 return 
len
;

43659 
	}
}

43661 static 
u32
 
__attribute__
((
noinline
)) 
	$serialGet
(

43662 const unsigned char *
buf
,

43663 
u32
 
serial_type
,

43664 
Mem
 *
pMem


43668 
u64
 
x
 = (((
u32
)(
buf
)[0]<<24)|((buf)[1]<<16)|((buf)[2]<<8)|(buf)[3]);

43669 
u32
 
y
 = (((u32)(
buf
+4)[0]<<24)|((buf+4)[1]<<16)|((buf+4)[2]<<8)|(buf+4)[3]);

43670 
x
 = (x<<32) + 
y
;

43671 if( 
serial_type
==6 )

43676 
pMem
->
u
.
i
 = *(
i64
*)&
x
;

43677 
pMem
->
flags
 = 0x0004;

43683 
	`memcpy
(&
pMem
->
u
.
r
, &
x
, sizeof(x));

43684 
pMem
->
flags
 = 
	`sqlite3IsNaN
(pMem->
u
.
r
) ? 0x0001 : 0x0008;

43687 
	}
}

43688 static 
u32
 
	$sqlite3VdbeSerialGet
(

43689 const unsigned char *
buf
,

43690 
u32
 
serial_type
,

43691 
Mem
 *
pMem


43695 switch( 
serial_type
 )

43702 
pMem
->
flags
 = 0x0001;

43708 
pMem
->
u
.
i
 = ((
i8
)(
buf
)[0]);

43709 
pMem
->
flags
 = 0x0004;

43716 
pMem
->
u
.
i
 = (256*(
i8
)((
buf
)[0])|(buf)[1]);

43717 
pMem
->
flags
 = 0x0004;

43724 
pMem
->
u
.
i
 = (65536*(
i8
)((
buf
)[0])|((buf)[1]<<8)|(buf)[2]);

43725 
pMem
->
flags
 = 0x0004;

43732 
pMem
->
u
.
i
 = (16777216*(
i8
)((
buf
)[0])|((buf)[1]<<16)|((buf)[2]<<8)|(buf)[3]);

43737 
pMem
->
flags
 = 0x0004;

43744 
pMem
->
u
.
i
 = (((
u32
)(
buf
+2)[0]<<24)|((buf+2)[1]<<16)|((buf+2)[2]<<8)|(buf+2)[3]) + (((
i64
)1)<<32)*(256*(
i8
)((buf)[0])|(buf)[1]);

43745 
pMem
->
flags
 = 0x0004;

43753 return 
	`serialGet
(
buf
,
serial_type
,
pMem
);

43759 
pMem
->
u
.
i
 = 
serial_type
-8;

43760 
pMem
->
flags
 = 0x0004;

43768 static const 
u16
 
aFlag
[] = { 0x0010|0x1000, 0x0002|0x1000 };

43769 
pMem
->
z
 = (char *)
buf
;

43770 
pMem
->
n
 = (
serial_type
-12)/2;

43771 
pMem
->
flags
 = 
aFlag
[
serial_type
&1];

43772 return 
pMem
->
n
;

43776 
	}
}

43778 static 
UnpackedRecord
 *
	$sqlite3VdbeAllocUnpackedRecord
(

43779 
KeyInfo
 *
pKeyInfo
,

43780 char *
pSpace
,

43781 int 
szSpace
,

43782 char **
ppFree


43786 
UnpackedRecord
 *
p
;

43787 int 
nOff
;

43788 int 
nByte
;

43794 
nOff
 = (8 - (((int)(long int)(
pSpace
)) & 7)) & 7;

43795 
nByte
 = (((sizeof(
UnpackedRecord
))+7)&~7) + sizeof(
Mem
)*(
pKeyInfo
->
nField
+1);

43796 if( 
nByte
>
szSpace
+
nOff
 )

43799 
p
 = (
UnpackedRecord
 *)
	`sqlite3DbMallocRaw
(
pKeyInfo
->
db
, 
nByte
);

43800 *
ppFree
 = (char *)
p
;

43801 if( !
p
 ) return 0;

43803 
p
 = (
UnpackedRecord
*)&
pSpace
[
nOff
];

43804 *
ppFree
 = 0;

43807 
p
->
aMem
 = (
Mem
*)&((char*)p)[(((sizeof(
UnpackedRecord
))+7)&~7)];

43809 
p
->
pKeyInfo
 = pKeyInfo;

43810 
p
->
nField
 = 
pKeyInfo
->nField + 1;

43811 return 
p
;

43812 
	}
}

43819 static void 
	$sqlite3VdbeRecordUnpack
(

43820 
KeyInfo
 *
pKeyInfo
,

43821 int 
nKey
,

43822 const void *
pKey
,

43823 
UnpackedRecord
 *
p


43827 const unsigned char *
aKey
 = (const unsigned char *)
pKey
;

43828 int 
d
;

43829 
u32
 
idx
;

43830 
u16
 
u
;

43831 
u32
 
szHdr
;

43832 
Mem
 *
pMem
 = 
p
->
aMem
;

43834 
p
->
default_rc
 = 0;

43836 
idx
 = (
u8
)((*(
aKey
)<(u8)0x80)?((
szHdr
)=(
u32
)*(aKey)),1:
	`sqlite3GetVarint32
((aKey),(u32 *)&(szHdr)));

43837 
d
 = 
szHdr
;

43838 
u
 = 0;

43839 while( 
idx
<
szHdr
 && 
d
<=
nKey
 )

43842 
u32
 
serial_type
;

43844 
idx
 += (
u8
)((*(&
aKey
[idx])<(u8)0x80)?((
serial_type
)=(
u32
)*(&aKey[idx])),1:
	`sqlite3GetVarint32
((&aKey[idx]),(u32 *)&(serial_type)));

43845 
pMem
->
enc
 = 
pKeyInfo
->enc;

43846 
pMem
->
db
 = 
pKeyInfo
->db;

43848 
pMem
->
szMalloc
 = 0;

43849 
d
 += 
	`sqlite3VdbeSerialGet
(&
aKey
[d], 
serial_type
, 
pMem
);

43850 
pMem
++;

43851 if( (++
u
)>=
p
->
nField
 ) break;

43854 
p
->
nField
 = 
u
;

43855 
	}
}

43857 static int 
	$vdbeCompareMemString
(

43858 const 
Mem
 *
pMem1
,

43859 const 
Mem
 *
pMem2
,

43860 const 
CollSeq
 *
pColl
,

43861 
u8
 *
prcErr


43865 if( 
pMem1
->
enc
==
pColl
->enc )

43870 return 
pColl
->
	`xCmp
(pColl->
pUser
,
pMem1
->
n
,pMem1->
z
,
pMem2
->n,pMem2->z);

43872 int 
rc
;

43873 const void *
v1
, *
v2
;

43874 int 
n1
, 
n2
;

43875 
Mem
 
c1
;

43876 
Mem
 
c2
;

43877 
	`sqlite3VdbeMemInit
(&
c1
, 
pMem1
->
db
, 0x0001);

43878 
	`sqlite3VdbeMemInit
(&
c2
, 
pMem1
->
db
, 0x0001);

43879 
	`sqlite3VdbeMemShallowCopy
(&
c1
, 
pMem1
, 0x1000);

43880 
	`sqlite3VdbeMemShallowCopy
(&
c2
, 
pMem2
, 0x1000);

43881 
v1
 = 
	`sqlite3ValueText
((
sqlite3_value
*)&
c1
, 
pColl
->
enc
);

43882 
n1
 = 
v1
==0 ? 0 : 
c1
.
n
;

43883 
v2
 = 
	`sqlite3ValueText
((
sqlite3_value
*)&
c2
, 
pColl
->
enc
);

43884 
n2
 = 
v2
==0 ? 0 : 
c2
.
n
;

43885 
rc
 = 
pColl
->
	`xCmp
(pColl->
pUser
, 
n1
, 
v1
, 
n2
, 
v2
);

43886 if( (
v1
==0 || 
v2
==0) && 
prcErr
 ) *prcErr = 7;

43887 
	`sqlite3VdbeMemRelease
(&
c1
);

43888 
	`sqlite3VdbeMemRelease
(&
c2
);

43889 return 
rc
;

43891 
	}
}

43898 static 
__attribute__
((
noinline
)) int 
	$sqlite3BlobCompare
(const 
Mem
 *
pB1
, const Mem *
pB2
)

43901 int 
c
 = 
	`memcmp
(
pB1
->
z
, 
pB2
->z, pB1->
n
>pB2->n ? pB2->n : pB1->n);

43902 if( 
c
 ) return c;

43903 return 
pB1
->
n
 - 
pB2
->n;

43904 
	}
}

43911 static int 
	$sqlite3IntFloatCompare
(
i64
 
i
, double 
r
)

43917 long double 
x
 = (long double)
i
;

43918 if( 
x
<
r
 ) return -1;

43919 if( 
x
>
r
 ) return +1;

43922 
i64
 
y
;

43923 double 
s
;

43924 if( 
r
<-9223372036854775808.0 ) return +1;

43925 if( 
r
>9223372036854775807.0 ) return -1;

43926 
y
 = (
i64
)
r
;

43927 if( 
i
<
y
 ) return -1;

43928 if( 
i
>
y
 )

43931 if( 
y
==(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) && 
r
>0.0 ) return -1;

43934 
s
 = (double)
i
;

43935 if( 
s
<
r
 ) return -1;

43936 if( 
s
>
r
 ) return +1;

43939 
	}
}

43941 static int 
	$sqlite3MemCompare
(const 
Mem
 *
pMem1
, const Mem *
pMem2
, const 
CollSeq
 *
pColl
)

43944 int 
f1
, 
f2
;

43945 int 
combined_flags
;

43947 
f1
 = 
pMem1
->
flags
;

43948 
f2
 = 
pMem2
->
flags
;

43949 
combined_flags
 = 
f1
|
f2
;

43955 if( 
combined_flags
&0x0001 )

43958 return (
f2
&0x0001) - (
f1
&0x0001);

43963 if( 
combined_flags
&(0x0004|0x0008) )

43966 if( (
f1
 & 
f2
 & 0x0004)!=0 )

43969 if( 
pMem1
->
u
.
i
 < 
pMem2
->u.i ) return -1;

43970 if( 
pMem1
->
u
.
i
 > 
pMem2
->u.i ) return +1;

43973 if( (
f1
 & 
f2
 & 0x0008)!=0 )

43976 if( 
pMem1
->
u
.
r
 < 
pMem2
->u.r ) return -1;

43977 if( 
pMem1
->
u
.
r
 > 
pMem2
->u.r ) return +1;

43980 if( (
f1
&0x0004)!=0 )

43983 if( (
f2
&0x0008)!=0 )

43986 return 
	`sqlite3IntFloatCompare
(
pMem1
->
u
.
i
, 
pMem2
->u.
r
);

43991 if( (
f1
&0x0008)!=0 )

43994 if( (
f2
&0x0004)!=0 )

43997 return -
	`sqlite3IntFloatCompare
(
pMem2
->
u
.
i
, 
pMem1
->u.
r
);

44008 if( 
combined_flags
&0x0002 )

44011 if( (
f1
 & 0x0002)==0 )

44016 if( (
f2
 & 0x0002)==0 )

44032 if( 
pColl
 )

44035 return 
	`vdbeCompareMemString
(
pMem1
, 
pMem2
, 
pColl
, 0);

44042 return 
	`sqlite3BlobCompare
(
pMem1
, 
pMem2
);

44043 
	}
}

44045 static 
i64
 
	$vdbeRecordDecodeInt
(
u32
 
serial_type
, const 
u8
 *
aKey
)

44048 
u32
 
y
;

44050 switch( 
serial_type
 )

44056 return ((
i8
)(
aKey
)[0]);

44059 return (256*(
i8
)((
aKey
)[0])|(aKey)[1]);

44062 return (65536*(
i8
)((
aKey
)[0])|((aKey)[1]<<8)|(aKey)[2]);

44065 
y
 = (((
u32
)(
aKey
)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);

44066 return (
i64
)*(int*)&
y
;

44070 return (((
u32
)(
aKey
+2)[0]<<24)|((aKey+2)[1]<<16)|((aKey+2)[2]<<8)|(aKey+2)[3]) + (((
i64
)1)<<32)*(256*(
i8
)((aKey)[0])|(aKey)[1]);

44073 
u64
 
x
 = (((
u32
)(
aKey
)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);

44075 
x
 = (x<<32) | (((
u32
)(
aKey
+4)[0]<<24)|((aKey+4)[1]<<16)|((aKey+4)[2]<<8)|(aKey+4)[3]);

44076 return (
i64
)*(i64*)&
x
;

44080 return (
serial_type
 - 8);

44081 
	}
}

44083 static int 
	$sqlite3VdbeRecordCompareWithSkip
(

44084 int 
nKey1
, const void *
pKey1
,

44085 
UnpackedRecord
 *
pPKey2
,

44086 int 
bSkip


44090 
u32
 
d1
;

44091 int 
i
;

44092 
u32
 
szHdr1
;

44093 
u32
 
idx1
;

44094 int 
rc
 = 0;

44095 
Mem
 *
pRhs
 = 
pPKey2
->
aMem
;

44096 
KeyInfo
 *
pKeyInfo
 = 
pPKey2
->pKeyInfo;

44097 const unsigned char *
aKey1
 = (const unsigned char *)
pKey1
;

44098 
Mem
 
mem1
;

44103 if( 
bSkip
 )

44106 
u32
 
s1
;

44107 
idx1
 = 1 + (
u8
)((*(&
aKey1
[1])<(u8)0x80)?((
s1
)=(
u32
)*(&aKey1[1])),1:
	`sqlite3GetVarint32
((&aKey1[1]),(u32 *)&(s1)));

44108 
szHdr1
 = 
aKey1
[0];

44109 
d1
 = 
szHdr1
 + 
	`sqlite3VdbeSerialTypeLen
(
s1
);

44110 
i
 = 1;

44111 
pRhs
++;

44113 
idx1
 = (
u8
)((*(
aKey1
)<(u8)0x80)?((
szHdr1
)=(
u32
)*(aKey1)),1:
	`sqlite3GetVarint32
((aKey1),(u32 *)&(szHdr1)));

44114 
d1
 = 
szHdr1
;

44115 if( 
d1
>(unsigned)
nKey1
 )

44118 
pPKey2
->
errCode
 = (
u8
)
	`sqlite3CorruptError
(71941);

44121 
i
 = 0;

44131 
u32
 
serial_type
;

44134 if( 
pRhs
->
flags
 & 0x0004 )

44137 
serial_type
 = 
aKey1
[
idx1
];

44139 if( 
serial_type
>=10 )

44142 
rc
 = +1;

44143 }else if( 
serial_type
==0 )

44146 
rc
 = -1;

44147 }else if( 
serial_type
==7 )

44150 
	`sqlite3VdbeSerialGet
(&
aKey1
[
d1
], 
serial_type
, &
mem1
);

44151 
rc
 = -
	`sqlite3IntFloatCompare
(
pRhs
->
u
.
i
, 
mem1
.u.
r
);

44153 
i64
 
lhs
 = 
	`vdbeRecordDecodeInt
(
serial_type
, &
aKey1
[
d1
]);

44154 
i64
 
rhs
 = 
pRhs
->
u
.
i
;

44155 if( 
lhs
<
rhs
 )

44158 
rc
 = -1;

44159 }else if( 
lhs
>
rhs
 )

44162 
rc
 = +1;

44168 else if( 
pRhs
->
flags
 & 0x0008 )

44171 
serial_type
 = 
aKey1
[
idx1
];

44172 if( 
serial_type
>=10 )

44179 
rc
 = +1;

44180 }else if( 
serial_type
==0 )

44183 
rc
 = -1;

44185 
	`sqlite3VdbeSerialGet
(&
aKey1
[
d1
], 
serial_type
, &
mem1
);

44186 if( 
serial_type
==7 )

44189 if( 
mem1
.
u
.
r
<
pRhs
->u.r )

44192 
rc
 = -1;

44193 }else if( 
mem1
.
u
.
r
>
pRhs
->u.r )

44196 
rc
 = +1;

44199 
rc
 = 
	`sqlite3IntFloatCompare
(
mem1
.
u
.
i
, 
pRhs
->u.
r
);

44205 else if( 
pRhs
->
flags
 & 0x0002 )

44208 (
u8
)((*(&
aKey1
[
idx1
])<(u8)0x80)?((
serial_type
)=(
u32
)*(&aKey1[idx1])),1:
	`sqlite3GetVarint32
((&aKey1[idx1]),(u32 *)&(serial_type)));

44210 if( 
serial_type
<12 )

44213 
rc
 = -1;

44214 }else if( !(
serial_type
 & 0x01) )

44217 
rc
 = +1;

44219 
mem1
.
n
 = (
serial_type
 - 12) / 2;

44222 if( (
d1
+
mem1
.
n
) > (unsigned)
nKey1
 )

44225 
pPKey2
->
errCode
 = (
u8
)
	`sqlite3CorruptError
(72016);

44227 }else if( 
pKeyInfo
->
aColl
[
i
] )

44230 
mem1
.
enc
 = 
pKeyInfo
->enc;

44231 
mem1
.
db
 = 
pKeyInfo
->db;

44232 
mem1
.
flags
 = 0x0002;

44233 
mem1
.
z
 = (char*)&
aKey1
[
d1
];

44234 
rc
 = 
	`vdbeCompareMemString
(

44235 &
mem1
, 
pRhs
, 
pKeyInfo
->
aColl
[
i
], &
pPKey2
->
errCode


44238 int 
nCmp
 = ((
mem1
.
n
)<(
pRhs
->n)?(mem1.n):(pRhs->n));

44239 
rc
 = 
	`memcmp
(&
aKey1
[
d1
], 
pRhs
->
z
, 
nCmp
);

44240 if( 
rc
==0 ) rc = 
mem1
.
n
 - 
pRhs
->n;

44246 else if( 
pRhs
->
flags
 & 0x0010 )

44249 (
u8
)((*(&
aKey1
[
idx1
])<(u8)0x80)?((
serial_type
)=(
u32
)*(&aKey1[idx1])),1:
	`sqlite3GetVarint32
((&aKey1[idx1]),(u32 *)&(serial_type)));

44251 if( 
serial_type
<12 || (serial_type & 0x01) )

44254 
rc
 = -1;

44256 int 
nStr
 = (
serial_type
 - 12) / 2;

44259 if( (
d1
+
nStr
) > (unsigned)
nKey1
 )

44262 
pPKey2
->
errCode
 = (
u8
)
	`sqlite3CorruptError
(72045);

44265 int 
nCmp
 = ((
nStr
)<(
pRhs
->
n
)?(nStr):(pRhs->n));

44266 
rc
 = 
	`memcmp
(&
aKey1
[
d1
], 
pRhs
->
z
, 
nCmp
);

44267 if( 
rc
==0 ) rc = 
nStr
 - 
pRhs
->
n
;

44274 
serial_type
 = 
aKey1
[
idx1
];

44275 
rc
 = (
serial_type
!=0);

44278 if( 
rc
!=0 )

44281 if( 
pKeyInfo
->
aSortOrder
[
i
] )

44284 
rc
 = -rc;

44288 return 
rc
;

44291 
i
++;

44292 
pRhs
++;

44293 
d1
 += 
	`sqlite3VdbeSerialTypeLen
(
serial_type
);

44294 
idx1
 += 
	`sqlite3VarintLen
(
serial_type
);

44295 }while( 
idx1
<(unsigned)
szHdr1
 && 
i
<
pPKey2
->
nField
 && 
d1
<=(unsigned)
nKey1
 );

44309 
pPKey2
->
eqSeen
 = 1;

44310 return 
pPKey2
->
default_rc
;

44311 
	}
}

44312 static int 
	$sqlite3VdbeRecordCompare
(

44313 int 
nKey1
, const void *
pKey1
,

44314 
UnpackedRecord
 *
pPKey2


44318 return 
	`sqlite3VdbeRecordCompareWithSkip
(
nKey1
, 
pKey1
, 
pPKey2
, 0);

44319 
	}
}

44321 static int 
	$vdbeRecordCompareInt
(

44322 int 
nKey1
, const void *
pKey1
,

44323 
UnpackedRecord
 *
pPKey2


44327 const 
u8
 *
aKey
 = &((const u8*)
pKey1
)[*(const u8*)pKey1 & 0x3F];

44328 int 
serial_type
 = ((const 
u8
*)
pKey1
)[1];

44329 int 
res
;

44330 
u32
 
y
;

44331 
u64
 
x
;

44332 
i64
 
v
 = 
pPKey2
->
aMem
[0].
u
.
i
;

44333 
i64
 
lhs
;

44337 switch( 
serial_type
 )

44341 
lhs
 = ((
i8
)(
aKey
)[0]);

44346 
lhs
 = (256*(
i8
)((
aKey
)[0])|(aKey)[1]);

44351 
lhs
 = (65536*(
i8
)((
aKey
)[0])|((aKey)[1]<<8)|(aKey)[2]);

44356 
y
 = (((
u32
)(
aKey
)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);

44357 
lhs
 = (
i64
)*(int*)&
y
;

44362 
lhs
 = (((
u32
)(
aKey
+2)[0]<<24)|((aKey+2)[1]<<16)|((aKey+2)[2]<<8)|(aKey+2)[3]) + (((
i64
)1)<<32)*(256*(
i8
)((aKey)[0])|(aKey)[1]);

44367 
x
 = (((
u32
)(
aKey
)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);

44368 
x
 = (x<<32) | (((
u32
)(
aKey
+4)[0]<<24)|((aKey+4)[1]<<16)|((aKey+4)[2]<<8)|(aKey+4)[3]);

44369 
lhs
 = *(
i64
*)&
x
;

44374 
lhs
 = 0;

44377 
lhs
 = 1;

44387 return 
	`sqlite3VdbeRecordCompare
(
nKey1
, 
pKey1
, 
pPKey2
);

44390 return 
	`sqlite3VdbeRecordCompare
(
nKey1
, 
pKey1
, 
pPKey2
);

44393 if( 
v
>
lhs
 )

44396 
res
 = 
pPKey2
->
r1
;

44397 }else if( 
v
<
lhs
 )

44400 
res
 = 
pPKey2
->
r2
;

44401 }else if( 
pPKey2
->
nField
>1 )

44406 
res
 = 
	`sqlite3VdbeRecordCompareWithSkip
(
nKey1
, 
pKey1
, 
pPKey2
, 1);

44410 
res
 = 
pPKey2
->
default_rc
;

44411 
pPKey2
->
eqSeen
 = 1;

44415 return 
res
;

44416 
	}
}

44424 static int 
	$vdbeRecordCompareString
(

44425 int 
nKey1
, const void *
pKey1
,

44426 
UnpackedRecord
 *
pPKey2


44430 const 
u8
 *
aKey1
 = (const u8*)
pKey1
;

44431 int 
serial_type
;

44432 int 
res
;

44436 (
u8
)((*(&
aKey1
[1])<(u8)0x80)?((
serial_type
)=(
u32
)*(&aKey1[1])),1:
	`sqlite3GetVarint32
((&aKey1[1]),(u32 *)&(serial_type)));

44437 if( 
serial_type
<12 )

44440 
res
 = 
pPKey2
->
r1
;

44441 }else if( !(
serial_type
 & 0x01) )

44444 
res
 = 
pPKey2
->
r2
;

44446 int 
nCmp
;

44447 int 
nStr
;

44448 int 
szHdr
 = 
aKey1
[0];

44450 
nStr
 = (
serial_type
-12) / 2;

44451 if( (
szHdr
 + 
nStr
) > 
nKey1
 )

44454 
pPKey2
->
errCode
 = (
u8
)
	`sqlite3CorruptError
(72223);

44457 
nCmp
 = ((
pPKey2
->
aMem
[0].
n
)<(
nStr
)?(pPKey2->aMem[0].n):(nStr));

44458 
res
 = 
	`memcmp
(&
aKey1
[
szHdr
], 
pPKey2
->
aMem
[0].
z
, 
nCmp
);

44460 if( 
res
==0 )

44463 
res
 = 
nStr
 - 
pPKey2
->
aMem
[0].
n
;

44464 if( 
res
==0 )

44467 if( 
pPKey2
->
nField
>1 )

44470 
res
 = 
	`sqlite3VdbeRecordCompareWithSkip
(
nKey1
, 
pKey1
, 
pPKey2
, 1);

44472 
res
 = 
pPKey2
->
default_rc
;

44473 
pPKey2
->
eqSeen
 = 1;

44475 }else if( 
res
>0 )

44478 
res
 = 
pPKey2
->
r2
;

44480 
res
 = 
pPKey2
->
r1
;

44482 }else if( 
res
>0 )

44485 
res
 = 
pPKey2
->
r2
;

44487 
res
 = 
pPKey2
->
r1
;

44495 return 
res
;

44496 
	}
}

44503 static 
RecordCompare
 
	$sqlite3VdbeFindCompare
(
UnpackedRecord
 *
p
)

44507 if( (
p
->
pKeyInfo
->
nField
 + p->pKeyInfo->
nXField
)<=13 )

44510 int 
flags
 = 
p
->
aMem
[0].flags;

44511 if( 
p
->
pKeyInfo
->
aSortOrder
[0] )

44514 
p
->
r1
 = 1;

44515 
p
->
r2
 = -1;

44517 
p
->
r1
 = -1;

44518 
p
->
r2
 = 1;

44520 if( (
flags
 & 0x0004) )

44523 return 
vdbeRecordCompareInt
;

44528 if( (
flags
 & (0x0008|0x0001|0x0010))==0 && 
p
->
pKeyInfo
->
aColl
[0]==0 )

44532 return 
vdbeRecordCompareString
;

44536 return 
sqlite3VdbeRecordCompare
;

44537 
	}
}

44539 static int 
	$sqlite3VdbeIdxRowid
(
sqlite3
 *
db
, 
BtCursor
 *
pCur
, 
i64
 *
rowid
)

44542 
i64
 
nCellKey
 = 0;

44543 int 
rc
;

44544 
u32
 
szHdr
;

44545 
u32
 
typeRowid
;

44546 
u32
 
lenRowid
;

44547 
Mem
 
m
, 
v
;

44555 
	`sqlite3BtreeKeySize
(
pCur
, &
nCellKey
);

44560 
	`sqlite3VdbeMemInit
(&
m
, 
db
, 0);

44561 
rc
 = 
	`sqlite3VdbeMemFromBtree
(
pCur
, 0, (
u32
)
nCellKey
, 1, &
m
);

44562 if( 
rc
 )

44565 return 
rc
;

44569 (void)(
u8
)((*((u8*)
m
.
z
)<(u8)0x80)?((
szHdr
)=(
u32
)*((u8*)m.z)),1:
	`sqlite3GetVarint32
(((u8*)m.z),(u32 *)&(szHdr)));

44572 if( (
szHdr
<3 || (int)szHdr>
m
.
n
) )

44575 goto 
idx_rowid_corruption
;

44580 (void)(
u8
)((*((u8*)&
m
.
z
[
szHdr
-1])<(u8)0x80)?((
typeRowid
)=(
u32
)*((u8*)&m.z[szHdr-1])),1:
	`sqlite3GetVarint32
(((u8*)&m.z[szHdr-1]),(u32 *)&(typeRowid)));

44589 if( (
typeRowid
<1 || typeRowid>9 || typeRowid==7) )

44592 goto 
idx_rowid_corruption
;

44594 
lenRowid
 = 
sqlite3SmallTypeSizes
[
typeRowid
];

44596 if( ((
u32
)
m
.
n
<
szHdr
+
lenRowid
) )

44599 goto 
idx_rowid_corruption
;

44603 
	`sqlite3VdbeSerialGet
((
u8
*)&
m
.
z
[m.
n
-
lenRowid
], 
typeRowid
, &
v
);

44604 *
rowid
 = 
v
.
u
.
i
;

44605 
	`sqlite3VdbeMemRelease
(&
m
);

44610 
idx_rowid_corruption
:

44612 
	`sqlite3VdbeMemRelease
(&
m
);

44613 return 
	`sqlite3CorruptError
(72372);

44614 
	}
}

44616 static int 
	$sqlite3VdbeIdxKeyCompare
(

44617 
sqlite3
 *
db
,

44618 
VdbeCursor
 *
pC
,

44619 
UnpackedRecord
 *
pUnpacked
,

44620 int *
res


44624 
i64
 
nCellKey
 = 0;

44625 int 
rc
;

44626 
BtCursor
 *
pCur
;

44627 
Mem
 
m
;

44630 
pCur
 = 
pC
->
uc
.
pCursor
;

44632 
	`sqlite3BtreeKeySize
(
pCur
, &
nCellKey
);

44636 if( 
nCellKey
<=0 || nCellKey>0x7fffffff )

44639 *
res
 = 0;

44640 return 
	`sqlite3CorruptError
(72406);

44642 
	`sqlite3VdbeMemInit
(&
m
, 
db
, 0);

44643 
rc
 = 
	`sqlite3VdbeMemFromBtree
(
pCur
, 0, (
u32
)
nCellKey
, 1, &
m
);

44644 if( 
rc
 )

44647 return 
rc
;

44649 *
res
 = 
	`sqlite3VdbeRecordCompare
(
m
.
n
, m.
z
, 
pUnpacked
);

44650 
	`sqlite3VdbeMemRelease
(&
m
);

44652 
	}
}

44658 static void 
	$sqlite3VdbeSetChanges
(
sqlite3
 *
db
, int 
nChange
)

44662 
db
->
nChange
 = nChange;

44663 
db
->
nTotalChange
 += 
nChange
;

44664 
	}
}

44670 static void 
	$sqlite3VdbeCountChanges
(
Vdbe
 *
v
)

44673 
v
->
changeCntOn
 = 1;

44674 
	}
}

44676 static void 
	$sqlite3ExpirePreparedStatements
(
sqlite3
 *
db
)

44679 
Vdbe
 *
p
;

44680 for(
p
 = 
db
->
pVdbe
; p; p=p->
pNext
)

44683 
p
->
expired
 = 1;

44685 
	}
}

44690 static 
sqlite3
 *
	$sqlite3VdbeDb
(
Vdbe
 *
v
)

44693 return 
v
->
db
;

44694 
	}
}

44696 static 
sqlite3_value
 *
	$sqlite3VdbeGetBoundValue
(
Vdbe
 *
v
, int 
iVar
, 
u8
 
aff
)

44700 if( 
v
 )

44703 
Mem
 *
pMem
 = &
v
->
aVar
[
iVar
-1];

44704 if( 0==(
pMem
->
flags
 & 0x0001) )

44707 
sqlite3_value
 *
pRet
 = 
	`sqlite3ValueNew
(
v
->
db
);

44708 if( 
pRet
 )

44711 
	`sqlite3VdbeMemCopy
((
Mem
 *)
pRet
, 
pMem
);

44712 
	`sqlite3ValueApplyAffinity
(
pRet
, 
aff
, 1);

44714 return 
pRet
;

44718 
	}
}

44725 static void 
	$sqlite3VdbeSetVarmask
(
Vdbe
 *
v
, int 
iVar
)

44729 if( 
iVar
>32 )

44732 
v
->
expmask
 = 0xffffffff;

44734 
v
->
expmask
 |= ((
u32
)1 << (
iVar
-1));

44736 
	}
}

44744 static void 
	$sqlite3VtabImportErrmsg
(
Vdbe
 *
p
, 
sqlite3_vtab
 *
pVtab
)

44747 if( 
pVtab
->
zErrMsg
 )

44750 
sqlite3
 *
db
 = 
p
->db;

44751 
	`sqlite3DbFree
(
db
, 
p
->
zErrMsg
);

44752 
p
->
zErrMsg
 = 
	`sqlite3DbStrDup
(
db
, 
pVtab
->zErrMsg);

44753 
	`sqlite3_free
(
pVtab
->
zErrMsg
);

44754 
pVtab
->
zErrMsg
 = 0;

44756 
	}
}

44758 int 
	$sqlite3_expired
(
sqlite3_stmt
 *
pStmt
)

44761 
Vdbe
 *
p
 = (Vdbe*)
pStmt
;

44762 return 
p
==0 || p->
expired
;

44763 
	}
}

44771 static int 
	$vdbeSafety
(
Vdbe
 *
p
)

44774 if( 
p
->
db
==0 )

44777 
	`sqlite3_log
(21, "API called with finalized prepared statement");

44782 
	}
}

44783 static int 
	$vdbeSafetyNotNull
(
Vdbe
 *
p
)

44786 if( 
p
==0 )

44789 
	`sqlite3_log
(21, "API called with NULL prepared statement");

44792 return 
	`vdbeSafety
(
p
);

44794 
	}
}

44801 static 
__attribute__
((
noinline
)) void 
	$invokeProfileCallback
(
sqlite3
 *
db
, 
Vdbe
 *
p
)

44804 
sqlite3_int64
 
iNow
;

44809 
	`sqlite3OsCurrentTimeInt64
(
db
->
pVfs
, &
iNow
);

44810 
db
->
	`xProfile
(db->
pProfileArg
, 
p
->
zSql
, (
iNow
 - p->
startTime
)*1000000);

44811 
p
->
startTime
 = 0;

44812 
	}
}

44814 int 
	$sqlite3_finalize
(
sqlite3_stmt
 *
pStmt
)

44817 int 
rc
;

44818 if( 
pStmt
==0 )

44823 
rc
 = 0;

44825 
Vdbe
 *
v
 = (Vdbe*)
pStmt
;

44826 
sqlite3
 *
db
 = 
v
->db;

44827 if( 
	`vdbeSafety
(
v
) ) return 
	`sqlite3MisuseError
(72615);

44828 
	`sqlite3_mutex_enter
(
db
->
mutex
);

44829 if( ((
v
)->
startTime
)>0 )

44831 
	`invokeProfileCallback
(
db
,
v
); };

44832 
rc
 = 
	`sqlite3VdbeFinalize
(
v
);

44833 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

44834 
	`sqlite3LeaveMutexAndCloseZombie
(
db
);

44836 return 
rc
;

44837 
	}
}

44839 int 
	$sqlite3_reset
(
sqlite3_stmt
 *
pStmt
)

44842 int 
rc
;

44843 if( 
pStmt
==0 )

44846 
rc
 = 0;

44848 
Vdbe
 *
v
 = (Vdbe*)
pStmt
;

44849 
sqlite3
 *
db
 = 
v
->db;

44850 
	`sqlite3_mutex_enter
(
db
->
mutex
);

44851 if( ((
v
)->
startTime
)>0 )

44853 
	`invokeProfileCallback
(
db
,
v
); };

44854 
rc
 = 
	`sqlite3VdbeReset
(
v
);

44855 
	`sqlite3VdbeRewind
(
v
);

44857 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

44858 
	`sqlite3_mutex_leave
(
db
->
mutex
);

44860 return 
rc
;

44861 
	}
}

44866 int 
	$sqlite3_clear_bindings
(
sqlite3_stmt
 *
pStmt
)

44869 int 
i
;

44870 int 
rc
 = 0;

44871 
Vdbe
 *
p
 = (Vdbe*)
pStmt
;

44873 
sqlite3_mutex
 *
mutex
 = ((
Vdbe
*)
pStmt
)->
db
->mutex;

44875 
	`sqlite3_mutex_enter
(
mutex
);

44876 for(
i
=0; i<
p
->
nVar
; i++)

44879 
	`sqlite3VdbeMemRelease
(&
p
->
aVar
[
i
]);

44880 
p
->
aVar
[
i
].
flags
 = 0x0001;

44882 if( 
p
->
isPrepareV2
 && p->
expmask
 )

44885 
p
->
expired
 = 1;

44887 
	`sqlite3_mutex_leave
(
mutex
);

44888 return 
rc
;

44889 
	}
}

44896 const void * 
	$sqlite3_value_blob
(
sqlite3_value
 *
pVal
)

44899 
Mem
 *
p
 = (Mem*)
pVal
;

44900 if( 
p
->
flags
 & (0x0010|0x0002) )

44903 if( 
	`sqlite3VdbeMemExpandBlob
(
p
)!=0 )

44909 
p
->
flags
 |= 0x0010;

44910 return 
p
->
n
 ? p->
z
 : 0;

44912 return 
	`sqlite3_value_text
(
pVal
);

44914 
	}
}

44915 int 
	$sqlite3_value_bytes
(
sqlite3_value
 *
pVal
)

44918 return 
	`sqlite3ValueBytes
(
pVal
, 1);

44919 
	}
}

44920 int 
	$sqlite3_value_bytes16
(
sqlite3_value
 *
pVal
)

44923 return 
	`sqlite3ValueBytes
(
pVal
, 2);

44924 
	}
}

44925 double 
	$sqlite3_value_double
(
sqlite3_value
 *
pVal
)

44928 return 
	`sqlite3VdbeRealValue
((
Mem
*)
pVal
);

44929 
	}
}

44930 int 
	$sqlite3_value_int
(
sqlite3_value
 *
pVal
)

44933 return (int)
	`sqlite3VdbeIntValue
((
Mem
*)
pVal
);

44934 
	}
}

44935 
sqlite_int64
 
	$sqlite3_value_int64
(
sqlite3_value
 *
pVal
)

44938 return 
	`sqlite3VdbeIntValue
((
Mem
*)
pVal
);

44939 
	}
}

44940 unsigned int 
	$sqlite3_value_subtype
(
sqlite3_value
 *
pVal
)

44943 
Mem
 *
pMem
 = (Mem*)
pVal
;

44944 return ((
pMem
->
flags
 & 0x8000) ? pMem->
eSubtype
 : 0);

44945 
	}
}

44946 const unsigned char * 
	$sqlite3_value_text
(
sqlite3_value
 *
pVal
)

44949 return (const unsigned char *)
	`sqlite3ValueText
(
pVal
, 1);

44950 
	}
}

44952 const void * 
	$sqlite3_value_text16
(
sqlite3_value
* 
pVal
)

44955 return 
	`sqlite3ValueText
(
pVal
, 2);

44956 
	}
}

44957 const void * 
	$sqlite3_value_text16be
(
sqlite3_value
 *
pVal
)

44960 return 
	`sqlite3ValueText
(
pVal
, 3);

44961 
	}
}

44962 const void * 
	$sqlite3_value_text16le
(
sqlite3_value
 *
pVal
)

44965 return 
	`sqlite3ValueText
(
pVal
, 2);

44966 
	}
}

44972 int 
	$sqlite3_value_type
(
sqlite3_value
* 
pVal
)

44975 static const 
u8
 
aType
[] = {

45009 return 
aType
[
pVal
->
flags
&0x001f];

45010 
	}
}

45014 
sqlite3_value
 * 
	$sqlite3_value_dup
(const 
sqlite3_value
 *
pOrig
)

45017 
sqlite3_value
 *
pNew
;

45018 if( 
pOrig
==0 ) return 0;

45019 
pNew
 = 
	`sqlite3_malloc
( sizeof(*pNew) );

45020 if( 
pNew
==0 ) return 0;

45021 
	`memset
(
pNew
, 0, sizeof(*pNew));

45022 
	`memcpy
(
pNew
, 
pOrig
, 
	`__builtin_offsetof
 (
Mem
, 
zMalloc
));

45023 
pNew
->
flags
 &= ~0x0400;

45024 
pNew
->
db
 = 0;

45025 if( 
pNew
->
flags
&(0x0002|0x0010) )

45028 
pNew
->
flags
 &= ~(0x0800|0x0400);

45029 
pNew
->
flags
 |= 0x1000;

45030 if( 
	`sqlite3VdbeMemMakeWriteable
(
pNew
)!=0 )

45033 
	`sqlite3ValueFree
(
pNew
);

45034 
pNew
 = 0;

45037 return 
pNew
;

45038 
	}
}

45043 void 
	$sqlite3_value_free
(
sqlite3_value
 *
pOld
)

45046 
	`sqlite3ValueFree
(
pOld
);

45047 
	}
}

45049 static void 
setResultStrOrError
(

45050 
sqlite3_context
 *
pCtx
,

45051 const char *
z
,

45052 int 
n
,

45053 
u8
 
enc
,

45054 void (*
xDel
)(void*)

45058 if( 
	`sqlite3VdbeMemSetStr
(
pCtx
->
pOut
, 
z
, 
n
, 
enc
, 
xDel
)==18 )

45061 
	`sqlite3_result_error_toobig
(
pCtx
);

45063 
	}
}

45064 static int 
invokeValueDestructor
(

45065 const void *
p
,

45066 void (*
xDel
)(void*),

45067 
sqlite3_context
 *
pCtx


45072 if( 
xDel
==0 )

45076 }else if( 
xDel
==((
sqlite3_destructor_type
)-1) )

45081 
	`xDel
((void*)
p
);

45083 if( 
pCtx
 ) 
	`sqlite3_result_error_toobig
(pCtx);

45085 
	}
}

45086 void 
sqlite3_result_blob
(

45087 
sqlite3_context
 *
pCtx
,

45088 const void *
z
,

45089 int 
n
,

45090 void (*
xDel
)(void *)

45096 
	`setResultStrOrError
(
pCtx
, 
z
, 
n
, 0, 
xDel
);

45097 
	}
}

45098 void 
sqlite3_result_blob64
(

45099 
sqlite3_context
 *
pCtx
,

45100 const void *
z
,

45101 
sqlite3_uint64
 
n
,

45102 void (*
xDel
)(void *)

45108 if( 
n
>0x7fffffff )

45111 (void)
	`invokeValueDestructor
(
z
, 
xDel
, 
pCtx
);

45113 
	`setResultStrOrError
(
pCtx
, 
z
, (int)
n
, 0, 
xDel
);

45115 
	}
}

45116 void 
	$sqlite3_result_double
(
sqlite3_context
 *
pCtx
, double 
rVal
)

45120 
	`sqlite3VdbeMemSetDouble
(
pCtx
->
pOut
, 
rVal
);

45121 
	}
}

45122 void 
	$sqlite3_result_error
(
sqlite3_context
 *
pCtx
, const char *
z
, int 
n
)

45126 
pCtx
->
isError
 = 1;

45127 
pCtx
->
fErrorOrAux
 = 1;

45128 
	`sqlite3VdbeMemSetStr
(
pCtx
->
pOut
, 
z
, 
n
, 1, ((
sqlite3_destructor_type
)-1));

45129 
	}
}

45131 void 
	$sqlite3_result_error16
(
sqlite3_context
 *
pCtx
, const void *
z
, int 
n
)

45135 
pCtx
->
isError
 = 1;

45136 
pCtx
->
fErrorOrAux
 = 1;

45137 
	`sqlite3VdbeMemSetStr
(
pCtx
->
pOut
, 
z
, 
n
, 2, ((
sqlite3_destructor_type
)-1));

45138 
	}
}

45140 void 
	$sqlite3_result_int
(
sqlite3_context
 *
pCtx
, int 
iVal
)

45144 
	`sqlite3VdbeMemSetInt64
(
pCtx
->
pOut
, (
i64
)
iVal
);

45145 
	}
}

45146 void 
	$sqlite3_result_int64
(
sqlite3_context
 *
pCtx
, 
i64
 
iVal
)

45150 
	`sqlite3VdbeMemSetInt64
(
pCtx
->
pOut
, 
iVal
);

45151 
	}
}

45152 void 
	$sqlite3_result_null
(
sqlite3_context
 *
pCtx
)

45156 
	`sqlite3VdbeMemSetNull
(
pCtx
->
pOut
);

45157 
	}
}

45158 void 
	$sqlite3_result_subtype
(
sqlite3_context
 *
pCtx
, unsigned int 
eSubtype
)

45161 
Mem
 *
pOut
 = 
pCtx
->pOut;

45163 
pOut
->
eSubtype
 = eSubtype & 0xff;

45164 
pOut
->
flags
 |= 0x8000;

45165 
	}
}

45166 void 
sqlite3_result_text
(

45167 
sqlite3_context
 *
pCtx
,

45168 const char *
z
,

45169 int 
n
,

45170 void (*
xDel
)(void *)

45175 
	`setResultStrOrError
(
pCtx
, 
z
, 
n
, 1, 
xDel
);

45176 
	}
}

45177 void 
sqlite3_result_text64
(

45178 
sqlite3_context
 *
pCtx
,

45179 const char *
z
,

45180 
sqlite3_uint64
 
n
,

45181 void (*
xDel
)(void *),

45182 unsigned char 
enc


45188 if( 
enc
==4 ) enc = 2;

45189 if( 
n
>0x7fffffff )

45192 (void)
	`invokeValueDestructor
(
z
, 
xDel
, 
pCtx
);

45194 
	`setResultStrOrError
(
pCtx
, 
z
, (int)
n
, 
enc
, 
xDel
);

45196 
	}
}

45198 void 
sqlite3_result_text16
(

45199 
sqlite3_context
 *
pCtx
,

45200 const void *
z
,

45201 int 
n
,

45202 void (*
xDel
)(void *)

45207 
	`setResultStrOrError
(
pCtx
, 
z
, 
n
, 2, 
xDel
);

45208 
	}
}

45209 void 
sqlite3_result_text16be
(

45210 
sqlite3_context
 *
pCtx
,

45211 const void *
z
,

45212 int 
n
,

45213 void (*
xDel
)(void *)

45218 
	`setResultStrOrError
(
pCtx
, 
z
, 
n
, 3, 
xDel
);

45219 
	}
}

45220 void 
sqlite3_result_text16le
(

45221 
sqlite3_context
 *
pCtx
,

45222 const void *
z
,

45223 int 
n
,

45224 void (*
xDel
)(void *)

45229 
	`setResultStrOrError
(
pCtx
, 
z
, 
n
, 2, 
xDel
);

45230 
	}
}

45232 void 
	$sqlite3_result_value
(
sqlite3_context
 *
pCtx
, 
sqlite3_value
 *
pValue
)

45236 
	`sqlite3VdbeMemCopy
(
pCtx
->
pOut
, 
pValue
);

45237 
	}
}

45238 void 
	$sqlite3_result_zeroblob
(
sqlite3_context
 *
pCtx
, int 
n
)

45242 
	`sqlite3VdbeMemSetZeroBlob
(
pCtx
->
pOut
, 
n
);

45243 
	}
}

45244 int 
	$sqlite3_result_zeroblob64
(
sqlite3_context
 *
pCtx
, 
u64
 
n
)

45247 
Mem
 *
pOut
 = 
pCtx
->pOut;

45249 if( 
n
>(
u64
)
pOut
->
db
->
aLimit
[0] )

45254 
	`sqlite3VdbeMemSetZeroBlob
(
pCtx
->
pOut
, (int)
n
);

45256 
	}
}

45257 void 
	$sqlite3_result_error_code
(
sqlite3_context
 *
pCtx
, int 
errCode
)

45260 
pCtx
->
isError
 = 
errCode
;

45261 
pCtx
->
fErrorOrAux
 = 1;

45265 if( 
pCtx
->
pOut
->
flags
 & 0x0001 )

45268 
	`sqlite3VdbeMemSetStr
(
pCtx
->
pOut
, 
	`sqlite3ErrStr
(
errCode
), -1,

45269 1, ((
sqlite3_destructor_type
)0));

45271 
	}
}

45274 void 
	$sqlite3_result_error_toobig
(
sqlite3_context
 *
pCtx
)

45278 
pCtx
->
isError
 = 18;

45279 
pCtx
->
fErrorOrAux
 = 1;

45280 
	`sqlite3VdbeMemSetStr
(
pCtx
->
pOut
, "string or blob too big", -1,

45281 1, ((
sqlite3_destructor_type
)0));

45282 
	}
}

45285 void 
	$sqlite3_result_error_nomem
(
sqlite3_context
 *
pCtx
)

45289 
	`sqlite3VdbeMemSetNull
(
pCtx
->
pOut
);

45290 
pCtx
->
isError
 = 7;

45291 
pCtx
->
fErrorOrAux
 = 1;

45292 
	`sqlite3OomFault
(
pCtx
->
pOut
->
db
);

45293 
	}
}

45299 static int 
	$doWalCallbacks
(
sqlite3
 *
db
)

45302 int 
rc
 = 0;

45304 int 
i
;

45305 for(
i
=0; i<
db
->
nDb
; i++)

45308 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

45309 if( 
pBt
 )

45312 int 
nEntry
;

45313 
	`sqlite3BtreeEnter
(
pBt
);

45314 
nEntry
 = 
	`sqlite3PagerWalCallback
(
	`sqlite3BtreePager
(
pBt
));

45315 
	`sqlite3BtreeLeave
(
pBt
);

45316 if( 
db
->
xWalCallback
 && 
nEntry
>0 && 
rc
==0 )

45319 
rc
 = 
db
->
	`xWalCallback
(db->
pWalArg
, db, db->
aDb
[
i
].
zName
, 
nEntry
);

45324 return 
rc
;

45325 
	}
}

45327 static int 
	$sqlite3Step
(
Vdbe
 *
p
)

45330 
sqlite3
 *
db
;

45331 int 
rc
;

45334 if( 
p
->
magic
!=0xbdf20da3 )

45338 
	`sqlite3_reset
((
sqlite3_stmt
*)
p
);

45343 
db
 = 
p
->db;

45344 if( 
db
->
mallocFailed
 )

45347 
p
->
rc
 = 7;

45351 if( 
p
->
pc
<=0 && p->
expired
 )

45354 
p
->
rc
 = 17;

45355 
rc
 = 1;

45356 goto 
end_of_step
;

45358 if( 
p
->
pc
<0 )

45365 if( 
db
->
nVdbeActive
==0 )

45368 
db
->
u1
.
isInterrupted
 = 0;

45376 if( 
db
->
xProfile
 && !db->
init
.
busy
 && 
p
->
zSql
 )

45379 
	`sqlite3OsCurrentTimeInt64
(
db
->
pVfs
, &
p
->
startTime
);

45385 
db
->
nVdbeActive
++;

45386 if( 
p
->
readOnly
==0 ) 
db
->
nVdbeWrite
++;

45387 if( 
p
->
bIsReader
 ) 
db
->
nVdbeRead
++;

45388 
p
->
pc
 = 0;

45394 if( 
p
->
explain
 )

45397 
rc
 = 
	`sqlite3VdbeList
(
p
);

45401 
db
->
nVdbeExec
++;

45402 
rc
 = 
	`sqlite3VdbeExec
(
p
);

45403 
db
->
nVdbeExec
--;

45408 if( 
rc
!=100 ) if( ((
p
)->
startTime
)>0 )

45410 
	`invokeProfileCallback
(
db
,
p
); };

45413 if( 
rc
==101 )

45417 
p
->
rc
 = 
	`doWalCallbacks
(
db
);

45418 if( 
p
->
rc
!=0 )

45421 
rc
 = 1;

45425 
db
->
errCode
 = 
rc
;

45426 if( 7==
	`sqlite3ApiExit
(
p
->
db
, p->
rc
) )

45429 
p
->
rc
 = 7;

45431 
end_of_step
:

45443 if( 
p
->
isPrepareV2
 && 
rc
!=100 && rc!=101 )

45450 
rc
 = 
	`sqlite3VdbeTransferError
(
p
);

45452 return (
rc
&
db
->
errMask
);

45453 
	}
}

45460 int 
	$sqlite3_step
(
sqlite3_stmt
 *
pStmt
)

45463 int 
rc
 = 0;

45464 int 
rc2
 = 0;

45465 
Vdbe
 *
v
 = (Vdbe*)
pStmt
;

45466 int 
cnt
 = 0;

45467 
sqlite3
 *
db
;

45469 if( 
	`vdbeSafetyNotNull
(
v
) )

45472 return 
	`sqlite3MisuseError
(73166);

45474 
db
 = 
v
->db;

45475 
	`sqlite3_mutex_enter
(
db
->
mutex
);

45476 
v
->
doingRerun
 = 0;

45477 while( (
rc
 = 
	`sqlite3Step
(
v
))==17

45478 && 
cnt
++ < 50 )

45481 int 
savedPc
 = 
v
->
pc
;

45482 
rc2
 = 
rc
 = 
	`sqlite3Reprepare
(
v
);

45483 if( 
rc
!=0) break;

45484 
	`sqlite3_reset
(
pStmt
);

45485 if( 
savedPc
>=0 ) 
v
->
doingRerun
 = 1;

45488 if( 
rc2
!=0 )

45492 const char *
zErr
 = (const char *)
	`sqlite3_value_text
(
db
->
pErr
);

45493 
	`sqlite3DbFree
(
db
, 
v
->
zErrMsg
);

45494 if( !
db
->
mallocFailed
 )

45497 
v
->
zErrMsg
 = 
	`sqlite3DbStrDup
(
db
, 
zErr
);

45498 
v
->
rc
 = 
rc2
;

45500 
v
->
zErrMsg
 = 0;

45501 
v
->
rc
 = rc = 7;

45504 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

45505 
	`sqlite3_mutex_leave
(
db
->
mutex
);

45506 return 
rc
;

45507 
	}
}

45514 void * 
	$sqlite3_user_data
(
sqlite3_context
 *
p
)

45518 return 
p
->
pFunc
->
pUserData
;

45519 
	}
}

45521 
sqlite3
 * 
	$sqlite3_context_db_handle
(
sqlite3_context
 *
p
)

45525 return 
p
->
pOut
->
db
;

45526 
	}
}

45528 static 
sqlite3_int64
 
	$sqlite3StmtCurrentTime
(
sqlite3_context
 *
p
)

45531 int 
rc
;

45533 
sqlite3_int64
 *
piTime
 = &
p
->
pVdbe
->
iCurrentTime
;

45539 if( *
piTime
==0 )

45542 
rc
 = 
	`sqlite3OsCurrentTimeInt64
(
p
->
pOut
->
db
->
pVfs
, 
piTime
);

45543 if( 
rc
 ) *
piTime
 = 0;

45545 return *
piTime
;

45546 
	}
}

45548 static void 
	$sqlite3InvalidFunction
(

45549 
sqlite3_context
 *
context
,

45550 int 
NotUsed
,

45551 
sqlite3_value
 **
NotUsed2


45555 const char *
zName
 = 
context
->
pFunc
->zName;

45556 char *
zErr
;

45557 (void)(
NotUsed
),(void)(
NotUsed2
);

45558 
zErr
 = 
	`sqlite3_mprintf
(

45559 "unable to use function %s in the requested context", 
zName
);

45560 
	`sqlite3_result_error
(
context
, 
zErr
, -1);

45561 
	`sqlite3_free
(
zErr
);

45562 
	}
}

45568 static 
__attribute__
((
noinline
)) void *
	$createAggContext
(
sqlite3_context
 *
p
, int 
nByte
)

45571 
Mem
 *
pMem
 = 
p
->pMem;

45573 if( 
nByte
<=0 )

45576 
	`sqlite3VdbeMemSetNull
(
pMem
);

45577 
pMem
->
z
 = 0;

45579 
	`sqlite3VdbeMemClearAndResize
(
pMem
, 
nByte
);

45580 
pMem
->
flags
 = 0x2000;

45581 
pMem
->
u
.
pDef
 = 
p
->
pFunc
;

45582 if( 
pMem
->
z
 )

45585 
	`memset
(
pMem
->
z
, 0, 
nByte
);

45588 return (void*)
pMem
->
z
;

45589 
	}
}

45596 void * 
	$sqlite3_aggregate_context
(
sqlite3_context
 *
p
, int 
nByte
)

45602 if( (
p
->
pMem
->
flags
 & 0x2000)==0 )

45605 return 
	`createAggContext
(
p
, 
nByte
);

45607 return (void*)
p
->
pMem
->
z
;

45609 
	}
}

45615 void * 
	$sqlite3_get_auxdata
(
sqlite3_context
 *
pCtx
, int 
iArg
)

45618 
AuxData
 *
pAuxData
;

45626 for(
pAuxData
=
pCtx
->
pVdbe
->pAuxData; pAuxData; pAuxData=pAuxData->
pNext
)

45629 if( 
pAuxData
->
iOp
==
pCtx
->iOp && pAuxData->
iArg
==iArg ) break;

45632 return (
pAuxData
 ? pAuxData->
pAux
 : 0);

45633 
	}
}

45640 void 
sqlite3_set_auxdata
(

45641 
sqlite3_context
 *
pCtx
,

45642 int 
iArg
,

45643 void *
pAux
,

45644 void (*
xDelete
)(void*)

45648 
AuxData
 *
pAuxData
;

45649 
Vdbe
 *
pVdbe
 = 
pCtx
->pVdbe;

45652 if( 
iArg
<0 ) goto 
failed
;

45659 for(
pAuxData
=
pVdbe
->pAuxData; pAuxData; pAuxData=pAuxData->
pNext
)

45662 if( 
pAuxData
->
iOp
==
pCtx
->iOp && pAuxData->
iArg
==iArg ) break;

45664 if( 
pAuxData
==0 )

45667 
pAuxData
 = 
	`sqlite3DbMallocZero
(
pVdbe
->
db
, sizeof(
AuxData
));

45668 if( !
pAuxData
 ) goto 
failed
;

45669 
pAuxData
->
iOp
 = 
pCtx
->iOp;

45670 
pAuxData
->
iArg
 = iArg;

45671 
pAuxData
->
pNext
 = 
pVdbe
->pAuxData;

45672 
pVdbe
->
pAuxData
 = pAuxData;

45673 if( 
pCtx
->
fErrorOrAux
==0 )

45676 
pCtx
->
isError
 = 0;

45677 
pCtx
->
fErrorOrAux
 = 1;

45679 }else if( 
pAuxData
->
xDelete
 )

45682 
pAuxData
->
	`xDelete
(pAuxData->
pAux
);

45685 
pAuxData
->
pAux
 = pAux;

45686 
pAuxData
->
xDelete
 = xDelete;

45689 
failed
:

45690 if( 
xDelete
 )

45693 
	`xDelete
(
pAux
);

45695 
	}
}

45697 int 
	$sqlite3_aggregate_count
(
sqlite3_context
 *
p
)

45701 return 
p
->
pMem
->
n
;

45702 
	}
}

45708 int 
	$sqlite3_column_count
(
sqlite3_stmt
 *
pStmt
)

45711 
Vdbe
 *
pVm
 = (Vdbe *)
pStmt
;

45712 return 
pVm
 ? pVm->
nResColumn
 : 0;

45713 
	}
}

45719 int 
	$sqlite3_data_count
(
sqlite3_stmt
 *
pStmt
)

45722 
Vdbe
 *
pVm
 = (Vdbe *)
pStmt
;

45723 if( 
pVm
==0 || pVm->
pResultSet
==0 ) return 0;

45724 return 
pVm
->
nResColumn
;

45725 
	}
}

45730 static const 
Mem
 *
	$columnNullValue
(void)

45734 static const 
Mem
 
nullMem


45740 (
u16
)0x0001,

45741 (
u8
)0,

45742 (
u8
)0,

45747 (
u32
)0,

45748 (
sqlite3
*)0,

45755 return &
nullMem
;

45756 
	}
}

45764 static 
Mem
 *
	$columnMem
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45767 
Vdbe
 *
pVm
;

45768 
Mem
 *
pOut
;

45770 
pVm
 = (
Vdbe
 *)
pStmt
;

45771 if( 
pVm
 && pVm->
pResultSet
!=0 && 
i
<pVm->
nResColumn
 && i>=0 )

45774 
	`sqlite3_mutex_enter
(
pVm
->
db
->
mutex
);

45775 
pOut
 = &
pVm
->
pResultSet
[
i
];

45777 if( 
pVm
 && (pVm->
db
) )

45780 
	`sqlite3_mutex_enter
(
pVm
->
db
->
mutex
);

45781 
	`sqlite3Error
(
pVm
->
db
, 25);

45783 
pOut
 = (
Mem
*)
	`columnNullValue
();

45785 return 
pOut
;

45786 
	}
}

45788 static void 
	$columnMallocFailure
(
sqlite3_stmt
 *
pStmt
)

45795 
Vdbe
 *
p
 = (Vdbe *)
pStmt
;

45796 if( 
p
 )

45799 
p
->
rc
 = 
	`sqlite3ApiExit
(p->
db
, p->rc);

45800 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

45802 
	}
}

45808 const void * 
	$sqlite3_column_blob
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45811 const void *
val
;

45812 
val
 = 
	`sqlite3_value_blob
( 
	`columnMem
(
pStmt
,
i
) );

45817 
	`columnMallocFailure
(
pStmt
);

45818 return 
val
;

45819 
	}
}

45820 int 
	$sqlite3_column_bytes
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45823 int 
val
 = 
	`sqlite3_value_bytes
( 
	`columnMem
(
pStmt
,
i
) );

45824 
	`columnMallocFailure
(
pStmt
);

45825 return 
val
;

45826 
	}
}

45827 int 
	$sqlite3_column_bytes16
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45830 int 
val
 = 
	`sqlite3_value_bytes16
( 
	`columnMem
(
pStmt
,
i
) );

45831 
	`columnMallocFailure
(
pStmt
);

45832 return 
val
;

45833 
	}
}

45834 double 
	$sqlite3_column_double
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45837 double 
val
 = 
	`sqlite3_value_double
( 
	`columnMem
(
pStmt
,
i
) );

45838 
	`columnMallocFailure
(
pStmt
);

45839 return 
val
;

45840 
	}
}

45841 int 
	$sqlite3_column_int
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45844 int 
val
 = 
	`sqlite3_value_int
( 
	`columnMem
(
pStmt
,
i
) );

45845 
	`columnMallocFailure
(
pStmt
);

45846 return 
val
;

45847 
	}
}

45848 
sqlite_int64
 
	$sqlite3_column_int64
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45851 
sqlite_int64
 
val
 = 
	`sqlite3_value_int64
( 
	`columnMem
(
pStmt
,
i
) );

45852 
	`columnMallocFailure
(
pStmt
);

45853 return 
val
;

45854 
	}
}

45855 const unsigned char * 
	$sqlite3_column_text
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45858 const unsigned char *
val
 = 
	`sqlite3_value_text
( 
	`columnMem
(
pStmt
,
i
) );

45859 
	`columnMallocFailure
(
pStmt
);

45860 return 
val
;

45861 
	}
}

45862 
sqlite3_value
 * 
	$sqlite3_column_value
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45865 
Mem
 *
pOut
 = 
	`columnMem
(
pStmt
, 
i
);

45866 if( 
pOut
->
flags
&0x0800 )

45869 
pOut
->
flags
 &= ~0x0800;

45870 
pOut
->
flags
 |= 0x1000;

45872 
	`columnMallocFailure
(
pStmt
);

45873 return (
sqlite3_value
 *)
pOut
;

45874 
	}
}

45876 const void * 
	$sqlite3_column_text16
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45879 const void *
val
 = 
	`sqlite3_value_text16
( 
	`columnMem
(
pStmt
,
i
) );

45880 
	`columnMallocFailure
(
pStmt
);

45881 return 
val
;

45882 
	}
}

45884 int 
	$sqlite3_column_type
(
sqlite3_stmt
 *
pStmt
, int 
i
)

45887 int 
iType
 = 
	`sqlite3_value_type
( 
	`columnMem
(
pStmt
,
i
) );

45888 
	`columnMallocFailure
(
pStmt
);

45889 return 
iType
;

45890 
	}
}

45892 static const void *
columnName
(

45893 
sqlite3_stmt
 *
pStmt
,

45894 int 
N
,

45895 const void *(*
xFunc
)(
Mem
*),

45896 int 
useType


45900 const void *
	gret
;

45901 
Vdbe
 *
	gp
;

45902 int 
	gn
;

45903 
sqlite3
 *
	gdb
;

45910 
	gret
 = 0;

45911 
	gp
 = (
Vdbe
 *)
pStmt
;

45912 
	gdb
 = 
p
->
db
;

45914 
	gn
 = 
sqlite3_column_count
(
pStmt
);

45915 if( 
	gN
<
	gn
 && N>=0 )

45918 
N
 += 
useType
*
n
;

45919 
sqlite3_mutex_enter
(
db
->
mutex
);

45921 
	gret
 = 
xFunc
(&
p
->
aColName
[
N
]);

45925 if( 
	gdb
->
	gmallocFailed
 )

45928 
sqlite3OomClear
(
db
);

45929 
	gret
 = 0;

45931 
sqlite3_mutex_leave
(
db
->
mutex
);

45933 return 
	gret
;

45940 const char * 
	$sqlite3_column_name
(
sqlite3_stmt
 *
pStmt
, int 
N
)

45943 return 
	`columnName
(

45944 
pStmt
, 
N
, (const void*(*)(
Mem
*))
sqlite3_value_text
, 0);

45945 
	}
}

45947 const void * 
	$sqlite3_column_name16
(
sqlite3_stmt
 *
pStmt
, int 
N
)

45950 return 
	`columnName
(

45951 
pStmt
, 
N
, (const void*(*)(
Mem
*))
sqlite3_value_text16
, 0);

45952 
	}
}

45954 const char * 
	$sqlite3_column_decltype
(
sqlite3_stmt
 *
pStmt
, int 
N
)

45957 return 
	`columnName
(

45958 
pStmt
, 
N
, (const void*(*)(
Mem
*))
sqlite3_value_text
, 1);

45959 
	}
}

45961 const void * 
	$sqlite3_column_decltype16
(
sqlite3_stmt
 *
pStmt
, int 
N
)

45964 return 
	`columnName
(

45965 
pStmt
, 
N
, (const void*(*)(
Mem
*))
sqlite3_value_text16
, 1);

45966 
	}
}

45968 static int 
	$vdbeUnbind
(
Vdbe
 *
p
, int 
i
)

45971 
Mem
 *
pVar
;

45972 if( 
	`vdbeSafetyNotNull
(
p
) )

45975 return 
	`sqlite3MisuseError
(73738);

45977 
	`sqlite3_mutex_enter
(
p
->
db
->
mutex
);

45978 if( 
p
->
magic
!=0xbdf20da3 || p->
pc
>=0 )

45981 
	`sqlite3Error
(
p
->
db
, 21);

45982 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

45983 
	`sqlite3_log
(21,

45984 "bind on a busy prepared statement: [%s]", 
p
->
zSql
);

45985 return 
	`sqlite3MisuseError
(73746);

45987 if( 
i
<1 || i>
p
->
nVar
 )

45990 
	`sqlite3Error
(
p
->
db
, 25);

45991 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

45994 
i
--;

45995 
pVar
 = &
p
->
aVar
[
i
];

45996 
	`sqlite3VdbeMemRelease
(
pVar
);

45997 
pVar
->
flags
 = 0x0001;

45998 
	`sqlite3Error
(
p
->
db
, 0);

46000 if( 
p
->
isPrepareV2
 &&

46001 ((
i
<32 && 
p
->
expmask
 & ((
u32
)1 << i)) || p->expmask==0xffffffff)

46005 
p
->
expired
 = 1;

46008 
	}
}

46013 static int 
bindText
(

46014 
sqlite3_stmt
 *
pStmt
,

46015 int 
i
,

46016 const void *
zData
,

46017 int 
nData
,

46018 void (*
xDel
)(void*),

46019 
u8
 
encoding


46023 
Vdbe
 *
p
 = (Vdbe *)
pStmt
;

46024 
Mem
 *
pVar
;

46025 int 
rc
;

46027 
rc
 = 
	`vdbeUnbind
(
p
, 
i
);

46028 if( 
rc
==0 )

46031 if( 
zData
!=0 )

46034 
pVar
 = &
p
->
aVar
[
i
-1];

46035 
rc
 = 
	`sqlite3VdbeMemSetStr
(
pVar
, 
zData
, 
nData
, 
encoding
, 
xDel
);

46036 if( 
rc
==0 && 
encoding
!=0 )

46039 
rc
 = 
	`sqlite3VdbeChangeEncoding
(
pVar
, ((
p
->
db
)->
enc
));

46041 
	`sqlite3Error
(
p
->
db
, 
rc
);

46042 
rc
 = 
	`sqlite3ApiExit
(
p
->
db
, rc);

46044 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

46045 }else if( 
xDel
!=((
sqlite3_destructor_type
)0) && xDel!=((sqlite3_destructor_type)-1) )

46048 
	`xDel
((void*)
zData
);

46050 return 
rc
;

46051 
	}
}

46057 int 
sqlite3_bind_blob
(

46058 
sqlite3_stmt
 *
pStmt
,

46059 int 
i
,

46060 const void *
zData
,

46061 int 
nData
,

46062 void (*
xDel
)(void*)

46069 return 
	`bindText
(
pStmt
, 
i
, 
zData
, 
nData
, 
xDel
, 0);

46070 
	}
}

46071 int 
sqlite3_bind_blob64
(

46072 
sqlite3_stmt
 *
pStmt
,

46073 int 
i
,

46074 const void *
zData
,

46075 
sqlite3_uint64
 
nData
,

46076 void (*
xDel
)(void*)

46081 if( 
nData
>0x7fffffff )

46084 return 
	`invokeValueDestructor
(
zData
, 
xDel
, 0);

46086 return 
	`bindText
(
pStmt
, 
i
, 
zData
, (int)
nData
, 
xDel
, 0);

46088 
	}
}

46089 int 
	$sqlite3_bind_double
(
sqlite3_stmt
 *
pStmt
, int 
i
, double 
rValue
)

46092 int 
rc
;

46093 
Vdbe
 *
p
 = (Vdbe *)
pStmt
;

46094 
rc
 = 
	`vdbeUnbind
(
p
, 
i
);

46095 if( 
rc
==0 )

46098 
	`sqlite3VdbeMemSetDouble
(&
p
->
aVar
[
i
-1], 
rValue
);

46099 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

46101 return 
rc
;

46102 
	}
}

46103 int 
	$sqlite3_bind_int
(
sqlite3_stmt
 *
p
, int 
i
, int 
iValue
)

46106 return 
	`sqlite3_bind_int64
(
p
, 
i
, (
i64
)
iValue
);

46107 
	}
}

46108 int 
	$sqlite3_bind_int64
(
sqlite3_stmt
 *
pStmt
, int 
i
, 
sqlite_int64
 
iValue
)

46111 int 
rc
;

46112 
Vdbe
 *
p
 = (Vdbe *)
pStmt
;

46113 
rc
 = 
	`vdbeUnbind
(
p
, 
i
);

46114 if( 
rc
==0 )

46117 
	`sqlite3VdbeMemSetInt64
(&
p
->
aVar
[
i
-1], 
iValue
);

46118 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

46120 return 
rc
;

46121 
	}
}

46122 int 
	$sqlite3_bind_null
(
sqlite3_stmt
 *
pStmt
, int 
i
)

46125 int 
rc
;

46126 
Vdbe
 *
p
 = (Vdbe*)
pStmt
;

46127 
rc
 = 
	`vdbeUnbind
(
p
, 
i
);

46128 if( 
rc
==0 )

46131 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

46133 return 
rc
;

46134 
	}
}

46135 int 
sqlite3_bind_text
(

46136 
sqlite3_stmt
 *
pStmt
,

46137 int 
i
,

46138 const char *
zData
,

46139 int 
nData
,

46140 void (*
xDel
)(void*)

46144 return 
	`bindText
(
pStmt
, 
i
, 
zData
, 
nData
, 
xDel
, 1);

46145 
	}
}

46146 int 
sqlite3_bind_text64
(

46147 
sqlite3_stmt
 *
pStmt
,

46148 int 
i
,

46149 const char *
zData
,

46150 
sqlite3_uint64
 
nData
,

46151 void (*
xDel
)(void*),

46152 unsigned char 
enc


46157 if( 
nData
>0x7fffffff )

46160 return 
	`invokeValueDestructor
(
zData
, 
xDel
, 0);

46162 if( 
enc
==4 ) enc = 2;

46163 return 
	`bindText
(
pStmt
, 
i
, 
zData
, (int)
nData
, 
xDel
, 
enc
);

46165 
	}
}

46167 int 
sqlite3_bind_text16
(

46168 
sqlite3_stmt
 *
pStmt
,

46169 int 
i
,

46170 const void *
zData
,

46171 int 
nData
,

46172 void (*
xDel
)(void*)

46176 return 
	`bindText
(
pStmt
, 
i
, 
zData
, 
nData
, 
xDel
, 2);

46177 
	}
}

46179 int 
	$sqlite3_bind_value
(
sqlite3_stmt
 *
pStmt
, int 
i
, const 
sqlite3_value
 *
pValue
)

46182 int 
rc
;

46183 switch( 
	`sqlite3_value_type
((
sqlite3_value
*)
pValue
) )

46187 
rc
 = 
	`sqlite3_bind_int64
(
pStmt
, 
i
, 
pValue
->
u
.i);

46191 
rc
 = 
	`sqlite3_bind_double
(
pStmt
, 
i
, 
pValue
->
u
.
r
);

46195 if( 
pValue
->
flags
 & 0x4000 )

46198 
rc
 = 
	`sqlite3_bind_zeroblob
(
pStmt
, 
i
, 
pValue
->
u
.
nZero
);

46200 
rc
 = 
	`sqlite3_bind_blob
(
pStmt
, 
i
, 
pValue
->
z
, pValue->
n
,((
sqlite3_destructor_type
)-1));

46205 
rc
 = 
	`bindText
(
pStmt
,
i
, 
pValue
->
z
, pValue->
n
, ((
sqlite3_destructor_type
)-1),

46206 
pValue
->
enc
);

46210 
rc
 = 
	`sqlite3_bind_null
(
pStmt
, 
i
);

46214 return 
rc
;

46215 
	}
}

46216 int 
	$sqlite3_bind_zeroblob
(
sqlite3_stmt
 *
pStmt
, int 
i
, int 
n
)

46219 int 
rc
;

46220 
Vdbe
 *
p
 = (Vdbe *)
pStmt
;

46221 
rc
 = 
	`vdbeUnbind
(
p
, 
i
);

46222 if( 
rc
==0 )

46225 
	`sqlite3VdbeMemSetZeroBlob
(&
p
->
aVar
[
i
-1], 
n
);

46226 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

46228 return 
rc
;

46229 
	}
}

46230 int 
	$sqlite3_bind_zeroblob64
(
sqlite3_stmt
 *
pStmt
, int 
i
, 
sqlite3_uint64
 
n
)

46233 int 
rc
;

46234 
Vdbe
 *
p
 = (Vdbe *)
pStmt
;

46235 
	`sqlite3_mutex_enter
(
p
->
db
->
mutex
);

46236 if( 
n
>(
u64
)
p
->
db
->
aLimit
[0] )

46239 
rc
 = 18;

46242 
rc
 = 
	`sqlite3_bind_zeroblob
(
pStmt
, 
i
, 
n
);

46244 
rc
 = 
	`sqlite3ApiExit
(
p
->
db
, rc);

46245 
	`sqlite3_mutex_leave
(
p
->
db
->
mutex
);

46246 return 
rc
;

46247 
	}
}

46253 int 
	$sqlite3_bind_parameter_count
(
sqlite3_stmt
 *
pStmt
)

46256 
Vdbe
 *
p
 = (Vdbe*)
pStmt
;

46257 return 
p
 ? p->
nVar
 : 0;

46258 
	}
}

46266 const char * 
	$sqlite3_bind_parameter_name
(
sqlite3_stmt
 *
pStmt
, int 
i
)

46269 
Vdbe
 *
p
 = (Vdbe*)
pStmt
;

46270 if( 
p
==0 || 
i
<1 || i>p->
nzVar
 )

46275 return 
p
->
azVar
[
i
-1];

46276 
	}
}

46283 static int 
	$sqlite3VdbeParameterIndex
(
Vdbe
 *
p
, const char *
zName
, int 
nName
)

46286 int 
i
;

46287 if( 
p
==0 )

46292 if( 
zName
 )

46295 for(
i
=0; i<
p
->
nzVar
; i++)

46298 const char *
z
 = 
p
->
azVar
[
i
];

46299 if( 
z
 && 
	`strncmp
(z,
zName
,
nName
)==0 && z[nName]==0 )

46302 return 
i
+1;

46307 
	}
}

46308 int 
	$sqlite3_bind_parameter_index
(
sqlite3_stmt
 *
pStmt
, const char *
zName
)

46311 return 
	`sqlite3VdbeParameterIndex
((
Vdbe
*)
pStmt
, 
zName
, 
	`sqlite3Strlen30
(zName));

46312 
	}
}

46317 static int 
	$sqlite3TransferBindings
(
sqlite3_stmt
 *
pFromStmt
, sqlite3_stmt *
pToStmt
)

46320 
Vdbe
 *
pFrom
 = (Vdbe*)
pFromStmt
;

46321 
Vdbe
 *
pTo
 = (Vdbe*)
pToStmt
;

46322 int 
i
;

46325 
	`sqlite3_mutex_enter
(
pTo
->
db
->
mutex
);

46326 for(
i
=0; i<
pFrom
->
nVar
; i++)

46329 
	`sqlite3VdbeMemMove
(&
pTo
->
aVar
[
i
], &
pFrom
->aVar[i]);

46331 
	`sqlite3_mutex_leave
(
pTo
->
db
->
mutex
);

46333 
	}
}

46335 int 
	$sqlite3_transfer_bindings
(
sqlite3_stmt
 *
pFromStmt
, sqlite3_stmt *
pToStmt
)

46338 
Vdbe
 *
pFrom
 = (Vdbe*)
pFromStmt
;

46339 
Vdbe
 *
pTo
 = (Vdbe*)
pToStmt
;

46340 if( 
pFrom
->
nVar
!=
pTo
->nVar )

46345 if( 
pTo
->
isPrepareV2
 && pTo->
expmask
 )

46348 
pTo
->
expired
 = 1;

46350 if( 
pFrom
->
isPrepareV2
 && pFrom->
expmask
 )

46353 
pFrom
->
expired
 = 1;

46355 return 
	`sqlite3TransferBindings
(
pFromStmt
, 
pToStmt
);

46356 
	}
}

46358 
sqlite3
 * 
	$sqlite3_db_handle
(
sqlite3_stmt
 *
pStmt
)

46361 return 
pStmt
 ? ((
Vdbe
*)pStmt)->
db
 : 0;

46362 
	}
}

46368 int 
	$sqlite3_stmt_readonly
(
sqlite3_stmt
 *
pStmt
)

46371 return 
pStmt
 ? ((
Vdbe
*)pStmt)->
readOnly
 : 1;

46372 
	}
}

46377 int 
	$sqlite3_stmt_busy
(
sqlite3_stmt
 *
pStmt
)

46380 
Vdbe
 *
v
 = (Vdbe*)
pStmt
;

46381 return 
v
!=0 && v->
pc
>=0 && v->
magic
==0xbdf20da3;

46382 
	}
}

46390 
sqlite3_stmt
 * 
	$sqlite3_next_stmt
(
sqlite3
 *
pDb
, 
sqlite3_stmt
 *
pStmt
)

46393 
sqlite3_stmt
 *
pNext
;

46400 
	`sqlite3_mutex_enter
(
pDb
->
mutex
);

46401 if( 
pStmt
==0 )

46404 
pNext
 = (
sqlite3_stmt
*)
pDb
->
pVdbe
;

46406 
pNext
 = (
sqlite3_stmt
*)((
Vdbe
*)
pStmt
)->pNext;

46408 
	`sqlite3_mutex_leave
(
pDb
->
mutex
);

46409 return 
pNext
;

46410 
	}
}

46415 int 
	$sqlite3_stmt_status
(
sqlite3_stmt
 *
pStmt
, int 
op
, int 
resetFlag
)

46418 
Vdbe
 *
pVdbe
 = (Vdbe*)
pStmt
;

46419 
u32
 
v
;

46426 
v
 = 
pVdbe
->
aCounter
[
op
];

46427 if( 
resetFlag
 ) 
pVdbe
->
aCounter
[
op
] = 0;

46428 return (int)
v
;

46429 
	}
}

46431 static int 
	$findNextHostParameter
(const char *
zSql
, int *
pnToken
)

46434 int 
tokenType
;

46435 int 
nTotal
 = 0;

46436 int 
n
;

46438 *
pnToken
 = 0;

46439 while( 
zSql
[0] )

46442 
n
 = 
	`sqlite3GetToken
((
u8
*)
zSql
, &
tokenType
);

46444 if( 
tokenType
==135 )

46447 *
pnToken
 = 
n
;

46450 
nTotal
 += 
n
;

46451 
zSql
 += 
n
;

46453 return 
nTotal
;

46454 
	}
}

46456 static char *
	$sqlite3VdbeExpandSql
(

46457 
Vdbe
 *
p
,

46458 const char *
zRawSql


46462 
sqlite3
 *
db
;

46463 int 
idx
 = 0;

46464 int 
nextIndex
 = 1;

46465 int 
n
;

46466 int 
nToken
;

46467 int 
i
;

46468 
Mem
 *
pVar
;

46469 
StrAccum
 
out
;

46470 char 
zBase
[100];

46472 
db
 = 
p
->db;

46473 
	`sqlite3StrAccumInit
(&
out
, 
db
, 
zBase
, sizeof(zBase),

46474 
db
->
aLimit
[0]);

46475 if( 
db
->
nVdbeExec
>1 )

46478 while( *
zRawSql
 )

46481 const char *
zStart
 = 
zRawSql
;

46482 while( *(
zRawSql
++)!='\n' && *zRawSql );

46483 
	`sqlite3StrAccumAppend
(&
out
, "-- ", 3);

46485 
	`sqlite3StrAccumAppend
(&
out
, 
zStart
, (int)(
zRawSql
-zStart));

46487 }else if( 
p
->
nVar
==0 )

46490 
	`sqlite3StrAccumAppend
(&
out
, 
zRawSql
, 
	`sqlite3Strlen30
(zRawSql));

46492 while( 
zRawSql
[0] )

46495 
n
 = 
	`findNextHostParameter
(
zRawSql
, &
nToken
);

46497 
	`sqlite3StrAccumAppend
(&
out
, 
zRawSql
, 
n
);

46498 
zRawSql
 += 
n
;

46500 if( 
nToken
==0 ) break;

46501 if( 
zRawSql
[0]=='?' )

46504 if( 
nToken
>1 )

46508 
	`sqlite3GetInt32
(&
zRawSql
[1], &
idx
);

46510 
idx
 = 
nextIndex
;

46519 
idx
 = 
	`sqlite3VdbeParameterIndex
(
p
, 
zRawSql
, 
nToken
);

46522 
zRawSql
 += 
nToken
;

46523 
nextIndex
 = 
idx
 + 1;

46525 
pVar
 = &
p
->
aVar
[
idx
-1];

46526 if( 
pVar
->
flags
 & 0x0001 )

46529 
	`sqlite3StrAccumAppend
(&
out
, "NULL", 4);

46530 }else if( 
pVar
->
flags
 & 0x0004 )

46533 
	`sqlite3XPrintf
(&
out
, "%lld", 
pVar
->
u
.
i
);

46534 }else if( 
pVar
->
flags
 & 0x0008 )

46537 
	`sqlite3XPrintf
(&
out
, "%!.15g", 
pVar
->
u
.
r
);

46538 }else if( 
pVar
->
flags
 & 0x0002 )

46541 int 
nOut
;

46543 
u8
 
enc
 = ((
db
)->enc);

46544 
Mem
 
utf8
;

46545 if( 
enc
!=1 )

46548 
	`memset
(&
utf8
, 0, sizeof(utf8));

46549 
utf8
.
db
 = db;

46550 
	`sqlite3VdbeMemSetStr
(&
utf8
, 
pVar
->
z
, pVar->
n
, 
enc
, ((
sqlite3_destructor_type
)0));

46551 
	`sqlite3VdbeChangeEncoding
(&
utf8
, 1);

46552 
pVar
 = &
utf8
;

46555 
nOut
 = 
pVar
->
n
;

46562 
	`sqlite3XPrintf
(&
out
, "'%.*q'", 
nOut
, 
pVar
->
z
);

46569 if( 
enc
!=1 ) 
	`sqlite3VdbeMemRelease
(&
utf8
);

46571 }else if( 
pVar
->
flags
 & 0x4000 )

46574 
	`sqlite3XPrintf
(&
out
, "zeroblob(%d)", 
pVar
->
u
.
nZero
);

46576 int 
nOut
;

46578 
	`sqlite3StrAccumAppend
(&
out
, "x'", 2);

46579 
nOut
 = 
pVar
->
n
;

46583 for(
i
=0; i<
nOut
; i++)

46586 
	`sqlite3XPrintf
(&
out
, "%02x", 
pVar
->
z
[
i
]&0xff);

46588 
	`sqlite3StrAccumAppend
(&
out
, "'", 1);

46597 return 
	`sqlite3StrAccumFinish
(&
out
);

46598 
	}
}

46600 static 
VdbeCursor
 *
	$allocateCursor
(

46601 
Vdbe
 *
p
,

46602 int 
iCur
,

46603 int 
nField
,

46604 int 
iDb
,

46605 
u8
 
eCurType


46610 
Mem
 *
pMem
 = 
iCur
>0 ? &
p
->
aMem
[p->
nMem
-iCur] : p->aMem;

46612 int 
nByte
;

46613 
VdbeCursor
 *
pCx
 = 0;

46614 
nByte
 =

46615 (((sizeof(
VdbeCursor
))+7)&~7) + 2*sizeof(
u32
)*
nField
 +

46616 (
eCurType
==0?
	`sqlite3BtreeCursorSize
():0);

46619 if( 
p
->
apCsr
[
iCur
] )

46622 
	`sqlite3VdbeFreeCursor
(
p
, p->
apCsr
[
iCur
]);

46623 
p
->
apCsr
[
iCur
] = 0;

46625 if( 0==
	`sqlite3VdbeMemClearAndResize
(
pMem
, 
nByte
) )

46628 
p
->
apCsr
[
iCur
] = 
pCx
 = (
VdbeCursor
*)
pMem
->
z
;

46629 
	`memset
(
pCx
, 0, sizeof(
VdbeCursor
));

46630 
pCx
->
eCurType
 = eCurType;

46631 
pCx
->
iDb
 = iDb;

46632 
pCx
->
nField
 = nField;

46633 
pCx
->
aOffset
 = &pCx->
aType
[
nField
];

46634 if( 
eCurType
==0 )

46637 
pCx
->
uc
.
pCursor
 = (
BtCursor
*)

46638 &
pMem
->
z
[(((sizeof(
VdbeCursor
))+7)&~7)+2*sizeof(
u32
)*
nField
];

46639 
	`sqlite3BtreeCursorZero
(
pCx
->
uc
.
pCursor
);

46642 return 
pCx
;

46643 
	}
}

46645 static void 
	$applyNumericAffinity
(
Mem
 *
pRec
, int 
bTryForInt
)

46648 double 
rValue
;

46649 
i64
 
iValue
;

46650 
u8
 
enc
 = 
pRec
->enc;

46652 if( 
	`sqlite3AtoF
(
pRec
->
z
, &
rValue
, pRec->
n
, 
enc
)==0 ) return;

46653 if( 0==
	`sqlite3Atoi64
(
pRec
->
z
, &
iValue
, pRec->
n
, 
enc
) )

46656 
pRec
->
u
.
i
 = 
iValue
;

46657 
pRec
->
flags
 |= 0x0004;

46659 
pRec
->
u
.
r
 = 
rValue
;

46660 
pRec
->
flags
 |= 0x0008;

46661 if( 
bTryForInt
 ) 
	`sqlite3VdbeIntegerAffinity
(
pRec
);

46663 
	}
}

46665 static void 
	$applyAffinity
(

46666 
Mem
 *
pRec
,

46667 char 
affinity
,

46668 
u8
 
enc


46672 if( 
affinity
>='C' )

46677 if( (
pRec
->
flags
 & 0x0004)==0 )

46680 if( (
pRec
->
flags
 & 0x0008)==0 )

46683 if( 
pRec
->
flags
 & 0x0002 ) 
	`applyNumericAffinity
(pRec,1);

46685 
	`sqlite3VdbeIntegerAffinity
(
pRec
);

46688 }else if( 
affinity
=='B' )

46695 if( 0==(
pRec
->
flags
&0x0002) && (pRec->flags&(0x0008|0x0004)) )

46698 
	`sqlite3VdbeMemStringify
(
pRec
, 
enc
, 1);

46700 
pRec
->
flags
 &= ~(0x0008|0x0004);

46702 
	}
}

46710 int 
	$sqlite3_value_numeric_type
(
sqlite3_value
 *
pVal
)

46713 int 
eType
 = 
	`sqlite3_value_type
(
pVal
);

46714 if( 
eType
==3 )

46717 
Mem
 *
pMem
 = (Mem*)
pVal
;

46718 
	`applyNumericAffinity
(
pMem
, 0);

46719 
eType
 = 
	`sqlite3_value_type
(
pVal
);

46721 return 
eType
;

46722 
	}
}

46728 static void 
	$sqlite3ValueApplyAffinity
(

46729 
sqlite3_value
 *
pVal
,

46730 
u8
 
affinity
,

46731 
u8
 
enc


46735 
	`applyAffinity
((
Mem
 *)
pVal
, 
affinity
, 
enc
);

46736 
	}
}

46744 static 
u16
 
__attribute__
((
noinline
)) 
	$computeNumericType
(
Mem
 *
pMem
)

46749 if( 
	`sqlite3AtoF
(
pMem
->
z
, &pMem->
u
.
r
, pMem->
n
, pMem->
enc
)==0 )

46754 if( 
	`sqlite3Atoi64
(
pMem
->
z
, &pMem->
u
.
i
, pMem->
n
, pMem->
enc
)==0 )

46760 
	}
}

46762 static 
u16
 
	$numericType
(
Mem
 *
pMem
)

46765 if( 
pMem
->
flags
 & (0x0004|0x0008) )

46768 return 
pMem
->
flags
 & (0x0004|0x0008);

46770 if( 
pMem
->
flags
 & (0x0002|0x0010) )

46773 return 
	`computeNumericType
(
pMem
);

46776 
	}
}

46778 static 
__attribute__
((
noinline
)) 
Mem
 *
	$out2PrereleaseWithClear
(
Mem
 *
pOut
)

46781 
	`sqlite3VdbeMemSetNull
(
pOut
);

46782 
pOut
->
flags
 = 0x0004;

46783 return 
pOut
;

46784 
	}
}

46785 static 
Mem
 *
	$out2Prerelease
(
Vdbe
 *
p
, 
VdbeOp
 *
pOp
)

46788 
Mem
 *
pOut
;

46791 
pOut
 = &
p
->
aMem
[
pOp
->
p2
];

46793 if( (((
pOut
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) )

46796 return 
	`out2PrereleaseWithClear
(
pOut
);

46798 
pOut
->
flags
 = 0x0004;

46799 return 
pOut
;

46801 
	}
}

46808 static int 
	$sqlite3VdbeExec
(

46809 
Vdbe
 *
p


46813 
Op
 *
aOp
 = 
p
->aOp;

46814 
Op
 *
pOp
 = 
aOp
;

46821 int 
rc
 = 0;

46822 
sqlite3
 *
db
 = 
p
->db;

46823 
u8
 
resetSchemaOnFault
 = 0;

46824 
u8
 
encoding
 = ((
db
)->
enc
);

46825 int 
iCompare
 = 0;

46826 unsigned 
nVmStep
 = 0;

46828 unsigned 
nProgressLimit
 = 0;

46830 
Mem
 *
aMem
 = 
p
->aMem;

46831 
Mem
 *
pIn1
 = 0;

46832 
Mem
 *
pIn2
 = 0;

46833 
Mem
 *
pIn3
 = 0;

46834 
Mem
 *
pOut
 = 0;

46835 int *
aPermute
 = 0;

46836 
i64
 
lastRowid
 = 
db
->lastRowid;

46843 
	`sqlite3VdbeEnter
(
p
);

46844 if( 
p
->
rc
==7 )

46849 goto 
no_mem
;

46853 
p
->
rc
 = 0;

46854 
p
->
iCurrentTime
 = 0;

46856 
p
->
pResultSet
 = 0;

46857 
db
->
busyHandler
.
nBusy
 = 0;

46858 if( 
db
->
u1
.
isInterrupted
 ) goto 
abort_due_to_interrupt
;

46861 if( 
db
->
xProgress
 )

46864 
u32
 
iPrior
 = 
p
->
aCounter
[4];

46866 
nProgressLimit
 = 
db
->
nProgressOps
 - (
iPrior
 % db->nProgressOps);

46869 for(
pOp
=&
aOp
[
p
->
pc
]; 1; pOp++)

46880 
nVmStep
++;

46882 switch( 
pOp
->
opcode
 )

46887 
jump_to_p2_and_check_for_interrupt
:

46888 
pOp
 = &
aOp
[pOp->
p2
 - 1];

46890 
check_for_interrupt
:

46891 if( 
db
->
u1
.
isInterrupted
 ) goto 
abort_due_to_interrupt
;

46899 if( 
db
->
xProgress
!=0 && 
nVmStep
>=
nProgressLimit
 )

46903 
nProgressLimit
 = 
nVmStep
 + 
db
->
nProgressOps
 - (nVmStep%db->nProgressOps);

46904 if( 
db
->
	`xProgress
(db->
pProgressArg
) )

46907 
rc
 = 9;

46908 goto 
abort_due_to_error
;

46923 
pIn1
 = &
aMem
[
pOp
->
p1
];

46926 
pIn1
->
flags
 = 0x0004;

46927 
pIn1
->
u
.
i
 = (int)(
pOp
-
aOp
);

46932 
jump_to_p2
:

46933 
pOp
 = &
aOp
[pOp->
p2
 - 1];

46943 
pIn1
 = &
aMem
[
pOp
->
p1
];

46945 
pOp
 = &
aOp
[
pIn1
->
u
.
i
];

46946 
pIn1
->
flags
 = 0x0080;

46954 
pOut
 = &
aMem
[
pOp
->
p1
];

46956 
pOut
->
u
.
i
 = 
pOp
->
p3
 - 1;

46957 
pOut
->
flags
 = 0x0004;

46958 if( 
pOp
->
p2
 ) goto 
jump_to_p2
;

46963 
VdbeOp
 *
pCaller
;

46964 
pIn1
 = &
aMem
[
pOp
->
p1
];

46967 
pCaller
 = &
aOp
[
pIn1
->
u
.
i
];

46970 
pOp
 = &
aOp
[
pCaller
->
p2
 - 1];

46971 
pIn1
->
flags
 = 0x0080;

46976 int 
pcDest
;

46977 
pIn1
 = &
aMem
[
pOp
->
p1
];

46979 
pIn1
->
flags
 = 0x0004;

46980 
pcDest
 = (int)
pIn1
->
u
.
i
;

46981 
pIn1
->
u
.
i
 = (int)(
pOp
 - 
aOp
);

46983 
pOp
 = &
aOp
[
pcDest
];

46988 
pIn3
 = &
aMem
[
pOp
->
p3
];

46989 if( (
pIn3
->
flags
 & 0x0001)==0 ) break;

46994 const char *
zType
;

46995 const char *
zLogFmt
;

46996 
VdbeFrame
 *
pFrame
;

46997 int 
pcx
;

46999 
pcx
 = (int)(
pOp
 - 
aOp
);

47000 if( 
pOp
->
p1
==0 && 
p
->
pFrame
 )

47004 
pFrame
 = 
p
->pFrame;

47005 
p
->
pFrame
 = pFrame->
pParent
;

47006 
p
->
nFrame
--;

47007 
	`sqlite3VdbeSetChanges
(
db
, 
p
->
nChange
);

47008 
pcx
 = 
	`sqlite3VdbeFrameRestore
(
pFrame
);

47009 
lastRowid
 = 
db
->lastRowid;

47010 if( 
pOp
->
p2
==4 )

47018 
pcx
 = 
p
->
aOp
[pcx].
p2
-1;

47020 
aOp
 = 
p
->aOp;

47021 
aMem
 = 
p
->aMem;

47022 
pOp
 = &
aOp
[
pcx
];

47025 
p
->
rc
 = 
pOp
->
p1
;

47026 
p
->
errorAction
 = (
u8
)
pOp
->
p2
;

47027 
p
->
pc
 = 
pcx
;

47028 if( 
p
->
rc
 )

47031 if( 
pOp
->
p5
 )

47034 static const char * const 
azType
[] = { "NOT NULL", "UNIQUE", "CHECK",

47041 
zType
 = 
azType
[
pOp
->
p5
-1];

47043 
zType
 = 0;

47046 
zLogFmt
 = "abort at %d in [%s]: %s";

47047 if( 
zType
 && 
pOp
->
p4
.
z
 )

47050 
	`sqlite3VdbeError
(
p
, "%s constraint failed: %s", 
zType
, 
pOp
->
p4
.
z
);

47051 }else if( 
pOp
->
p4
.
z
 )

47054 
	`sqlite3VdbeError
(
p
, "%s", 
pOp
->
p4
.
z
);

47056 
	`sqlite3VdbeError
(
p
, "%s constraint failed", 
zType
);

47058 
	`sqlite3_log
(
pOp
->
p1
, 
zLogFmt
, 
pcx
, 
p
->
zSql
, p->
zErrMsg
);

47060 
rc
 = 
	`sqlite3VdbeHalt
(
p
);

47062 if( 
rc
==5 )

47065 
p
->
rc
 = rc = 5;

47069 
rc
 = 
p
->rc ? 1 : 101;

47071 goto 
vdbe_return
;

47080 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47081 
pOut
->
u
.
i
 = 
pOp
->
p1
;

47092 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47094 
pOut
->
u
.
i
 = *
pOp
->
p4
.
pI64
;

47099 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47100 
pOut
->
flags
 = 0x0008;

47102 
pOut
->
u
.
r
 = *
pOp
->
p4
.
pReal
;

47108 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47109 
pOp
->
opcode
 = 24;

47110 
pOp
->
p1
 = 
	`sqlite3Strlen30
(pOp->
p4
.
z
);

47113 if( 
encoding
!=1 )

47116 
rc
 = 
	`sqlite3VdbeMemSetStr
(
pOut
, 
pOp
->
p4
.
z
, -1, 1, ((
sqlite3_destructor_type
)0));

47117 if( 
rc
 )

47121 goto 
too_big
;

47123 if( 0!=
	`sqlite3VdbeChangeEncoding
(
pOut
, 
encoding
) ) goto 
no_mem
;

47126 
pOut
->
szMalloc
 = 0;

47127 
pOut
->
flags
 |= 0x0800;

47128 if( 
pOp
->
p4type
==(-1) )

47131 
	`sqlite3DbFree
(
db
, 
pOp
->
p4
.
z
);

47133 
pOp
->
p4type
 = (-1);

47134 
pOp
->
p4
.
z
 = 
pOut
->z;

47135 
pOp
->
p1
 = 
pOut
->
n
;

47138 if( 
pOp
->
p1
>
db
->
aLimit
[0] )

47141 goto 
too_big
;

47148 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47149 
pOut
->
flags
 = 0x0002|0x0800|0x0200;

47150 
pOut
->
z
 = 
pOp
->
p4
.z;

47151 
pOut
->
n
 = 
pOp
->
p1
;

47152 
pOut
->
enc
 = 
encoding
;

47155 if( 
pOp
->
p5
 )

47160 
pIn3
 = &
aMem
[
pOp
->
p3
];

47162 if( 
pIn3
->
u
.
i
 ) 
pOut
->
flags
 = 0x0010|0x0800|0x0200;

47169 int 
cnt
;

47170 
u16
 
nullFlag
;

47171 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47172 
cnt
 = 
pOp
->
p3
-pOp->
p2
;

47174 
pOut
->
flags
 = 
nullFlag
 = 
pOp
->
p1
 ? (0x0001|0x0100) : 0x0001;

47175 while( 
cnt
>0 )

47178 
pOut
++;

47180 
	`sqlite3VdbeMemSetNull
(
pOut
);

47181 
pOut
->
flags
 = 
nullFlag
;

47182 
cnt
--;

47189 
pOut
 = &
aMem
[
pOp
->
p1
];

47190 
pOut
->
flags
 = (pOut->flags|0x0001)&~0x0080;

47202 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47203 
	`sqlite3VdbeMemSetStr
(
pOut
, 
pOp
->
p4
.
z
, pOp->
p1
, 0, 0);

47204 
pOut
->
enc
 = 
encoding
;

47210 
Mem
 *
pVar
;

47214 
pVar
 = &
p
->
aVar
[
pOp
->
p1
 - 1];

47215 if( 
	`sqlite3VdbeMemTooBig
(
pVar
) )

47218 goto 
too_big
;

47220 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

47221 
	`sqlite3VdbeMemShallowCopy
(
pOut
, 
pVar
, 0x0800);

47227 int 
n
;

47228 int 
p1
;

47229 int 
p2
;

47231 
n
 = 
pOp
->
p3
;

47232 
p1
 = 
pOp
->p1;

47233 
p2
 = 
pOp
->p2;

47237 
pIn1
 = &
aMem
[
p1
];

47238 
pOut
 = &
aMem
[
p2
];

47244 
	`sqlite3VdbeMemMove
(
pOut
, 
pIn1
);

47250 if( ((
pOut
)->
flags
&0x1000)!=0 && 
	`sqlite3VdbeMemMakeWriteable
(pOut) )

47252 goto 
no_mem
;};

47254 
pIn1
++;

47255 
pOut
++;

47256 }while( --
n
 );

47261 int 
n
;

47263 
n
 = 
pOp
->
p3
;

47264 
pIn1
 = &
aMem
[
pOp
->
p1
];

47265 
pOut
 = &
aMem
[
pOp
->
p2
];

47270 
	`sqlite3VdbeMemShallowCopy
(
pOut
, 
pIn1
, 0x1000);

47271 if( ((
pOut
)->
flags
&0x1000)!=0 && 
	`sqlite3VdbeMemMakeWriteable
(pOut) )

47273 goto 
no_mem
;};

47278 if( (
n
--)==0 ) break;

47279 
pOut
++;

47280 
pIn1
++;

47286 
pIn1
 = &
aMem
[
pOp
->
p1
];

47287 
pOut
 = &
aMem
[
pOp
->
p2
];

47289 
	`sqlite3VdbeMemShallowCopy
(
pOut
, 
pIn1
, 0x1000);

47297 
pIn1
 = &
aMem
[
pOp
->
p1
];

47299 
pOut
 = &
aMem
[
pOp
->
p2
];

47300 
	`sqlite3VdbeMemSetInt64
(
pOut
, 
pIn1
->
u
.
i
);

47305 
Mem
 *
pMem
;

47306 int 
i
;

47314 if( 
db
->
xProgress
!=0

47315 && 
nVmStep
>=
nProgressLimit


47316 && 
db
->
	`xProgress
(db->
pProgressArg
)!=0

47320 
rc
 = 9;

47321 goto 
abort_due_to_error
;

47328 if( 0!=(
rc
 = 
	`sqlite3VdbeCheckFk
(
p
, 0)) )

47333 goto 
abort_due_to_error
;

47337 
rc
 = 
	`sqlite3VdbeCloseStatement
(
p
, 1);

47341 
p
->
cacheCtr
 = (p->cacheCtr + 2)|1;

47347 
pMem
 = 
p
->
pResultSet
 = &
aMem
[
pOp
->
p1
];

47348 for(
i
=0; i<
pOp
->
p2
; i++)

47352 if( ((&
pMem
[
i
])->
flags
&0x1000)!=0 && 
	`sqlite3VdbeMemMakeWriteable
(&pMem[i]) )

47354 goto 
no_mem
;};

47357 
	`sqlite3VdbeMemNulTerminate
(&
pMem
[
i
]);

47360 if( 
db
->
mallocFailed
 ) goto 
no_mem
;

47364 
p
->
pc
 = (int)(
pOp
 - 
aOp
) + 1;

47365 
rc
 = 100;

47366 goto 
vdbe_return
;

47370 
i64
 
nByte
;

47372 
pIn1
 = &
aMem
[
pOp
->
p1
];

47373 
pIn2
 = &
aMem
[
pOp
->
p2
];

47374 
pOut
 = &
aMem
[
pOp
->
p3
];

47376 if( (
pIn1
->
flags
 | 
pIn2
->flags) & 0x0001 )

47379 
	`sqlite3VdbeMemSetNull
(
pOut
);

47382 if( (((
pIn1
)->
flags
&0x4000)?
	`sqlite3VdbeMemExpandBlob
(pIn1):0) || (((
pIn2
)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn2):0) ) goto 
no_mem
;

47383 if(((
pIn1
)->
flags
&(0x0002|0x0010))==0 && 
	`sqlite3VdbeMemStringify
(pIn1,
encoding
,0)) { goto 
no_mem
; };

47384 if(((
pIn2
)->
flags
&(0x0002|0x0010))==0 && 
	`sqlite3VdbeMemStringify
(pIn2,
encoding
,0)) { goto 
no_mem
; };

47385 
nByte
 = 
pIn1
->
n
 + 
pIn2
->n;

47386 if( 
nByte
>
db
->
aLimit
[0] )

47389 goto 
too_big
;

47391 if( 
	`sqlite3VdbeMemGrow
(
pOut
, (int)
nByte
+2, pOut==
pIn2
) )

47394 goto 
no_mem
;

47396 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0002);

47397 if( 
pOut
!=
pIn2
 )

47400 
	`memcpy
(
pOut
->
z
, 
pIn2
->z, pIn2->
n
);

47402 
	`memcpy
(&
pOut
->
z
[
pIn2
->
n
], 
pIn1
->z, pIn1->n);

47403 
pOut
->
z
[
nByte
]=0;

47404 
pOut
->
z
[
nByte
+1] = 0;

47405 
pOut
->
flags
 |= 0x0200;

47406 
pOut
->
n
 = (int)
nByte
;

47407 
pOut
->
enc
 = 
encoding
;

47417 char 
bIntint
;

47418 
u16
 
flags
;

47419 
u16
 
type1
;

47420 
u16
 
type2
;

47421 
i64
 
iA
;

47422 
i64
 
iB
;

47423 double 
rA
;

47424 double 
rB
;

47426 
pIn1
 = &
aMem
[
pOp
->
p1
];

47427 
type1
 = 
	`numericType
(
pIn1
);

47428 
pIn2
 = &
aMem
[
pOp
->
p2
];

47429 
type2
 = 
	`numericType
(
pIn2
);

47430 
pOut
 = &
aMem
[
pOp
->
p3
];

47431 
flags
 = 
pIn1
->flags | 
pIn2
->flags;

47432 if( (
flags
 & 0x0001)!=0 ) goto 
arithmetic_result_is_null
;

47433 if( (
type1
 & 
type2
 & 0x0004)!=0 )

47436 
iA
 = 
pIn1
->
u
.
i
;

47437 
iB
 = 
pIn2
->
u
.
i
;

47438 
bIntint
 = 1;

47439 switch( 
pOp
->
opcode
 )

47442 case 89: if( 
	`sqlite3AddInt64
(&
iB
,
iA
) ) goto 
fp_math
; break;

47443 case 90: if( 
	`sqlite3SubInt64
(&
iB
,
iA
) ) goto 
fp_math
; break;

47444 case 91: if( 
	`sqlite3MulInt64
(&
iB
,
iA
) ) goto 
fp_math
; break;

47446 if( 
iA
==0 ) goto 
arithmetic_result_is_null
;

47447 if( 
iA
==-1 && 
iB
==(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) goto 
fp_math
;

47448 
iB
 /= 
iA
;

47452 if( 
iA
==0 ) goto 
arithmetic_result_is_null
;

47453 if( 
iA
==-1 ) iA = 1;

47454 
iB
 %= 
iA
;

47458 
pOut
->
u
.
i
 = 
iB
;

47459 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0004);

47461 
bIntint
 = 0;

47462 
fp_math
:

47463 
rA
 = 
	`sqlite3VdbeRealValue
(
pIn1
);

47464 
rB
 = 
	`sqlite3VdbeRealValue
(
pIn2
);

47465 switch( 
pOp
->
opcode
 )

47468 case 89: 
rB
 += 
rA
; break;

47469 case 90: 
rB
 -= 
rA
; break;

47470 case 91: 
rB
 *= 
rA
; break;

47473 if( 
rA
==(double)0 ) goto 
arithmetic_result_is_null
;

47474 
rB
 /= 
rA
;

47478 
iA
 = (
i64
)
rA
;

47479 
iB
 = (
i64
)
rB
;

47480 if( 
iA
==0 ) goto 
arithmetic_result_is_null
;

47481 if( 
iA
==-1 ) iA = 1;

47482 
rB
 = (double)(
iB
 % 
iA
);

47490 if( 
	`sqlite3IsNaN
(
rB
) )

47493 goto 
arithmetic_result_is_null
;

47495 
pOut
->
u
.
r
 = 
rB
;

47496 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0008);

47497 if( ((
type1
|
type2
)&0x0008)==0 && !
bIntint
 )

47500 
	`sqlite3VdbeIntegerAffinity
(
pOut
);

47506 
arithmetic_result_is_null
:

47507 
	`sqlite3VdbeMemSetNull
(
pOut
);

47513 if( 
pOp
->
p1
 )

47516 
	`sqlite3VdbeMemSetInt64
(&
aMem
[
pOp
->
p1
], 0);

47522 int 
n
;

47523 
sqlite3_context
 *
pCtx
;

47526 
n
 = 
pOp
->
p5
;

47530 
pCtx
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(*pCtx) + (
n
-1)*sizeof(
sqlite3_value
*));

47531 if( 
pCtx
==0 ) goto 
no_mem
;

47532 
pCtx
->
pOut
 = 0;

47533 
pCtx
->
pFunc
 = 
pOp
->
p4
.pFunc;

47534 
pCtx
->
iOp
 = (int)(
pOp
 - 
aOp
);

47535 
pCtx
->
pVdbe
 = 
p
;

47536 
pCtx
->
argc
 = 
n
;

47537 
pOp
->
p4type
 = (-20);

47538 
pOp
->
p4
.
pCtx
 = pCtx;

47539 
pOp
->
opcode
 = 36;

47543 int 
i
;

47544 
sqlite3_context
 *
pCtx
;

47547 
pCtx
 = 
pOp
->
p4
.pCtx;

47553 
pOut
 = &
aMem
[
pOp
->
p3
];

47554 if( 
pCtx
->
pOut
 != pOut )

47557 
pCtx
->
pOut
 = pOut;

47558 for(
i
=
pCtx
->
argc
-1; i>=0; i--) pCtx->
argv
[i] = &
aMem
[
pOp
->
p2
+i];

47568 ((
pCtx
->
pOut
)->
flags
 = ((pCtx->pOut)->flags&~(0x81ff|0x4000))|0x0001);

47569 
pCtx
->
fErrorOrAux
 = 0;

47570 
db
->
lastRowid
 = lastRowid;

47571 (*
pCtx
->
pFunc
->
xSFunc
)(pCtx, pCtx->
argc
, pCtx->
argv
);

47572 
lastRowid
 = 
db
->lastRowid;

47575 if( 
pCtx
->
fErrorOrAux
 )

47578 if( 
pCtx
->
isError
 )

47581 
	`sqlite3VdbeError
(
p
, "%s", 
	`sqlite3_value_text
(
pCtx
->
pOut
));

47582 
rc
 = 
pCtx
->
isError
;

47584 
	`sqlite3VdbeDeleteAuxData
(
db
, &
p
->
pAuxData
, 
pCtx
->
iOp
, 
pOp
->
p1
);

47585 if( 
rc
 ) goto 
abort_due_to_error
;

47589 if( 
pOut
->
flags
 & (0x0002|0x0010) )

47592 
	`sqlite3VdbeChangeEncoding
(
pCtx
->
pOut
, 
encoding
);

47593 if( 
	`sqlite3VdbeMemTooBig
(
pCtx
->
pOut
) ) goto 
too_big
;

47605 
i64
 
iA
;

47606 
u64
 
uA
;

47607 
i64
 
iB
;

47608 
u8
 
op
;

47610 
pIn1
 = &
aMem
[
pOp
->
p1
];

47611 
pIn2
 = &
aMem
[
pOp
->
p2
];

47612 
pOut
 = &
aMem
[
pOp
->
p3
];

47613 if( (
pIn1
->
flags
 | 
pIn2
->flags) & 0x0001 )

47616 
	`sqlite3VdbeMemSetNull
(
pOut
);

47619 
iA
 = 
	`sqlite3VdbeIntValue
(
pIn2
);

47620 
iB
 = 
	`sqlite3VdbeIntValue
(
pIn1
);

47621 
op
 = 
pOp
->
opcode
;

47622 if( 
op
==85 )

47625 
iA
 &= 
iB
;

47626 }else if( 
op
==86 )

47629 
iA
 |= 
iB
;

47630 }else if( 
iB
!=0 )

47636 if( 
iB
<0 )

47640 
op
 = 2*87 + 1 - op;

47641 
iB
 = iB>(-64) ? -iB : 64;

47644 if( 
iB
>=64 )

47647 
iA
 = (iA>=0 || 
op
==87) ? 0 : -1;

47649 
	`memcpy
(&
uA
, &
iA
, sizeof(uA));

47650 if( 
op
==87 )

47653 
uA
 <<= 
iB
;

47655 
uA
 >>= 
iB
;

47657 if( 
iA
<0 ) 
uA
 |= ((((
u64
)0xffffffff)<<32)|0xffffffff) << (64-
iB
);

47659 
	`memcpy
(&
iA
, &
uA
, sizeof(iA));

47662 
pOut
->
u
.
i
 = 
iA
;

47663 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0004);

47668 
pIn1
 = &
aMem
[
pOp
->
p1
];

47670 
	`sqlite3VdbeMemIntegerify
(
pIn1
);

47671 
pIn1
->
u
.
i
 += 
pOp
->
p2
;

47676 
pIn1
 = &
aMem
[
pOp
->
p1
];

47677 if( (
pIn1
->
flags
 & 0x0004)==0 )

47680 
	`applyAffinity
(
pIn1
, 'C', 
encoding
);

47682 if( (
pIn1
->
flags
 & 0x0004)==0 )

47685 if( 
pOp
->
p2
==0 )

47688 
rc
 = 20;

47689 goto 
abort_due_to_error
;

47691 goto 
jump_to_p2
;

47695 ((
pIn1
)->
flags
 = ((pIn1)->flags&~(0x81ff|0x4000))|0x0004);

47700 
pIn1
 = &
aMem
[
pOp
->
p1
];

47701 if( 
pIn1
->
flags
 & 0x0004 )

47704 
	`sqlite3VdbeMemRealify
(
pIn1
);

47716 
pIn1
 = &
aMem
[
pOp
->
p1
];

47718 
rc
 = (((
pIn1
)->
flags
&0x4000)?
	`sqlite3VdbeMemExpandBlob
(pIn1):0);

47719 
	`sqlite3VdbeMemCast
(
pIn1
, 
pOp
->
p2
, 
encoding
);

47721 if( 
rc
 ) goto 
abort_due_to_error
;

47731 int 
res
;

47732 char 
affinity
;

47733 
u16
 
flags1
;

47734 
u16
 
flags3
;

47736 
pIn1
 = &
aMem
[
pOp
->
p1
];

47737 
pIn3
 = &
aMem
[
pOp
->
p3
];

47738 
flags1
 = 
pIn1
->
flags
;

47739 
flags3
 = 
pIn3
->
flags
;

47740 if( (
flags1
 | 
flags3
)&0x0001 )

47744 if( 
pOp
->
p5
 & 0x80 )

47754 if( (
flags1
&0x0001)!=0

47755 && (
flags3
&0x0001)!=0

47756 && (
flags3
&0x0100)==0

47760 
res
 = 0;

47762 
res
 = 1;

47769 if( 
pOp
->
p5
 & 0x20 )

47772 
pOut
 = &
aMem
[
pOp
->
p2
];

47774 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0001);

47778 if( 
pOp
->
p5
 & 0x10 )

47781 goto 
jump_to_p2
;

47788 
affinity
 = 
pOp
->
p5
 & 0x47;

47789 if( 
affinity
>='C' )

47792 if( (
flags1
 & (0x0004|0x0008|0x0002))==0x0002 )

47795 
	`applyNumericAffinity
(
pIn1
,0);

47797 if( (
flags3
 & (0x0004|0x0008|0x0002))==0x0002 )

47800 
	`applyNumericAffinity
(
pIn3
,0);

47802 }else if( 
affinity
=='B' )

47805 if( (
flags1
 & 0x0002)==0 && (flags1 & (0x0004|0x0008))!=0 )

47810 
	`sqlite3VdbeMemStringify
(
pIn1
, 
encoding
, 1);

47812 
flags1
 = (
pIn1
->
flags
 & ~0x81ff) | (flags1 & 0x81ff);

47814 if( (
flags3
 & 0x0002)==0 && (flags3 & (0x0004|0x0008))!=0 )

47819 
	`sqlite3VdbeMemStringify
(
pIn3
, 
encoding
, 1);

47821 
flags3
 = (
pIn3
->
flags
 & ~0x81ff) | (flags3 & 0x81ff);

47825 if( 
flags1
 & 0x4000 )

47828 
	`sqlite3VdbeMemExpandBlob
(
pIn1
);

47829 
flags1
 &= ~0x4000;

47831 if( 
flags3
 & 0x4000 )

47834 
	`sqlite3VdbeMemExpandBlob
(
pIn3
);

47835 
flags3
 &= ~0x4000;

47837 
res
 = 
	`sqlite3MemCompare
(
pIn3
, 
pIn1
, 
pOp
->
p4
.
pColl
);

47839 switch( 
pOp
->
opcode
 )

47842 case 79: 
res
 = res==0; break;

47843 case 78: 
res
 = res!=0; break;

47844 case 82: 
res
 = res<0; break;

47845 case 81: 
res
 = res<=0; break;

47846 case 80: 
res
 = res>0; break;

47847 default: 
res
 = res>=0; break;

47852 
pIn1
->
flags
 = 
flags1
;

47854 
pIn3
->
flags
 = 
flags3
;

47856 if( 
pOp
->
p5
 & 0x20 )

47859 
pOut
 = &
aMem
[
pOp
->
p2
];

47861 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0004);

47862 
pOut
->
u
.
i
 = 
res
;

47866 if( 
res
 )

47869 goto 
jump_to_p2
;

47878 
aPermute
 = 
pOp
->
p4
.
ai
 + 1;

47883 int 
n
;

47884 int 
i
;

47885 int 
p1
;

47886 int 
p2
;

47887 const 
KeyInfo
 *
pKeyInfo
;

47888 int 
idx
;

47889 
CollSeq
 *
pColl
;

47890 int 
bRev
;

47892 if( (
pOp
->
p5
 & 0x01)==0 ) 
aPermute
 = 0;

47893 
n
 = 
pOp
->
p3
;

47894 
pKeyInfo
 = 
pOp
->
p4
.pKeyInfo;

47897 
p1
 = 
pOp
->p1;

47898 
p2
 = 
pOp
->p2;

47900 for(
i
=0; i<
n
; i++)

47903 
idx
 = 
aPermute
 ? aPermute[
i
] : i;

47909 
pColl
 = 
pKeyInfo
->
aColl
[
i
];

47910 
bRev
 = 
pKeyInfo
->
aSortOrder
[
i
];

47911 
iCompare
 = 
	`sqlite3MemCompare
(&
aMem
[
p1
+
idx
], &aMem[
p2
+idx], 
pColl
);

47912 if( 
iCompare
 )

47915 if( 
bRev
 ) 
iCompare
 = -iCompare;

47919 
aPermute
 = 0;

47930 if( 
iCompare
<0 )

47933 ; 
pOp
 = &
aOp
[pOp->
p1
 - 1];

47934 }else if( 
iCompare
==0 )

47937 ; 
pOp
 = &
aOp
[pOp->
p2
 - 1];

47939 ; 
pOp
 = &
aOp
[pOp->
p3
 - 1];

47946 int 
v1
;

47947 int 
v2
;

47949 
pIn1
 = &
aMem
[
pOp
->
p1
];

47950 if( 
pIn1
->
flags
 & 0x0001 )

47953 
v1
 = 2;

47955 
v1
 = 
	`sqlite3VdbeIntValue
(
pIn1
)!=0;

47957 
pIn2
 = &
aMem
[
pOp
->
p2
];

47958 if( 
pIn2
->
flags
 & 0x0001 )

47961 
v2
 = 2;

47963 
v2
 = 
	`sqlite3VdbeIntValue
(
pIn2
)!=0;

47965 if( 
pOp
->
opcode
==72 )

47968 static const unsigned char 
and_logic
[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };

47969 
v1
 = 
and_logic
[v1*3+
v2
];

47971 static const unsigned char 
or_logic
[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };

47972 
v1
 = 
or_logic
[v1*3+
v2
];

47974 
pOut
 = &
aMem
[
pOp
->
p3
];

47975 if( 
v1
==2 )

47978 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0001);

47980 
pOut
->
u
.
i
 = 
v1
;

47981 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0004);

47987 
pIn1
 = &
aMem
[
pOp
->
p1
];

47988 
pOut
 = &
aMem
[
pOp
->
p2
];

47989 
	`sqlite3VdbeMemSetNull
(
pOut
);

47990 if( (
pIn1
->
flags
 & 0x0001)==0 )

47993 
pOut
->
flags
 = 0x0004;

47994 
pOut
->
u
.
i
 = !
	`sqlite3VdbeIntValue
(
pIn1
);

48000 
pIn1
 = &
aMem
[
pOp
->
p1
];

48001 
pOut
 = &
aMem
[
pOp
->
p2
];

48002 
	`sqlite3VdbeMemSetNull
(
pOut
);

48003 if( (
pIn1
->
flags
 & 0x0001)==0 )

48006 
pOut
->
flags
 = 0x0004;

48007 
pOut
->
u
.
i
 = ~
	`sqlite3VdbeIntValue
(
pIn1
);

48015 if( 
p
->
aOnceFlag
[
pOp
->
p1
] )

48018 goto 
jump_to_p2
;

48020 
p
->
aOnceFlag
[
pOp
->
p1
] = 1;

48027 int 
c
;

48028 
pIn1
 = &
aMem
[
pOp
->
p1
];

48029 if( 
pIn1
->
flags
 & 0x0001 )

48032 
c
 = 
pOp
->
p3
;

48037 
c
 = 
	`sqlite3VdbeRealValue
(
pIn1
)!=0.0;

48039 if( 
pOp
->
opcode
==46 ) 
c
 = !c;

48042 if( 
c
 )

48045 goto 
jump_to_p2
;

48056 
pIn1
 = &
aMem
[
pOp
->
p1
];

48058 if( (
pIn1
->
flags
 & 0x0001)!=0 )

48061 goto 
jump_to_p2
;

48072 
pIn1
 = &
aMem
[
pOp
->
p1
];

48074 if( (
pIn1
->
flags
 & 0x0001)==0 )

48077 goto 
jump_to_p2
;

48083 
i64
 
payloadSize64
;

48084 int 
p2
;

48085 
VdbeCursor
 *
pC
;

48086 
BtCursor
 *
pCrsr
;

48087 
u32
 *
aOffset
;

48088 int 
len
;

48089 int 
i
;

48090 
Mem
 *
pDest
;

48091 
Mem
 
sMem
;

48092 const 
u8
 *
zData
;

48093 const 
u8
 *
zHdr
;

48094 const 
u8
 *
zEndHdr
;

48095 
u32
 
offset
;

48096 
u64
 
offset64
;

48097 
u32
 
avail
;

48098 
u32
 
t
;

48099 
Mem
 *
pReg
;

48101 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

48102 
p2
 = 
pOp
->p2;

48105 
rc
 = 
	`sqlite3VdbeCursorMoveto
(&
pC
, &
p2
);

48108 
pDest
 = &
aMem
[
pOp
->
p3
];

48113 
aOffset
 = 
pC
->aOffset;

48117 
pCrsr
 = 
pC
->
uc
.
pCursor
;

48119 if( 
rc
 ) goto 
abort_due_to_error
;

48120 if( 
pC
->
cacheStatus
!=
p
->
cacheCtr
 )

48123 if( 
pC
->
nullRow
 )

48126 if( 
pC
->
eCurType
==3 )

48130 
pReg
 = &
aMem
[
pC
->
uc
.
pseudoTableReg
];

48133 
pC
->
payloadSize
 = pC->
szRow
 = 
avail
 = 
pReg
->
n
;

48134 
pC
->
aRow
 = (
u8
*)
pReg
->
z
;

48136 
	`sqlite3VdbeMemSetNull
(
pDest
);

48137 goto 
op_column_out
;

48142 if( 
pC
->
isTable
==0 )

48146 
	`sqlite3BtreeKeySize
(
pCrsr
, &
payloadSize64
);

48152 
pC
->
aRow
 = 
	`sqlite3BtreeKeyFetch
(
pCrsr
, &
avail
);

48153 
pC
->
payloadSize
 = (
u32
)
payloadSize64
;

48156 
	`sqlite3BtreeDataSize
(
pCrsr
, &
pC
->
payloadSize
);

48158 
pC
->
aRow
 = 
	`sqlite3BtreeDataFetch
(
pCrsr
, &
avail
);

48161 if( 
pC
->
payloadSize
 <= (
u32
)
avail
 )

48164 
pC
->
szRow
 = pC->
payloadSize
;

48165 }else if( 
pC
->
payloadSize
 > (
u32
)
db
->
aLimit
[0] )

48168 goto 
too_big
;

48170 
pC
->
szRow
 = 
avail
;

48173 
pC
->
cacheStatus
 = 
p
->
cacheCtr
;

48174 
pC
->
iHdrOffset
 = (
u8
)((*(pC->
aRow
)<(u8)0x80)?((
offset
)=(
u32
)*(pC->aRow)),1:
	`sqlite3GetVarint32
((pC->aRow),(u32 *)&(offset)));

48175 
pC
->
nHdrParsed
 = 0;

48176 
aOffset
[0] = 
offset
;

48179 if( 
avail
<
offset
 )

48186 
pC
->
aRow
 = 0;

48187 
pC
->
szRow
 = 0;

48189 if( 
offset
 > 98307 || offset > 
pC
->
payloadSize
 )

48192 
rc
 = 
	`sqlite3CorruptError
(76949);

48193 goto 
abort_due_to_error
;

48202 goto 
op_column_read_header
;

48208 if( 
pC
->
nHdrParsed
<=
p2
 )

48214 
op_column_read_header
:

48215 if( 
pC
->
iHdrOffset
<
aOffset
[0] )

48219 if( 
pC
->
aRow
==0 )

48222 
	`memset
(&
sMem
, 0, sizeof(sMem));

48223 
rc
 = 
	`sqlite3VdbeMemFromBtree
(
pCrsr
, 0, 
aOffset
[0], !
pC
->
isTable
, &
sMem
);

48224 if( 
rc
!=0 ) goto 
abort_due_to_error
;

48225 
zData
 = (
u8
*)
sMem
.
z
;

48227 
zData
 = 
pC
->
aRow
;

48231 
i
 = 
pC
->
nHdrParsed
;

48232 
offset64
 = 
aOffset
[
i
];

48233 
zHdr
 = 
zData
 + 
pC
->
iHdrOffset
;

48234 
zEndHdr
 = 
zData
 + 
aOffset
[0];

48237 if( (
t
 = 
zHdr
[0])<0x80 )

48240 
zHdr
++;

48241 
offset64
 += 
	`sqlite3VdbeOneByteSerialTypeLen
(
t
);

48243 
zHdr
 += 
	`sqlite3GetVarint32
(zHdr, &
t
);

48244 
offset64
 += 
	`sqlite3VdbeSerialTypeLen
(
t
);

48246 
pC
->
aType
[
i
++] = 
t
;

48247 
aOffset
[
i
] = (
u32
)(
offset64
 & 0xffffffff);

48248 }while( 
i
<=
p2
 && 
zHdr
<
zEndHdr
 );

48249 
pC
->
nHdrParsed
 = 
i
;

48250 
pC
->
iHdrOffset
 = (
u32
)(
zHdr
 - 
zData
);

48257 if( (
zHdr
>=
zEndHdr
 && (zHdr>zEndHdr || 
offset64
!=
pC
->
payloadSize
))

48258 || (
offset64
 > 
pC
->
payloadSize
)

48262 if( 
pC
->
aRow
==0 ) 
	`sqlite3VdbeMemRelease
(&
sMem
);

48263 
rc
 = 
	`sqlite3CorruptError
(77010);

48264 goto 
abort_due_to_error
;

48266 if( 
pC
->
aRow
==0 ) 
	`sqlite3VdbeMemRelease
(&
sMem
);

48269 
t
 = 0;

48276 if( 
pC
->
nHdrParsed
<=
p2
 )

48279 if( 
pOp
->
p4type
==(-8) )

48282 
	`sqlite3VdbeMemShallowCopy
(
pDest
, 
pOp
->
p4
.
pMem
, 0x0800);

48284 
	`sqlite3VdbeMemSetNull
(
pDest
);

48286 goto 
op_column_out
;

48289 
t
 = 
pC
->
aType
[
p2
];

48299 if( (((
pDest
)->
flags
&(0x2000|0x0400|0x0020|0x0040))!=0) ) 
	`sqlite3VdbeMemSetNull
(pDest);

48301 
pDest
->
enc
 = 
encoding
;

48302 if( 
pC
->
szRow
>=
aOffset
[
p2
+1] )

48307 
zData
 = 
pC
->
aRow
 + 
aOffset
[
p2
];

48308 if( 
t
<12 )

48311 
	`sqlite3VdbeSerialGet
(
zData
, 
t
, 
pDest
);

48317 static const 
u16
 
aFlag
[] = { 0x0010, 0x0002|0x0200 };

48318 
pDest
->
n
 = 
len
 = (
t
-12)/2;

48319 if( 
pDest
->
szMalloc
 < 
len
+2 )

48322 
pDest
->
flags
 = 0x0001;

48323 if( 
	`sqlite3VdbeMemGrow
(
pDest
, 
len
+2, 0) ) goto 
no_mem
;

48325 
pDest
->
z
 = pDest->
zMalloc
;

48327 
	`memcpy
(
pDest
->
z
, 
zData
, 
len
);

48328 
pDest
->
z
[
len
] = 0;

48329 
pDest
->
z
[
len
+1] = 0;

48330 
pDest
->
flags
 = 
aFlag
[
t
&1];

48334 if( ((
pOp
->
p5
 & (0x40|0x80))!=0

48335 && ((
t
>=12 && (t&1)==0) || (
pOp
->
p5
 & 0x80)!=0))

48336 || (
len
 = 
	`sqlite3VdbeSerialTypeLen
(
t
))==0

48346 static 
u8
 
aZero
[8];

48347 
	`sqlite3VdbeSerialGet
(
aZero
, 
t
, 
pDest
);

48349 
rc
 = 
	`sqlite3VdbeMemFromBtree
(
pCrsr
, 
aOffset
[
p2
], 
len
, !
pC
->
isTable
,

48350 
pDest
);

48351 if( 
rc
!=0 ) goto 
abort_due_to_error
;

48352 
	`sqlite3VdbeSerialGet
((const 
u8
*)
pDest
->
z
, 
t
, pDest);

48353 
pDest
->
flags
 &= ~0x1000;

48357 
op_column_out
:

48364 const char *
zAffinity
;

48365 char 
cAff
;

48367 
zAffinity
 = 
pOp
->
p4
.
z
;

48370 
pIn1
 = &
aMem
[
pOp
->
p1
];

48371 while( (
cAff
 = *(
zAffinity
++))!=0 )

48376 
	`applyAffinity
(
pIn1
, 
cAff
, 
encoding
);

48377 
pIn1
++;

48383 
u8
 *
zNewRecord
;

48384 
Mem
 *
pRec
;

48385 
u64
 
nData
;

48386 int 
nHdr
;

48387 
i64
 
nByte
;

48388 
i64
 
nZero
;

48389 int 
nVarint
;

48390 
u32
 
serial_type
;

48391 
Mem
 *
pData0
;

48392 
Mem
 *
pLast
;

48393 int 
nField
;

48394 char *
zAffinity
;

48395 int 
file_format
;

48396 int 
i
;

48397 int 
j
;

48398 
u32
 
len
;

48400 
nData
 = 0;

48401 
nHdr
 = 0;

48402 
nZero
 = 0;

48403 
nField
 = 
pOp
->
p1
;

48404 
zAffinity
 = 
pOp
->
p4
.
z
;

48406 
pData0
 = &
aMem
[
nField
];

48407 
nField
 = 
pOp
->
p2
;

48408 
pLast
 = &
pData0
[
nField
-1];

48409 
file_format
 = 
p
->
minWriteFileFormat
;

48413 
pOut
 = &
aMem
[
pOp
->
p3
];

48419 if( 
zAffinity
 )

48422 
pRec
 = 
pData0
;

48424 
	`applyAffinity
(
pRec
++, *(
zAffinity
++), 
encoding
);

48426 }while( 
zAffinity
[0] );

48432 
pRec
 = 
pLast
;

48435 
pRec
->
uTemp
 = 
serial_type
 = 
	`sqlite3VdbeSerialType
(pRec, 
file_format
, &
len
);

48436 if( 
pRec
->
flags
 & 0x4000 )

48439 if( 
nData
 )

48442 if( 
	`sqlite3VdbeMemExpandBlob
(
pRec
) ) goto 
no_mem
;

48444 
nZero
 += 
pRec
->
u
.nZero;

48445 
len
 -= 
pRec
->
u
.
nZero
;

48448 
nData
 += 
len
;

48451 
nHdr
 += 
serial_type
<=127 ? 1 : 
	`sqlite3VarintLen
(serial_type);

48452 }while( (--
pRec
)>=
pData0
 );

48460 if( 
nHdr
<=126 )

48464 
nHdr
 += 1;

48467 
nVarint
 = 
	`sqlite3VarintLen
(
nHdr
);

48468 
nHdr
 += 
nVarint
;

48469 if( 
nVarint
<
	`sqlite3VarintLen
(
nHdr
) ) nHdr++;

48471 
nByte
 = 
nHdr
+
nData
;

48472 if( 
nByte
+
nZero
>
db
->
aLimit
[0] )

48475 goto 
too_big
;

48483 if( 
	`sqlite3VdbeMemClearAndResize
(
pOut
, (int)
nByte
) )

48486 goto 
no_mem
;

48488 
zNewRecord
 = (
u8
 *)
pOut
->
z
;

48491 
i
 = (
u8
)(((
u32
)(
nHdr
)<(u32)0x80)?(*(
zNewRecord
)=(unsigned char)(nHdr)),1: 
	`sqlite3PutVarint
((zNewRecord),(nHdr)));

48492 
j
 = 
nHdr
;

48494 
pRec
 = 
pData0
;

48496 
serial_type
 = 
pRec
->
uTemp
;

48499 
i
 += (
u8
)(((
u32
)(
serial_type
)<(u32)0x80)?(*(&
zNewRecord
[i])=(unsigned char)(serial_type)),1: 
	`sqlite3PutVarint
((&zNewRecord[i]),(serial_type)));

48502 
j
 += 
	`sqlite3VdbeSerialPut
(&
zNewRecord
[j], 
pRec
, 
serial_type
);

48503 }while( (++
pRec
)<=
pLast
 );

48508 
pOut
->
n
 = (int)
nByte
;

48509 
pOut
->
flags
 = 0x0010;

48510 if( 
nZero
 )

48513 
pOut
->
u
.
nZero
 = nZero;

48514 
pOut
->
flags
 |= 0x4000;

48516 
pOut
->
enc
 = 1;

48523 
i64
 
nEntry
;

48524 
BtCursor
 *
pCrsr
;

48527 
pCrsr
 = 
p
->
apCsr
[
pOp
->
p1
]->
uc
.
pCursor
;

48529 
nEntry
 = 0;

48530 
rc
 = 
	`sqlite3BtreeCount
(
pCrsr
, &
nEntry
);

48531 if( 
rc
 ) goto 
abort_due_to_error
;

48532 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

48533 
pOut
->
u
.
i
 = 
nEntry
;

48538 int 
p1
;

48539 char *
zName
;

48540 int 
nName
;

48541 
Savepoint
 *
pNew
;

48542 
Savepoint
 *
pSavepoint
;

48543 
Savepoint
 *
pTmp
;

48544 int 
iSavepoint
;

48545 int 
ii
;

48547 
p1
 = 
pOp
->p1;

48548 
zName
 = 
pOp
->
p4
.
z
;

48559 if( 
p1
==0 )

48562 if( 
db
->
nVdbeWrite
>0 )

48568 
	`sqlite3VdbeError
(
p
, "cannot open savepoint - SQL statements in progress");

48569 
rc
 = 5;

48571 
nName
 = 
	`sqlite3Strlen30
(
zName
);

48579 
rc
 = 
	`sqlite3VtabSavepoint
(
db
, 0,

48580 
db
->
nStatement
+db->
nSavepoint
);

48581 if( 
rc
!=0 ) goto 
abort_due_to_error
;

48585 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(
Savepoint
)+
nName
+1);

48586 if( 
pNew
 )

48589 
pNew
->
zName
 = (char *)&pNew[1];

48590 
	`memcpy
(
pNew
->
zName
, zName, 
nName
+1);

48594 if( 
db
->
autoCommit
 )

48597 
db
->
autoCommit
 = 0;

48598 
db
->
isTransactionSavepoint
 = 1;

48600 
db
->
nSavepoint
++;

48604 
pNew
->
pNext
 = 
db
->
pSavepoint
;

48605 
db
->
pSavepoint
 = 
pNew
;

48606 
pNew
->
nDeferredCons
 = 
db
->nDeferredCons;

48607 
pNew
->
nDeferredImmCons
 = 
db
->nDeferredImmCons;

48611 
iSavepoint
 = 0;

48616 
pSavepoint
 = 
db
->pSavepoint;

48617 
pSavepoint
 && 
	`sqlite3StrICmp
(pSavepoint->
zName
, zName);

48618 
pSavepoint
 = pSavepoint->
pNext


48622 
iSavepoint
++;

48624 if( !
pSavepoint
 )

48627 
	`sqlite3VdbeError
(
p
, "no such savepoint: %s", 
zName
);

48628 
rc
 = 1;

48629 }else if( 
db
->
nVdbeWrite
>0 && 
p1
==1 )

48635 
	`sqlite3VdbeError
(
p
, "cannot release savepoint - "

48637 
rc
 = 5;

48644 int 
isTransaction
 = 
pSavepoint
->
pNext
==0 && 
db
->
isTransactionSavepoint
;

48645 if( 
isTransaction
 && 
p1
==1 )

48648 if( (
rc
 = 
	`sqlite3VdbeCheckFk
(
p
, 1))!=0 )

48651 goto 
vdbe_return
;

48653 
db
->
autoCommit
 = 1;

48654 if( 
	`sqlite3VdbeHalt
(
p
)==5 )

48657 
p
->
pc
 = (int)(
pOp
 - 
aOp
);

48658 
db
->
autoCommit
 = 0;

48659 
p
->
rc
 = rc = 5;

48660 goto 
vdbe_return
;

48662 
db
->
isTransactionSavepoint
 = 0;

48663 
rc
 = 
p
->rc;

48665 int 
isSchemaChange
;

48666 
iSavepoint
 = 
db
->
nSavepoint
 - iSavepoint - 1;

48667 if( 
p1
==2 )

48670 
isSchemaChange
 = (
db
->
flags
 & 0x00000002)!=0;

48671 for(
ii
=0; ii<
db
->
nDb
; ii++)

48674 
rc
 = 
	`sqlite3BtreeTripAllCursors
(
db
->
aDb
[
ii
].
pBt
,

48676 
isSchemaChange
==0);

48677 if( 
rc
!=0 ) goto 
abort_due_to_error
;

48680 
isSchemaChange
 = 0;

48682 for(
ii
=0; ii<
db
->
nDb
; ii++)

48685 
rc
 = 
	`sqlite3BtreeSavepoint
(
db
->
aDb
[
ii
].
pBt
, 
p1
, 
iSavepoint
);

48686 if( 
rc
!=0 )

48689 goto 
abort_due_to_error
;

48692 if( 
isSchemaChange
 )

48695 
	`sqlite3ExpirePreparedStatements
(
db
);

48696 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

48697 
db
->
flags
 = (db->flags | 0x00000002);

48703 while( 
db
->
pSavepoint
!=pSavepoint )

48706 
pTmp
 = 
db
->
pSavepoint
;

48707 
db
->
pSavepoint
 = 
pTmp
->
pNext
;

48708 
	`sqlite3DbFree
(
db
, 
pTmp
);

48709 
db
->
nSavepoint
--;

48716 if( 
p1
==1 )

48720 
db
->
pSavepoint
 = pSavepoint->
pNext
;

48721 
	`sqlite3DbFree
(
db
, 
pSavepoint
);

48722 if( !
isTransaction
 )

48725 
db
->
nSavepoint
--;

48728 
db
->
nDeferredCons
 = 
pSavepoint
->nDeferredCons;

48729 
db
->
nDeferredImmCons
 = 
pSavepoint
->nDeferredImmCons;

48732 if( !
isTransaction
 || 
p1
==2 )

48735 
rc
 = 
	`sqlite3VtabSavepoint
(
db
, 
p1
, 
iSavepoint
);

48736 if( 
rc
!=0 ) goto 
abort_due_to_error
;

48740 if( 
rc
 ) goto 
abort_due_to_error
;

48746 int 
desiredAutoCommit
;

48747 int 
iRollback
;

48749 
desiredAutoCommit
 = 
pOp
->
p1
;

48750 
iRollback
 = 
pOp
->
p2
;

48756 if( 
desiredAutoCommit
!=
db
->
autoCommit
 )

48759 if( 
iRollback
 )

48763 
	`sqlite3RollbackAll
(
db
, (4 | (2<<8)));

48764 
db
->
autoCommit
 = 1;

48765 }else if( 
desiredAutoCommit
 && 
db
->
nVdbeWrite
>0 )

48771 
	`sqlite3VdbeError
(
p
, "cannot commit transaction - "

48773 
rc
 = 5;

48774 goto 
abort_due_to_error
;

48775 }else if( (
rc
 = 
	`sqlite3VdbeCheckFk
(
p
, 1))!=0 )

48778 goto 
vdbe_return
;

48780 
db
->
autoCommit
 = (
u8
)
desiredAutoCommit
;

48782 if( 
	`sqlite3VdbeHalt
(
p
)==5 )

48785 
p
->
pc
 = (int)(
pOp
 - 
aOp
);

48786 
db
->
autoCommit
 = (
u8
)(1-
desiredAutoCommit
);

48787 
p
->
rc
 = rc = 5;

48788 goto 
vdbe_return
;

48791 
	`sqlite3CloseSavepoints
(
db
);

48792 if( 
p
->
rc
==0 )

48795 
rc
 = 101;

48797 
rc
 = 1;

48799 goto 
vdbe_return
;

48801 
	`sqlite3VdbeError
(
p
,

48802 (!
desiredAutoCommit
)?"cannot start a transaction within a transaction":(

48803 (
iRollback
)?"cannot rollback - no transaction is active":

48806 
rc
 = 1;

48807 goto 
abort_due_to_error
;

48813 
Btree
 *
pBt
;

48814 int 
iMeta
;

48815 int 
iGen
;

48821 if( 
pOp
->
p2
 && (
db
->
flags
 & 0x02000000)!=0 )

48824 
rc
 = 8;

48825 goto 
abort_due_to_error
;

48827 
pBt
 = 
db
->
aDb
[
pOp
->
p1
].pBt;

48829 if( 
pBt
 )

48832 
rc
 = 
	`sqlite3BtreeBeginTrans
(
pBt
, 
pOp
->
p2
);

48835 if( (
rc
&0xff)==5 )

48838 
p
->
pc
 = (int)(
pOp
 - 
aOp
);

48839 
p
->
rc
 = rc;

48840 goto 
vdbe_return
;

48842 if( 
rc
!=0 )

48845 goto 
abort_due_to_error
;

48848 if( 
pOp
->
p2
 && 
p
->
usesStmtJournal


48849 && (
db
->
autoCommit
==0 || db->
nVdbeRead
>1)

48854 if( 
p
->
iStatement
==0 )

48858 
db
->
nStatement
++;

48859 
p
->
iStatement
 = 
db
->
nSavepoint
 + db->
nStatement
;

48862 
rc
 = 
	`sqlite3VtabSavepoint
(
db
, 0, 
p
->
iStatement
-1);

48863 if( 
rc
==0 )

48866 
rc
 = 
	`sqlite3BtreeBeginStmt
(
pBt
, 
p
->
iStatement
);

48872 
p
->
nStmtDefCons
 = 
db
->
nDeferredCons
;

48873 
p
->
nStmtDefImmCons
 = 
db
->
nDeferredImmCons
;

48882 
	`sqlite3BtreeGetMeta
(
pBt
, 1, (
u32
 *)&
iMeta
);

48883 
iGen
 = 
db
->
aDb
[
pOp
->
p1
].
pSchema
->
iGeneration
;

48885 
iGen
 = 
iMeta
 = 0;

48888 if( 
pOp
->
p5
 && (
iMeta
!=pOp->
p3
 || 
iGen
!=pOp->
p4
.
i
) )

48891 
	`sqlite3DbFree
(
db
, 
p
->
zErrMsg
);

48892 
p
->
zErrMsg
 = 
	`sqlite3DbStrDup
(
db
, "database schema has changed");

48894 if( 
db
->
aDb
[
pOp
->
p1
].
pSchema
->
schema_cookie
!=
iMeta
 )

48897 
	`sqlite3ResetOneSchema
(
db
, 
pOp
->
p1
);

48899 
p
->
expired
 = 1;

48900 
rc
 = 17;

48902 if( 
rc
 ) goto 
abort_due_to_error
;

48907 int 
iMeta
;

48908 int 
iDb
;

48909 int 
iCookie
;

48912 
iDb
 = 
pOp
->
p1
;

48913 
iCookie
 = 
pOp
->
p3
;

48919 
	`sqlite3BtreeGetMeta
(
db
->
aDb
[
iDb
].
pBt
, 
iCookie
, (
u32
 *)&
iMeta
);

48920 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

48921 
pOut
->
u
.
i
 = 
iMeta
;

48926 
Db
 *
pDb
;

48931 
pDb
 = &
db
->
aDb
[
pOp
->
p1
];

48935 
rc
 = 
	`sqlite3BtreeUpdateMeta
(
pDb
->
pBt
, 
pOp
->
p2
, pOp->
p3
);

48936 if( 
pOp
->
p2
==1 )

48940 
pDb
->
pSchema
->
schema_cookie
 = 
pOp
->
p3
;

48941 
db
->
flags
 |= 0x00000002;

48942 }else if( 
pOp
->
p2
==2 )

48946 
pDb
->
pSchema
->
file_format
 = 
pOp
->
p3
;

48948 if( 
pOp
->
p1
==1 )

48953 
	`sqlite3ExpirePreparedStatements
(
db
);

48954 
p
->
expired
 = 0;

48956 if( 
rc
 ) goto 
abort_due_to_error
;

48961 int 
nField
;

48962 
KeyInfo
 *
pKeyInfo
;

48963 int 
p2
;

48964 int 
iDb
;

48965 int 
wrFlag
;

48966 
Btree
 *
pX
;

48967 
VdbeCursor
 *
pCur
;

48968 
Db
 *
pDb
;

48972 
pCur
 = 
p
->
apCsr
[
pOp
->
p1
];

48973 if( 
pCur
 && pCur->
pgnoRoot
==(
u32
)
pOp
->
p2
 )

48977 goto 
open_cursor_set_hints
;

48989 if( 
p
->
expired
 )

48992 
rc
 = (4 | (2<<8));

48993 goto 
abort_due_to_error
;

48996 
nField
 = 0;

48997 
pKeyInfo
 = 0;

48998 
p2
 = 
pOp
->p2;

48999 
iDb
 = 
pOp
->
p3
;

49002 
pDb
 = &
db
->
aDb
[
iDb
];

49003 
pX
 = 
pDb
->
pBt
;

49005 if( 
pOp
->
opcode
==55 )

49009 
wrFlag
 = 0x00000004 | (
pOp
->
p5
 & 0x08);

49011 if( 
pDb
->
pSchema
->
file_format
 < 
p
->
minWriteFileFormat
 )

49014 
p
->
minWriteFileFormat
 = 
pDb
->
pSchema
->
file_format
;

49017 
wrFlag
 = 0;

49019 if( 
pOp
->
p5
 & 0x10 )

49024 
pIn2
 = &
aMem
[
p2
];

49027 
	`sqlite3VdbeMemIntegerify
(
pIn2
);

49028 
p2
 = (int)
pIn2
->
u
.
i
;

49035 if( 
pOp
->
p4type
==(-6) )

49038 
pKeyInfo
 = 
pOp
->
p4
.pKeyInfo;

49041 
nField
 = 
pKeyInfo
->nField+pKeyInfo->
nXField
;

49042 }else if( 
pOp
->
p4type
==(-14) )

49045 
nField
 = 
pOp
->
p4
.
i
;

49050 
pCur
 = 
	`allocateCursor
(
p
, 
pOp
->
p1
, 
nField
, 
iDb
, 0);

49051 if( 
pCur
==0 ) goto 
no_mem
;

49052 
pCur
->
nullRow
 = 1;

49053 
pCur
->
isOrdered
 = 1;

49054 
pCur
->
pgnoRoot
 = 
p2
;

49058 
rc
 = 
	`sqlite3BtreeCursor
(
pX
, 
p2
, 
wrFlag
, 
pKeyInfo
, 
pCur
->
uc
.
pCursor
);

49059 
pCur
->
pKeyInfo
 = pKeyInfo;

49064 
pCur
->
isTable
 = 
pOp
->
p4type
!=(-6);

49066 
open_cursor_set_hints
:

49073 
	`sqlite3BtreeCursorHintFlags
(
pCur
->
uc
.
pCursor
,

49074 (
pOp
->
p5
 & (0x01|0x02)));

49075 if( 
rc
 ) goto 
abort_due_to_error
;

49081 
VdbeCursor
 *
pCx
;

49082 
KeyInfo
 *
pKeyInfo
;

49084 static const int 
vfsFlags
 =

49092 
pCx
 = 
	`allocateCursor
(
p
, 
pOp
->
p1
, pOp->
p2
, -1, 0);

49093 if( 
pCx
==0 ) goto 
no_mem
;

49094 
pCx
->
nullRow
 = 1;

49095 
pCx
->
isEphemeral
 = 1;

49096 
rc
 = 
	`sqlite3BtreeOpen
(
db
->
pVfs
, 0, db, &
pCx
->
pBt
,

49097 1 | 4 | 
pOp
->
p5
, 
vfsFlags
);

49098 if( 
rc
==0 )

49101 
rc
 = 
	`sqlite3BtreeBeginTrans
(
pCx
->
pBt
, 1);

49103 if( 
rc
==0 )

49111 if( (
pKeyInfo
 = 
pOp
->
p4
.pKeyInfo)!=0 )

49114 int 
pgno
;

49116 
rc
 = 
	`sqlite3BtreeCreateTable
(
pCx
->
pBt
, &
pgno
, 2 | 
pOp
->
p5
);

49117 if( 
rc
==0 )

49123 
pCx
->
pKeyInfo
 = pKeyInfo;

49124 
rc
 = 
	`sqlite3BtreeCursor
(
pCx
->
pBt
, 
pgno
, 0x00000004,

49125 
pKeyInfo
, 
pCx
->
uc
.
pCursor
);

49127 
pCx
->
isTable
 = 0;

49129 
rc
 = 
	`sqlite3BtreeCursor
(
pCx
->
pBt
, 1, 0x00000004,

49130 0, 
pCx
->
uc
.
pCursor
);

49131 
pCx
->
isTable
 = 1;

49134 if( 
rc
 ) goto 
abort_due_to_error
;

49135 
pCx
->
isOrdered
 = (
pOp
->
p5
!=8);

49140 
VdbeCursor
 *
pCx
;

49144 
pCx
 = 
	`allocateCursor
(
p
, 
pOp
->
p1
, pOp->
p2
, -1, 1);

49145 if( 
pCx
==0 ) goto 
no_mem
;

49146 
pCx
->
pKeyInfo
 = 
pOp
->
p4
.pKeyInfo;

49149 
rc
 = 
	`sqlite3VdbeSorterInit
(
db
, 
pOp
->
p3
, 
pCx
);

49150 if( 
rc
 ) goto 
abort_due_to_error
;

49155 
VdbeCursor
 *
pC
;

49157 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49159 if( (
pC
->
seqCount
++)==0 )

49162 goto 
jump_to_p2
;

49168 
VdbeCursor
 *
pCx
;

49172 
pCx
 = 
	`allocateCursor
(
p
, 
pOp
->
p1
, pOp->
p3
, -1, 3);

49173 if( 
pCx
==0 ) goto 
no_mem
;

49174 
pCx
->
nullRow
 = 1;

49175 
pCx
->
uc
.
pseudoTableReg
 = 
pOp
->
p2
;

49176 
pCx
->
isTable
 = 1;

49188 
	`sqlite3VdbeFreeCursor
(
p
, p->
apCsr
[
pOp
->
p1
]);

49189 
p
->
apCsr
[
pOp
->
p1
] = 0;

49197 int 
res
;

49198 int 
oc
;

49199 
VdbeCursor
 *
pC
;

49200 
UnpackedRecord
 
r
;

49201 int 
nField
;

49202 
i64
 
iKey
;

49203 int 
eqOnly
;

49207 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49215 
oc
 = 
pOp
->
opcode
;

49216 
eqOnly
 = 0;

49217 
pC
->
nullRow
 = 0;

49222 if( 
pC
->
isTable
 )

49231 
pIn3
 = &
aMem
[
pOp
->
p3
];

49232 if( (
pIn3
->
flags
 & (0x0004|0x0008|0x0002))==0x0002 )

49235 
	`applyNumericAffinity
(
pIn3
, 0);

49237 
iKey
 = 
	`sqlite3VdbeIntValue
(
pIn3
);

49241 if( (
pIn3
->
flags
 & 0x0004)==0 )

49244 if( (
pIn3
->
flags
 & 0x0008)==0 )

49249 ; goto 
jump_to_p2
;

49253 if( 
pIn3
->
u
.
r
<(double)
iKey
 )

49259 if( (
oc
 & 0x0001)==(66 & 0x0001) ) oc--;

49264 else if( 
pIn3
->
u
.
r
>(double)
iKey
 )

49270 if( (
oc
 & 0x0001)==(63 & 0x0001) ) oc++;

49273 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pC
->
uc
.
pCursor
, 0, (
u64
)
iKey
, 0, &
res
);

49274 
pC
->
movetoTarget
 = 
iKey
;

49275 if( 
rc
!=0 )

49278 goto 
abort_due_to_error
;

49285 if( 
	`sqlite3BtreeCursorHasHint
(
pC
->
uc
.
pCursor
, 0x00000002) )

49288 
eqOnly
 = 1;

49297 
nField
 = 
pOp
->
p4
.
i
;

49300 
r
.
pKeyInfo
 = 
pC
->pKeyInfo;

49301 
r
.
nField
 = (
u16
)nField;

49303 
r
.
default_rc
 = ((1 & (
oc
 - 63)) ? -1 : +1);

49309 
r
.
aMem
 = &aMem[
pOp
->
p3
];

49313 (((
r
.
aMem
)->
flags
&0x4000)?
	`sqlite3VdbeMemExpandBlob
(r.aMem):0);

49314 
r
.
eqSeen
 = 0;

49315 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pC
->
uc
.
pCursor
, &
r
, 0, 0, &
res
);

49316 if( 
rc
!=0 )

49319 goto 
abort_due_to_error
;

49321 if( 
eqOnly
 && 
r
.
eqSeen
==0 )

49325 goto 
seek_not_found
;

49328 
pC
->
deferredMoveto
 = 0;

49329 
pC
->
cacheStatus
 = 0;

49333 if( 
oc
>=65 )

49336 if( 
res
<0 || (res==0 && 
oc
==66) )

49339 
res
 = 0;

49340 
rc
 = 
	`sqlite3BtreeNext
(
pC
->
uc
.
pCursor
, &
res
);

49341 if( 
rc
!=0 ) goto 
abort_due_to_error
;

49343 
res
 = 0;

49347 if( 
res
>0 || (res==0 && 
oc
==63) )

49350 
res
 = 0;

49351 
rc
 = 
	`sqlite3BtreePrevious
(
pC
->
uc
.
pCursor
, &
res
);

49352 if( 
rc
!=0 ) goto 
abort_due_to_error
;

49357 
res
 = 
	`sqlite3BtreeEof
(
pC
->
uc
.
pCursor
);

49360 
seek_not_found
:

49363 if( 
res
 )

49366 goto 
jump_to_p2
;

49367 }else if( 
eqOnly
 )

49371 
pOp
++;

49379 int 
alreadyExists
;

49380 int 
takeJump
;

49381 int 
ii
;

49382 
VdbeCursor
 *
pC
;

49383 int 
res
;

49384 char *
pFree
;

49385 
UnpackedRecord
 *
pIdxKey
;

49386 
UnpackedRecord
 
r
;

49387 char 
aTempRec
[(((sizeof(
UnpackedRecord
))+7)&~7) + sizeof(
Mem
)*4 + 7];

49395 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49400 
pIn3
 = &
aMem
[
pOp
->
p3
];

49404 
pFree
 = 0;

49405 if( 
pOp
->
p4
.
i
>0 )

49408 
r
.
pKeyInfo
 = 
pC
->pKeyInfo;

49409 
r
.
nField
 = (
u16
)
pOp
->
p4
.
i
;

49410 
r
.
aMem
 = 
pIn3
;

49411 for(
ii
=0; ii<
r
.
nField
; ii++)

49415 (((&
r
.
aMem
[
ii
])->
flags
&0x4000)?
	`sqlite3VdbeMemExpandBlob
(&r.aMem[ii]):0);

49420 
pIdxKey
 = &
r
;

49422 
pIdxKey
 = 
	`sqlite3VdbeAllocUnpackedRecord
(

49423 
pC
->
pKeyInfo
, 
aTempRec
, sizeof(aTempRec), &
pFree


49425 if( 
pIdxKey
==0 ) goto 
no_mem
;

49427 (((
pIn3
)->
flags
&0x4000)?
	`sqlite3VdbeMemExpandBlob
(pIn3):0);

49428 
	`sqlite3VdbeRecordUnpack
(
pC
->
pKeyInfo
, 
pIn3
->
n
, pIn3->
z
, 
pIdxKey
);

49430 
pIdxKey
->
default_rc
 = 0;

49431 
takeJump
 = 0;

49432 if( 
pOp
->
opcode
==67 )

49438 for(
ii
=0; ii<
pIdxKey
->
nField
; ii++)

49441 if( 
pIdxKey
->
aMem
[
ii
].
flags
 & 0x0001 )

49444 
takeJump
 = 1;

49449 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pC
->
uc
.
pCursor
, 
pIdxKey
, 0, 0, &
res
);

49450 
	`sqlite3DbFree
(
db
, 
pFree
);

49451 if( 
rc
!=0 )

49454 goto 
abort_due_to_error
;

49456 
pC
->
seekResult
 = 
res
;

49457 
alreadyExists
 = (
res
==0);

49458 
pC
->
nullRow
 = 1-
alreadyExists
;

49459 
pC
->
deferredMoveto
 = 0;

49460 
pC
->
cacheStatus
 = 0;

49461 if( 
pOp
->
opcode
==69 )

49465 if( 
alreadyExists
 ) goto 
jump_to_p2
;

49468 if( 
takeJump
 || !
alreadyExists
 ) goto 
jump_to_p2
;

49474 
VdbeCursor
 *
pC
;

49475 
BtCursor
 *
pCrsr
;

49476 int 
res
;

49477 
u64
 
iKey
;

49479 
pIn3
 = &
aMem
[
pOp
->
p3
];

49482 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49489 
pCrsr
 = 
pC
->
uc
.
pCursor
;

49491 
res
 = 0;

49492 
iKey
 = 
pIn3
->
u
.
i
;

49493 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pCrsr
, 0, 
iKey
, 0, &
res
);

49495 
pC
->
movetoTarget
 = 
iKey
;

49496 
pC
->
nullRow
 = 0;

49497 
pC
->
cacheStatus
 = 0;

49498 
pC
->
deferredMoveto
 = 0;

49500 
pC
->
seekResult
 = 
res
;

49501 if( 
res
!=0 )

49505 if( 
pOp
->
p2
==0 )

49508 
rc
 = 
	`sqlite3CorruptError
(78535);

49510 goto 
jump_to_p2
;

49513 if( 
rc
 ) goto 
abort_due_to_error
;

49521 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

49522 
pOut
->
u
.
i
 = 
p
->
apCsr
[
pOp
->
p1
]->
seqCount
++;

49527 
i64
 
v
;

49528 
VdbeCursor
 *
pC
;

49529 int 
res
;

49530 int 
cnt
;

49531 
Mem
 *
pMem
;

49532 
VdbeFrame
 *
pFrame
;

49534 
v
 = 0;

49535 
res
 = 0;

49536 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

49538 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49546 if( !
pC
->
useRandomRowid
 )

49549 
rc
 = 
	`sqlite3BtreeLast
(
pC
->
uc
.
pCursor
, &
res
);

49550 if( 
rc
!=0 )

49553 goto 
abort_due_to_error
;

49555 if( 
res
 )

49558 
v
 = 1;

49561 
rc
 = 
	`sqlite3BtreeKeySize
(
pC
->
uc
.
pCursor
, &
v
);

49563 if( 
v
>=(
i64
)( (((
u64
)0x7fffffff)<<32) | (u64)0xffffffff ) )

49566 
pC
->
useRandomRowid
 = 1;

49568 
v
++;

49574 if( 
pOp
->
p3
 )

49579 if( 
p
->
pFrame
 )

49582 for(
pFrame
=
p
->pFrame; pFrame->
pParent
; pFrame=pFrame->pParent);

49585 
pMem
 = &
pFrame
->
aMem
[
pOp
->
p3
];

49589 
pMem
 = &
aMem
[
pOp
->
p3
];

49595 
	`sqlite3VdbeMemIntegerify
(
pMem
);

49597 if( 
pMem
->
u
.
i
==(
i64
)( (((
u64
)0x7fffffff)<<32) | (u64)0xffffffff ) || 
pC
->
useRandomRowid
 )

49600 
rc
 = 13;

49601 goto 
abort_due_to_error
;

49603 if( 
v
<
pMem
->
u
.
i
+1 )

49606 
v
 = 
pMem
->
u
.
i
 + 1;

49608 
pMem
->
u
.
i
 = 
v
;

49611 if( 
pC
->
useRandomRowid
 )

49620 
cnt
 = 0;

49622 
	`sqlite3_randomness
(sizeof(
v
), &v);

49623 
v
 &= ((
i64
)( (((
u64
)0x7fffffff)<<32) | (u64)0xffffffff )>>1); v++;

49624 }while( ((
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pC
->
uc
.
pCursor
, 0, (
u64
)
v
,

49625 0, &
res
))==0)

49626 && (
res
==0)

49627 && (++
cnt
<100));

49628 if( 
rc
 ) goto 
abort_due_to_error
;

49629 if( 
res
==0 )

49632 
rc
 = 13;

49633 goto 
abort_due_to_error
;

49637 
pC
->
deferredMoveto
 = 0;

49638 
pC
->
cacheStatus
 = 0;

49640 
pOut
->
u
.
i
 = 
v
;

49646 
Mem
 *
pData
;

49647 
Mem
 *
pKey
;

49648 
i64
 
iKey
;

49649 
VdbeCursor
 *
pC
;

49650 int 
nZero
;

49651 int 
seekResult
;

49652 const char *
zDb
;

49653 const char *
zTbl
;

49654 int 
op
;

49656 
pData
 = &
aMem
[
pOp
->
p2
];

49659 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49666 if( 
pOp
->
opcode
==75 )

49669 
pKey
 = &
aMem
[
pOp
->
p3
];

49673 
iKey
 = 
pKey
->
u
.
i
;

49676 
iKey
 = 
pOp
->
p3
;

49679 if( 
pOp
->
p5
 & 0x01 ) 
p
->
nChange
++;

49680 if( 
pOp
->
p5
 & 0x02 ) 
db
->
lastRowid
 = lastRowid = 
iKey
;

49681 if( 
pData
->
flags
 & 0x0001 )

49684 
pData
->
z
 = 0;

49685 
pData
->
n
 = 0;

49689 
seekResult
 = ((
pOp
->
p5
 & 0x10) ? 
pC
->seekResult : 0);

49690 if( 
pData
->
flags
 & 0x4000 )

49693 
nZero
 = 
pData
->
u
.nZero;

49695 
nZero
 = 0;

49697 
rc
 = 
	`sqlite3BtreeInsert
(
pC
->
uc
.
pCursor
, 0, 
iKey
,

49698 
pData
->
z
, pData->
n
, 
nZero
,

49699 (
pOp
->
p5
 & 0x08)!=0, 
seekResult


49701 
pC
->
deferredMoveto
 = 0;

49702 
pC
->
cacheStatus
 = 0;

49705 if( 
rc
 ) goto 
abort_due_to_error
;

49706 if( 
db
->
xUpdateCallback
 && 
pOp
->
p4
.
z
 )

49709 
zDb
 = 
db
->
aDb
[
pC
->
iDb
].
zName
;

49710 
zTbl
 = 
pOp
->
p4
.
z
;

49711 
op
 = ((
pOp
->
p5
 & 0x04) ? 23 : 18);

49713 
db
->
	`xUpdateCallback
(db->
pUpdateArg
, 
op
, 
zDb
, 
zTbl
, 
iKey
);

49720 
VdbeCursor
 *
pC
;

49721 
u8
 
hasUpdateCallback
;

49724 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49730 
hasUpdateCallback
 = 
db
->
xUpdateCallback
 && 
pOp
->
p4
.
z
 && 
pC
->
isTable
;

49731 if( 
pOp
->
p5
 && 
hasUpdateCallback
 )

49734 
	`sqlite3BtreeKeySize
(
pC
->
uc
.
pCursor
, &pC->
movetoTarget
);

49741 
rc
 = 
	`sqlite3BtreeDelete
(
pC
->
uc
.
pCursor
, 
pOp
->
p5
);

49742 
pC
->
cacheStatus
 = 0;

49745 if( 
rc
 ) goto 
abort_due_to_error
;

49746 if( 
hasUpdateCallback
 )

49749 
db
->
	`xUpdateCallback
(db->
pUpdateArg
, 9,

49750 
db
->
aDb
[
pC
->
iDb
].
zName
, 
pOp
->
p4
.
z
, pC->
movetoTarget
);

49753 if( 
pOp
->
p2
 & 0x01 ) 
p
->
nChange
++;

49764 
	`sqlite3VdbeSetChanges
(
db
, 
p
->
nChange
);

49765 
p
->
nChange
 = 0;

49770 
VdbeCursor
 *
pC
;

49771 int 
res
;

49772 int 
nKeyCol
;

49774 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49777 
pIn3
 = &
aMem
[
pOp
->
p3
];

49778 
nKeyCol
 = 
pOp
->
p4
.
i
;

49779 
res
 = 0;

49780 
rc
 = 
	`sqlite3VdbeSorterCompare
(
pC
, 
pIn3
, 
nKeyCol
, &
res
);

49782 if( 
rc
 ) goto 
abort_due_to_error
;

49783 if( 
res
 ) goto 
jump_to_p2
;

49788 
VdbeCursor
 *
pC
;

49790 
pOut
 = &
aMem
[
pOp
->
p2
];

49791 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49793 
rc
 = 
	`sqlite3VdbeSorterRowkey
(
pC
, 
pOut
);

49796 if( 
rc
 ) goto 
abort_due_to_error
;

49797 
p
->
apCsr
[
pOp
->
p3
]->
cacheStatus
 = 0;

49803 
VdbeCursor
 *
pC
;

49804 
BtCursor
 *
pCrsr
;

49805 
u32
 
n
;

49806 
i64
 
n64
;

49808 
pOut
 = &
aMem
[
pOp
->
p2
];

49813 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49821 
pCrsr
 = 
pC
->
uc
.
pCursor
;

49830 if( 
pC
->
isTable
==0 )

49834 
	`sqlite3BtreeKeySize
(
pCrsr
, &
n64
);

49836 if( 
n64
>
db
->
aLimit
[0] )

49839 goto 
too_big
;

49841 
n
 = (
u32
)
n64
;

49843 
	`sqlite3BtreeDataSize
(
pCrsr
, &
n
);

49845 if( 
n
>(
u32
)
db
->
aLimit
[0] )

49848 goto 
too_big
;

49852 if( 
	`sqlite3VdbeMemClearAndResize
(
pOut
, ((
n
)>(32)?(n):(32))) )

49855 goto 
no_mem
;

49857 
pOut
->
n
 = n;

49858 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0010);

49859 if( 
pC
->
isTable
==0 )

49862 
rc
 = 
	`sqlite3BtreeKey
(
pCrsr
, 0, 
n
, 
pOut
->
z
);

49864 
rc
 = 
	`sqlite3BtreeData
(
pCrsr
, 0, 
n
, 
pOut
->
z
);

49866 if( 
rc
 ) goto 
abort_due_to_error
;

49867 
pOut
->
enc
 = 1;

49874 
VdbeCursor
 *
pC
;

49875 
i64
 
v
;

49876 
sqlite3_vtab
 *
pVtab
;

49877 const 
sqlite3_module
 *
pModule
;

49879 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

49881 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49884 if( 
pC
->
nullRow
 )

49887 
pOut
->
flags
 = 0x0001;

49889 }else if( 
pC
->
deferredMoveto
 )

49892 
v
 = 
pC
->
movetoTarget
;

49894 }else if( 
pC
->
eCurType
==2 )

49898 
pVtab
 = 
pC
->
uc
.
pVCur
->pVtab;

49899 
pModule
 = 
pVtab
->pModule;

49901 
rc
 = 
pModule
->
	`xRowid
(
pC
->
uc
.
pVCur
, &
v
);

49902 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

49903 if( 
rc
 ) goto 
abort_due_to_error
;

49908 
rc
 = 
	`sqlite3VdbeCursorRestore
(
pC
);

49909 if( 
rc
 ) goto 
abort_due_to_error
;

49910 if( 
pC
->
nullRow
 )

49913 
pOut
->
flags
 = 0x0001;

49916 
rc
 = 
	`sqlite3BtreeKeySize
(
pC
->
uc
.
pCursor
, &
v
);

49919 
pOut
->
u
.
i
 = 
v
;

49930 
VdbeCursor
 *
pC
;

49933 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49935 
pC
->
nullRow
 = 1;

49936 
pC
->
cacheStatus
 = 0;

49937 if( 
pC
->
eCurType
==0 )

49941 
	`sqlite3BtreeClearCursor
(
pC
->
uc
.
pCursor
);

49947 
VdbeCursor
 *
pC
;

49948 
BtCursor
 *
pCrsr
;

49949 int 
res
;

49952 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49955 
pCrsr
 = 
pC
->
uc
.
pCursor
;

49956 
res
 = 0;

49958 
rc
 = 
	`sqlite3BtreeLast
(
pCrsr
, &
res
);

49959 
pC
->
nullRow
 = (
u8
)
res
;

49960 
pC
->
deferredMoveto
 = 0;

49961 
pC
->
cacheStatus
 = 0;

49962 
pC
->
seekResult
 = 
pOp
->
p3
;

49966 if( 
rc
 ) goto 
abort_due_to_error
;

49967 if( 
pOp
->
p2
>0 )

49971 if( 
res
 ) goto 
jump_to_p2
;

49982 
p
->
aCounter
[2]++;

49987 
VdbeCursor
 *
pC
;

49988 
BtCursor
 *
pCrsr
;

49989 int 
res
;

49992 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

49995 
res
 = 1;

49999 if( ((
pC
)->
eCurType
==1) )

50002 
rc
 = 
	`sqlite3VdbeSorterRewind
(
pC
, &
res
);

50005 
pCrsr
 = 
pC
->
uc
.
pCursor
;

50007 
rc
 = 
	`sqlite3BtreeFirst
(
pCrsr
, &
res
);

50008 
pC
->
deferredMoveto
 = 0;

50009 
pC
->
cacheStatus
 = 0;

50011 if( 
rc
 ) goto 
abort_due_to_error
;

50012 
pC
->
nullRow
 = (
u8
)
res
;

50015 if( 
res
 ) goto 
jump_to_p2
;

50020 
VdbeCursor
 *
pC
;

50021 int 
res
;

50023 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

50025 
res
 = 0;

50026 
rc
 = 
	`sqlite3VdbeSorterNext
(
db
, 
pC
, &
res
);

50027 goto 
next_tail
;

50030 if( 
p
->
apCsr
[
pOp
->
p1
]==0 ) break;

50036 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

50037 
res
 = 
pOp
->
p3
;

50057 
rc
 = 
pOp
->
p4
.
	`xAdvance
(
pC
->
uc
.
pCursor
, &
res
);

50058 
next_tail
:

50059 
pC
->
cacheStatus
 = 0;

50061 if( 
rc
 ) goto 
abort_due_to_error
;

50062 if( 
res
==0 )

50065 
pC
->
nullRow
 = 0;

50066 
p
->
aCounter
[
pOp
->
p5
]++;

50070 goto 
jump_to_p2_and_check_for_interrupt
;

50072 
pC
->
nullRow
 = 1;

50074 goto 
check_for_interrupt
;

50079 
VdbeCursor
 *
pC
;

50080 int 
nKey
;

50081 const char *
zKey
;

50084 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

50087 
pIn2
 = &
aMem
[
pOp
->
p2
];

50089 if( 
pOp
->
p5
 & 0x01 ) 
p
->
nChange
++;

50092 
rc
 = (((
pIn2
)->
flags
&0x4000)?
	`sqlite3VdbeMemExpandBlob
(pIn2):0);

50093 if( 
rc
 ) goto 
abort_due_to_error
;

50094 if( 
pOp
->
opcode
==109 )

50097 
rc
 = 
	`sqlite3VdbeSorterWrite
(
pC
, 
pIn2
);

50099 
nKey
 = 
pIn2
->
n
;

50100 
zKey
 = 
pIn2
->
z
;

50101 
rc
 = 
	`sqlite3BtreeInsert
(
pC
->
uc
.
pCursor
, 
zKey
, 
nKey
, "", 0, 0, 
pOp
->
p3
,

50102 ((
pOp
->
p5
 & 0x10) ? 
pC
->
seekResult
 : 0)

50105 
pC
->
cacheStatus
 = 0;

50107 if( 
rc
) goto 
abort_due_to_error
;

50112 
VdbeCursor
 *
pC
;

50113 
BtCursor
 *
pCrsr
;

50114 int 
res
;

50115 
UnpackedRecord
 
r
;

50120 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

50123 
pCrsr
 = 
pC
->
uc
.
pCursor
;

50126 
r
.
pKeyInfo
 = 
pC
->pKeyInfo;

50127 
r
.
nField
 = (
u16
)
pOp
->
p3
;

50128 
r
.
default_rc
 = 0;

50129 
r
.
aMem
 = &aMem[
pOp
->
p2
];

50130 
rc
 = 
	`sqlite3BtreeMovetoUnpacked
(
pCrsr
, &
r
, 0, 0, &
res
);

50131 if( 
rc
 ) goto 
abort_due_to_error
;

50132 if( 
res
==0 )

50135 
rc
 = 
	`sqlite3BtreeDelete
(
pCrsr
, 0x04);

50136 if( 
rc
 ) goto 
abort_due_to_error
;

50139 
pC
->
cacheStatus
 = 0;

50145 
VdbeCursor
 *
pC
;

50146 
VdbeCursor
 *
pTabCur
;

50147 
i64
 
rowid
;

50150 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

50160 
rc
 = 
	`sqlite3VdbeCursorRestore
(
pC
);

50165 if( (
rc
!=0) ) goto 
abort_due_to_error
;

50167 if( !
pC
->
nullRow
 )

50170 
rowid
 = 0;

50171 
rc
 = 
	`sqlite3VdbeIdxRowid
(
db
, 
pC
->
uc
.
pCursor
, &
rowid
);

50172 if( 
rc
!=0 )

50175 goto 
abort_due_to_error
;

50177 if( 
pOp
->
opcode
==112 )

50181 
pTabCur
 = 
p
->
apCsr
[
pOp
->
p3
];

50186 
pTabCur
->
nullRow
 = 0;

50187 
pTabCur
->
movetoTarget
 = 
rowid
;

50188 
pTabCur
->
deferredMoveto
 = 1;

50190 
pTabCur
->
aAltMap
 = 
pOp
->
p4
.
ai
;

50191 
pTabCur
->
pAltCursor
 = 
pC
;

50193 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

50194 
pOut
->
u
.
i
 = 
rowid
;

50195 
pOut
->
flags
 = 0x0004;

50199 
	`sqlite3VdbeMemSetNull
(&
aMem
[
pOp
->
p2
]);

50208 
VdbeCursor
 *
pC
;

50209 int 
res
;

50210 
UnpackedRecord
 
r
;

50213 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

50221 
r
.
pKeyInfo
 = 
pC
->pKeyInfo;

50222 
r
.
nField
 = (
u16
)
pOp
->
p4
.
i
;

50223 if( 
pOp
->
opcode
<116 )

50227 
r
.
default_rc
 = -1;

50230 
r
.
default_rc
 = 0;

50232 
r
.
aMem
 = &aMem[
pOp
->
p3
];

50236 
res
 = 0;

50237 
rc
 = 
	`sqlite3VdbeIdxKeyCompare
(
db
, 
pC
, &
r
, &
res
);

50239 if( (
pOp
->
opcode
&1)==(116&1) )

50243 
res
 = -res;

50246 
res
++;

50249 if( 
rc
 ) goto 
abort_due_to_error
;

50250 if( 
res
>0 ) goto 
jump_to_p2
;

50255 int 
iMoved
;

50256 int 
iDb
;

50260 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

50261 
pOut
->
flags
 = 0x0001;

50262 if( 
db
->
nVdbeRead
 > db->
nVDestroy
+1 )

50265 
rc
 = 6;

50266 
p
->
errorAction
 = 2;

50267 goto 
abort_due_to_error
;

50269 
iDb
 = 
pOp
->
p3
;

50271 
iMoved
 = 0;

50272 
rc
 = 
	`sqlite3BtreeDropTable
(
db
->
aDb
[
iDb
].
pBt
, 
pOp
->
p1
, &
iMoved
);

50273 
pOut
->
flags
 = 0x0004;

50274 
pOut
->
u
.
i
 = 
iMoved
;

50275 if( 
rc
 ) goto 
abort_due_to_error
;

50277 if( 
iMoved
!=0 )

50280 
	`sqlite3RootPageMoved
(
db
, 
iDb
, 
iMoved
, 
pOp
->
p1
);

50283 
resetSchemaOnFault
 = 
iDb
+1;

50291 int 
nChange
;

50293 
nChange
 = 0;

50296 
rc
 = 
	`sqlite3BtreeClearTable
(

50297 
db
->
aDb
[
pOp
->
p2
].
pBt
, pOp->
p1
, (pOp->
p3
 ? &
nChange
 : 0)

50299 if( 
pOp
->
p3
 )

50302 
p
->
nChange
 += nChange;

50303 if( 
pOp
->
p3
>0 )

50308 
aMem
[
pOp
->
p3
].
u
.
i
 += 
nChange
;

50311 if( 
rc
 ) goto 
abort_due_to_error
;

50316 
VdbeCursor
 *
pC
;

50319 
pC
 = 
p
->
apCsr
[
pOp
->
p1
];

50321 if( ((
pC
)->
eCurType
==1) )

50324 
	`sqlite3VdbeSorterReset
(
db
, 
pC
->
uc
.
pSorter
);

50328 
rc
 = 
	`sqlite3BtreeClearTableOfCursor
(
pC
->
uc
.
pCursor
);

50329 if( 
rc
 ) goto 
abort_due_to_error
;

50336 int 
pgno
;

50337 int 
flags
;

50338 
Db
 *
pDb
;

50340 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

50341 
pgno
 = 0;

50345 
pDb
 = &
db
->
aDb
[
pOp
->
p1
];

50347 if( 
pOp
->
opcode
==122 )

50351 
flags
 = 1;

50353 
flags
 = 2;

50355 
rc
 = 
	`sqlite3BtreeCreateTable
(
pDb
->
pBt
, &
pgno
, 
flags
);

50356 if( 
rc
 ) goto 
abort_due_to_error
;

50357 
pOut
->
u
.
i
 = 
pgno
;

50362 int 
iDb
;

50363 const char *
zMaster
;

50364 char *
zSql
;

50365 
InitData
 
initData
;

50367 
iDb
 = 
pOp
->
p1
;

50371 
zMaster
 = ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master");

50372 
initData
.
db
 = db;

50373 
initData
.
iDb
 = 
pOp
->
p1
;

50374 
initData
.
pzErrMsg
 = &
p
->
zErrMsg
;

50375 
zSql
 = 
	`sqlite3MPrintf
(
db
,

50377 
db
->
aDb
[
iDb
].
zName
, 
zMaster
, 
pOp
->
p4
.
z
);

50378 if( 
zSql
==0 )

50381 
rc
 = 7;

50384 
db
->
init
.
busy
 = 1;

50385 
initData
.
rc
 = 0;

50387 
rc
 = 
	`sqlite3_exec
(
db
, 
zSql
, 
sqlite3InitCallback
, &
initData
, 0);

50388 if( 
rc
==0 ) rc = 
initData
.rc;

50389 
	`sqlite3DbFree
(
db
, 
zSql
);

50390 
db
->
init
.
busy
 = 0;

50393 if( 
rc
 )

50396 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

50397 if( 
rc
==7 )

50400 goto 
no_mem
;

50402 goto 
abort_due_to_error
;

50409 
rc
 = 
	`sqlite3AnalysisLoad
(
db
, 
pOp
->
p1
);

50410 if( 
rc
 ) goto 
abort_due_to_error
;

50415 
	`sqlite3UnlinkAndDeleteTable
(
db
, 
pOp
->
p1
, pOp->
p4
.
z
);

50420 
	`sqlite3UnlinkAndDeleteIndex
(
db
, 
pOp
->
p1
, pOp->
p4
.
z
);

50425 
	`sqlite3UnlinkAndDeleteTrigger
(
db
, 
pOp
->
p1
, pOp->
p4
.
z
);

50430 int 
nRoot
;

50431 int *
aRoot
;

50432 int 
nErr
;

50433 char *
z
;

50434 
Mem
 *
pnErr
;

50437 
nRoot
 = 
pOp
->
p2
;

50438 
aRoot
 = 
pOp
->
p4
.
ai
;

50442 
pnErr
 = &
aMem
[
pOp
->
p3
];

50445 
pIn1
 = &
aMem
[
pOp
->
p1
];

50448 
z
 = 
	`sqlite3BtreeIntegrityCheck
(
db
->
aDb
[
pOp
->
p5
].
pBt
, 
aRoot
, 
nRoot
,

50449 (int)
pnErr
->
u
.
i
, &
nErr
);

50450 
pnErr
->
u
.
i
 -= 
nErr
;

50451 
	`sqlite3VdbeMemSetNull
(
pIn1
);

50452 if( 
nErr
==0 )

50456 }else if( 
z
==0 )

50459 goto 
no_mem
;

50461 
	`sqlite3VdbeMemSetStr
(
pIn1
, 
z
, -1, 1, 
sqlite3_free
);

50464 
	`sqlite3VdbeChangeEncoding
(
pIn1
, 
encoding
);

50469 
pIn1
 = &
aMem
[
pOp
->
p1
];

50470 
pIn2
 = &
aMem
[
pOp
->
p2
];

50472 if( (
pIn1
->
flags
 & 0x0020)==0 )

50475 
	`sqlite3VdbeMemSetRowSet
(
pIn1
);

50476 if( (
pIn1
->
flags
 & 0x0020)==0 ) goto 
no_mem
;

50478 
	`sqlite3RowSetInsert
(
pIn1
->
u
.
pRowSet
, 
pIn2
->u.
i
);

50483 
i64
 
val
;

50485 
pIn1
 = &
aMem
[
pOp
->
p1
];

50486 if( (
pIn1
->
flags
 & 0x0020)==0

50487 || 
	`sqlite3RowSetNext
(
pIn1
->
u
.
pRowSet
, &
val
)==0

50492 
	`sqlite3VdbeMemSetNull
(
pIn1
);

50494 goto 
jump_to_p2_and_check_for_interrupt
;

50498 
	`sqlite3VdbeMemSetInt64
(&
aMem
[
pOp
->
p3
], 
val
);

50500 goto 
check_for_interrupt
;

50504 int 
iSet
;

50505 int 
exists
;

50507 
pIn1
 = &
aMem
[
pOp
->
p1
];

50508 
pIn3
 = &
aMem
[
pOp
->
p3
];

50509 
iSet
 = 
pOp
->
p4
.
i
;

50515 if( (
pIn1
->
flags
 & 0x0020)==0 )

50518 
	`sqlite3VdbeMemSetRowSet
(
pIn1
);

50519 if( (
pIn1
->
flags
 & 0x0020)==0 ) goto 
no_mem
;

50524 if( 
iSet
 )

50527 
exists
 = 
	`sqlite3RowSetTest
(
pIn1
->
u
.
pRowSet
, 
iSet
, 
pIn3
->u.
i
);

50529 if( 
exists
 ) goto 
jump_to_p2
;

50531 if( 
iSet
>=0 )

50534 
	`sqlite3RowSetInsert
(
pIn1
->
u
.
pRowSet
, 
pIn3
->u.
i
);

50540 int 
nMem
;

50541 int 
nByte
;

50542 
Mem
 *
pRt
;

50543 
Mem
 *
pMem
;

50544 
Mem
 *
pEnd
;

50545 
VdbeFrame
 *
pFrame
;

50546 
SubProgram
 *
pProgram
;

50547 void *
t
;

50549 
pProgram
 = 
pOp
->
p4
.pProgram;

50550 
pRt
 = &
aMem
[
pOp
->
p3
];

50553 if( 
pOp
->
p5
 )

50556 
t
 = 
pProgram
->
token
;

50557 for(
pFrame
=
p
->pFrame; pFrame && pFrame->
token
!=
t
; pFrame=pFrame->
pParent
);

50558 if( 
pFrame
 ) break;

50561 if( 
p
->
nFrame
>=
db
->
aLimit
[10] )

50564 
rc
 = 1;

50565 
	`sqlite3VdbeError
(
p
, "too many levels of trigger recursion");

50566 goto 
abort_due_to_error
;

50573 if( (
pRt
->
flags
&0x0040)==0 )

50581 
nMem
 = 
pProgram
->nMem + pProgram->
nCsr
;

50583 if( 
pProgram
->
nCsr
==0 ) 
nMem
++;

50584 
nByte
 = (((sizeof(
VdbeFrame
))+7)&~7)

50585 + 
nMem
 * sizeof(
Mem
)

50586 + 
pProgram
->
nCsr
 * sizeof(
VdbeCursor
 *)

50587 + 
pProgram
->
nOnce
 * sizeof(
u8
);

50588 
pFrame
 = 
	`sqlite3DbMallocZero
(
db
, 
nByte
);

50589 if( !
pFrame
 )

50592 goto 
no_mem
;

50594 
	`sqlite3VdbeMemRelease
(
pRt
);

50595 
pRt
->
flags
 = 0x0040;

50596 
pRt
->
u
.
pFrame
 = pFrame;

50598 
pFrame
->
v
 = 
p
;

50599 
pFrame
->
nChildMem
 = 
nMem
;

50600 
pFrame
->
nChildCsr
 = 
pProgram
->
nCsr
;

50601 
pFrame
->
pc
 = (int)(
pOp
 - 
aOp
);

50602 
pFrame
->
aMem
 = 
p
->aMem;

50603 
pFrame
->
nMem
 = 
p
->nMem;

50604 
pFrame
->
apCsr
 = 
p
->apCsr;

50605 
pFrame
->
nCursor
 = 
p
->nCursor;

50606 
pFrame
->
aOp
 = 
p
->aOp;

50607 
pFrame
->
nOp
 = 
p
->nOp;

50608 
pFrame
->
token
 = 
pProgram
->token;

50609 
pFrame
->
aOnceFlag
 = 
p
->aOnceFlag;

50610 
pFrame
->
nOnceFlag
 = 
p
->nOnceFlag;

50615 
pEnd
 = &((
Mem
 *)&((
u8
 *)
pFrame
)[(((sizeof(
VdbeFrame
))+7)&~7)])[pFrame->
nChildMem
];

50616 for(
pMem
=((
Mem
 *)&((
u8
 *)
pFrame
)[(((sizeof(
VdbeFrame
))+7)&~7)]); pMem!=
pEnd
; pMem++)

50619 
pMem
->
flags
 = 0x0080;

50620 
pMem
->
db
 = db;

50623 
pFrame
 = 
pRt
->
u
.pFrame;

50630 
p
->
nFrame
++;

50631 
pFrame
->
pParent
 = 
p
->pFrame;

50632 
pFrame
->
lastRowid
 = lastRowid;

50633 
pFrame
->
nChange
 = 
p
->nChange;

50634 
pFrame
->
nDbChange
 = 
p
->
db
->
nChange
;

50636 
pFrame
->
pAuxData
 = 
p
->pAuxData;

50637 
p
->
pAuxData
 = 0;

50638 
p
->
nChange
 = 0;

50639 
p
->
pFrame
 = pFrame;

50640 
p
->
aMem
 = aMem = ((
Mem
 *)&((
u8
 *)
pFrame
)[(((sizeof(
VdbeFrame
))+7)&~7)]);

50641 
p
->
nMem
 = 
pFrame
->
nChildMem
;

50642 
p
->
nCursor
 = (
u16
)
pFrame
->
nChildCsr
;

50643 
p
->
apCsr
 = (
VdbeCursor
 **)&
aMem
[p->
nMem
];

50644 
p
->
aOp
 = aOp = 
pProgram
->aOp;

50645 
p
->
nOp
 = 
pProgram
->nOp;

50646 
p
->
aOnceFlag
 = (
u8
 *)&p->
apCsr
[p->
nCursor
];

50647 
p
->
nOnceFlag
 = 
pProgram
->
nOnce
;

50651 
pOp
 = &
aOp
[-1];

50652 
	`memset
(
p
->
aOnceFlag
, 0, p->
nOnceFlag
);

50658 
VdbeFrame
 *
pFrame
;

50659 
Mem
 *
pIn
;

50660 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

50661 
pFrame
 = 
p
->pFrame;

50662 
pIn
 = &
pFrame
->
aMem
[
pOp
->
p1
 + pFrame->
aOp
[pFrame->
pc
].p1];

50663 
	`sqlite3VdbeMemShallowCopy
(
pOut
, 
pIn
, 0x1000);

50668 if( 
db
->
flags
 & 0x01000000 )

50671 
db
->
nDeferredImmCons
 += 
pOp
->
p2
;

50672 }else if( 
pOp
->
p1
 )

50675 
db
->
nDeferredCons
 += 
pOp
->
p2
;

50677 
p
->
nFkConstraint
 += 
pOp
->
p2
;

50683 if( 
pOp
->
p1
 )

50687 if( 
db
->
nDeferredCons
==0 && db->
nDeferredImmCons
==0 ) goto 
jump_to_p2
;

50690 if( 
p
->
nFkConstraint
==0 && 
db
->
nDeferredImmCons
==0 ) goto 
jump_to_p2
;

50696 
VdbeFrame
 *
pFrame
;

50697 if( 
p
->
pFrame
 )

50700 for(
pFrame
=
p
->pFrame; pFrame->
pParent
; pFrame=pFrame->pParent);

50701 
pIn1
 = &
pFrame
->
aMem
[
pOp
->
p1
];

50703 
pIn1
 = &
aMem
[
pOp
->
p1
];

50706 
	`sqlite3VdbeMemIntegerify
(
pIn1
);

50707 
pIn2
 = &
aMem
[
pOp
->
p2
];

50708 
	`sqlite3VdbeMemIntegerify
(
pIn2
);

50709 if( 
pIn1
->
u
.
i
<
pIn2
->u.i)

50712 
pIn1
->
u
.
i
 = 
pIn2
->u.i;

50718 
pIn1
 = &
aMem
[
pOp
->
p1
];

50721 if( 
pIn1
->
u
.
i
>0 )

50724 
pIn1
->
u
.
i
 -= 
pOp
->
p3
;

50725 goto 
jump_to_p2
;

50731 
pIn1
 = &
aMem
[
pOp
->
p1
];

50732 
pIn3
 = &
aMem
[
pOp
->
p3
];

50733 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

50736 
pOut
->
u
.
i
 = 
pIn1
->u.i<=0 ? -1 : pIn1->u.i+(
pIn3
->u.i>0?pIn3->u.i:0);

50741 
pIn1
 = &
aMem
[
pOp
->
p1
];

50744 if( 
pIn1
->
u
.
i
 )

50747 
pIn1
->
u
.
i
 -= 
pOp
->
p3
;

50748 goto 
jump_to_p2
;

50760 
pIn1
 = &
aMem
[
pOp
->
p1
];

50762 
pIn1
->
u
.
i
--;

50764 if( 
pIn1
->
u
.
i
==0 ) goto 
jump_to_p2
;

50769 
pIn1
 = &
aMem
[
pOp
->
p1
];

50772 if( (
pIn1
->
u
.
i
++)==0 ) goto 
jump_to_p2
;

50777 int 
n
;

50778 
sqlite3_context
 *
pCtx
;

50781 
n
 = 
pOp
->
p5
;

50785 
pCtx
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(*pCtx) + (
n
-1)*sizeof(
sqlite3_value
*));

50786 if( 
pCtx
==0 ) goto 
no_mem
;

50787 
pCtx
->
pMem
 = 0;

50788 
pCtx
->
pFunc
 = 
pOp
->
p4
.pFunc;

50789 
pCtx
->
iOp
 = (int)(
pOp
 - 
aOp
);

50790 
pCtx
->
pVdbe
 = 
p
;

50791 
pCtx
->
argc
 = 
n
;

50792 
pOp
->
p4type
 = (-20);

50793 
pOp
->
p4
.
pCtx
 = pCtx;

50794 
pOp
->
opcode
 = 144;

50798 int 
i
;

50799 
sqlite3_context
 *
pCtx
;

50800 
Mem
 *
pMem
;

50801 
Mem
 
t
;

50804 
pCtx
 = 
pOp
->
p4
.pCtx;

50805 
pMem
 = &
aMem
[
pOp
->
p3
];

50811 if( 
pCtx
->
pMem
 != pMem )

50814 
pCtx
->
pMem
 = pMem;

50815 for(
i
=
pCtx
->
argc
-1; i>=0; i--) pCtx->
argv
[i] = &
aMem
[
pOp
->
p2
+i];

50818 
pMem
->
n
++;

50819 
	`sqlite3VdbeMemInit
(&
t
, 
db
, 0x0001);

50820 
pCtx
->
pOut
 = &
t
;

50821 
pCtx
->
fErrorOrAux
 = 0;

50822 
pCtx
->
skipFlag
 = 0;

50823 (
pCtx
->
pFunc
->
xSFunc
)(pCtx,pCtx->
argc
,pCtx->
argv
);

50824 if( 
pCtx
->
fErrorOrAux
 )

50827 if( 
pCtx
->
isError
 )

50830 
	`sqlite3VdbeError
(
p
, "%s", 
	`sqlite3_value_text
(&
t
));

50831 
rc
 = 
pCtx
->
isError
;

50833 
	`sqlite3VdbeMemRelease
(&
t
);

50834 if( 
rc
 ) goto 
abort_due_to_error
;

50838 if( 
pCtx
->
skipFlag
 )

50842 
i
 = 
pOp
[-1].
p1
;

50843 if( 
i
 ) 
	`sqlite3VdbeMemSetInt64
(&
aMem
[i], 1);

50849 
Mem
 *
pMem
;

50851 
pMem
 = &
aMem
[
pOp
->
p1
];

50853 
rc
 = 
	`sqlite3VdbeMemFinalize
(
pMem
, 
pOp
->
p4
.
pFunc
);

50854 if( 
rc
 )

50857 
	`sqlite3VdbeError
(
p
, "%s", 
	`sqlite3_value_text
(
pMem
));

50858 goto 
abort_due_to_error
;

50860 
	`sqlite3VdbeChangeEncoding
(
pMem
, 
encoding
);

50862 if( 
	`sqlite3VdbeMemTooBig
(
pMem
) )

50865 goto 
too_big
;

50871 int 
i
;

50872 int 
aRes
[3];

50873 
Mem
 *
pMem
;

50876 
aRes
[0] = 0;

50877 
aRes
[1] = aRes[2] = -1;

50883 
rc
 = 
	`sqlite3Checkpoint
(
db
, 
pOp
->
p1
, pOp->
p2
, &
aRes
[1], &aRes[2]);

50884 if( 
rc
 )

50887 if( 
rc
!=5 ) goto 
abort_due_to_error
;

50888 
rc
 = 0;

50889 
aRes
[0] = 1;

50891 for(
i
=0, 
pMem
 = &
aMem
[
pOp
->
p3
]; i<3; i++, pMem++)

50894 
	`sqlite3VdbeMemSetInt64
(
pMem
, (
i64
)
aRes
[
i
]);

50900 
Btree
 *
pBt
;

50901 
Pager
 *
pPager
;

50902 int 
eNew
;

50903 int 
eOld
;

50905 const char *
zFilename
;

50908 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

50909 
eNew
 = 
pOp
->
p3
;

50921 
pBt
 = 
db
->
aDb
[
pOp
->
p1
].pBt;

50922 
pPager
 = 
	`sqlite3BtreePager
(
pBt
);

50923 
eOld
 = 
	`sqlite3PagerGetJournalMode
(
pPager
);

50924 if( 
eNew
==(-1) ) eNew = 
eOld
;

50925 if( !
	`sqlite3PagerOkToChangeJournalMode
(
pPager
) ) 
eNew
 = 
eOld
;

50928 
zFilename
 = 
	`sqlite3PagerFilename
(
pPager
, 1);

50933 if( 
eNew
==5

50934 && (
	`sqlite3Strlen30
(
zFilename
)==0

50935 || !
	`sqlite3PagerWalSupported
(
pPager
))

50939 
eNew
 = 
eOld
;

50942 if( (
eNew
!=
eOld
)

50943 && (
eOld
==5 || 
eNew
==5)

50947 if( !
db
->
autoCommit
 || db->
nVdbeRead
>1 )

50950 
rc
 = 1;

50951 
	`sqlite3VdbeError
(
p
,

50953 (
eNew
==5 ? "into" : "out of")

50955 goto 
abort_due_to_error
;

50958 if( 
eOld
==5 )

50966 
rc
 = 
	`sqlite3PagerCloseWal
(
pPager
);

50967 if( 
rc
==0 )

50970 
	`sqlite3PagerSetJournalMode
(
pPager
, 
eNew
);

50972 }else if( 
eOld
==4 )

50977 
	`sqlite3PagerSetJournalMode
(
pPager
, 2);

50984 if( 
rc
==0 )

50987 
rc
 = 
	`sqlite3BtreeSetVersion
(
pBt
, (
eNew
==5 ? 2 : 1));

50993 if( 
rc
 ) 
eNew
 = 
eOld
;

50994 
eNew
 = 
	`sqlite3PagerSetJournalMode
(
pPager
, eNew);

50996 
pOut
->
flags
 = 0x0002|0x0800|0x0200;

50997 
pOut
->
z
 = (char *)
	`sqlite3JournalModename
(
eNew
);

50998 
pOut
->
n
 = 
	`sqlite3Strlen30
(pOut->
z
);

50999 
pOut
->
enc
 = 1;

51000 
	`sqlite3VdbeChangeEncoding
(
pOut
, 
encoding
);

51001 if( 
rc
 ) goto 
abort_due_to_error
;

51007 
rc
 = 
	`sqlite3RunVacuum
(&
p
->
zErrMsg
, 
db
);

51008 if( 
rc
 ) goto 
abort_due_to_error
;

51013 
Btree
 *
pBt
;

51018 
pBt
 = 
db
->
aDb
[
pOp
->
p1
].pBt;

51019 
rc
 = 
	`sqlite3BtreeIncrVacuum
(
pBt
);

51021 if( 
rc
 )

51024 if( 
rc
!=101 ) goto 
abort_due_to_error
;

51025 
rc
 = 0;

51026 goto 
jump_to_p2
;

51032 if( !
pOp
->
p1
 )

51035 
	`sqlite3ExpirePreparedStatements
(
db
);

51037 
p
->
expired
 = 1;

51043 
u8
 
isWriteLock
 = (u8)
pOp
->
p3
;

51044 if( 
isWriteLock
 || 0==(
db
->
flags
&0x0004000) )

51047 int 
p1
 = 
pOp
->p1;

51051 
rc
 = 
	`sqlite3BtreeLockTable
(
db
->
aDb
[
p1
].
pBt
, 
pOp
->
p2
, 
isWriteLock
);

51052 if( 
rc
 )

51055 if( (
rc
&0xFF)==6 )

51058 const char *
z
 = 
pOp
->
p4
.z;

51059 
	`sqlite3VdbeError
(
p
, "database table is locked: %s", 
z
);

51061 goto 
abort_due_to_error
;

51068 
VTable
 *
pVTab
;

51069 
pVTab
 = 
pOp
->
p4
.
pVtab
;

51070 
rc
 = 
	`sqlite3VtabBegin
(
db
, 
pVTab
);

51071 if( 
pVTab
 ) 
	`sqlite3VtabImportErrmsg
(
p
, pVTab->
pVtab
);

51072 if( 
rc
 ) goto 
abort_due_to_error
;

51077 
Mem
 
sMem
;

51078 const char *
zTab
;

51080 
	`memset
(&
sMem
, 0, sizeof(sMem));

51081 
sMem
.
db
 = db;

51086 
rc
 = 
	`sqlite3VdbeMemCopy
(&
sMem
, &
aMem
[
pOp
->
p2
]);

51088 
zTab
 = (const char*)
	`sqlite3_value_text
(&
sMem
);

51090 if( 
zTab
 )

51093 
rc
 = 
	`sqlite3VtabCallCreate
(
db
, 
pOp
->
p1
, 
zTab
, &
p
->
zErrMsg
);

51095 
	`sqlite3VdbeMemRelease
(&
sMem
);

51096 if( 
rc
 ) goto 
abort_due_to_error
;

51101 
db
->
nVDestroy
++;

51102 
rc
 = 
	`sqlite3VtabCallDestroy
(
db
, 
pOp
->
p1
, pOp->
p4
.
z
);

51103 
db
->
nVDestroy
--;

51104 if( 
rc
 ) goto 
abort_due_to_error
;

51109 
VdbeCursor
 *
pCur
;

51110 
sqlite3_vtab_cursor
 *
pVCur
;

51111 
sqlite3_vtab
 *
pVtab
;

51112 const 
sqlite3_module
 *
pModule
;

51115 
pCur
 = 0;

51116 
pVCur
 = 0;

51117 
pVtab
 = 
pOp
->
p4
.pVtab->pVtab;

51118 if( 
pVtab
==0 || (pVtab->
pModule
==0) )

51121 
rc
 = 6;

51122 goto 
abort_due_to_error
;

51124 
pModule
 = 
pVtab
->pModule;

51125 
rc
 = 
pModule
->
	`xOpen
(
pVtab
, &
pVCur
);

51126 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

51127 if( 
rc
 ) goto 
abort_due_to_error
;

51130 
pVCur
->
pVtab
 = pVtab;

51133 
pCur
 = 
	`allocateCursor
(
p
, 
pOp
->
p1
, 0, -1, 2);

51134 if( 
pCur
 )

51137 
pCur
->
uc
.
pVCur
 = pVCur;

51138 
pVtab
->
nRef
++;

51141 
pModule
->
	`xClose
(
pVCur
);

51142 goto 
no_mem
;

51148 int 
nArg
;

51149 int 
iQuery
;

51150 const 
sqlite3_module
 *
pModule
;

51151 
Mem
 *
pQuery
;

51152 
Mem
 *
pArgc
;

51153 
sqlite3_vtab_cursor
 *
pVCur
;

51154 
sqlite3_vtab
 *
pVtab
;

51155 
VdbeCursor
 *
pCur
;

51156 int 
res
;

51157 int 
i
;

51158 
Mem
 **
apArg
;

51160 
pQuery
 = &
aMem
[
pOp
->
p3
];

51161 
pArgc
 = &
pQuery
[1];

51162 
pCur
 = 
p
->
apCsr
[
pOp
->
p1
];

51166 
pVCur
 = 
pCur
->
uc
.pVCur;

51167 
pVtab
 = 
pVCur
->pVtab;

51168 
pModule
 = 
pVtab
->pModule;

51172 
nArg
 = (int)
pArgc
->
u
.
i
;

51173 
iQuery
 = (int)
pQuery
->
u
.
i
;

51176 
res
 = 0;

51177 
apArg
 = 
p
->apArg;

51178 for(
i
 = 0; i<
nArg
; i++)

51181 
apArg
[
i
] = &
pArgc
[i+1];

51183 
rc
 = 
pModule
->
	`xFilter
(
pVCur
, 
iQuery
, 
pOp
->
p4
.
z
, 
nArg
, 
apArg
);

51184 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

51185 if( 
rc
 ) goto 
abort_due_to_error
;

51186 
res
 = 
pModule
->
	`xEof
(
pVCur
);

51187 
pCur
->
nullRow
 = 0;

51189 if( 
res
 ) goto 
jump_to_p2
;

51194 
sqlite3_vtab
 *
pVtab
;

51195 const 
sqlite3_module
 *
pModule
;

51196 
Mem
 *
pDest
;

51197 
sqlite3_context
 
sContext
;

51199 
VdbeCursor
 *
pCur
 = 
p
->
apCsr
[
pOp
->
p1
];

51202 
pDest
 = &
aMem
[
pOp
->
p3
];

51204 if( 
pCur
->
nullRow
 )

51207 
	`sqlite3VdbeMemSetNull
(
pDest
);

51210 
pVtab
 = 
pCur
->
uc
.
pVCur
->pVtab;

51211 
pModule
 = 
pVtab
->pModule;

51213 
	`memset
(&
sContext
, 0, sizeof(sContext));

51214 
sContext
.
pOut
 = 
pDest
;

51215 ((
pDest
)->
flags
 = ((pDest)->flags&~(0x81ff|0x4000))|0x0001);

51216 
rc
 = 
pModule
->
	`xColumn
(
pCur
->
uc
.
pVCur
, &
sContext
, 
pOp
->
p2
);

51217 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

51218 if( 
sContext
.
isError
 )

51221 
rc
 = 
sContext
.
isError
;

51223 
	`sqlite3VdbeChangeEncoding
(
pDest
, 
encoding
);

51227 if( 
	`sqlite3VdbeMemTooBig
(
pDest
) )

51230 goto 
too_big
;

51232 if( 
rc
 ) goto 
abort_due_to_error
;

51237 
sqlite3_vtab
 *
pVtab
;

51238 const 
sqlite3_module
 *
pModule
;

51239 int 
res
;

51240 
VdbeCursor
 *
pCur
;

51242 
res
 = 0;

51243 
pCur
 = 
p
->
apCsr
[
pOp
->
p1
];

51245 if( 
pCur
->
nullRow
 )

51250 
pVtab
 = 
pCur
->
uc
.
pVCur
->pVtab;

51251 
pModule
 = 
pVtab
->pModule;

51260 
rc
 = 
pModule
->
	`xNext
(
pCur
->
uc
.
pVCur
);

51261 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

51262 if( 
rc
 ) goto 
abort_due_to_error
;

51263 
res
 = 
pModule
->
	`xEof
(
pCur
->
uc
.
pVCur
);

51265 if( !
res
 )

51269 goto 
jump_to_p2_and_check_for_interrupt
;

51271 goto 
check_for_interrupt
;

51275 
sqlite3_vtab
 *
pVtab
;

51276 
Mem
 *
pName
;

51278 
pVtab
 = 
pOp
->
p4
.pVtab->pVtab;

51279 
pName
 = &
aMem
[
pOp
->
p1
];

51288 
rc
 = 
	`sqlite3VdbeChangeEncoding
(
pName
, 1);

51289 if( 
rc
 ) goto 
abort_due_to_error
;

51290 
rc
 = 
pVtab
->
pModule
->
	`xRename
(pVtab, 
pName
->
z
);

51291 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

51292 
p
->
expired
 = 0;

51293 if( 
rc
 ) goto 
abort_due_to_error
;

51298 
sqlite3_vtab
 *
pVtab
;

51299 const 
sqlite3_module
 *
pModule
;

51300 int 
nArg
;

51301 int 
i
;

51302 
sqlite_int64
 
rowid
;

51303 
Mem
 **
apArg
;

51304 
Mem
 *
pX
;

51310 
pVtab
 = 
pOp
->
p4
.pVtab->pVtab;

51311 if( 
pVtab
==0 || (pVtab->
pModule
==0) )

51314 
rc
 = 6;

51315 goto 
abort_due_to_error
;

51317 
pModule
 = 
pVtab
->pModule;

51318 
nArg
 = 
pOp
->
p2
;

51320 if( (
pModule
->
xUpdate
) )

51323 
u8
 
vtabOnConflict
 = 
db
->vtabOnConflict;

51324 
apArg
 = 
p
->apArg;

51325 
pX
 = &
aMem
[
pOp
->
p3
];

51326 for(
i
=0; i<
nArg
; i++)

51331 
apArg
[
i
] = 
pX
;

51332 
pX
++;

51334 
db
->
vtabOnConflict
 = 
pOp
->
p5
;

51335 
rc
 = 
pModule
->
	`xUpdate
(
pVtab
, 
nArg
, 
apArg
, &
rowid
);

51336 
db
->
vtabOnConflict
 = vtabOnConflict;

51337 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

51338 if( 
rc
==0 && 
pOp
->
p1
 )

51342 
db
->
lastRowid
 = lastRowid = 
rowid
;

51344 if( (
rc
&0xff)==19 && 
pOp
->
p4
.
pVtab
->
bConstraint
 )

51347 if( 
pOp
->
p5
==4 )

51350 
rc
 = 0;

51352 
p
->
errorAction
 = ((
pOp
->
p5
==5) ? 2 : pOp->p5);

51355 
p
->
nChange
++;

51357 if( 
rc
 ) goto 
abort_due_to_error
;

51369 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

51370 
pOut
->
u
.
i
 = 
	`sqlite3BtreeLastPage
(
db
->
aDb
[
pOp
->
p1
].
pBt
);

51375 unsigned int 
newMax
;

51376 
Btree
 *
pBt
;

51378 
pOut
 = 
	`out2Prerelease
(
p
, 
pOp
);

51379 
pBt
 = 
db
->
aDb
[
pOp
->
p1
].pBt;

51380 
newMax
 = 0;

51381 if( 
pOp
->
p3
 )

51384 
newMax
 = 
	`sqlite3BtreeLastPage
(
pBt
);

51385 if( 
newMax
 < (unsigned)
pOp
->
p3
 ) newMax = (unsigned)pOp->p3;

51387 
pOut
->
u
.
i
 = 
	`sqlite3BtreeMaxPageCount
(
pBt
, 
newMax
);

51392 char *
zTrace
;

51393 char *
z
;

51396 if( 
db
->
xTrace


51397 && !
p
->
doingRerun


51398 && (
zTrace
 = (
pOp
->
p4
.
z
 ? pOp->p4.z : 
p
->
zSql
))!=0

51402 
z
 = 
	`sqlite3VdbeExpandSql
(
p
, 
zTrace
);

51403 
db
->
	`xTrace
(db->
pTraceArg
, 
z
);

51404 
	`sqlite3DbFree
(
db
, 
z
);

51407 if( 
pOp
->
p2
 ) goto 
jump_to_p2
;

51429 
abort_due_to_error
:

51430 if( 
db
->
mallocFailed
 ) 
rc
 = 7;

51432 if( 
p
->
zErrMsg
==0 && 
rc
!=(10 | (12<<8)) )

51435 
	`sqlite3VdbeError
(
p
, "%s", 
	`sqlite3ErrStr
(
rc
));

51437 
p
->
rc
 = rc;

51438 
	`sqlite3SystemError
(
db
, 
rc
);

51440 
	`sqlite3_log
(
rc
, "statement aborts at %d: [%s] %s",

51441 (int)(
pOp
 - 
aOp
), 
p
->
zSql
, p->
zErrMsg
);

51442 
	`sqlite3VdbeHalt
(
p
);

51443 if( 
rc
==(10 | (12<<8)) ) 
	`sqlite3OomFault
(
db
);

51444 
rc
 = 1;

51445 if( 
resetSchemaOnFault
>0 )

51448 
	`sqlite3ResetOneSchema
(
db
, 
resetSchemaOnFault
-1);

51454 
vdbe_return
:

51455 
db
->
lastRowid
 = lastRowid;

51457 
p
->
aCounter
[4] += (int)
nVmStep
;

51458 
	`sqlite3VdbeLeave
(
p
);

51462 return 
rc
;

51467 
too_big
:

51468 
	`sqlite3VdbeError
(
p
, "string or blob too big");

51469 
rc
 = 18;

51470 goto 
abort_due_to_error
;

51474 
no_mem
:

51475 
	`sqlite3OomFault
(
db
);

51476 
	`sqlite3VdbeError
(
p
, "out of memory");

51477 
rc
 = 7;

51478 goto 
abort_due_to_error
;

51483 
abort_due_to_interrupt
:

51485 
rc
 = 
db
->
mallocFailed
 ? 7 : 9;

51486 
p
->
rc
 = rc;

51487 
	`sqlite3VdbeError
(
p
, "%s", 
	`sqlite3ErrStr
(
rc
));

51488 goto 
abort_due_to_error
;

51489 
	}
}

51491 typedef struct 
Incrblob
 
	tIncrblob
;

51492 struct 
	sIncrblob
 {

51493 int 
	mflags
;

51494 int 
	mnByte
;

51495 int 
	miOffset
;

51496 int 
	miCol
;

51497 
BtCursor
 *
	mpCsr
;

51498 
sqlite3_stmt
 *
	mpStmt
;

51499 
sqlite3
 *
	mdb
;

51502 static int 
	$blobSeekToRow
(
Incrblob
 *
p
, 
sqlite3_int64
 
iRow
, char **
pzErr
)

51505 int 
rc
;

51506 char *
zErr
 = 0;

51507 
Vdbe
 *
v
 = (Vdbe *)
p
->
pStmt
;

51514 
v
->
aVar
[0].
u
.
i
 = 
iRow
;

51516 
rc
 = 
	`sqlite3_step
(
p
->
pStmt
);

51517 if( 
rc
==100 )

51520 
VdbeCursor
 *
pC
 = 
v
->
apCsr
[0];

51521 
u32
 
type
 = 
pC
->
aType
[
p
->
iCol
];

51522 if( 
type
<12 )

51525 
zErr
 = 
	`sqlite3MPrintf
(
p
->
db
, "cannot open value of type %s",

51526 
type
==0?"null": type==7?"real": "integer"

51528 
rc
 = 1;

51529 
	`sqlite3_finalize
(
p
->
pStmt
);

51530 
p
->
pStmt
 = 0;

51532 
p
->
iOffset
 = 
pC
->
aType
[p->
iCol
 + pC->
nField
];

51533 
p
->
nByte
 = 
	`sqlite3VdbeSerialTypeLen
(
type
);

51534 
p
->
pCsr
 = 
pC
->
uc
.
pCursor
;

51535 
	`sqlite3BtreeIncrblobCursor
(
p
->
pCsr
);

51539 if( 
rc
==100 )

51542 
rc
 = 0;

51543 }else if( 
p
->
pStmt
 )

51546 
rc
 = 
	`sqlite3_finalize
(
p
->
pStmt
);

51547 
p
->
pStmt
 = 0;

51548 if( 
rc
==0 )

51551 
zErr
 = 
	`sqlite3MPrintf
(
p
->
db
, "no such rowid: %lld", 
iRow
);

51552 
rc
 = 1;

51554 
zErr
 = 
	`sqlite3MPrintf
(
p
->
db
, "%s", 
	`sqlite3_errmsg
(p->db));

51561 *
pzErr
 = 
zErr
;

51562 return 
rc
;

51563 
	}
}

51568 int 
	$sqlite3_blob_open
(

51569 
sqlite3
* 
db
,

51570 const char *
zDb
,

51571 const char *
zTable
,

51572 const char *
zColumn
,

51573 
sqlite_int64
 
iRow
,

51574 int 
flags
,

51575 
sqlite3_blob
 **
ppBlob


51579 int 
nAttempt
 = 0;

51580 int 
iCol
;

51581 int 
rc
 = 0;

51582 char *
zErr
 = 0;

51583 
Table
 *
pTab
;

51584 
Parse
 *
pParse
 = 0;

51585 
Incrblob
 *
pBlob
 = 0;

51592 *
ppBlob
 = 0;

51598 
flags
 = !!flags;

51600 
	`sqlite3_mutex_enter
(
db
->
mutex
);

51602 
pBlob
 = (
Incrblob
 *)
	`sqlite3DbMallocZero
(
db
, sizeof(Incrblob));

51603 if( !
pBlob
 ) goto 
blob_open_out
;

51604 
pParse
 = 
	`sqlite3DbMallocRaw
(
db
,sizeof(*pParse));

51605 if( !
pParse
 ) goto 
blob_open_out
;

51608 
	`memset
(
pParse
, 0, sizeof(
Parse
));

51609 
pParse
->
db
 = db;

51610 
	`sqlite3DbFree
(
db
, 
zErr
);

51611 
zErr
 = 0;

51613 
	`sqlite3BtreeEnterAll
(
db
);

51614 
pTab
 = 
	`sqlite3LocateTable
(
pParse
, 0, 
zTable
, 
zDb
);

51615 if( 
pTab
 && (((pTab)->
tabFlags
 & 0x10)!=0) )

51618 
pTab
 = 0;

51619 
	`sqlite3ErrorMsg
(
pParse
, "cannot open virtual table: %s", 
zTable
);

51621 if( 
pTab
 && !(((pTab)->
tabFlags
 & 0x20)==0) )

51624 
pTab
 = 0;

51625 
	`sqlite3ErrorMsg
(
pParse
, "cannot open table without rowid: %s", 
zTable
);

51628 if( 
pTab
 && pTab->
pSelect
 )

51631 
pTab
 = 0;

51632 
	`sqlite3ErrorMsg
(
pParse
, "cannot open view: %s", 
zTable
);

51635 if( !
pTab
 )

51638 if( 
pParse
->
zErrMsg
 )

51641 
	`sqlite3DbFree
(
db
, 
zErr
);

51642 
zErr
 = 
pParse
->
zErrMsg
;

51643 
pParse
->
zErrMsg
 = 0;

51645 
rc
 = 1;

51646 
	`sqlite3BtreeLeaveAll
(
db
);

51647 goto 
blob_open_out
;

51651 for(
iCol
=0; iCol<
pTab
->
nCol
; iCol++) {

51652 if( 
	`sqlite3StrICmp
(
pTab
->
aCol
[
iCol
].
zName
, 
zColumn
)==0 )

51658 if( 
iCol
==
pTab
->
nCol
 )

51661 
	`sqlite3DbFree
(
db
, 
zErr
);

51662 
zErr
 = 
	`sqlite3MPrintf
(
db
, "no such column: \"%s\"", 
zColumn
);

51663 
rc
 = 1;

51664 
	`sqlite3BtreeLeaveAll
(
db
);

51665 goto 
blob_open_out
;

51672 if( 
flags
 )

51675 const char *
zFault
 = 0;

51676 
Index
 *
pIdx
;

51678 if( 
db
->
flags
&0x00080000 )

51685 
FKey
 *
pFKey
;

51686 for(
pFKey
=
pTab
->pFKey; pFKey; pFKey=pFKey->
pNextFrom
)

51689 int 
j
;

51690 for(
j
=0; j<
pFKey
->
nCol
; j++)

51693 if( 
pFKey
->
aCol
[
j
].
iFrom
==
iCol
 )

51696 
zFault
 = "foreign key";

51702 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

51705 int 
j
;

51706 for(
j
=0; j<
pIdx
->
nKeyCol
; j++)

51710 if( 
pIdx
->
aiColumn
[
j
]==
iCol
 || pIdx->aiColumn[j]==(-2) )

51713 
zFault
 = "indexed";

51717 if( 
zFault
 )

51720 
	`sqlite3DbFree
(
db
, 
zErr
);

51721 
zErr
 = 
	`sqlite3MPrintf
(
db
, "cannot open %s column for writing", 
zFault
);

51722 
rc
 = 1;

51723 
	`sqlite3BtreeLeaveAll
(
db
);

51724 goto 
blob_open_out
;

51728 
pBlob
->
pStmt
 = (
sqlite3_stmt
 *)
	`sqlite3VdbeCreate
(
pParse
);

51730 if( 
pBlob
->
pStmt
 )

51734 static const int 
iLn
 = 0;

51735 static const 
VdbeOpList
 
openBlob
[] = {

51746 
Vdbe
 *
v
 = (Vdbe *)
pBlob
->
pStmt
;

51747 int 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

51748 
VdbeOp
 *
aOp
;

51750 
	`sqlite3VdbeAddOp4Int
(
v
, 2, 
iDb
, 
flags
,

51751 
pTab
->
pSchema
->
schema_cookie
,

51752 
pTab
->
pSchema
->
iGeneration
);

51753 
	`sqlite3VdbeChangeP5
(
v
, 1);

51754 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
openBlob
)/sizeof(openBlob[0]))), openBlob, 
iLn
);

51757 
	`sqlite3VdbeUsesBtree
(
v
, 
iDb
);

51759 if( 
db
->
mallocFailed
==0 )

51767 
aOp
[0].
p1
 = 
iDb
;

51768 
aOp
[0].
p2
 = 
pTab
->
tnum
;

51769 
aOp
[0].
p3
 = 
flags
;

51770 
	`sqlite3VdbeChangeP4
(
v
, 1, 
pTab
->
zName
, 0);

51772 if( 
db
->
mallocFailed
==0 )

51779 if( 
flags
 ) 
aOp
[1].
opcode
 = 55;

51780 
aOp
[1].
p2
 = 
pTab
->
tnum
;

51781 
aOp
[1].
p3
 = 
iDb
;

51783 
aOp
[1].
p4type
 = (-14);

51784 
aOp
[1].
p4
.
i
 = 
pTab
->
nCol
+1;

51785 
aOp
[4].
p2
 = 
pTab
->
nCol
;

51787 
pParse
->
nVar
 = 1;

51788 
pParse
->
nMem
 = 1;

51789 
pParse
->
nTab
 = 1;

51790 
	`sqlite3VdbeMakeReady
(
v
, 
pParse
);

51794 
pBlob
->
flags
 = flags;

51795 
pBlob
->
iCol
 = iCol;

51796 
pBlob
->
db
 = db;

51797 
	`sqlite3BtreeLeaveAll
(
db
);

51798 if( 
db
->
mallocFailed
 )

51801 goto 
blob_open_out
;

51803 
	`sqlite3_bind_int64
(
pBlob
->
pStmt
, 1, 
iRow
);

51804 
rc
 = 
	`blobSeekToRow
(
pBlob
, 
iRow
, &
zErr
);

51805 } while( (++
nAttempt
)<50 && 
rc
==17 );

51807 
blob_open_out
:

51808 if( 
rc
==0 && 
db
->
mallocFailed
==0 )

51811 *
ppBlob
 = (
sqlite3_blob
 *)
pBlob
;

51813 if( 
pBlob
 && pBlob->
pStmt
 ) 
	`sqlite3VdbeFinalize
((
Vdbe
 *)pBlob->pStmt);

51814 
	`sqlite3DbFree
(
db
, 
pBlob
);

51816 
	`sqlite3ErrorWithMsg
(
db
, 
rc
, (
zErr
 ? "%s" : 0), zErr);

51817 
	`sqlite3DbFree
(
db
, 
zErr
);

51818 
	`sqlite3ParserReset
(
pParse
);

51819 
	`sqlite3DbFree
(
db
,
pParse
);

51820 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

51821 
	`sqlite3_mutex_leave
(
db
->
mutex
);

51822 return 
rc
;

51823 
	}
}

51829 int 
	$sqlite3_blob_close
(
sqlite3_blob
 *
pBlob
)

51832 
Incrblob
 *
p
 = (Incrblob *)
pBlob
;

51833 int 
rc
;

51834 
sqlite3
 *
db
;

51836 if( 
p
 )

51839 
db
 = 
p
->db;

51840 
	`sqlite3_mutex_enter
(
db
->
mutex
);

51841 
rc
 = 
	`sqlite3_finalize
(
p
->
pStmt
);

51842 
	`sqlite3DbFree
(
db
, 
p
);

51843 
	`sqlite3_mutex_leave
(
db
->
mutex
);

51845 
rc
 = 0;

51847 return 
rc
;

51848 
	}
}

51853 static int 
blobReadWrite
(

51854 
sqlite3_blob
 *
pBlob
,

51855 void *
z
,

51856 int 
n
,

51857 int 
iOffset
,

51858 int (*
xCall
)(
BtCursor
*, 
u32
, u32, void*)

51862 int 
rc
;

51863 
Incrblob
 *
p
 = (Incrblob *)
pBlob
;

51864 
Vdbe
 *
v
;

51865 
sqlite3
 *
db
;

51867 if( 
p
==0 ) return 
	`sqlite3MisuseError
(81735);

51868 
db
 = 
p
->db;

51869 
	`sqlite3_mutex_enter
(
db
->
mutex
);

51870 
v
 = (
Vdbe
*)
p
->
pStmt
;

51872 if( 
n
<0 || 
iOffset
<0 || ((
sqlite3_int64
)iOffset+n)>
p
->
nByte
 )

51876 
rc
 = 1;

51877 }else if( 
v
==0 )

51883 
rc
 = 4;

51889 
	`sqlite3BtreeEnterCursor
(
p
->
pCsr
);

51890 
rc
 = 
	`xCall
(
p
->
pCsr
, 
iOffset
+p->iOffset, 
n
, 
z
);

51891 
	`sqlite3BtreeLeaveCursor
(
p
->
pCsr
);

51892 if( 
rc
==4 )

51895 
	`sqlite3VdbeFinalize
(
v
);

51896 
p
->
pStmt
 = 0;

51898 
v
->
rc
 = rc;

51901 
	`sqlite3Error
(
db
, 
rc
);

51902 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

51903 
	`sqlite3_mutex_leave
(
db
->
mutex
);

51904 return 
rc
;

51905 
	}
}

51910 int 
	$sqlite3_blob_read
(
sqlite3_blob
 *
pBlob
, void *
z
, int 
n
, int 
iOffset
)

51913 return 
	`blobReadWrite
(
pBlob
, 
z
, 
n
, 
iOffset
, 
sqlite3BtreeData
);

51914 
	}
}

51919 int 
	$sqlite3_blob_write
(
sqlite3_blob
 *
pBlob
, const void *
z
, int 
n
, int 
iOffset
)

51922 return 
	`blobReadWrite
(
pBlob
, (void *)
z
, 
n
, 
iOffset
, 
sqlite3BtreePutData
);

51923 
	}
}

51931 int 
	$sqlite3_blob_bytes
(
sqlite3_blob
 *
pBlob
)

51934 
Incrblob
 *
p
 = (Incrblob *)
pBlob
;

51935 return (
p
 && p->
pStmt
) ? p->
nByte
 : 0;

51936 
	}
}

51938 int 
	$sqlite3_blob_reopen
(
sqlite3_blob
 *
pBlob
, 
sqlite3_int64
 
iRow
)

51941 int 
rc
;

51942 
Incrblob
 *
p
 = (Incrblob *)
pBlob
;

51943 
sqlite3
 *
db
;

51945 if( 
p
==0 ) return 
	`sqlite3MisuseError
(81809);

51946 
db
 = 
p
->db;

51947 
	`sqlite3_mutex_enter
(
db
->
mutex
);

51949 if( 
p
->
pStmt
==0 )

51955 
rc
 = 4;

51957 char *
zErr
;

51958 
rc
 = 
	`blobSeekToRow
(
p
, 
iRow
, &
zErr
);

51959 if( 
rc
!=0 )

51962 
	`sqlite3ErrorWithMsg
(
db
, 
rc
, (
zErr
 ? "%s" : 0), zErr);

51963 
	`sqlite3DbFree
(
db
, 
zErr
);

51968 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

51970 
	`sqlite3_mutex_leave
(
db
->
mutex
);

51971 return 
rc
;

51972 
	}
}

51974 typedef struct 
MergeEngine
 
	tMergeEngine
;

51975 typedef struct 
PmaReader
 
	tPmaReader
;

51976 typedef struct 
PmaWriter
 
	tPmaWriter
;

51977 typedef struct 
SorterRecord
 
	tSorterRecord
;

51978 typedef struct 
SortSubtask
 
	tSortSubtask
;

51979 typedef struct 
SorterFile
 
	tSorterFile
;

51980 typedef struct 
SorterList
 
	tSorterList
;

51981 typedef struct 
IncrMerger
 
	tIncrMerger
;

51987 struct 
	sSorterFile
 {

51988 
sqlite3_file
 *
	mpFd
;

51989 
i64
 
	miEof
;

51992 struct 
	sSorterList
 {

51993 
SorterRecord
 *
	mpList
;

51994 
u8
 *
	maMemory
;

51995 int 
	mszPMA
;

51998 struct 
	sMergeEngine
 {

51999 int 
	mnTree
;

52000 
SortSubtask
 *
	mpTask
;

52001 int *
	maTree
;

52002 
PmaReader
 *
	maReadr
;

52005 typedef int (*
	tSorterCompare
)(
	tSortSubtask
*,int*,const void*,int,const void*,int);

52006 struct 
	sSortSubtask
 {

52007 
SQLiteThread
 *
pThread
;

52008 int 
bDone
;

52009 
VdbeSorter
 *
pSorter
;

52010 
UnpackedRecord
 *
pUnpacked
;

52011 
SorterList
 
list
;

52012 int 
nPMA
;

52013 
SorterCompare
 
xCompare
;

52014 
SorterFile
 
file
;

52015 
SorterFile
 
file2
;

52018 struct 
	sVdbeSorter
 {

52019 int 
mnPmaSize
;

52020 int 
mxPmaSize
;

52021 int 
mxKeysize
;

52022 int 
pgsz
;

52023 
PmaReader
 *
pReader
;

52024 
MergeEngine
 *
pMerger
;

52025 
sqlite3
 *
db
;

52026 
KeyInfo
 *
pKeyInfo
;

52027 
UnpackedRecord
 *
pUnpacked
;

52028 
SorterList
 
list
;

52029 int 
iMemory
;

52030 int 
nMemory
;

52031 
u8
 
bUsePMA
;

52032 
u8
 
bUseThreads
;

52033 
u8
 
iPrev
;

52034 
u8
 
nTask
;

52035 
u8
 
typeMask
;

52036 
SortSubtask
 
aTask
[1];

52039 struct 
	sPmaReader
 {

52040 
i64
 
iReadOff
;

52041 
i64
 
iEof
;

52042 int 
nAlloc
;

52043 int 
nKey
;

52044 
sqlite3_file
 *
pFd
;

52045 
u8
 *
aAlloc
;

52046 
u8
 *
aKey
;

52047 
u8
 *
aBuffer
;

52048 int 
nBuffer
;

52049 
u8
 *
aMap
;

52050 
IncrMerger
 *
pIncr
;

52053 struct 
	sIncrMerger
 {

52054 
SortSubtask
 *
pTask
;

52055 
MergeEngine
 *
pMerger
;

52056 
i64
 
iStartOff
;

52057 int 
mxSz
;

52058 int 
bEof
;

52059 int 
bUseThread
;

52060 
SorterFile
 
aFile
[2];

52063 struct 
	sPmaWriter
 {

52064 int 
eFWErr
;

52065 
u8
 *
aBuffer
;

52066 int 
nBuffer
;

52067 int 
iBufStart
;

52068 int 
iBufEnd
;

52069 
i64
 
iWriteOff
;

52070 
sqlite3_file
 *
pFd
;

52073 struct 
	sSorterRecord
 {

52074 int 
nVal
;

52076 
SorterRecord
 *
pNext
;

52077 int 
iNext
;

52078 } 
u
;

52082 static int 
	`vdbeIncrSwap
(
IncrMerger
*);

52083 static void 
	`vdbeIncrFree
(
IncrMerger
 *);

52089 static void 
	$vdbePmaReaderClear
(
PmaReader
 *
pReadr
)

52092 
	`sqlite3_free
(
pReadr
->
aAlloc
);

52093 
	`sqlite3_free
(
pReadr
->
aBuffer
);

52094 if( 
pReadr
->
aMap
 ) 
	`sqlite3OsUnfetch
(pReadr->
pFd
, 0, pReadr->aMap);

52095 
	`vdbeIncrFree
(
pReadr
->
pIncr
);

52096 
	`memset
(
pReadr
, 0, sizeof(
PmaReader
));

52097 
	}
}

52099 static int 
	$vdbePmaReadBlob
(

52100 
PmaReader
 *
p
,

52101 int 
nByte
,

52102 
u8
 **
ppOut


52106 int 
iBuf
;

52107 int 
nAvail
;

52109 if( 
p
->
aMap
 )

52112 *
ppOut
 = &
p
->
aMap
[p->
iReadOff
];

52113 
p
->
iReadOff
 += 
nByte
;

52122 
iBuf
 = 
p
->
iReadOff
 % p->
nBuffer
;

52123 if( 
iBuf
==0 )

52126 int 
nRead
;

52127 int 
rc
;

52130 if( (
p
->
iEof
 - p->
iReadOff
) > (
i64
)p->
nBuffer
 )

52133 
nRead
 = 
p
->
nBuffer
;

52135 
nRead
 = (int)(
p
->
iEof
 - p->
iReadOff
);

52140 
rc
 = 
	`sqlite3OsRead
(
p
->
pFd
, p->
aBuffer
, 
nRead
, p->
iReadOff
);

52142 if( 
rc
!=0 ) return rc;

52144 
nAvail
 = 
p
->
nBuffer
 - 
iBuf
;

52146 if( 
nByte
<=
nAvail
 )

52152 *
ppOut
 = &
p
->
aBuffer
[
iBuf
];

52153 
p
->
iReadOff
 += 
nByte
;

52158 int 
nRem
;

52161 if( 
p
->
nAlloc
<
nByte
 )

52164 
u8
 *
aNew
;

52165 int 
nNew
 = ((128)>(
p
->
nAlloc
*2)?(128):(p->nAlloc*2));

52166 while( 
nByte
>
nNew
 ) nNew = nNew*2;

52167 
aNew
 = 
	`sqlite3Realloc
(
p
->
aAlloc
, 
nNew
);

52168 if( !
aNew
 ) return 7;

52169 
p
->
nAlloc
 = 
nNew
;

52170 
p
->
aAlloc
 = 
aNew
;

52175 
	`memcpy
(
p
->
aAlloc
, &p->
aBuffer
[
iBuf
], 
nAvail
);

52176 
p
->
iReadOff
 += 
nAvail
;

52177 
nRem
 = 
nByte
 - 
nAvail
;

52181 while( 
nRem
>0 )

52184 int 
rc
;

52185 int 
nCopy
;

52186 
u8
 *
aNext
;

52188 
nCopy
 = 
nRem
;

52189 if( 
nRem
>
p
->
nBuffer
 ) 
nCopy
 = p->nBuffer;

52190 
rc
 = 
	`vdbePmaReadBlob
(
p
, 
nCopy
, &
aNext
);

52191 if( 
rc
!=0 ) return rc;

52193 
	`memcpy
(&
p
->
aAlloc
[
nByte
 - 
nRem
], 
aNext
, 
nCopy
);

52194 
nRem
 -= 
nCopy
;

52197 *
ppOut
 = 
p
->
aAlloc
;

52201 
	}
}

52207 static int 
	$vdbePmaReadVarint
(
PmaReader
 *
p
, 
u64
 *
pnOut
)

52210 int 
iBuf
;

52212 if( 
p
->
aMap
 )

52215 
p
->
iReadOff
 += 
	`sqlite3GetVarint
(&p->
aMap
[p->iReadOff], 
pnOut
);

52217 
iBuf
 = 
p
->
iReadOff
 % p->
nBuffer
;

52218 if( 
iBuf
 && (
p
->
nBuffer
-iBuf)>=9 )

52221 
p
->
iReadOff
 += 
	`sqlite3GetVarint
(&p->
aBuffer
[
iBuf
], 
pnOut
);

52223 
u8
 
aVarint
[16], *
a
;

52224 int 
i
 = 0, 
rc
;

52226 
rc
 = 
	`vdbePmaReadBlob
(
p
, 1, &
a
);

52227 if( 
rc
 ) return rc;

52228 
aVarint
[(
i
++)&0xf] = 
a
[0];

52229 }while( (
a
[0]&0x80)!=0 );

52230 
	`sqlite3GetVarint
(
aVarint
, 
pnOut
);

52235 
	}
}

52237 static int 
	$vdbeSorterMapFile
(
SortSubtask
 *
pTask
, 
SorterFile
 *
pFile
, 
u8
 **
pp
)

52240 int 
rc
 = 0;

52241 if( 
pFile
->
iEof
<=(
i64
)(
pTask
->
pSorter
->
db
->
nMaxSorterMmap
) )

52244 
sqlite3_file
 *
pFd
 = 
pFile
->pFd;

52245 if( 
pFd
->
pMethods
->
iVersion
>=3 )

52248 
rc
 = 
	`sqlite3OsFetch
(
pFd
, 0, (int)
pFile
->
iEof
, (void**)
pp
);

52252 return 
rc
;

52253 
	}
}

52260 static int 
	$vdbePmaReaderSeek
(

52261 
SortSubtask
 *
pTask
,

52262 
PmaReader
 *
pReadr
,

52263 
SorterFile
 *
pFile
,

52264 
i64
 
iOff


52268 int 
rc
 = 0;

52272 if( 
	`sqlite3FaultSim
(201) ) return (10 | (1<<8));

52273 if( 
pReadr
->
aMap
 )

52276 
	`sqlite3OsUnfetch
(
pReadr
->
pFd
, 0, pReadr->
aMap
);

52277 
pReadr
->
aMap
 = 0;

52279 
pReadr
->
iReadOff
 = 
iOff
;

52280 
pReadr
->
iEof
 = 
pFile
->iEof;

52281 
pReadr
->
pFd
 = 
pFile
->pFd;

52283 
rc
 = 
	`vdbeSorterMapFile
(
pTask
, 
pFile
, &
pReadr
->
aMap
);

52284 if( 
rc
==0 && 
pReadr
->
aMap
==0 )

52287 int 
pgsz
 = 
pTask
->
pSorter
->pgsz;

52288 int 
iBuf
 = 
pReadr
->
iReadOff
 % 
pgsz
;

52289 if( 
pReadr
->
aBuffer
==0 )

52292 
pReadr
->
aBuffer
 = (
u8
*)
	`sqlite3Malloc
(
pgsz
);

52293 if( 
pReadr
->
aBuffer
==0 ) 
rc
 = 7;

52294 
pReadr
->
nBuffer
 = 
pgsz
;

52296 if( 
rc
==0 && 
iBuf
 )

52299 int 
nRead
 = 
pgsz
 - 
iBuf
;

52300 if( (
pReadr
->
iReadOff
 + 
nRead
) > pReadr->
iEof
 )

52303 
nRead
 = (int)(
pReadr
->
iEof
 - pReadr->
iReadOff
);

52305 
rc
 = 
	`sqlite3OsRead
(

52306 
pReadr
->
pFd
, &pReadr->
aBuffer
[
iBuf
], 
nRead
, pReadr->
iReadOff


52312 return 
rc
;

52313 
	}
}

52319 static int 
	$vdbePmaReaderNext
(
PmaReader
 *
pReadr
)

52322 int 
rc
 = 0;

52323 
u64
 
nRec
 = 0;

52326 if( 
pReadr
->
iReadOff
>=pReadr->
iEof
 )

52329 
IncrMerger
 *
pIncr
 = 
pReadr
->pIncr;

52330 int 
bEof
 = 1;

52331 if( 
pIncr
 )

52334 
rc
 = 
	`vdbeIncrSwap
(
pIncr
);

52335 if( 
rc
==0 && 
pIncr
->
bEof
==0 )

52338 
rc
 = 
	`vdbePmaReaderSeek
(

52339 
pIncr
->
pTask
, 
pReadr
, &pIncr->
aFile
[0], pIncr->
iStartOff


52341 
bEof
 = 0;

52345 if( 
bEof
 )

52349 
	`vdbePmaReaderClear
(
pReadr
);

52351 return 
rc
;

52355 if( 
rc
==0 )

52358 
rc
 = 
	`vdbePmaReadVarint
(
pReadr
, &
nRec
);

52360 if( 
rc
==0 )

52363 
pReadr
->
nKey
 = (int)
nRec
;

52364 
rc
 = 
	`vdbePmaReadBlob
(
pReadr
, (int)
nRec
, &pReadr->
aKey
);

52368 return 
rc
;

52369 
	}
}

52371 static int 
	$vdbePmaReaderInit
(

52372 
SortSubtask
 *
pTask
,

52373 
SorterFile
 *
pFile
,

52374 
i64
 
iStart
,

52375 
PmaReader
 *
pReadr
,

52376 
i64
 *
pnByte


52380 int 
rc
;

52387 
rc
 = 
	`vdbePmaReaderSeek
(
pTask
, 
pReadr
, 
pFile
, 
iStart
);

52388 if( 
rc
==0 )

52391 
u64
 
nByte
 = 0;

52392 
rc
 = 
	`vdbePmaReadVarint
(
pReadr
, &
nByte
);

52393 
pReadr
->
iEof
 = pReadr->
iReadOff
 + 
nByte
;

52394 *
pnByte
 += 
nByte
;

52397 if( 
rc
==0 )

52400 
rc
 = 
	`vdbePmaReaderNext
(
pReadr
);

52402 return 
rc
;

52403 
	}
}

52410 static int 
	$vdbeSorterCompareTail
(

52411 
SortSubtask
 *
pTask
,

52412 int *
pbKey2Cached
,

52413 const void *
pKey1
, int 
nKey1
,

52414 const void *
pKey2
, int 
nKey2


52418 
UnpackedRecord
 *
r2
 = 
pTask
->
pUnpacked
;

52419 if( *
pbKey2Cached
==0 )

52422 
	`sqlite3VdbeRecordUnpack
(
pTask
->
pSorter
->
pKeyInfo
, 
nKey2
, 
pKey2
, 
r2
);

52423 *
pbKey2Cached
 = 1;

52425 return 
	`sqlite3VdbeRecordCompareWithSkip
(
nKey1
, 
pKey1
, 
r2
, 1);

52426 
	}
}

52428 static int 
	$vdbeSorterCompare
(

52429 
SortSubtask
 *
pTask
,

52430 int *
pbKey2Cached
,

52431 const void *
pKey1
, int 
nKey1
,

52432 const void *
pKey2
, int 
nKey2


52436 
UnpackedRecord
 *
r2
 = 
pTask
->
pUnpacked
;

52437 if( !*
pbKey2Cached
 )

52440 
	`sqlite3VdbeRecordUnpack
(
pTask
->
pSorter
->
pKeyInfo
, 
nKey2
, 
pKey2
, 
r2
);

52441 *
pbKey2Cached
 = 1;

52443 return 
	`sqlite3VdbeRecordCompare
(
nKey1
, 
pKey1
, 
r2
);

52444 
	}
}

52451 static int 
	$vdbeSorterCompareText
(

52452 
SortSubtask
 *
pTask
,

52453 int *
pbKey2Cached
,

52454 const void *
pKey1
, int 
nKey1
,

52455 const void *
pKey2
, int 
nKey2


52459 const 
u8
 * const 
p1
 = (const u8 * const)
pKey1
;

52460 const 
u8
 * const 
p2
 = (const u8 * const)
pKey2
;

52461 const 
u8
 * const 
v1
 = &
p1
[ p1[0] ];

52462 const 
u8
 * const 
v2
 = &
p2
[ p2[0] ];

52464 int 
n1
;

52465 int 
n2
;

52466 int 
res
;

52468 (
u8
)((*(&
p1
[1])<(u8)0x80)?((
n1
)=(
u32
)*(&p1[1])),1:
	`sqlite3GetVarint32
((&p1[1]),(u32 *)&(n1))); n1 = (n1 - 13) / 2;

52469 (
u8
)((*(&
p2
[1])<(u8)0x80)?((
n2
)=(
u32
)*(&p2[1])),1:
	`sqlite3GetVarint32
((&p2[1]),(u32 *)&(n2))); n2 = (n2 - 13) / 2;

52470 
res
 = 
	`memcmp
(
v1
, 
v2
, ((
n1
)<(
n2
)?(n1):(n2)));

52471 if( 
res
==0 )

52474 
res
 = 
n1
 - 
n2
;

52477 if( 
res
==0 )

52480 if( 
pTask
->
pSorter
->
pKeyInfo
->
nField
>1 )

52483 
res
 = 
	`vdbeSorterCompareTail
(

52484 
pTask
, 
pbKey2Cached
, 
pKey1
, 
nKey1
, 
pKey2
, 
nKey2


52488 if( 
pTask
->
pSorter
->
pKeyInfo
->
aSortOrder
[0] )

52491 
res
 = res * -1;

52495 return 
res
;

52496 
	}
}

52502 static int 
	$vdbeSorterCompareInt
(

52503 
SortSubtask
 *
pTask
,

52504 int *
pbKey2Cached
,

52505 const void *
pKey1
, int 
nKey1
,

52506 const void *
pKey2
, int 
nKey2


52510 const 
u8
 * const 
p1
 = (const u8 * const)
pKey1
;

52511 const 
u8
 * const 
p2
 = (const u8 * const)
pKey2
;

52512 const int 
s1
 = 
p1
[1];

52513 const int 
s2
 = 
p2
[1];

52514 const 
u8
 * const 
v1
 = &
p1
[ p1[0] ];

52515 const 
u8
 * const 
v2
 = &
p2
[ p2[0] ];

52516 int 
res
;

52521 if( 
s1
>7 && 
s2
>7 )

52524 
res
 = 
s1
 - 
s2
;

52526 if( 
s1
==
s2
 )

52529 if( (*
v1
 ^ *
v2
) & 0x80 )

52533 
res
 = (*
v1
 & 0x80) ? -1 : +1;

52536 static const 
u8
 
aLen
[] = {0, 1, 2, 3, 4, 6, 8 };

52537 int 
i
;

52538 
res
 = 0;

52539 for(
i
=0; i<
aLen
[
s1
]; i++)

52542 if( (
res
 = 
v1
[
i
] - 
v2
[i]) ) break;

52546 if( 
s2
>7 )

52549 
res
 = +1;

52550 }else if( 
s1
>7 )

52553 
res
 = -1;

52555 
res
 = 
s1
 - 
s2
;

52559 if( 
res
>0 )

52562 if( *
v1
 & 0x80 ) 
res
 = -1;

52564 if( *
v2
 & 0x80 ) 
res
 = +1;

52569 if( 
res
==0 )

52572 if( 
pTask
->
pSorter
->
pKeyInfo
->
nField
>1 )

52575 
res
 = 
	`vdbeSorterCompareTail
(

52576 
pTask
, 
pbKey2Cached
, 
pKey1
, 
nKey1
, 
pKey2
, 
nKey2


52579 }else if( 
pTask
->
pSorter
->
pKeyInfo
->
aSortOrder
[0] )

52582 
res
 = res * -1;

52585 return 
res
;

52586 
	}
}

52588 static int 
	$sqlite3VdbeSorterInit
(

52589 
sqlite3
 *
db
,

52590 int 
nField
,

52591 
VdbeCursor
 *
pCsr


52595 int 
pgsz
;

52596 int 
i
;

52597 int 
mxCache
;

52598 
VdbeSorter
 *
pSorter
;

52599 
KeyInfo
 *
pKeyInfo
;

52600 int 
szKeyInfo
;

52601 int 
sz
;

52602 int 
rc
 = 0;

52606 int 
nWorker
;

52611 if( 
	`sqlite3TempInMemory
(
db
) || 
sqlite3Config
.
bCoreMutex
==0 )

52614 
nWorker
 = 0;

52616 
nWorker
 = 
db
->
aLimit
[11];

52621 
szKeyInfo
 = sizeof(
KeyInfo
) + (
pCsr
->
pKeyInfo
->
nField
-1)*sizeof(
CollSeq
*);

52622 
sz
 = sizeof(
VdbeSorter
) + 
nWorker
 * sizeof(
SortSubtask
);

52624 
pSorter
 = (
VdbeSorter
*)
	`sqlite3DbMallocZero
(
db
, 
sz
 + 
szKeyInfo
);

52625 
pCsr
->
uc
.
pSorter
 = pSorter;

52626 if( 
pSorter
==0 )

52629 
rc
 = 7;

52631 
pSorter
->
pKeyInfo
 = pKeyInfo = (
KeyInfo
*)((
u8
*)pSorter + 
sz
);

52632 
	`memcpy
(
pKeyInfo
, 
pCsr
->pKeyInfo, 
szKeyInfo
);

52633 
pKeyInfo
->
db
 = 0;

52634 if( 
nField
 && 
nWorker
==0 )

52637 
pKeyInfo
->
nXField
 += (pKeyInfo->
nField
 - nField);

52638 
pKeyInfo
->
nField
 = nField;

52640 
pSorter
->
pgsz
 = pgsz = 
	`sqlite3BtreeGetPageSize
(
db
->
aDb
[0].
pBt
);

52641 
pSorter
->
nTask
 = 
nWorker
 + 1;

52642 
pSorter
->
iPrev
 = (
u8
)(
nWorker
 - 1);

52643 
pSorter
->
bUseThreads
 = (pSorter->
nTask
>1);

52644 
pSorter
->
db
 = db;

52645 for(
i
=0; i<
pSorter
->
nTask
; i++)

52648 
SortSubtask
 *
pTask
 = &
pSorter
->
aTask
[
i
];

52649 
pTask
->
pSorter
 = pSorter;

52652 if( !
	`sqlite3TempInMemory
(
db
) )

52655 
u32
 
szPma
 = 
sqlite3Config
.szPma;

52656 
pSorter
->
mnPmaSize
 = 
szPma
 * 
pgsz
;

52657 
mxCache
 = 
db
->
aDb
[0].
pSchema
->
cache_size
;

52658 if( 
mxCache
<(int)
szPma
 ) mxCache = (int)szPma;

52659 
pSorter
->
mxPmaSize
 = (((
i64
)
mxCache
*
pgsz
)<((1<<29))?((i64)mxCache*pgsz):((1<<29)));

52665 if( 
sqlite3Config
.
pScratch
==0 )

52669 
pSorter
->
nMemory
 = 
pgsz
;

52670 
pSorter
->
list
.
aMemory
 = (
u8
*)
	`sqlite3Malloc
(
pgsz
);

52671 if( !
pSorter
->
list
.
aMemory
 ) 
rc
 = 7;

52675 if( (
pKeyInfo
->
nField
+pKeyInfo->
nXField
)<13

52676 && (
pKeyInfo
->
aColl
[0]==0 || pKeyInfo->aColl[0]==
db
->
pDfltColl
)

52680 
pSorter
->
typeMask
 = 0x01 | 0x02;

52684 return 
rc
;

52685 
	}
}

52691 static void 
	$vdbeSorterRecordFree
(
sqlite3
 *
db
, 
SorterRecord
 *
pRecord
)

52694 
SorterRecord
 *
p
;

52695 
SorterRecord
 *
pNext
;

52696 for(
p
=
pRecord
; p; p=
pNext
)

52699 
pNext
 = 
p
->
u
.pNext;

52700 
	`sqlite3DbFree
(
db
, 
p
);

52702 
	}
}

52708 static void 
	$vdbeSortSubtaskCleanup
(
sqlite3
 *
db
, 
SortSubtask
 *
pTask
)

52711 
	`sqlite3DbFree
(
db
, 
pTask
->
pUnpacked
);

52715 if( 
pTask
->
list
.
aMemory
 )

52718 
	`sqlite3_free
(
pTask
->
list
.
aMemory
);

52723 
	`vdbeSorterRecordFree
(0, 
pTask
->
list
.
pList
);

52725 if( 
pTask
->
file
.
pFd
 )

52728 
	`sqlite3OsCloseFree
(
pTask
->
file
.
pFd
);

52730 if( 
pTask
->
file2
.
pFd
 )

52733 
	`sqlite3OsCloseFree
(
pTask
->
file2
.
pFd
);

52735 
	`memset
(
pTask
, 0, sizeof(
SortSubtask
));

52736 
	}
}

52738 static int 
	$vdbeSorterJoinThread
(
SortSubtask
 *
pTask
)

52741 int 
rc
 = 0;

52742 if( 
pTask
->
pThread
 )

52748 void *
pRet
 = ((void*)(long int)(1));

52750 (void)
	`sqlite3ThreadJoin
(
pTask
->
pThread
, &
pRet
);

52752 
rc
 = ((int)(long int)(
pRet
));

52754 
pTask
->
bDone
 = 0;

52755 
pTask
->
pThread
 = 0;

52757 return 
rc
;

52758 
	}
}

52763 static int 
vdbeSorterCreateThread
(

52764 
SortSubtask
 *
pTask
,

52765 void *(*
xTask
)(void*),

52766 void *
pIn


52771 return 
sqlite3ThreadCreate
(&
pTask
->
pThread
, 
xTask
, 
pIn
);

52778 static int 
	$vdbeSorterJoinAll
(
VdbeSorter
 *
pSorter
, int 
rcin
)

52781 int 
rc
 = 
rcin
;

52782 int 
i
;

52784 for(
i
=
pSorter
->
nTask
-1; i>=0; i--)

52787 
SortSubtask
 *
pTask
 = &
pSorter
->
aTask
[
i
];

52788 int 
rc2
 = 
	`vdbeSorterJoinThread
(
pTask
);

52789 if( 
rc
==0 ) rc = 
rc2
;

52791 return 
rc
;

52792 
	}
}

52794 static 
MergeEngine
 *
	$vdbeMergeEngineNew
(int 
nReader
)

52797 int 
N
 = 2;

52798 int 
nByte
;

52799 
MergeEngine
 *
pNew
;

52803 while( 
N
<
nReader
 ) N += N;

52804 
nByte
 = sizeof(
MergeEngine
) + 
N
 * (sizeof(int) + sizeof(
PmaReader
));

52806 
pNew
 = 
	`sqlite3FaultSim
(100) ? 0 : (
MergeEngine
*)
	`sqlite3MallocZero
(
nByte
);

52807 if( 
pNew
 )

52810 
pNew
->
nTree
 = 
N
;

52811 
pNew
->
pTask
 = 0;

52812 
pNew
->
aReadr
 = (
PmaReader
*)&pNew[1];

52813 
pNew
->
aTree
 = (int*)&pNew->
aReadr
[
N
];

52815 return 
pNew
;

52816 
	}
}

52821 static void 
	$vdbeMergeEngineFree
(
MergeEngine
 *
pMerger
)

52824 int 
i
;

52825 if( 
pMerger
 )

52828 for(
i
=0; i<
pMerger
->
nTree
; i++)

52831 
	`vdbePmaReaderClear
(&
pMerger
->
aReadr
[
i
]);

52834 
	`sqlite3_free
(
pMerger
);

52835 
	}
}

52841 static void 
	$vdbeIncrFree
(
IncrMerger
 *
pIncr
)

52844 if( 
pIncr
 )

52848 if( 
pIncr
->
bUseThread
 )

52851 
	`vdbeSorterJoinThread
(
pIncr
->
pTask
);

52852 if( 
pIncr
->
aFile
[0].
pFd
 ) 
	`sqlite3OsCloseFree
(pIncr->aFile[0].pFd);

52853 if( 
pIncr
->
aFile
[1].
pFd
 ) 
	`sqlite3OsCloseFree
(pIncr->aFile[1].pFd);

52856 
	`vdbeMergeEngineFree
(
pIncr
->
pMerger
);

52857 
	`sqlite3_free
(
pIncr
);

52859 
	}
}

52864 static void 
	$sqlite3VdbeSorterReset
(
sqlite3
 *
db
, 
VdbeSorter
 *
pSorter
)

52867 int 
i
;

52868 (void)
	`vdbeSorterJoinAll
(
pSorter
, 0);

52871 if( 
pSorter
->
pReader
 )

52874 
	`vdbePmaReaderClear
(
pSorter
->
pReader
);

52875 
	`sqlite3DbFree
(
db
, 
pSorter
->
pReader
);

52876 
pSorter
->
pReader
 = 0;

52879 
	`vdbeMergeEngineFree
(
pSorter
->
pMerger
);

52880 
pSorter
->
pMerger
 = 0;

52881 for(
i
=0; i<
pSorter
->
nTask
; i++)

52884 
SortSubtask
 *
pTask
 = &
pSorter
->
aTask
[
i
];

52885 
	`vdbeSortSubtaskCleanup
(
db
, 
pTask
);

52886 
pTask
->
pSorter
 = pSorter;

52888 if( 
pSorter
->
list
.
aMemory
==0 )

52891 
	`vdbeSorterRecordFree
(0, 
pSorter
->
list
.
pList
);

52893 
pSorter
->
list
.
pList
 = 0;

52894 
pSorter
->
list
.
szPMA
 = 0;

52895 
pSorter
->
bUsePMA
 = 0;

52896 
pSorter
->
iMemory
 = 0;

52897 
pSorter
->
mxKeysize
 = 0;

52898 
	`sqlite3DbFree
(
db
, 
pSorter
->
pUnpacked
);

52899 
pSorter
->
pUnpacked
 = 0;

52900 
	}
}

52905 static void 
	$sqlite3VdbeSorterClose
(
sqlite3
 *
db
, 
VdbeCursor
 *
pCsr
)

52908 
VdbeSorter
 *
pSorter
;

52910 
pSorter
 = 
pCsr
->
uc
.pSorter;

52911 if( 
pSorter
 )

52914 
	`sqlite3VdbeSorterReset
(
db
, 
pSorter
);

52915 
	`sqlite3_free
(
pSorter
->
list
.
aMemory
);

52916 
	`sqlite3DbFree
(
db
, 
pSorter
);

52917 
pCsr
->
uc
.
pSorter
 = 0;

52919 
	}
}

52921 static void 
	$vdbeSorterExtendFile
(
sqlite3
 *
db
, 
sqlite3_file
 *
pFd
, 
i64
 
nByte
)

52924 if( 
nByte
<=(
i64
)(
db
->
nMaxSorterMmap
) && 
pFd
->
pMethods
->
iVersion
>=3 )

52927 void *
p
 = 0;

52928 int 
chunksize
 = 4*1024;

52929 
	`sqlite3OsFileControlHint
(
pFd
, 6, &
chunksize
);

52930 
	`sqlite3OsFileControlHint
(
pFd
, 5, &
nByte
);

52931 
	`sqlite3OsFetch
(
pFd
, 0, (int)
nByte
, &
p
);

52932 
	`sqlite3OsUnfetch
(
pFd
, 0, 
p
);

52934 
	}
}

52936 static int 
	$vdbeSorterOpenTempFile
(

52937 
sqlite3
 *
db
,

52938 
i64
 
nExtend
,

52939 
sqlite3_file
 **
ppFd


52943 int 
rc
;

52944 if( 
	`sqlite3FaultSim
(202) ) return (10 | (13<<8));

52945 
rc
 = 
	`sqlite3OsOpenMalloc
(
db
->
pVfs
, 0, 
ppFd
,

52948 0x00000010 | 0x00000008, &
rc


52950 if( 
rc
==0 )

52953 
i64
 
max
 = 0x7fff0000;

52954 
	`sqlite3OsFileControlHint
(*
ppFd
, 18, (void*)&
max
);

52955 if( 
nExtend
>0 )

52958 
	`vdbeSorterExtendFile
(
db
, *
ppFd
, 
nExtend
);

52961 return 
rc
;

52962 
	}
}

52969 static int 
	$vdbeSortAllocUnpacked
(
SortSubtask
 *
pTask
)

52972 if( 
pTask
->
pUnpacked
==0 )

52975 char *
pFree
;

52976 
pTask
->
pUnpacked
 = 
	`sqlite3VdbeAllocUnpackedRecord
(

52977 
pTask
->
pSorter
->
pKeyInfo
, 0, 0, &
pFree


52980 if( 
pFree
==0 ) return 7;

52981 
pTask
->
pUnpacked
->
nField
 = pTask->
pSorter
->
pKeyInfo
->nField;

52982 
pTask
->
pUnpacked
->
errCode
 = 0;

52985 
	}
}

52992 static void 
	$vdbeSorterMerge
(

52993 
SortSubtask
 *
pTask
,

52994 
SorterRecord
 *
p1
,

52995 
SorterRecord
 *
p2
,

52996 
SorterRecord
 **
ppOut


53000 
SorterRecord
 *
pFinal
 = 0;

53001 
SorterRecord
 **
pp
 = &
pFinal
;

53002 int 
bCached
 = 0;

53004 while( 
p1
 && 
p2
 )

53007 int 
res
;

53008 
res
 = 
pTask
->
	`xCompare
(

53009 
pTask
, &
bCached
, ((void*)((
SorterRecord
*)(
p1
) + 1)), p1->
nVal
, ((void*)((SorterRecord*)(
p2
) + 1)), p2->nVal

53012 if( 
res
<=0 )

53015 *
pp
 = 
p1
;

53016 
pp
 = &
p1
->
u
.
pNext
;

53017 
p1
 = p1->
u
.
pNext
;

53019 *
pp
 = 
p2
;

53020 
pp
 = &
p2
->
u
.
pNext
;

53021 
p2
 = p2->
u
.
pNext
;

53022 
bCached
 = 0;

53025 *
pp
 = 
p1
 ? p1 : 
p2
;

53026 *
ppOut
 = 
pFinal
;

53027 
	}
}

53033 static 
SorterCompare
 
	$vdbeSorterGetCompare
(
VdbeSorter
 *
p
)

53036 if( 
p
->
typeMask
==0x01 )

53039 return 
vdbeSorterCompareInt
;

53040 }else if( 
p
->
typeMask
==0x02 )

53043 return 
vdbeSorterCompareText
;

53045 return 
vdbeSorterCompare
;

53046 
	}
}

53053 static int 
	$vdbeSorterSort
(
SortSubtask
 *
pTask
, 
SorterList
 *
pList
)

53056 int 
i
;

53057 
SorterRecord
 **
aSlot
;

53058 
SorterRecord
 *
p
;

53059 int 
rc
;

53061 
rc
 = 
	`vdbeSortAllocUnpacked
(
pTask
);

53062 if( 
rc
!=0 ) return rc;

53064 
p
 = 
pList
->pList;

53065 
pTask
->
xCompare
 = 
	`vdbeSorterGetCompare
(pTask->
pSorter
);

53067 
aSlot
 = (
SorterRecord
 **)
	`sqlite3MallocZero
(64 * sizeof(SorterRecord *));

53068 if( !
aSlot
 )

53074 while( 
p
 )

53077 
SorterRecord
 *
pNext
;

53078 if( 
pList
->
aMemory
 )

53081 if( (
u8
*)
p
==
pList
->
aMemory
 )

53084 
pNext
 = 0;

53087 
pNext
 = (
SorterRecord
*)&
pList
->
aMemory
[
p
->
u
.
iNext
];

53090 
pNext
 = 
p
->
u
.pNext;

53093 
p
->
u
.
pNext
 = 0;

53094 for(
i
=0; 
aSlot
[i]; i++)

53097 
	`vdbeSorterMerge
(
pTask
, 
p
, 
aSlot
[
i
], &p);

53098 
aSlot
[
i
] = 0;

53100 
aSlot
[
i
] = 
p
;

53101 
p
 = 
pNext
;

53104 
p
 = 0;

53105 for(
i
=0; i<64; i++)

53108 
	`vdbeSorterMerge
(
pTask
, 
p
, 
aSlot
[
i
], &p);

53110 
pList
->pList = 
p
;

53112 
	`sqlite3_free
(
aSlot
);

53116 return 
pTask
->
pUnpacked
->
errCode
;

53117 
	}
}

53122 static void 
	$vdbePmaWriterInit
(

53123 
sqlite3_file
 *
pFd
,

53124 
PmaWriter
 *
p
,

53125 int 
nBuf
,

53126 
i64
 
iStart


53130 
	`memset
(
p
, 0, sizeof(
PmaWriter
));

53131 
p
->
aBuffer
 = (
u8
*)
	`sqlite3Malloc
(
nBuf
);

53132 if( !
p
->
aBuffer
 )

53135 
p
->
eFWErr
 = 7;

53137 
p
->
iBufEnd
 = p->
iBufStart
 = (
iStart
 % 
nBuf
);

53138 
p
->
iWriteOff
 = 
iStart
 - p->
iBufStart
;

53139 
p
->
nBuffer
 = 
nBuf
;

53140 
p
->
pFd
 = pFd;

53142 
	}
}

53148 static void 
	$vdbePmaWriteBlob
(
PmaWriter
 *
p
, 
u8
 *
pData
, int 
nData
)

53151 int 
nRem
 = 
nData
;

53152 while( 
nRem
>0 && 
p
->
eFWErr
==0 )

53155 int 
nCopy
 = 
nRem
;

53156 if( 
nCopy
>(
p
->
nBuffer
 - p->
iBufEnd
) )

53159 
nCopy
 = 
p
->
nBuffer
 - p->
iBufEnd
;

53162 
	`memcpy
(&
p
->
aBuffer
[p->
iBufEnd
], &
pData
[
nData
-
nRem
], 
nCopy
);

53163 
p
->
iBufEnd
 += 
nCopy
;

53164 if( 
p
->
iBufEnd
==p->
nBuffer
 )

53167 
p
->
eFWErr
 = 
	`sqlite3OsWrite
(p->
pFd
,

53168 &
p
->
aBuffer
[p->
iBufStart
], p->
iBufEnd
 - p->iBufStart,

53169 
p
->
iWriteOff
 + p->
iBufStart


53171 
p
->
iBufStart
 = p->
iBufEnd
 = 0;

53172 
p
->
iWriteOff
 += p->
nBuffer
;

53176 
nRem
 -= 
nCopy
;

53178 
	}
}

53180 static int 
	$vdbePmaWriterFinish
(
PmaWriter
 *
p
, 
i64
 *
piEof
)

53183 int 
rc
;

53184 if( 
p
->
eFWErr
==0 && (p->
aBuffer
) && p->
iBufEnd
>p->
iBufStart
 )

53187 
p
->
eFWErr
 = 
	`sqlite3OsWrite
(p->
pFd
,

53188 &
p
->
aBuffer
[p->
iBufStart
], p->
iBufEnd
 - p->iBufStart,

53189 
p
->
iWriteOff
 + p->
iBufStart


53192 *
piEof
 = (
p
->
iWriteOff
 + p->
iBufEnd
);

53193 
	`sqlite3_free
(
p
->
aBuffer
);

53194 
rc
 = 
p
->
eFWErr
;

53195 
	`memset
(
p
, 0, sizeof(
PmaWriter
));

53196 return 
rc
;

53197 
	}
}

53203 static void 
	$vdbePmaWriteVarint
(
PmaWriter
 *
p
, 
u64
 
iVal
)

53206 int 
nByte
;

53207 
u8
 
aByte
[10];

53208 
nByte
 = 
	`sqlite3PutVarint
(
aByte
, 
iVal
);

53209 
	`vdbePmaWriteBlob
(
p
, 
aByte
, 
nByte
);

53210 
	}
}

53212 static int 
	$vdbeSorterListToPMA
(
SortSubtask
 *
pTask
, 
SorterList
 *
pList
)

53215 
sqlite3
 *
db
 = 
pTask
->
pSorter
->db;

53216 int 
rc
 = 0;

53217 
PmaWriter
 
writer
;

53226 
	`memset
(&
writer
, 0, sizeof(
PmaWriter
));

53230 if( 
pTask
->
file
.
pFd
==0 )

53233 
rc
 = 
	`vdbeSorterOpenTempFile
(
db
, 0, &
pTask
->
file
.
pFd
);

53240 if( 
rc
==0 )

53243 
	`vdbeSorterExtendFile
(
db
, 
pTask
->
file
.
pFd
, pTask->file.
iEof
+
pList
->
szPMA
+9);

53247 if( 
rc
==0 )

53250 
rc
 = 
	`vdbeSorterSort
(
pTask
, 
pList
);

53253 if( 
rc
==0 )

53256 
SorterRecord
 *
p
;

53257 
SorterRecord
 *
pNext
 = 0;

53259 
	`vdbePmaWriterInit
(
pTask
->
file
.
pFd
, &
writer
, pTask->
pSorter
->
pgsz
,

53260 
pTask
->
file
.
iEof
);

53261 
pTask
->
nPMA
++;

53262 
	`vdbePmaWriteVarint
(&
writer
, 
pList
->
szPMA
);

53263 for(
p
=
pList
->pList; p; p=
pNext
)

53266 
pNext
 = 
p
->
u
.pNext;

53267 
	`vdbePmaWriteVarint
(&
writer
, 
p
->
nVal
);

53268 
	`vdbePmaWriteBlob
(&
writer
, ((void*)((
SorterRecord
*)(
p
) + 1)), p->
nVal
);

53269 if( 
pList
->
aMemory
==0 ) 
	`sqlite3_free
(
p
);

53271 
pList
->pList = 
p
;

53272 
rc
 = 
	`vdbePmaWriterFinish
(&
writer
, &
pTask
->
file
.
iEof
);

53278 return 
rc
;

53279 
	}
}

53281 static int 
	$vdbeMergeEngineStep
(

53282 
MergeEngine
 *
pMerger
,

53283 int *
pbEof


53287 int 
rc
;

53288 int 
iPrev
 = 
pMerger
->
aTree
[1];

53289 
SortSubtask
 *
pTask
 = 
pMerger
->pTask;

53292 
rc
 = 
	`vdbePmaReaderNext
(&
pMerger
->
aReadr
[
iPrev
]);

53295 if( 
rc
==0 )

53298 int 
i
;

53299 
PmaReader
 *
pReadr1
;

53300 
PmaReader
 *
pReadr2
;

53301 int 
bCached
 = 0;

53305 
pReadr1
 = &
pMerger
->
aReadr
[(
iPrev
 & 0xFFFE)];

53306 
pReadr2
 = &
pMerger
->
aReadr
[(
iPrev
 | 0x0001)];

53308 for(
i
=(
pMerger
->
nTree
+
iPrev
)/2; i>0; i=i/2)

53312 int 
iRes
;

53313 if( 
pReadr1
->
pFd
==0 )

53316 
iRes
 = +1;

53317 }else if( 
pReadr2
->
pFd
==0 )

53320 
iRes
 = -1;

53322 
iRes
 = 
pTask
->
	`xCompare
(pTask, &
bCached
,

53323 
pReadr1
->
aKey
, pReadr1->
nKey
, 
pReadr2
->aKey, pReadr2->nKey

53327 if( 
iRes
<0 || (iRes==0 && 
pReadr1
<
pReadr2
) )

53330 
pMerger
->
aTree
[
i
] = (int)(
pReadr1
 - pMerger->
aReadr
);

53331 
pReadr2
 = &
pMerger
->
aReadr
[ pMerger->
aTree
[
i
 ^ 0x0001] ];

53332 
bCached
 = 0;

53334 if( 
pReadr1
->
pFd
 ) 
bCached
 = 0;

53335 
pMerger
->
aTree
[
i
] = (int)(
pReadr2
 - pMerger->
aReadr
);

53336 
pReadr1
 = &
pMerger
->
aReadr
[ pMerger->
aTree
[
i
 ^ 0x0001] ];

53339 *
pbEof
 = (
pMerger
->
aReadr
[pMerger->
aTree
[1]].
pFd
==0);

53342 return (
rc
==0 ? 
pTask
->
pUnpacked
->
errCode
 : rc);

53343 
	}
}

53349 static void *
	$vdbeSorterFlushThread
(void *
pCtx
)

53352 
SortSubtask
 *
pTask
 = (SortSubtask*)
pCtx
;

53353 int 
rc
;

53355 
rc
 = 
	`vdbeSorterListToPMA
(
pTask
, &pTask->
list
);

53356 
pTask
->
bDone
 = 1;

53357 return ((void*)(long int)(
rc
));

53358 
	}
}

53365 static int 
	$vdbeSorterFlushPMA
(
VdbeSorter
 *
pSorter
)

53372 int 
rc
 = 0;

53373 int 
i
;

53374 
SortSubtask
 *
pTask
 = 0;

53375 int 
nWorker
 = (
pSorter
->
nTask
-1);

53379 
pSorter
->
bUsePMA
 = 1;

53381 for(
i
=0; i<
nWorker
; i++)

53384 int 
iTest
 = (
pSorter
->
iPrev
 + 
i
 + 1) % 
nWorker
;

53385 
pTask
 = &
pSorter
->
aTask
[
iTest
];

53386 if( 
pTask
->
bDone
 )

53389 
rc
 = 
	`vdbeSorterJoinThread
(
pTask
);

53391 if( 
rc
!=0 || 
pTask
->
pThread
==0 ) break;

53394 if( 
rc
==0 )

53397 if( 
i
==
nWorker
 )

53401 
rc
 = 
	`vdbeSorterListToPMA
(&
pSorter
->
aTask
[
nWorker
], &pSorter->
list
);

53404 
u8
 *
aMem
 = 
pTask
->
list
.
aMemory
;

53405 void *
pCtx
 = (void*)
pTask
;

53411 
pSorter
->
iPrev
 = (
u8
)(
pTask
 - pSorter->
aTask
);

53412 
pTask
->
list
 = 
pSorter
->list;

53413 
pSorter
->
list
.
pList
 = 0;

53414 
pSorter
->
list
.
szPMA
 = 0;

53415 if( 
aMem
 )

53418 
pSorter
->
list
.
aMemory
 = 
aMem
;

53419 
pSorter
->
nMemory
 = 
	`sqlite3MallocSize
(
aMem
);

53420 }else if( 
pSorter
->
list
.
aMemory
 )

53423 
pSorter
->
list
.
aMemory
 = 
	`sqlite3Malloc
(pSorter->
nMemory
);

53424 if( !
pSorter
->
list
.
aMemory
 ) return 7;

53427 
rc
 = 
	`vdbeSorterCreateThread
(
pTask
, 
vdbeSorterFlushThread
, 
pCtx
);

53431 return 
rc
;

53433 
	}
}

53438 static int 
	$sqlite3VdbeSorterWrite
(

53439 const 
VdbeCursor
 *
pCsr
,

53440 
Mem
 *
pVal


53444 
VdbeSorter
 *
pSorter
;

53445 int 
rc
 = 0;

53446 
SorterRecord
 *
pNew
;

53447 int 
bFlush
;

53448 int 
nReq
;

53449 int 
nPMA
;

53450 int 
t
;

53453 
pSorter
 = 
pCsr
->
uc
.pSorter;

53454 (
u8
)((*((const u8*)&
pVal
->
z
[1])<(u8)0x80)?((
t
)=(
u32
)*((const u8*)&pVal->z[1])),1:
	`sqlite3GetVarint32
(((const u8*)&pVal->z[1]),(u32 *)&(t)));

53455 if( 
t
>0 && t<10 && t!=7 )

53458 
pSorter
->
typeMask
 &= 0x01;

53459 }else if( 
t
>10 && (t & 0x01) )

53462 
pSorter
->
typeMask
 &= 0x02;

53464 
pSorter
->
typeMask
 = 0;

53469 
nReq
 = 
pVal
->
n
 + sizeof(
SorterRecord
);

53470 
nPMA
 = 
pVal
->
n
 + 
	`sqlite3VarintLen
(pVal->n);

53471 if( 
pSorter
->
mxPmaSize
 )

53474 if( 
pSorter
->
list
.
aMemory
 )

53477 
bFlush
 = 
pSorter
->
iMemory
 && (pSorter->iMemory+
nReq
) > pSorter->
mxPmaSize
;

53479 
bFlush
 = (

53480 (
pSorter
->
list
.
szPMA
 > pSorter->
mxPmaSize
)

53481 || (
pSorter
->
list
.
szPMA
 > pSorter->
mnPmaSize
 && 
	`sqlite3HeapNearlyFull
())

53484 if( 
bFlush
 )

53487 
rc
 = 
	`vdbeSorterFlushPMA
(
pSorter
);

53488 
pSorter
->
list
.
szPMA
 = 0;

53489 
pSorter
->
iMemory
 = 0;

53494 
pSorter
->
list
.
szPMA
 += 
nPMA
;

53495 if( 
nPMA
>
pSorter
->
mxKeysize
 )

53498 
pSorter
->
mxKeysize
 = 
nPMA
;

53501 if( 
pSorter
->
list
.
aMemory
 )

53504 int 
nMin
 = 
pSorter
->
iMemory
 + 
nReq
;

53506 if( 
nMin
>
pSorter
->
nMemory
 )

53509 
u8
 *
aNew
;

53510 int 
iListOff
 = (
u8
*)
pSorter
->
list
.
pList
 - pSorter->list.
aMemory
;

53511 int 
nNew
 = 
pSorter
->
nMemory
 * 2;

53512 while( 
nNew
 < 
nMin
 ) nNew = nNew*2;

53513 if( 
nNew
 > 
pSorter
->
mxPmaSize
 ) nNew = pSorter->mxPmaSize;

53514 if( 
nNew
 < 
nMin
 ) nNew = nMin;

53516 
aNew
 = 
	`sqlite3Realloc
(
pSorter
->
list
.
aMemory
, 
nNew
);

53517 if( !
aNew
 ) return 7;

53518 
pSorter
->
list
.
pList
 = (
SorterRecord
*)&
aNew
[
iListOff
];

53519 
pSorter
->
list
.
aMemory
 = 
aNew
;

53520 
pSorter
->
nMemory
 = 
nNew
;

53523 
pNew
 = (
SorterRecord
*)&
pSorter
->
list
.
aMemory
[pSorter->
iMemory
];

53524 
pSorter
->
iMemory
 += (((
nReq
)+7)&~7);

53525 if( 
pSorter
->
list
.
pList
 )

53528 
pNew
->
u
.
iNext
 = (int)((
u8
*)(
pSorter
->
list
.
pList
) - pSorter->list.
aMemory
);

53531 
pNew
 = (
SorterRecord
 *)
	`sqlite3Malloc
(
nReq
);

53532 if( 
pNew
==0 )

53537 
pNew
->
u
.
pNext
 = 
pSorter
->
list
.
pList
;

53540 
	`memcpy
(((void*)((
SorterRecord
*)(
pNew
) + 1)), 
pVal
->
z
, pVal->
n
);

53541 
pNew
->
nVal
 = 
pVal
->
n
;

53542 
pSorter
->
list
.
pList
 = 
pNew
;

53544 return 
rc
;

53545 
	}
}

53552 static int 
	$vdbeIncrPopulate
(
IncrMerger
 *
pIncr
)

53555 int 
rc
 = 0;

53556 int 
rc2
;

53557 
i64
 
iStart
 = 
pIncr
->
iStartOff
;

53558 
SorterFile
 *
pOut
 = &
pIncr
->
aFile
[1];

53559 
SortSubtask
 *
pTask
 = 
pIncr
->pTask;

53560 
MergeEngine
 *
pMerger
 = 
pIncr
->pMerger;

53561 
PmaWriter
 
writer
;

53566 
	`vdbePmaWriterInit
(
pOut
->
pFd
, &
writer
, 
pTask
->
pSorter
->
pgsz
, 
iStart
);

53567 while( 
rc
==0 )

53570 int 
dummy
;

53571 
PmaReader
 *
pReader
 = &
pMerger
->
aReadr
[ pMerger->
aTree
[1] ];

53572 int 
nKey
 = 
pReader
->nKey;

53573 
i64
 
iEof
 = 
writer
.
iWriteOff
 + writer.
iBufEnd
;

53577 if( 
pReader
->
pFd
==0 ) break;

53578 if( (
iEof
 + 
nKey
 + 
	`sqlite3VarintLen
(nKey))>(
iStart
 + 
pIncr
->
mxSz
) ) break;

53581 
	`vdbePmaWriteVarint
(&
writer
, 
nKey
);

53582 
	`vdbePmaWriteBlob
(&
writer
, 
pReader
->
aKey
, 
nKey
);

53584 
rc
 = 
	`vdbeMergeEngineStep
(
pIncr
->
pMerger
, &
dummy
);

53587 
rc2
 = 
	`vdbePmaWriterFinish
(&
writer
, &
pOut
->
iEof
);

53588 if( 
rc
==0 ) rc = 
rc2
;

53590 return 
rc
;

53591 
	}
}

53598 static void *
	$vdbeIncrPopulateThread
(void *
pCtx
)

53601 
IncrMerger
 *
pIncr
 = (IncrMerger*)
pCtx
;

53602 void *
pRet
 = ((void*)(long int)(
	`vdbeIncrPopulate
(
pIncr
)));

53603 
pIncr
->
pTask
->
bDone
 = 1;

53604 return 
pRet
;

53605 
	}
}

53610 static int 
	$vdbeIncrBgPopulate
(
IncrMerger
 *
pIncr
)

53613 void *
p
 = (void*)
pIncr
;

53615 return 
	`vdbeSorterCreateThread
(
pIncr
->
pTask
, 
vdbeIncrPopulateThread
, 
p
);

53616 
	}
}

53618 static int 
	$vdbeIncrSwap
(
IncrMerger
 *
pIncr
)

53621 int 
rc
 = 0;

53624 if( 
pIncr
->
bUseThread
 )

53627 
rc
 = 
	`vdbeSorterJoinThread
(
pIncr
->
pTask
);

53629 if( 
rc
==0 )

53632 
SorterFile
 
f0
 = 
pIncr
->
aFile
[0];

53633 
pIncr
->
aFile
[0] = pIncr->aFile[1];

53634 
pIncr
->
aFile
[1] = 
f0
;

53637 if( 
rc
==0 )

53640 if( 
pIncr
->
aFile
[0].
iEof
==pIncr->
iStartOff
 )

53643 
pIncr
->
bEof
 = 1;

53645 
rc
 = 
	`vdbeIncrBgPopulate
(
pIncr
);

53651 
rc
 = 
	`vdbeIncrPopulate
(
pIncr
);

53652 
pIncr
->
aFile
[0] = pIncr->aFile[1];

53653 if( 
pIncr
->
aFile
[0].
iEof
==pIncr->
iStartOff
 )

53656 
pIncr
->
bEof
 = 1;

53660 return 
rc
;

53661 
	}
}

53669 static int 
	$vdbeIncrMergerNew
(

53670 
SortSubtask
 *
pTask
,

53671 
MergeEngine
 *
pMerger
,

53672 
IncrMerger
 **
ppOut


53676 int 
rc
 = 0;

53677 
IncrMerger
 *
pIncr
 = *
ppOut
 = (IncrMerger*)

53678 (
	`sqlite3FaultSim
(100) ? 0 : 
	`sqlite3MallocZero
(sizeof(*
pIncr
)));

53679 if( 
pIncr
 )

53682 
pIncr
->
pMerger
 = pMerger;

53683 
pIncr
->
pTask
 = pTask;

53684 
pIncr
->
mxSz
 = ((
pTask
->
pSorter
->
mxKeysize
+9)>(pTask->pSorter->
mxPmaSize
/2)?(pTask->pSorter->mxKeysize+9):(pTask->pSorter->mxPmaSize/2));

53685 
pTask
->
file2
.
iEof
 += 
pIncr
->
mxSz
;

53687 
	`vdbeMergeEngineFree
(
pMerger
);

53688 
rc
 = 7;

53690 return 
rc
;

53691 
	}
}

53697 static void 
	$vdbeIncrMergerSetThreads
(
IncrMerger
 *
pIncr
)

53700 
pIncr
->
bUseThread
 = 1;

53701 
pIncr
->
pTask
->
file2
.
iEof
 -= pIncr->
mxSz
;

53702 
	}
}

53704 static void 
	$vdbeMergeEngineCompare
(

53705 
MergeEngine
 *
pMerger
,

53706 int 
iOut


53710 int 
i1
;

53711 int 
i2
;

53712 int 
iRes
;

53713 
PmaReader
 *
p1
;

53714 
PmaReader
 *
p2
;

53718 if( 
iOut
>=(
pMerger
->
nTree
/2) )

53721 
i1
 = (
iOut
 - 
pMerger
->
nTree
/2) * 2;

53722 
i2
 = 
i1
 + 1;

53724 
i1
 = 
pMerger
->
aTree
[
iOut
*2];

53725 
i2
 = 
pMerger
->
aTree
[
iOut
*2+1];

53728 
p1
 = &
pMerger
->
aReadr
[
i1
];

53729 
p2
 = &
pMerger
->
aReadr
[
i2
];

53731 if( 
p1
->
pFd
==0 )

53734 
iRes
 = 
i2
;

53735 }else if( 
p2
->
pFd
==0 )

53738 
iRes
 = 
i1
;

53740 
SortSubtask
 *
pTask
 = 
pMerger
->pTask;

53741 int 
bCached
 = 0;

53742 int 
res
;

53744 
res
 = 
pTask
->
	`xCompare
(

53745 
pTask
, &
bCached
, 
p1
->
aKey
, p1->
nKey
, 
p2
->aKey, p2->nKey

53747 if( 
res
<=0 )

53750 
iRes
 = 
i1
;

53752 
iRes
 = 
i2
;

53756 
pMerger
->
aTree
[
iOut
] = 
iRes
;

53757 
	}
}

53759 static int 
vdbePmaReaderIncrInit
(
PmaReader
 *
pReadr
, int 
eMode
);

53761 static int 
	$vdbeMergeEngineInit
(

53762 
SortSubtask
 *
pTask
,

53763 
MergeEngine
 *
pMerger
,

53764 int 
eMode


53768 int 
rc
 = 0;

53769 int 
i
;

53770 int 
nTree
 = 
pMerger
->nTree;

53777 
pMerger
->
pTask
 = pTask;

53779 for(
i
=0; i<
nTree
; i++)

53782 if( 8>0 && 
eMode
==2 )

53792 
rc
 = 
	`vdbePmaReaderNext
(&
pMerger
->
aReadr
[
nTree
-
i
-1]);

53794 
rc
 = 
	`vdbePmaReaderIncrInit
(&
pMerger
->
aReadr
[
i
], 0);

53796 if( 
rc
!=0 ) return rc;

53799 for(
i
=
pMerger
->
nTree
-1; i>0; i--)

53802 
	`vdbeMergeEngineCompare
(
pMerger
, 
i
);

53804 return 
pTask
->
pUnpacked
->
errCode
;

53805 
	}
}

53807 static int 
	$vdbePmaReaderIncrMergeInit
(
PmaReader
 *
pReadr
, int 
eMode
)

53810 int 
rc
 = 0;

53811 
IncrMerger
 *
pIncr
 = 
pReadr
->pIncr;

53812 
SortSubtask
 *
pTask
 = 
pIncr
->pTask;

53813 
sqlite3
 *
db
 = 
pTask
->
pSorter
->db;

53818 
rc
 = 
	`vdbeMergeEngineInit
(
pTask
, 
pIncr
->
pMerger
, 
eMode
);

53823 if( 
rc
==0 )

53826 int 
mxSz
 = 
pIncr
->mxSz;

53828 if( 
pIncr
->
bUseThread
 )

53831 
rc
 = 
	`vdbeSorterOpenTempFile
(
db
, 
mxSz
, &
pIncr
->
aFile
[0].
pFd
);

53832 if( 
rc
==0 )

53835 
rc
 = 
	`vdbeSorterOpenTempFile
(
db
, 
mxSz
, &
pIncr
->
aFile
[1].
pFd
);

53840 if( 
pTask
->
file2
.
pFd
==0 )

53844 
rc
 = 
	`vdbeSorterOpenTempFile
(
db
, 
pTask
->
file2
.
iEof
, &pTask->file2.
pFd
);

53845 
pTask
->
file2
.
iEof
 = 0;

53847 if( 
rc
==0 )

53850 
pIncr
->
aFile
[1].
pFd
 = 
pTask
->
file2
.pFd;

53851 
pIncr
->
iStartOff
 = 
pTask
->
file2
.
iEof
;

53852 
pTask
->
file2
.
iEof
 += 
mxSz
;

53858 if( 
rc
==0 && 
pIncr
->
bUseThread
 )

53863 
rc
 = 
	`vdbeIncrPopulate
(
pIncr
);

53867 if( 
rc
==0 && (8==0 || 
eMode
!=1) )

53870 
rc
 = 
	`vdbePmaReaderNext
(
pReadr
);

53873 return 
rc
;

53874 
	}
}

53881 static void *
	$vdbePmaReaderBgIncrInit
(void *
pCtx
)

53884 
PmaReader
 *
pReader
 = (PmaReader*)
pCtx
;

53885 void *
pRet
 = ((void*)(long int)(
	`vdbePmaReaderIncrMergeInit
(
pReader
,1)))

53888 
pReader
->
pIncr
->
pTask
->
bDone
 = 1;

53889 return 
pRet
;

53890 
	}
}

53892 static int 
	$vdbePmaReaderIncrInit
(
PmaReader
 *
pReadr
, int 
eMode
)

53895 
IncrMerger
 *
pIncr
 = 
pReadr
->pIncr;

53896 int 
rc
 = 0;

53897 if( 
pIncr
 )

53902 if( 
pIncr
->
bUseThread
 )

53905 void *
pCtx
 = (void*)
pReadr
;

53906 
rc
 = 
	`vdbeSorterCreateThread
(
pIncr
->
pTask
, 
vdbePmaReaderBgIncrInit
, 
pCtx
);

53910 
rc
 = 
	`vdbePmaReaderIncrMergeInit
(
pReadr
, 
eMode
);

53913 return 
rc
;

53914 
	}
}

53916 static int 
	$vdbeMergeEngineLevel0
(

53917 
SortSubtask
 *
pTask
,

53918 int 
nPMA
,

53919 
i64
 *
piOffset
,

53920 
MergeEngine
 **
ppOut


53924 
MergeEngine
 *
pNew
;

53925 
i64
 
iOff
 = *
piOffset
;

53926 int 
i
;

53927 int 
rc
 = 0;

53929 *
ppOut
 = 
pNew
 = 
	`vdbeMergeEngineNew
(
nPMA
);

53930 if( 
pNew
==0 ) 
rc
 = 7;

53932 for(
i
=0; i<
nPMA
 && 
rc
==0; i++)

53935 
i64
 
nDummy
 = 0;

53936 
PmaReader
 *
pReadr
 = &
pNew
->
aReadr
[
i
];

53937 
rc
 = 
	`vdbePmaReaderInit
(
pTask
, &pTask->
file
, 
iOff
, 
pReadr
, &
nDummy
);

53938 
iOff
 = 
pReadr
->
iEof
;

53941 if( 
rc
!=0 )

53944 
	`vdbeMergeEngineFree
(
pNew
);

53945 *
ppOut
 = 0;

53947 *
piOffset
 = 
iOff
;

53948 return 
rc
;

53949 
	}
}

53951 static int 
	$vdbeSorterTreeDepth
(int 
nPMA
)

53954 int 
nDepth
 = 0;

53955 
i64
 
nDiv
 = 16;

53956 while( 
nDiv
 < (
i64
)
nPMA
 )

53959 
nDiv
 = nDiv * 16;

53960 
nDepth
++;

53962 return 
nDepth
;

53963 
	}
}

53965 static int 
	$vdbeSorterAddToTree
(

53966 
SortSubtask
 *
pTask
,

53967 int 
nDepth
,

53968 int 
iSeq
,

53969 
MergeEngine
 *
pRoot
,

53970 
MergeEngine
 *
pLeaf


53974 int 
rc
 = 0;

53975 int 
nDiv
 = 1;

53976 int 
i
;

53977 
MergeEngine
 *
p
 = 
pRoot
;

53978 
IncrMerger
 *
pIncr
;

53980 
rc
 = 
	`vdbeIncrMergerNew
(
pTask
, 
pLeaf
, &
pIncr
);

53982 for(
i
=1; i<
nDepth
; i++)

53985 
nDiv
 = nDiv * 16;

53988 for(
i
=1; i<
nDepth
 && 
rc
==0; i++)

53991 int 
iIter
 = (
iSeq
 / 
nDiv
) % 16;

53992 
PmaReader
 *
pReadr
 = &
p
->
aReadr
[
iIter
];

53994 if( 
pReadr
->
pIncr
==0 )

53997 
MergeEngine
 *
pNew
 = 
	`vdbeMergeEngineNew
(16);

53998 if( 
pNew
==0 )

54001 
rc
 = 7;

54003 
rc
 = 
	`vdbeIncrMergerNew
(
pTask
, 
pNew
, &
pReadr
->
pIncr
);

54006 if( 
rc
==0 )

54009 
p
 = 
pReadr
->
pIncr
->
pMerger
;

54010 
nDiv
 = nDiv / 16;

54014 if( 
rc
==0 )

54017 
p
->
aReadr
[
iSeq
 % 16].
pIncr
 = pIncr;

54019 
	`vdbeIncrFree
(
pIncr
);

54021 return 
rc
;

54022 
	}
}

54024 static int 
	$vdbeSorterMergeTreeBuild
(

54025 
VdbeSorter
 *
pSorter
,

54026 
MergeEngine
 **
ppOut


54030 
MergeEngine
 *
pMain
 = 0;

54031 int 
rc
 = 0;

54032 int 
iTask
;

54039 if( 
pSorter
->
nTask
>1 )

54042 
pMain
 = 
	`vdbeMergeEngineNew
(
pSorter
->
nTask
);

54043 if( 
pMain
==0 ) 
rc
 = 7;

54047 for(
iTask
=0; 
rc
==0 && iTask<
pSorter
->
nTask
; iTask++)

54050 
SortSubtask
 *
pTask
 = &
pSorter
->
aTask
[
iTask
];

54052 if( 8==0 || 
pTask
->
nPMA
 )

54055 
MergeEngine
 *
pRoot
 = 0;

54056 int 
nDepth
 = 
	`vdbeSorterTreeDepth
(
pTask
->
nPMA
);

54057 
i64
 
iReadOff
 = 0;

54059 if( 
pTask
->
nPMA
<=16 )

54062 
rc
 = 
	`vdbeMergeEngineLevel0
(
pTask
, pTask->
nPMA
, &
iReadOff
, &
pRoot
);

54064 int 
i
;

54065 int 
iSeq
 = 0;

54066 
pRoot
 = 
	`vdbeMergeEngineNew
(16);

54067 if( 
pRoot
==0 ) 
rc
 = 7;

54068 for(
i
=0; i<
pTask
->
nPMA
 && 
rc
==0; i += 16)

54071 
MergeEngine
 *
pMerger
 = 0;

54072 int 
nReader
;

54074 
nReader
 = ((
pTask
->
nPMA
 - 
i
)<(16)?(pTask->nPMA - i):(16));

54075 
rc
 = 
	`vdbeMergeEngineLevel0
(
pTask
, 
nReader
, &
iReadOff
, &
pMerger
);

54076 if( 
rc
==0 )

54079 
rc
 = 
	`vdbeSorterAddToTree
(
pTask
, 
nDepth
, 
iSeq
++, 
pRoot
, 
pMerger
);

54084 if( 
rc
==0 )

54088 if( 
pMain
!=0 )

54091 
rc
 = 
	`vdbeIncrMergerNew
(
pTask
, 
pRoot
, &
pMain
->
aReadr
[
iTask
].
pIncr
);

54096 
pMain
 = 
pRoot
;

54099 
	`vdbeMergeEngineFree
(
pRoot
);

54104 if( 
rc
!=0 )

54107 
	`vdbeMergeEngineFree
(
pMain
);

54108 
pMain
 = 0;

54110 *
ppOut
 = 
pMain
;

54111 return 
rc
;

54112 
	}
}

54114 static int 
	$vdbeSorterSetupMerge
(
VdbeSorter
 *
pSorter
)

54117 int 
rc
;

54118 
SortSubtask
 *
pTask0
 = &
pSorter
->
aTask
[0];

54119 
MergeEngine
 *
pMain
 = 0;

54121 
sqlite3
 *
db
 = 
pTask0
->
pSorter
->db;

54122 int 
i
;

54123 
SorterCompare
 
xCompare
 = 
	`vdbeSorterGetCompare
(
pSorter
);

54124 for(
i
=0; i<
pSorter
->
nTask
; i++)

54127 
pSorter
->
aTask
[
i
].
xCompare
 = xCompare;

54131 
rc
 = 
	`vdbeSorterMergeTreeBuild
(
pSorter
, &
pMain
);

54132 if( 
rc
==0 )

54137 if( 
pSorter
->
bUseThreads
 )

54140 int 
iTask
;

54141 
PmaReader
 *
pReadr
 = 0;

54142 
SortSubtask
 *
pLast
 = &
pSorter
->
aTask
[pSorter->
nTask
-1];

54143 
rc
 = 
	`vdbeSortAllocUnpacked
(
pLast
);

54144 if( 
rc
==0 )

54147 
pReadr
 = (
PmaReader
*)
	`sqlite3DbMallocZero
(
db
, sizeof(PmaReader));

54148 
pSorter
->
pReader
 = 
pReadr
;

54149 if( 
pReadr
==0 ) 
rc
 = 7;

54151 if( 
rc
==0 )

54154 
rc
 = 
	`vdbeIncrMergerNew
(
pLast
, 
pMain
, &
pReadr
->
pIncr
);

54155 if( 
rc
==0 )

54158 
	`vdbeIncrMergerSetThreads
(
pReadr
->
pIncr
);

54159 for(
iTask
=0; iTask<(
pSorter
->
nTask
-1); iTask++)

54162 
IncrMerger
 *
pIncr
;

54163 if( (
pIncr
 = 
pMain
->
aReadr
[
iTask
].pIncr) )

54166 
	`vdbeIncrMergerSetThreads
(
pIncr
);

54170 for(
iTask
=0; 
rc
==0 && iTask<
pSorter
->
nTask
; iTask++)

54174 
PmaReader
 *
p
 = &
pMain
->
aReadr
[
iTask
];

54179 
rc
 = 
	`vdbePmaReaderIncrInit
(
p
, 1);

54182 
pMain
 = 0;

54184 if( 
rc
==0 )

54187 
rc
 = 
	`vdbePmaReaderIncrMergeInit
(
pReadr
, 2);

54192 
rc
 = 
	`vdbeMergeEngineInit
(
pTask0
, 
pMain
, 0);

54193 
pSorter
->
pMerger
 = 
pMain
;

54194 
pMain
 = 0;

54198 if( 
rc
!=0 )

54201 
	`vdbeMergeEngineFree
(
pMain
);

54203 return 
rc
;

54204 
	}
}

54212 static int 
	$sqlite3VdbeSorterRewind
(const 
VdbeCursor
 *
pCsr
, int *
pbEof
)

54215 
VdbeSorter
 *
pSorter
;

54216 int 
rc
 = 0;

54219 
pSorter
 = 
pCsr
->
uc
.pSorter;

54225 if( 
pSorter
->
bUsePMA
==0 )

54228 if( 
pSorter
->
list
.
pList
 )

54231 *
pbEof
 = 0;

54232 
rc
 = 
	`vdbeSorterSort
(&
pSorter
->
aTask
[0], &pSorter->
list
);

54234 *
pbEof
 = 1;

54236 return 
rc
;

54244 
rc
 = 
	`vdbeSorterFlushPMA
(
pSorter
);

54247 
rc
 = 
	`vdbeSorterJoinAll
(
pSorter
, rc);

54254 if( 
rc
==0 )

54257 
rc
 = 
	`vdbeSorterSetupMerge
(
pSorter
);

54258 *
pbEof
 = 0;

54262 return 
rc
;

54263 
	}
}

54268 static int 
	$sqlite3VdbeSorterNext
(
sqlite3
 *
db
, const 
VdbeCursor
 *
pCsr
, int *
pbEof
)

54271 
VdbeSorter
 *
pSorter
;

54272 int 
rc
;

54275 
pSorter
 = 
pCsr
->
uc
.pSorter;

54277 if( 
pSorter
->
bUsePMA
 )

54284 if( 
pSorter
->
bUseThreads
 )

54287 
rc
 = 
	`vdbePmaReaderNext
(
pSorter
->
pReader
);

54288 *
pbEof
 = (
pSorter
->
pReader
->
pFd
==0);

54294 
rc
 = 
	`vdbeMergeEngineStep
(
pSorter
->
pMerger
, 
pbEof
);

54297 
SorterRecord
 *
pFree
 = 
pSorter
->
list
.
pList
;

54298 
pSorter
->
list
.
pList
 = 
pFree
->
u
.
pNext
;

54299 
pFree
->
u
.
pNext
 = 0;

54300 if( 
pSorter
->
list
.
aMemory
==0 ) 
	`vdbeSorterRecordFree
(
db
, 
pFree
);

54301 *
pbEof
 = !
pSorter
->
list
.
pList
;

54302 
rc
 = 0;

54304 return 
rc
;

54305 
	}
}

54311 static void *
	$vdbeSorterRowkey
(

54312 const 
VdbeSorter
 *
pSorter
,

54313 int *
pnKey


54317 void *
pKey
;

54318 if( 
pSorter
->
bUsePMA
 )

54321 
PmaReader
 *
pReader
;

54323 if( 
pSorter
->
bUseThreads
 )

54326 
pReader
 = 
pSorter
->pReader;

54330 
pReader
 = &
pSorter
->
pMerger
->
aReadr
[pSorter->pMerger->
aTree
[1]];

54332 *
pnKey
 = 
pReader
->
nKey
;

54333 
pKey
 = 
pReader
->
aKey
;

54335 *
pnKey
 = 
pSorter
->
list
.
pList
->
nVal
;

54336 
pKey
 = ((void*)((
SorterRecord
*)(
pSorter
->
list
.
pList
) + 1));

54338 return 
pKey
;

54339 
	}
}

54344 static int 
	$sqlite3VdbeSorterRowkey
(const 
VdbeCursor
 *
pCsr
, 
Mem
 *
pOut
)

54347 
VdbeSorter
 *
pSorter
;

54348 void *
pKey
; int 
nKey
;

54351 
pSorter
 = 
pCsr
->
uc
.pSorter;

54352 
pKey
 = 
	`vdbeSorterRowkey
(
pSorter
, &
nKey
);

54353 if( 
	`sqlite3VdbeMemClearAndResize
(
pOut
, 
nKey
) )

54358 
pOut
->
n
 = 
nKey
;

54359 ((
pOut
)->
flags
 = ((pOut)->flags&~(0x81ff|0x4000))|0x0010);

54360 
	`memcpy
(
pOut
->
z
, 
pKey
, 
nKey
);

54363 
	}
}

54365 static int 
	$sqlite3VdbeSorterCompare
(

54366 const 
VdbeCursor
 *
pCsr
,

54367 
Mem
 *
pVal
,

54368 int 
nKeyCol
,

54369 int *
pRes


54373 
VdbeSorter
 *
pSorter
;

54374 
UnpackedRecord
 *
r2
;

54375 
KeyInfo
 *
pKeyInfo
;

54376 int 
i
;

54377 void *
pKey
; int 
nKey
;

54380 
pSorter
 = 
pCsr
->
uc
.pSorter;

54381 
r2
 = 
pSorter
->
pUnpacked
;

54382 
pKeyInfo
 = 
pCsr
->pKeyInfo;

54383 if( 
r2
==0 )

54386 char *
p
;

54387 
r2
 = 
pSorter
->
pUnpacked
 = 
	`sqlite3VdbeAllocUnpackedRecord
(
pKeyInfo
,0,0,&
p
);

54389 if( 
r2
==0 ) return 7;

54390 
r2
->
nField
 = 
nKeyCol
;

54394 
pKey
 = 
	`vdbeSorterRowkey
(
pSorter
, &
nKey
);

54395 
	`sqlite3VdbeRecordUnpack
(
pKeyInfo
, 
nKey
, 
pKey
, 
r2
);

54396 for(
i
=0; i<
nKeyCol
; i++)

54399 if( 
r2
->
aMem
[
i
].
flags
 & 0x0001 )

54402 *
pRes
 = -1;

54407 *
pRes
 = 
	`sqlite3VdbeRecordCompare
(
pVal
->
n
, pVal->
z
, 
r2
);

54409 
	}
}

54411 typedef struct 
MemJournal
 
	tMemJournal
;

54412 typedef struct 
FilePoint
 
	tFilePoint
;

54413 typedef struct 
FileChunk
 
	tFileChunk
;

54421 struct 
	sFileChunk
 {

54422 
FileChunk
 *
	mpNext
;

54423 
u8
 
	mzChunk
[8];

54426 struct 
	sFilePoint
 {

54427 
sqlite3_int64
 
	miOffset
;

54428 
FileChunk
 *
	mpChunk
;

54435 struct 
	sMemJournal
 {

54436 const 
sqlite3_io_methods
 *
	mpMethod
;

54437 int 
	mnChunkSize
;

54439 int 
	mnSpill
;

54440 int 
	mnSize
;

54441 
FileChunk
 *
	mpFirst
;

54442 
FilePoint
 
	mendpoint
;

54443 
FilePoint
 
	mreadpoint
;

54445 int 
	mflags
;

54446 
sqlite3_vfs
 *
	mpVfs
;

54447 const char *
	mzJournal
;

54454 static int 
	$memjrnlRead
(

54455 
sqlite3_file
 *
pJfd
,

54456 void *
zBuf
,

54457 int 
iAmt
,

54458 
sqlite_int64
 
iOfst


54462 
MemJournal
 *
p
 = (MemJournal *)
pJfd
;

54463 
u8
 *
zOut
 = 
zBuf
;

54464 int 
nRead
 = 
iAmt
;

54465 int 
iChunkOffset
;

54466 
FileChunk
 *
pChunk
;

54475 if( 
p
->
readpoint
.
iOffset
!=
iOfst
 || iOfst==0 )

54478 
sqlite3_int64
 
iOff
 = 0;

54479 for(
pChunk
=
p
->
pFirst
;

54480 (
pChunk
) && (
iOff
+
p
->
nChunkSize
)<=
iOfst
;

54481 
pChunk
=pChunk->
pNext


54485 
iOff
 += 
p
->
nChunkSize
;

54488 
pChunk
 = 
p
->
readpoint
.pChunk;

54491 
iChunkOffset
 = (int)(
iOfst
%
p
->
nChunkSize
);

54493 int 
iSpace
 = 
p
->
nChunkSize
 - 
iChunkOffset
;

54494 int 
nCopy
 = ((
nRead
)<((
p
->
nChunkSize
 - 
iChunkOffset
))?(nRead):((p->nChunkSize - iChunkOffset)));

54495 
	`memcpy
(
zOut
, (
u8
*)
pChunk
->
zChunk
 + 
iChunkOffset
, 
nCopy
);

54496 
zOut
 += 
nCopy
;

54497 
nRead
 -= 
iSpace
;

54498 
iChunkOffset
 = 0;

54499 } while( 
nRead
>=0 && (
pChunk
=pChunk->
pNext
)!=0 && nRead>0 );

54500 
p
->
readpoint
.
iOffset
 = 
iOfst
+
iAmt
;

54501 
p
->
readpoint
.
pChunk
 = pChunk;

54504 
	}
}

54509 static void 
	$memjrnlFreeChunks
(
MemJournal
 *
p
)

54512 
FileChunk
 *
pIter
;

54513 
FileChunk
 *
pNext
;

54514 for(
pIter
=
p
->
pFirst
; pIter; pIter=
pNext
)

54517 
pNext
 = 
pIter
->pNext;

54518 
	`sqlite3_free
(
pIter
);

54520 
p
->
pFirst
 = 0;

54521 
	}
}

54526 static int 
	$memjrnlCreateFile
(
MemJournal
 *
p
)

54529 int 
rc
;

54530 
sqlite3_file
 *
pReal
 = (sqlite3_file*)
p
;

54531 
MemJournal
 
copy
 = *
p
;

54533 
	`memset
(
p
, 0, sizeof(
MemJournal
));

54534 
rc
 = 
	`sqlite3OsOpen
(
copy
.
pVfs
, copy.
zJournal
, 
pReal
, copy.
flags
, 0);

54535 if( 
rc
==0 )

54538 int 
nChunk
 = 
copy
.
nChunkSize
;

54539 
i64
 
iOff
 = 0;

54540 
FileChunk
 *
pIter
;

54541 for(
pIter
=
copy
.
pFirst
; pIter; pIter=pIter->
pNext
)

54544 if( 
iOff
 + 
nChunk
 > 
copy
.
endpoint
.
iOffset
 )

54547 
nChunk
 = 
copy
.
endpoint
.
iOffset
 - 
iOff
;

54549 
rc
 = 
	`sqlite3OsWrite
(
pReal
, (
u8
*)
pIter
->
zChunk
, 
nChunk
, 
iOff
);

54550 if( 
rc
 ) break;

54551 
iOff
 += 
nChunk
;

54553 if( 
rc
==0 )

54557 
	`memjrnlFreeChunks
(&
copy
);

54560 if( 
rc
!=0 )

54567 
	`sqlite3OsClose
(
pReal
);

54568 *
p
 = 
copy
;

54570 return 
rc
;

54571 
	}
}

54577 static int 
	$memjrnlWrite
(

54578 
sqlite3_file
 *
pJfd
,

54579 const void *
zBuf
,

54580 int 
iAmt
,

54581 
sqlite_int64
 
iOfst


54585 
MemJournal
 *
p
 = (MemJournal *)
pJfd
;

54586 int 
nWrite
 = 
iAmt
;

54587 
u8
 *
zWrite
 = (u8 *)
zBuf
;

54591 if( 
p
->
nSpill
>0 && (
iAmt
+
iOfst
)>p->nSpill )

54594 int 
rc
 = 
	`memjrnlCreateFile
(
p
);

54595 if( 
rc
==0 )

54598 
rc
 = 
	`sqlite3OsWrite
(
pJfd
, 
zBuf
, 
iAmt
, 
iOfst
);

54600 return 
rc
;

54620 while( 
nWrite
>0 )

54623 
FileChunk
 *
pChunk
 = 
p
->
endpoint
.pChunk;

54624 int 
iChunkOffset
 = (int)(
p
->
endpoint
.
iOffset
%p->
nChunkSize
);

54625 int 
iSpace
 = ((
nWrite
)<(
p
->
nChunkSize
 - 
iChunkOffset
)?(nWrite):(p->nChunkSize - iChunkOffset));

54627 if( 
iChunkOffset
==0 )

54631 
FileChunk
 *
pNew
 = 
	`sqlite3_malloc
((sizeof(FileChunk) + ((
p
->
nChunkSize
)-8)));

54632 if( !
pNew
 )

54637 
pNew
->
pNext
 = 0;

54638 if( 
pChunk
 )

54642 
pChunk
->
pNext
 = 
pNew
;

54645 
p
->
pFirst
 = 
pNew
;

54647 
p
->
endpoint
.
pChunk
 = 
pNew
;

54650 
	`memcpy
((
u8
*)
p
->
endpoint
.
pChunk
->
zChunk
 + 
iChunkOffset
, 
zWrite
, 
iSpace
);

54651 
zWrite
 += 
iSpace
;

54652 
nWrite
 -= 
iSpace
;

54653 
p
->
endpoint
.
iOffset
 += 
iSpace
;

54655 
p
->
nSize
 = 
iAmt
 + 
iOfst
;

54660 
	}
}

54662 static int 
	$memjrnlTruncate
(
sqlite3_file
 *
pJfd
, 
sqlite_int64
 
size
)

54665 
MemJournal
 *
p
 = (MemJournal *)
pJfd
;

54666 if( (
size
==0) )

54669 
	`memjrnlFreeChunks
(
p
);

54670 
p
->
nSize
 = 0;

54671 
p
->
endpoint
.
pChunk
 = 0;

54672 
p
->
endpoint
.
iOffset
 = 0;

54673 
p
->
readpoint
.
pChunk
 = 0;

54674 
p
->
readpoint
.
iOffset
 = 0;

54677 
	}
}

54682 static int 
	$memjrnlClose
(
sqlite3_file
 *
pJfd
)

54685 
MemJournal
 *
p
 = (MemJournal *)
pJfd
;

54686 
	`memjrnlFreeChunks
(
p
);

54688 
	}
}

54696 static int 
	$memjrnlSync
(
sqlite3_file
 *
pJfd
, int 
flags
)

54699 (void)(
pJfd
),(void)(
flags
);

54701 
	}
}

54706 static int 
	$memjrnlFileSize
(
sqlite3_file
 *
pJfd
, 
sqlite_int64
 *
pSize
)

54709 
MemJournal
 *
p
 = (MemJournal *)
pJfd
;

54710 *
pSize
 = (
sqlite_int64
) 
p
->
endpoint
.
iOffset
;

54712 
	}
}

54717 static const struct 
sqlite3_io_methods
 
	gMemJournalMethods
 = {

54719 
memjrnlClose
,

54720 
memjrnlRead
,

54721 
memjrnlWrite
,

54722 
memjrnlTruncate
,

54723 
memjrnlSync
,

54724 
memjrnlFileSize
,

54739 static int 
	$sqlite3JournalOpen
(

54740 
sqlite3_vfs
 *
pVfs
,

54741 const char *
zName
,

54742 
sqlite3_file
 *
pJfd
,

54743 int 
flags
,

54744 int 
nSpill


54748 
MemJournal
 *
p
 = (MemJournal*)
pJfd
;

54754 
	`memset
(
p
, 0, sizeof(
MemJournal
));

54755 if( 
nSpill
==0 )

54758 return 
	`sqlite3OsOpen
(
pVfs
, 
zName
, 
pJfd
, 
flags
, 0);

54761 if( 
nSpill
>0 )

54764 
p
->
nChunkSize
 = 
nSpill
;

54766 
p
->
nChunkSize
 = 8 + 1024 - sizeof(
FileChunk
);

54770 
p
->
pMethod
 = (const 
sqlite3_io_methods
*)&
MemJournalMethods
;

54771 
p
->
nSpill
 = nSpill;

54772 
p
->
flags
 = flags;

54773 
p
->
zJournal
 = 
zName
;

54774 
p
->
pVfs
 = pVfs;

54776 
	}
}

54781 static void 
	$sqlite3MemJournalOpen
(
sqlite3_file
 *
pJfd
)

54784 
	`sqlite3JournalOpen
(0, 0, 
pJfd
, 0, -1);

54785 
	}
}

54787 static int 
	$sqlite3JournalIsInMemory
(
sqlite3_file
 *
p
)

54790 return 
p
->
pMethods
==&
MemJournalMethods
;

54791 
	}
}

54797 static int 
	$sqlite3JournalSize
(
sqlite3_vfs
 *
pVfs
)

54800 return ((
pVfs
->
szOsFile
)>((int)sizeof(
MemJournal
))?(pVfs->szOsFile):((int)sizeof(MemJournal)));

54801 
	}
}

54803 static 
__attribute__
((
noinline
)) int 
	$walkExpr
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

54806 int 
rc
;

54809 
rc
 = 
pWalker
->
	`xExprCallback
(pWalker, 
pExpr
);

54810 if( 
rc
==0

54811 && !(((
pExpr
)->
flags
&(0x004000))!=0) )

54814 if( 
	`sqlite3WalkExpr
(
pWalker
, 
pExpr
->
pLeft
) ) return 2;

54815 if( 
	`sqlite3WalkExpr
(
pWalker
, 
pExpr
->
pRight
) ) return 2;

54816 if( (((
pExpr
)->
flags
&(0x000800))!=0) )

54819 if( 
	`sqlite3WalkSelect
(
pWalker
, 
pExpr
->
x
.
pSelect
) ) return 2;

54821 if( 
	`sqlite3WalkExprList
(
pWalker
, 
pExpr
->
x
.
pList
) ) return 2;

54824 return 
rc
 & 2;

54825 
	}
}

54826 static int 
	$sqlite3WalkExpr
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

54829 return 
pExpr
 ? 
	`walkExpr
(
pWalker
,pExpr) : 0;

54830 
	}
}

54836 static int 
	$sqlite3WalkExprList
(
Walker
 *
pWalker
, 
ExprList
 *
p
)

54839 int 
i
;

54840 struct 
ExprList_item
 *
pItem
;

54841 if( 
p
 )

54844 for(
i
=
p
->
nExpr
, 
pItem
=p->
a
; i>0; i--, pItem++)

54847 if( 
	`sqlite3WalkExpr
(
pWalker
, 
pItem
->
pExpr
) ) return 2;

54851 
	}
}

54859 static int 
	$sqlite3WalkSelectExpr
(
Walker
 *
pWalker
, 
Select
 *
p
)

54862 if( 
	`sqlite3WalkExprList
(
pWalker
, 
p
->
pEList
) ) return 2;

54863 if( 
	`sqlite3WalkExpr
(
pWalker
, 
p
->
pWhere
) ) return 2;

54864 if( 
	`sqlite3WalkExprList
(
pWalker
, 
p
->
pGroupBy
) ) return 2;

54865 if( 
	`sqlite3WalkExpr
(
pWalker
, 
p
->
pHaving
) ) return 2;

54866 if( 
	`sqlite3WalkExprList
(
pWalker
, 
p
->
pOrderBy
) ) return 2;

54867 if( 
	`sqlite3WalkExpr
(
pWalker
, 
p
->
pLimit
) ) return 2;

54868 if( 
	`sqlite3WalkExpr
(
pWalker
, 
p
->
pOffset
) ) return 2;

54870 
	}
}

54872 static int 
	$sqlite3WalkSelectFrom
(
Walker
 *
pWalker
, 
Select
 *
p
)

54875 
SrcList
 *
pSrc
;

54876 int 
i
;

54877 struct 
SrcList_item
 *
pItem
;

54879 
pSrc
 = 
p
->pSrc;

54880 if( (
pSrc
) )

54883 for(
i
=
pSrc
->
nSrc
, 
pItem
=pSrc->
a
; i>0; i--, pItem++)

54886 if( 
	`sqlite3WalkSelect
(
pWalker
, 
pItem
->
pSelect
) )

54891 if( 
pItem
->
fg
.
isTabFunc


54892 && 
	`sqlite3WalkExprList
(
pWalker
, 
pItem
->
u1
.
pFuncArg
)

54901 
	}
}

54903 static int 
	$sqlite3WalkSelect
(
Walker
 *
pWalker
, 
Select
 *
p
)

54906 int 
rc
;

54907 if( 
p
==0 || (
pWalker
->
xSelectCallback
==0 && pWalker->
xSelectCallback2
==0) )

54912 
rc
 = 0;

54913 
pWalker
->
walkerDepth
++;

54914 while( 
p
 )

54917 if( 
pWalker
->
xSelectCallback
 )

54920 
rc
 = 
pWalker
->
	`xSelectCallback
(pWalker, 
p
);

54921 if( 
rc
 ) break;

54923 if( 
	`sqlite3WalkSelectExpr
(
pWalker
, 
p
)

54924 || 
	`sqlite3WalkSelectFrom
(
pWalker
, 
p
)

54928 
pWalker
->
walkerDepth
--;

54931 if( 
pWalker
->
xSelectCallback2
 )

54934 
pWalker
->
	`xSelectCallback2
(pWalker, 
p
);

54936 
p
 = p->
pPrior
;

54938 
pWalker
->
walkerDepth
--;

54939 return 
rc
 & 2;

54940 
	}
}

54942 static int 
	$incrAggDepth
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

54945 if( 
pExpr
->
op
==153 ) pExpr->
op2
 += 
pWalker
->
u
.
n
;

54947 
	}
}

54948 static void 
	$incrAggFunctionDepth
(
Expr
 *
pExpr
, int 
N
)

54951 if( 
N
>0 )

54954 
Walker
 
w
;

54955 
	`memset
(&
w
, 0, sizeof(w));

54956 
w
.
xExprCallback
 = 
incrAggDepth
;

54957 
w
.
u
.
n
 = 
N
;

54958 
	`sqlite3WalkExpr
(&
w
, 
pExpr
);

54960 
	}
}

54962 static void 
	$resolveAlias
(

54963 
Parse
 *
pParse
,

54964 
ExprList
 *
pEList
,

54965 int 
iCol
,

54966 
Expr
 *
pExpr
,

54967 const char *
zType
,

54968 int 
nSubquery


54972 
Expr
 *
pOrig
;

54973 
Expr
 *
pDup
;

54974 
sqlite3
 *
db
;

54977 
pOrig
 = 
pEList
->
a
[
iCol
].
pExpr
;

54979 
db
 = 
pParse
->db;

54980 
pDup
 = 
	`sqlite3ExprDup
(
db
, 
pOrig
, 0);

54981 if( 
pDup
==0 ) return;

54982 if( 
zType
[0]!='G' ) 
	`incrAggFunctionDepth
(
pDup
, 
nSubquery
);

54983 if( 
pExpr
->
op
==95 )

54986 
pDup
 = 
	`sqlite3ExprAddCollateString
(
pParse
, pDup, 
pExpr
->
u
.
zToken
);

54988 (
pDup
)->
flags
|=(0x400000);

54990 (
pExpr
)->
flags
|=(0x008000);

54991 
	`sqlite3ExprDelete
(
db
, 
pExpr
);

54992 
	`memcpy
(
pExpr
, 
pDup
, sizeof(*pExpr));

54993 if( !(((
pExpr
)->
flags
&(0x000400))!=0) && pExpr->
u
.
zToken
!=0 )

54997 
pExpr
->
u
.
zToken
 = 
	`sqlite3DbStrDup
(
db
, pExpr->u.zToken);

54998 
pExpr
->
flags
 |= 0x010000;

55000 
	`sqlite3DbFree
(
db
, 
pDup
);

55001 
	}
}

55003 static int 
	$nameInUsingClause
(
IdList
 *
pUsing
, const char *
zCol
)

55006 if( 
pUsing
 )

55009 int 
k
;

55010 for(
k
=0; k<
pUsing
->
nId
; k++)

55013 if( 
	`sqlite3StrICmp
(
pUsing
->
a
[
k
].
zName
, 
zCol
)==0 ) return 1;

55017 
	}
}

55019 static int 
	$sqlite3MatchSpanName
(

55020 const char *
zSpan
,

55021 const char *
zCol
,

55022 const char *
zTab
,

55023 const char *
zDb


55027 int 
n
;

55028 for(
n
=0; (
zSpan
[n]) && zSpan[n]!='.'; n++)

55031 if( 
zDb
 && (
	`sqlite3_strnicmp
(
zSpan
, zDb, 
n
)!=0 || zDb[n]!=0) )

55036 
zSpan
 += 
n
+1;

55037 for(
n
=0; (
zSpan
[n]) && zSpan[n]!='.'; n++)

55040 if( 
zTab
 && (
	`sqlite3_strnicmp
(
zSpan
, zTab, 
n
)!=0 || zTab[n]!=0) )

55045 
zSpan
 += 
n
+1;

55046 if( 
zCol
 && 
	`sqlite3StrICmp
(
zSpan
, zCol)!=0 )

55052 
	}
}

55054 static int 
	$lookupName
(

55055 
Parse
 *
pParse
,

55056 const char *
zDb
,

55057 const char *
zTab
,

55058 const char *
zCol
,

55059 
NameContext
 *
pNC
,

55060 
Expr
 *
pExpr


55064 int 
i
, 
j
;

55065 int 
cnt
 = 0;

55066 int 
cntTab
 = 0;

55067 int 
nSubquery
 = 0;

55068 
sqlite3
 *
db
 = 
pParse
->db;

55069 struct 
SrcList_item
 *
pItem
;

55070 struct 
SrcList_item
 *
pMatch
 = 0;

55071 
NameContext
 *
pTopNC
 = 
pNC
;

55072 
Schema
 *
pSchema
 = 0;

55073 int 
isTrigger
 = 0;

55074 
Table
 *
pTab
 = 0;

55075 
Column
 *
pCol
;

55082 
pExpr
->
iTable
 = -1;

55083 
pExpr
->
pTab
 = 0;

55090 if( 
zDb
 )

55095 if( (
pNC
->
ncFlags
 & (0x0010|0x0004))!=0 )

55102 
zDb
 = 0;

55104 for(
i
=0; i<
db
->
nDb
; i++)

55108 if( 
	`sqlite3StrICmp
(
db
->
aDb
[
i
].
zName
,
zDb
)==0 )

55111 
pSchema
 = 
db
->
aDb
[
i
].pSchema;

55119 while( 
pNC
 && 
cnt
==0 )

55122 
ExprList
 *
pEList
;

55123 
SrcList
 *
pSrcList
 = 
pNC
->pSrcList;

55125 if( 
pSrcList
 )

55128 for(
i
=0, 
pItem
=
pSrcList
->
a
; i<pSrcList->
nSrc
; i++, pItem++)

55131 
pTab
 = 
pItem
->pTab;

55134 if( 
pItem
->
pSelect
 && (pItem->pSelect->
selFlags
 & 0x00400)!=0 )

55137 int 
hit
 = 0;

55138 
pEList
 = 
pItem
->
pSelect
->pEList;

55139 for(
j
=0; j<
pEList
->
nExpr
; j++)

55142 if( 
	`sqlite3MatchSpanName
(
pEList
->
a
[
j
].
zSpan
, 
zCol
, 
zTab
, 
zDb
) )

55145 
cnt
++;

55146 
cntTab
 = 2;

55147 
pMatch
 = 
pItem
;

55148 
pExpr
->
iColumn
 = 
j
;

55149 
hit
 = 1;

55152 if( 
hit
 || 
zTab
==0 ) continue;

55154 if( 
zDb
 && 
pTab
->
pSchema
!=pSchema )

55159 if( 
zTab
 )

55162 const char *
zTabName
 = 
pItem
->
zAlias
 ? pItem->zAlias : 
pTab
->
zName
;

55164 if( 
	`sqlite3StrICmp
(
zTabName
, 
zTab
)!=0 )

55170 if( 0==(
cntTab
++) )

55173 
pMatch
 = 
pItem
;

55175 for(
j
=0, 
pCol
=
pTab
->
aCol
; j<pTab->
nCol
; j++, pCol++)

55178 if( 
	`sqlite3StrICmp
(
pCol
->
zName
, 
zCol
)==0 )

55185 if( 
cnt
==1 )

55188 if( 
pItem
->
fg
.
jointype
 & 0x0004 ) continue;

55189 if( 
	`nameInUsingClause
(
pItem
->
pUsing
, 
zCol
) ) continue;

55191 
cnt
++;

55192 
pMatch
 = 
pItem
;

55194 
pExpr
->
iColumn
 = 
j
==
pTab
->
iPKey
 ? -1 : (
i16
)j;

55199 if( 
pMatch
 )

55202 
pExpr
->
iTable
 = 
pMatch
->
iCursor
;

55203 
pExpr
->
pTab
 = 
pMatch
->pTab;

55206 if( (
pMatch
->
fg
.
jointype
 & 0x0008)!=0 )

55209 (
pExpr
)->
flags
|=(0x100000);

55211 
pSchema
 = 
pExpr
->
pTab
->pSchema;

55219 if( 
zDb
==0 && 
zTab
!=0 && 
cntTab
==0 && 
pParse
->
pTriggerTab
!=0 )

55222 int 
op
 = 
pParse
->
eTriggerOp
;

55224 if( 
op
!=109 && 
	`sqlite3StrICmp
("new",
zTab
) == 0 )

55227 
pExpr
->
iTable
 = 1;

55228 
pTab
 = 
pParse
->
pTriggerTab
;

55229 }else if( 
op
!=108 && 
	`sqlite3StrICmp
("old",
zTab
)==0 )

55232 
pExpr
->
iTable
 = 0;

55233 
pTab
 = 
pParse
->
pTriggerTab
;

55235 
pTab
 = 0;

55238 if( 
pTab
 )

55241 int 
iCol
;

55242 
pSchema
 = 
pTab
->pSchema;

55243 
cntTab
++;

55244 for(
iCol
=0, 
pCol
=
pTab
->
aCol
; iCol<pTab->
nCol
; iCol++, pCol++)

55247 if( 
	`sqlite3StrICmp
(
pCol
->
zName
, 
zCol
)==0 )

55250 if( 
iCol
==
pTab
->
iPKey
 )

55253 
iCol
 = -1;

55258 if( 
iCol
>=
pTab
->
nCol
 && 
	`sqlite3IsRowid
(
zCol
) && (((pTab)->
tabFlags
 & 0x40)==0) )

55262 
iCol
 = -1;

55264 if( 
iCol
<
pTab
->
nCol
 )

55267 
cnt
++;

55268 if( 
iCol
<0 )

55271 
pExpr
->
affinity
 = 'D';

55272 }else if( 
pExpr
->
iTable
==0 )

55277 
pParse
->
oldmask
 |= (
iCol
>=32 ? 0xffffffff : (((
u32
)1)<<iCol));

55281 
pParse
->
newmask
 |= (
iCol
>=32 ? 0xffffffff : (((
u32
)1)<<iCol));

55283 
pExpr
->
iColumn
 = (
i16
)
iCol
;

55284 
pExpr
->
pTab
 = pTab;

55285 
isTrigger
 = 1;

55294 if( 
cnt
==0

55295 && 
cntTab
==1

55296 && 
pMatch


55297 && (
pNC
->
ncFlags
 & 0x0020)==0

55298 && 
	`sqlite3IsRowid
(
zCol
)

55299 && (((
pMatch
->
pTab
)->
tabFlags
 & 0x40)==0)

55303 
cnt
 = 1;

55304 
pExpr
->
iColumn
 = -1;

55305 
pExpr
->
affinity
 = 'D';

55308 if( (
pEList
 = 
pNC
->pEList)!=0

55309 && 
zTab
==0

55310 && 
cnt
==0

55314 for(
j
=0; j<
pEList
->
nExpr
; j++)

55317 char *
zAs
 = 
pEList
->
a
[
j
].
zName
;

55318 if( 
zAs
!=0 && 
	`sqlite3StrICmp
(zAs, 
zCol
)==0 )

55321 
Expr
 *
pOrig
;

55325 
pOrig
 = 
pEList
->
a
[
j
].
pExpr
;

55326 if( (
pNC
->
ncFlags
&0x0001)==0 && (((
pOrig
)->
flags
&(0x000002))!=0) )

55329 
	`sqlite3ErrorMsg
(
pParse
, "misuse of aliased aggregate %s", 
zAs
);

55332 
	`resolveAlias
(
pParse
, 
pEList
, 
j
, 
pExpr
, "", 
nSubquery
);

55333 
cnt
 = 1;

55334 
pMatch
 = 0;

55336 goto 
lookupname_end
;

55344 if( 
cnt
==0 )

55347 
pNC
 = pNC->
pNext
;

55348 
nSubquery
++;

55352 if( 
cnt
==0 && 
zTab
==0 && (((
pExpr
)->
flags
&(0x000040))!=0) )

55355 
pExpr
->
op
 = 97;

55356 
pExpr
->
pTab
 = 0;

55364 if( 
cnt
!=1 )

55367 const char *
zErr
;

55368 
zErr
 = 
cnt
==0 ? "no such column" : "ambiguous column name";

55369 if( 
zDb
 )

55372 
	`sqlite3ErrorMsg
(
pParse
, "%s: %s.%s.%s", 
zErr
, 
zDb
, 
zTab
, 
zCol
);

55373 }else if( 
zTab
 )

55376 
	`sqlite3ErrorMsg
(
pParse
, "%s: %s.%s", 
zErr
, 
zTab
, 
zCol
);

55378 
	`sqlite3ErrorMsg
(
pParse
, "%s: %s", 
zErr
, 
zCol
);

55380 
pParse
->
checkSchema
 = 1;

55381 
pTopNC
->
nErr
++;

55390 if( 
pExpr
->
iColumn
>=0 && 
pMatch
!=0 )

55393 int 
n
 = 
pExpr
->
iColumn
;

55395 if( 
n
>=((int)(sizeof(
Bitmask
)*8)) )

55398 
n
 = ((int)(sizeof(
Bitmask
)*8))-1;

55401 
pMatch
->
colUsed
 |= ((
Bitmask
)1)<<
n
;

55406 
	`sqlite3ExprDelete
(
db
, 
pExpr
->
pLeft
);

55407 
pExpr
->
pLeft
 = 0;

55408 
	`sqlite3ExprDelete
(
db
, 
pExpr
->
pRight
);

55409 
pExpr
->
pRight
 = 0;

55410 
pExpr
->
op
 = (
isTrigger
 ? 62 : 152);

55411 
lookupname_end
:

55412 if( 
cnt
==1 )

55416 if( !(((
pExpr
)->
flags
&(0x400000))!=0) )

55419 
	`sqlite3AuthRead
(
pParse
, 
pExpr
, 
pSchema
, 
pNC
->
pSrcList
);

55427 
pTopNC
->
nRef
++;

55428 if( 
pTopNC
==
pNC
 ) break;

55429 
pTopNC
 = pTopNC->
pNext
;

55435 
	}
}

55441 static 
Expr
 *
	$sqlite3CreateColumnExpr
(
sqlite3
 *
db
, 
SrcList
 *
pSrc
, int 
iSrc
, int 
iCol
)

55444 
Expr
 *
p
 = 
	`sqlite3ExprAlloc
(
db
, 152, 0, 0);

55445 if( 
p
 )

55448 struct 
SrcList_item
 *
pItem
 = &
pSrc
->
a
[
iSrc
];

55449 
p
->
pTab
 = 
pItem
->pTab;

55450 
p
->
iTable
 = 
pItem
->
iCursor
;

55451 if( 
p
->
pTab
->
iPKey
==
iCol
 )

55454 
p
->
iColumn
 = -1;

55456 
p
->
iColumn
 = (
ynVar
)
iCol
;

55459 
pItem
->
colUsed
 |= ((
Bitmask
)1)<<(
iCol
>=((int)(sizeof(Bitmask)*8)) ? ((int)(sizeof(Bitmask)*8))-1 : iCol);

55461 (
p
)->
flags
|=(0x000004);

55463 return 
p
;

55464 
	}
}

55470 static void 
	$notValid
(

55471 
Parse
 *
pParse
,

55472 
NameContext
 *
pNC
,

55473 const char *
zMsg
,

55474 int 
validMask


55479 if( (
pNC
->
ncFlags
 & 
validMask
)!=0 )

55482 const char *
zIn
 = "partial index WHERE clauses";

55483 if( 
pNC
->
ncFlags
 & 0x0020 ) 
zIn
 = "index expressions";

55485 else if( 
pNC
->
ncFlags
 & 0x0004 ) 
zIn
 = "CHECK constraints";

55487 
	`sqlite3ErrorMsg
(
pParse
, "%s prohibited in %s", 
zMsg
, 
zIn
);

55489 
	}
}

55496 static int 
	$exprProbability
(
Expr
 *
p
)

55499 double 
r
 = -1.0;

55500 if( 
p
->
op
!=133 ) return -1;

55501 
	`sqlite3AtoF
(
p
->
u
.
zToken
, &
r
, 
	`sqlite3Strlen30
(p->u.zToken), 1);

55503 if( 
r
>1.0 ) return -1;

55504 return (int)(
r
*134217728.0);

55505 
	}
}

55507 static int 
	$resolveExprStep
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

55510 
NameContext
 *
pNC
;

55511 
Parse
 *
pParse
;

55513 
pNC
 = 
pWalker
->
u
.pNC;

55515 
pParse
 = 
pNC
->pParse;

55518 if( (((
pExpr
)->
flags
&(0x000004))!=0) ) return 1;

55519 (
pExpr
)->
flags
|=(0x000004);

55521 switch( 
pExpr
->
op
 )

55526 return 
	`lookupName
(
pParse
, 0, 0, 
pExpr
->
u
.
zToken
, 
pNC
, pExpr);

55533 const char *
zColumn
;

55534 const char *
zTable
;

55535 const char *
zDb
;

55536 
Expr
 *
pRight
;

55539 
	`notValid
(
pParse
, 
pNC
, "the \".\" operator", 0x0020);

55541 
pRight
 = 
pExpr
->pRight;

55542 if( 
pRight
->
op
==27 )

55545 
zDb
 = 0;

55546 
zTable
 = 
pExpr
->
pLeft
->
u
.
zToken
;

55547 
zColumn
 = 
pRight
->
u
.
zToken
;

55550 
zDb
 = 
pExpr
->
pLeft
->
u
.
zToken
;

55551 
zTable
 = 
pRight
->
pLeft
->
u
.
zToken
;

55552 
zColumn
 = 
pRight
->pRight->
u
.
zToken
;

55554 return 
	`lookupName
(
pParse
, 
zDb
, 
zTable
, 
zColumn
, 
pNC
, 
pExpr
);

55560 
ExprList
 *
pList
 = 
pExpr
->
x
.pList;

55561 int 
n
 = 
pList
 ? pList->
nExpr
 : 0;

55562 int 
no_such_func
 = 0;

55563 int 
wrong_num_args
 = 0;

55564 int 
is_agg
 = 0;

55565 int 
auth
;

55566 int 
nId
;

55567 const char *
zId
;

55568 
FuncDef
 *
pDef
;

55569 
u8
 
enc
 = ((
pParse
->
db
)->enc);

55572 
	`notValid
(
pParse
, 
pNC
, "functions", 0x0010);

55573 
zId
 = 
pExpr
->
u
.
zToken
;

55574 
nId
 = 
	`sqlite3Strlen30
(
zId
);

55575 
pDef
 = 
	`sqlite3FindFunction
(
pParse
->
db
, 
zId
, 
n
, 
enc
, 0);

55576 if( 
pDef
==0 )

55579 
pDef
 = 
	`sqlite3FindFunction
(
pParse
->
db
, 
zId
, -2, 
enc
, 0);

55580 if( 
pDef
==0 )

55583 
no_such_func
 = 1;

55585 
wrong_num_args
 = 1;

55588 
is_agg
 = 
pDef
->
xFinalize
!=0;

55589 if( 
pDef
->
funcFlags
 & 0x0400 )

55592 (
pExpr
)->
flags
|=(0x040000|0x001000);

55593 if( 
n
==2 )

55596 
pExpr
->
iTable
 = 
	`exprProbability
(
pList
->
a
[1].pExpr);

55597 if( 
pExpr
->
iTable
<0 )

55600 
	`sqlite3ErrorMsg
(
pParse
,

55603 
pNC
->
nErr
++;

55607 
pExpr
->
iTable
 = 
pDef
->
zName
[0]=='u' ? 8388608 : 125829120;

55611 
auth
 = 
	`sqlite3AuthCheck
(
pParse
, 31, 0, 
pDef
->
zName
, 0);

55612 if( 
auth
!=0 )

55615 if( 
auth
==1 )

55618 
	`sqlite3ErrorMsg
(
pParse
, "not authorized to use function: %s",

55619 
pDef
->
zName
);

55620 
pNC
->
nErr
++;

55622 
pExpr
->
op
 = 101;

55626 if( 
pDef
->
funcFlags
 & (0x0800|0x2000) )

55632 (
pExpr
)->
flags
|=(0x080000);

55634 if( (
pDef
->
funcFlags
 & 0x0800)==0 )

55640 
	`notValid
(
pParse
, 
pNC
, "non-deterministic functions", 0x0020);

55643 if( 
is_agg
 && (
pNC
->
ncFlags
 & 0x0001)==0 )

55646 
	`sqlite3ErrorMsg
(
pParse
, "misuse of aggregate function %.*s()", 
nId
,
zId
);

55647 
pNC
->
nErr
++;

55648 
is_agg
 = 0;

55649 }else if( 
no_such_func
 && 
pParse
->
db
->
init
.
busy
==0 )

55652 
	`sqlite3ErrorMsg
(
pParse
, "no such function: %.*s", 
nId
, 
zId
);

55653 
pNC
->
nErr
++;

55654 }else if( 
wrong_num_args
 )

55657 
	`sqlite3ErrorMsg
(
pParse
,"wrong number of arguments to function %.*s()",

55658 
nId
, 
zId
);

55659 
pNC
->
nErr
++;

55661 if( 
is_agg
 ) 
pNC
->
ncFlags
 &= ~0x0001;

55662 
	`sqlite3WalkExprList
(
pWalker
, 
pList
);

55663 if( 
is_agg
 )

55666 
NameContext
 *
pNC2
 = 
pNC
;

55667 
pExpr
->
op
 = 153;

55668 
pExpr
->
op2
 = 0;

55669 while( 
pNC2
 && !
	`sqlite3FunctionUsesThisSrc
(
pExpr
, pNC2->
pSrcList
) )

55672 
pExpr
->
op2
++;

55673 
pNC2
 = pNC2->
pNext
;

55676 if( 
pNC2
 )

55681 
pNC2
->
ncFlags
 |= 0x0002 | (
pDef
->
funcFlags
 & 0x1000);

55684 
pNC
->
ncFlags
 |= 0x0001;

55697 if( (((
pExpr
)->
flags
&(0x000800))!=0) )

55700 int 
nRef
 = 
pNC
->nRef;

55701 
	`notValid
(
pParse
, 
pNC
, "subqueries", 0x0004|0x0010|0x0020);

55702 
	`sqlite3WalkSelect
(
pWalker
, 
pExpr
->
x
.
pSelect
);

55704 if( 
nRef
!=
pNC
->nRef )

55707 (
pExpr
)->
flags
|=(0x000020);

55713 
	`notValid
(
pParse
, 
pNC
, "parameters", 0x0004|0x0010|0x0020);

55717 return (
pParse
->
nErr
 || pParse->
db
->
mallocFailed
) ? 2 : 0;

55718 
	}
}

55720 static int 
	$resolveAsName
(

55721 
Parse
 *
pParse
,

55722 
ExprList
 *
pEList
,

55723 
Expr
 *
pE


55727 int 
i
;

55729 (void)(
pParse
);

55731 if( 
pE
->
op
==27 )

55734 char *
zCol
 = 
pE
->
u
.
zToken
;

55735 for(
i
=0; i<
pEList
->
nExpr
; i++)

55738 char *
zAs
 = 
pEList
->
a
[
i
].
zName
;

55739 if( 
zAs
!=0 && 
	`sqlite3StrICmp
(zAs, 
zCol
)==0 )

55742 return 
i
+1;

55747 
	}
}

55749 static int 
	$resolveOrderByTermToExprList
(

55750 
Parse
 *
pParse
,

55751 
Select
 *
pSelect
,

55752 
Expr
 *
pE


55756 int 
i
;

55757 
ExprList
 *
pEList
;

55758 
NameContext
 
nc
;

55759 
sqlite3
 *
db
;

55760 int 
rc
;

55761 
u8
 
savedSuppErr
;

55764 
pEList
 = 
pSelect
->pEList;

55768 
	`memset
(&
nc
, 0, sizeof(nc));

55769 
nc
.
pParse
 = pParse;

55770 
nc
.
pSrcList
 = 
pSelect
->
pSrc
;

55771 
nc
.
pEList
 = pEList;

55772 
nc
.
ncFlags
 = 0x0001;

55773 
nc
.
nErr
 = 0;

55774 
db
 = 
pParse
->db;

55775 
savedSuppErr
 = 
db
->
suppressErr
;

55776 
db
->
suppressErr
 = 1;

55777 
rc
 = 
	`sqlite3ResolveExprNames
(&
nc
, 
pE
);

55778 
db
->
suppressErr
 = 
savedSuppErr
;

55779 if( 
rc
 ) return 0;

55785 for(
i
=0; i<
pEList
->
nExpr
; i++)

55788 if( 
	`sqlite3ExprCompare
(
pEList
->
a
[
i
].
pExpr
, 
pE
, -1)<2 )

55791 return 
i
+1;

55797 
	}
}

55802 static void 
	$resolveOutOfRangeError
(

55803 
Parse
 *
pParse
,

55804 const char *
zType
,

55805 int 
i
,

55806 int 
mx


55810 
	`sqlite3ErrorMsg
(
pParse
,

55812 "between 1 and %d", 
i
, 
zType
, 
mx
);

55813 
	}
}

55815 static int 
	$resolveCompoundOrderBy
(

55816 
Parse
 *
pParse
,

55817 
Select
 *
pSelect


55821 int 
i
;

55822 
ExprList
 *
pOrderBy
;

55823 
ExprList
 *
pEList
;

55824 
sqlite3
 *
db
;

55825 int 
moreToDo
 = 1;

55827 
pOrderBy
 = 
pSelect
->pOrderBy;

55828 if( 
pOrderBy
==0 ) return 0;

55829 
db
 = 
pParse
->db;

55831 if( 
pOrderBy
->
nExpr
>
db
->
aLimit
[2] )

55834 
	`sqlite3ErrorMsg
(
pParse
, "too many terms in ORDER BY clause");

55838 for(
i
=0; i<
pOrderBy
->
nExpr
; i++)

55841 
pOrderBy
->
a
[
i
].
done
 = 0;

55843 
pSelect
->
pNext
 = 0;

55844 while( 
pSelect
->
pPrior
 )

55847 
pSelect
->
pPrior
->
pNext
 = pSelect;

55848 
pSelect
 = pSelect->
pPrior
;

55850 while( 
pSelect
 && 
moreToDo
 )

55853 struct 
ExprList_item
 *
pItem
;

55854 
moreToDo
 = 0;

55855 
pEList
 = 
pSelect
->pEList;

55857 for(
i
=0, 
pItem
=
pOrderBy
->
a
; i<pOrderBy->
nExpr
; i++, pItem++)

55860 int 
iCol
 = -1;

55861 
Expr
 *
pE
, *
pDup
;

55862 if( 
pItem
->
done
 ) continue;

55863 
pE
 = 
	`sqlite3ExprSkipCollate
(
pItem
->
pExpr
);

55864 if( 
	`sqlite3ExprIsInteger
(
pE
, &
iCol
) )

55867 if( 
iCol
<=0 || iCol>
pEList
->
nExpr
 )

55870 
	`resolveOutOfRangeError
(
pParse
, "ORDER", 
i
+1, 
pEList
->
nExpr
);

55874 
iCol
 = 
	`resolveAsName
(
pParse
, 
pEList
, 
pE
);

55875 if( 
iCol
==0 )

55878 
pDup
 = 
	`sqlite3ExprDup
(
db
, 
pE
, 0);

55879 if( !
db
->
mallocFailed
 )

55883 
iCol
 = 
	`resolveOrderByTermToExprList
(
pParse
, 
pSelect
, 
pDup
);

55885 
	`sqlite3ExprDelete
(
db
, 
pDup
);

55888 if( 
iCol
>0 )

55893 
Expr
 *
pNew
 = 
	`sqlite3Expr
(
db
, 132, 0);

55894 if( 
pNew
==0 ) return 1;

55895 
pNew
->
flags
 |= 0x000400;

55896 
pNew
->
u
.
iValue
 = 
iCol
;

55897 if( 
pItem
->
pExpr
==
pE
 )

55900 
pItem
->
pExpr
 = 
pNew
;

55902 
Expr
 *
pParent
 = 
pItem
->
pExpr
;

55904 while( 
pParent
->
pLeft
->
op
==95 ) pParent = pParent->pLeft;

55906 
pParent
->
pLeft
 = 
pNew
;

55908 
	`sqlite3ExprDelete
(
db
, 
pE
);

55909 
pItem
->
u
.
x
.
iOrderByCol
 = (
u16
)
iCol
;

55910 
pItem
->
done
 = 1;

55912 
moreToDo
 = 1;

55915 
pSelect
 = pSelect->
pNext
;

55917 for(
i
=0; i<
pOrderBy
->
nExpr
; i++)

55920 if( 
pOrderBy
->
a
[
i
].
done
==0 )

55923 
	`sqlite3ErrorMsg
(
pParse
, "%r ORDER BY term does not match any "

55924 "column in the result set", 
i
+1);

55929 
	}
}

55931 static int 
	$sqlite3ResolveOrderGroupBy
(

55932 
Parse
 *
pParse
,

55933 
Select
 *
pSelect
,

55934 
ExprList
 *
pOrderBy
,

55935 const char *
zType


55939 int 
i
;

55940 
sqlite3
 *
db
 = 
pParse
->db;

55941 
ExprList
 *
pEList
;

55942 struct 
ExprList_item
 *
pItem
;

55944 if( 
pOrderBy
==0 || 
pParse
->
db
->
mallocFailed
 ) return 0;

55946 if( 
pOrderBy
->
nExpr
>
db
->
aLimit
[2] )

55949 
	`sqlite3ErrorMsg
(
pParse
, "too many terms in %s BY clause", 
zType
);

55953 
pEList
 = 
pSelect
->pEList;

55955 for(
i
=0, 
pItem
=
pOrderBy
->
a
; i<pOrderBy->
nExpr
; i++, pItem++)

55958 if( 
pItem
->
u
.
x
.
iOrderByCol
 )

55961 if( 
pItem
->
u
.
x
.
iOrderByCol
>
pEList
->
nExpr
 )

55964 
	`resolveOutOfRangeError
(
pParse
, 
zType
, 
i
+1, 
pEList
->
nExpr
);

55967 
	`resolveAlias
(
pParse
, 
pEList
, 
pItem
->
u
.
x
.
iOrderByCol
-1, pItem->
pExpr
,

55968 
zType
,0);

55972 
	}
}

55974 static int 
	$resolveOrderGroupBy
(

55975 
NameContext
 *
pNC
,

55976 
Select
 *
pSelect
,

55977 
ExprList
 *
pOrderBy
,

55978 const char *
zType


55982 int 
i
, 
j
;

55983 int 
iCol
;

55984 struct 
ExprList_item
 *
pItem
;

55985 
Parse
 *
pParse
;

55986 int 
nResult
;

55988 if( 
pOrderBy
==0 ) return 0;

55989 
nResult
 = 
pSelect
->
pEList
->
nExpr
;

55990 
pParse
 = 
pNC
->pParse;

55991 for(
i
=0, 
pItem
=
pOrderBy
->
a
; i<pOrderBy->
nExpr
; i++, pItem++)

55994 
Expr
 *
pE
 = 
pItem
->
pExpr
;

55995 
Expr
 *
pE2
 = 
	`sqlite3ExprSkipCollate
(
pE
);

55996 if( 
zType
[0]!='G' )

55999 
iCol
 = 
	`resolveAsName
(
pParse
, 
pSelect
->
pEList
, 
pE2
);

56000 if( 
iCol
>0 )

56007 
pItem
->
u
.
x
.
iOrderByCol
 = (
u16
)
iCol
;

56011 if( 
	`sqlite3ExprIsInteger
(
pE2
, &
iCol
) )

56017 if( 
iCol
<1 || iCol>0xffff )

56020 
	`resolveOutOfRangeError
(
pParse
, 
zType
, 
i
+1, 
nResult
);

56023 
pItem
->
u
.
x
.
iOrderByCol
 = (
u16
)
iCol
;

56028 
pItem
->
u
.
x
.
iOrderByCol
 = 0;

56029 if( 
	`sqlite3ResolveExprNames
(
pNC
, 
pE
) )

56034 for(
j
=0; j<
pSelect
->
pEList
->
nExpr
; j++)

56037 if( 
	`sqlite3ExprCompare
(
pE
, 
pSelect
->
pEList
->
a
[
j
].
pExpr
, -1)==0 )

56040 
pItem
->
u
.
x
.
iOrderByCol
 = 
j
+1;

56044 return 
	`sqlite3ResolveOrderGroupBy
(
pParse
, 
pSelect
, 
pOrderBy
, 
zType
);

56045 
	}
}

56050 static int 
	$resolveSelectStep
(
Walker
 *
pWalker
, 
Select
 *
p
)

56053 
NameContext
 *
pOuterNC
;

56054 
NameContext
 
sNC
;

56055 int 
isCompound
;

56056 int 
nCompound
;

56057 
Parse
 *
pParse
;

56058 int 
i
;

56059 
ExprList
 *
pGroupBy
;

56060 
Select
 *
pLeftmost
;

56061 
sqlite3
 *
db
;

56065 if( 
p
->
selFlags
 & 0x00004 )

56070 
pOuterNC
 = 
pWalker
->
u
.
pNC
;

56071 
pParse
 = 
pWalker
->pParse;

56072 
db
 = 
pParse
->db;

56074 if( (
p
->
selFlags
 & 0x00020)==0 )

56077 
	`sqlite3SelectPrep
(
pParse
, 
p
, 
pOuterNC
);

56078 return (
pParse
->
nErr
 || 
db
->
mallocFailed
) ? 2 : 1;

56081 
isCompound
 = 
p
->
pPrior
!=0;

56082 
nCompound
 = 0;

56083 
pLeftmost
 = 
p
;

56084 while( 
p
 )

56089 
p
->
selFlags
 |= 0x00004;

56094 
	`memset
(&
sNC
, 0, sizeof(sNC));

56095 
sNC
.
pParse
 = pParse;

56096 if( 
	`sqlite3ResolveExprNames
(&
sNC
, 
p
->
pLimit
) ||

56097 
	`sqlite3ResolveExprNames
(&
sNC
, 
p
->
pOffset
) )

56109 if( 
p
->
selFlags
 & 0x08000 )

56112 
Select
 *
pSub
 = 
p
->
pSrc
->
a
[0].
pSelect
;

56115 
pSub
->
pOrderBy
 = 
p
->pOrderBy;

56116 
p
->
pOrderBy
 = 0;

56121 for(
i
=0; i<
p
->
pSrc
->
nSrc
; i++)

56124 struct 
SrcList_item
 *
pItem
 = &
p
->
pSrc
->
a
[
i
];

56125 if( 
pItem
->
pSelect
 )

56128 
NameContext
 *
pNC
;

56129 int 
nRef
 = 0;

56130 const char *
zSavedContext
 = 
pParse
->
zAuthContext
;

56137 for(
pNC
=
pOuterNC
; pNC; pNC=pNC->
pNext
) 
nRef
 += pNC->nRef;

56139 if( 
pItem
->
zName
 ) 
pParse
->
zAuthContext
 = pItem->zName;

56140 
	`sqlite3ResolveSelectNames
(
pParse
, 
pItem
->
pSelect
, 
pOuterNC
);

56141 
pParse
->
zAuthContext
 = 
zSavedContext
;

56142 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 ) return 2;

56144 for(
pNC
=
pOuterNC
; pNC; pNC=pNC->
pNext
) 
nRef
 -= pNC->nRef;

56146 
pItem
->
fg
.
isCorrelated
 = (
nRef
!=0);

56153 
sNC
.
ncFlags
 = 0x0001;

56154 
sNC
.
pSrcList
 = 
p
->
pSrc
;

56155 
sNC
.
pNext
 = 
pOuterNC
;

56158 if( 
	`sqlite3ResolveExprListNames
(&
sNC
, 
p
->
pEList
) ) return 2;

56164 
pGroupBy
 = 
p
->pGroupBy;

56165 if( 
pGroupBy
 || (
sNC
.
ncFlags
 & 0x0002)!=0 )

56169 
p
->
selFlags
 |= 0x00008 | (
sNC
.
ncFlags
&0x1000);

56171 
sNC
.
ncFlags
 &= ~0x0001;

56176 if( 
p
->
pHaving
 && !
pGroupBy
 )

56179 
	`sqlite3ErrorMsg
(
pParse
, "a GROUP BY clause is required before HAVING");

56183 
sNC
.
pEList
 = 
p
->pEList;

56184 if( 
	`sqlite3ResolveExprNames
(&
sNC
, 
p
->
pHaving
) ) return 2;

56185 if( 
	`sqlite3ResolveExprNames
(&
sNC
, 
p
->
pWhere
) ) return 2;

56188 for(
i
=0; i<
p
->
pSrc
->
nSrc
; i++)

56191 struct 
SrcList_item
 *
pItem
 = &
p
->
pSrc
->
a
[
i
];

56192 if( 
pItem
->
fg
.
isTabFunc


56193 && 
	`sqlite3ResolveExprListNames
(&
sNC
, 
pItem
->
u1
.
pFuncArg
)

56204 
sNC
.
pNext
 = 0;

56205 
sNC
.
ncFlags
 |= 0x0001;

56212 if( 
p
->
selFlags
 & 0x08000 )

56215 
Select
 *
pSub
 = 
p
->
pSrc
->
a
[0].
pSelect
;

56216 
p
->
pOrderBy
 = 
pSub
->pOrderBy;

56217 
pSub
->
pOrderBy
 = 0;

56220 if( 
isCompound
<=
nCompound


56221 && 
	`resolveOrderGroupBy
(&
sNC
, 
p
, p->
pOrderBy
, "ORDER")

56227 if( 
db
->
mallocFailed
 )

56236 if( 
pGroupBy
 )

56239 struct 
ExprList_item
 *
pItem
;

56241 if( 
	`resolveOrderGroupBy
(&
sNC
, 
p
, 
pGroupBy
, "GROUP") || 
db
->
mallocFailed
 )

56246 for(
i
=0, 
pItem
=
pGroupBy
->
a
; i<pGroupBy->
nExpr
; i++, pItem++)

56249 if( (((
pItem
->
pExpr
)->
flags
&(0x000002))!=0) )

56252 
	`sqlite3ErrorMsg
(
pParse
, "aggregate functions are not allowed in "

56261 if( 
p
->
pNext
 && p->
pEList
->
nExpr
!=p->pNext->pEList->nExpr )

56264 
	`sqlite3SelectWrongNumTermsError
(
pParse
, 
p
->
pNext
);

56270 
p
 = p->
pPrior
;

56271 
nCompound
++;

56277 if( 
isCompound
 && 
	`resolveCompoundOrderBy
(
pParse
, 
pLeftmost
) )

56284 
	}
}

56286 static int 
	$sqlite3ResolveExprNames
(

56287 
NameContext
 *
pNC
,

56288 
Expr
 *
pExpr


56292 
u16
 
savedHasAgg
;

56293 
Walker
 
w
;

56295 if( 
pExpr
==0 ) return 0;

56298 
Parse
 *
pParse
 = 
pNC
->pParse;

56299 if( 
	`sqlite3ExprCheckHeight
(
pParse
, 
pExpr
->
nHeight
+
pNC
->pParse->nHeight) )

56304 
pParse
->
nHeight
 += 
pExpr
->nHeight;

56307 
savedHasAgg
 = 
pNC
->
ncFlags
 & (0x0002|0x1000);

56308 
pNC
->
ncFlags
 &= ~(0x0002|0x1000);

56309 
w
.
pParse
 = 
pNC
->pParse;

56310 
w
.
xExprCallback
 = 
resolveExprStep
;

56311 
w
.
xSelectCallback
 = 
resolveSelectStep
;

56312 
w
.
xSelectCallback2
 = 0;

56313 
w
.
walkerDepth
 = 0;

56314 
w
.
eCode
 = 0;

56315 
w
.
u
.
pNC
 = pNC;

56316 
	`sqlite3WalkExpr
(&
w
, 
pExpr
);

56318 
pNC
->
pParse
->
nHeight
 -= 
pExpr
->nHeight;

56320 if( 
pNC
->
nErr
>0 || 
w
.
pParse
->nErr>0 )

56323 (
pExpr
)->
flags
|=(0x000008);

56325 if( 
pNC
->
ncFlags
 & 0x0002 )

56328 (
pExpr
)->
flags
|=(0x000002);

56330 
pNC
->
ncFlags
 |= 
savedHasAgg
;

56331 return (((
pExpr
)->
flags
&(0x000008))!=0);

56332 
	}
}

56339 static int 
	$sqlite3ResolveExprListNames
(

56340 
NameContext
 *
pNC
,

56341 
ExprList
 *
pList


56345 int 
i
;

56346 if( 
pList
 )

56349 for(
i
=0; i<
pList
->
nExpr
; i++)

56352 if( 
	`sqlite3ResolveExprNames
(
pNC
, 
pList
->
a
[
i
].
pExpr
) ) return 2;

56356 
	}
}

56358 static void 
	$sqlite3ResolveSelectNames
(

56359 
Parse
 *
pParse
,

56360 
Select
 *
p
,

56361 
NameContext
 *
pOuterNC


56365 
Walker
 
w
;

56368 
	`memset
(&
w
, 0, sizeof(w));

56369 
w
.
xExprCallback
 = 
resolveExprStep
;

56370 
w
.
xSelectCallback
 = 
resolveSelectStep
;

56371 
w
.
pParse
 = pParse;

56372 
w
.
u
.
pNC
 = 
pOuterNC
;

56373 
	`sqlite3WalkSelect
(&
w
, 
p
);

56374 
	}
}

56376 static void 
	$sqlite3ResolveSelfReference
(

56377 
Parse
 *
pParse
,

56378 
Table
 *
pTab
,

56379 int 
type
,

56380 
Expr
 *
pExpr
,

56381 
ExprList
 *
pList


56385 
SrcList
 
sSrc
;

56386 
NameContext
 
sNC
;

56389 
	`memset
(&
sNC
, 0, sizeof(sNC));

56390 
	`memset
(&
sSrc
, 0, sizeof(sSrc));

56391 
sSrc
.
nSrc
 = 1;

56392 
sSrc
.
a
[0].
zName
 = 
pTab
->zName;

56393 
sSrc
.
a
[0].
pTab
 = pTab;

56394 
sSrc
.
a
[0].
iCursor
 = -1;

56395 
sNC
.
pParse
 = pParse;

56396 
sNC
.
pSrcList
 = &
sSrc
;

56397 
sNC
.
ncFlags
 = 
type
;

56398 if( 
	`sqlite3ResolveExprNames
(&
sNC
, 
pExpr
) ) return;

56399 if( 
pList
 ) 
	`sqlite3ResolveExprListNames
(&
sNC
, pList);

56400 
	}
}

56402 static char 
	$sqlite3ExprAffinity
(
Expr
 *
pExpr
)

56405 int 
op
;

56406 
pExpr
 = 
	`sqlite3ExprSkipCollate
(pExpr);

56407 if( 
pExpr
->
flags
 & 0x000200 ) return 0;

56408 
op
 = 
pExpr
->op;

56409 if( 
op
==119 )

56413 return 
	`sqlite3ExprAffinity
(
pExpr
->
x
.
pSelect
->
pEList
->
a
[0].pExpr);

56416 if( 
op
==38 )

56420 return 
	`sqlite3AffinityType
(
pExpr
->
u
.
zToken
, 0);

56423 if( (
op
==154 || op==152 || op==157)

56424 && 
pExpr
->
pTab
!=0

56430 int 
j
 = 
pExpr
->
iColumn
;

56431 if( 
j
<0 ) return 'D';

56433 return 
pExpr
->
pTab
->
aCol
[
j
].
affinity
;

56435 return 
pExpr
->
affinity
;

56436 
	}
}

56438 static 
Expr
 *
	$sqlite3ExprAddCollateToken
(

56439 
Parse
 *
pParse
,

56440 
Expr
 *
pExpr
,

56441 const 
Token
 *
pCollName
,

56442 int 
dequote


56446 if( 
pCollName
->
n
>0 )

56449 
Expr
 *
pNew
 = 
	`sqlite3ExprAlloc
(
pParse
->
db
, 95, 
pCollName
, 
dequote
);

56450 if( 
pNew
 )

56453 
pNew
->
pLeft
 = 
pExpr
;

56454 
pNew
->
flags
 |= 0x000100|0x001000;

56455 
pExpr
 = 
pNew
;

56458 return 
pExpr
;

56459 
	}
}

56460 static 
Expr
 *
	$sqlite3ExprAddCollateString
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, const char *
zC
)

56463 
Token
 
s
;

56465 
	`sqlite3TokenInit
(&
s
, (char*)
zC
);

56466 return 
	`sqlite3ExprAddCollateToken
(
pParse
, 
pExpr
, &
s
, 0);

56467 
	}
}

56473 static 
Expr
 *
	$sqlite3ExprSkipCollate
(
Expr
 *
pExpr
)

56476 while( 
pExpr
 && (((pExpr)->
flags
&(0x001000))!=0) )

56479 if( (((
pExpr
)->
flags
&(0x040000))!=0) )

56485 
pExpr
 = pExpr->
x
.
pList
->
a
[0].pExpr;

56488 
pExpr
 = pExpr->
pLeft
;

56491 return 
pExpr
;

56492 
	}
}

56494 static 
CollSeq
 *
	$sqlite3ExprCollSeq
(
Parse
 *
pParse
, 
Expr
 *
pExpr
)

56497 
sqlite3
 *
db
 = 
pParse
->db;

56498 
CollSeq
 *
pColl
 = 0;

56499 
Expr
 *
p
 = 
pExpr
;

56500 while( 
p
 )

56503 int 
op
 = 
p
->op;

56504 if( 
p
->
flags
 & 0x000200 ) break;

56505 if( 
op
==38 || op==156 )

56508 
p
 = p->
pLeft
;

56511 if( 
op
==95 || (op==157 && 
p
->
op2
==95) )

56514 
pColl
 = 
	`sqlite3GetCollSeq
(
pParse
, ((
db
)->
enc
), 0, 
p
->
u
.
zToken
);

56517 if( (
op
==154 || op==152

56518 || 
op
==157 || op==62)

56519 && 
p
->
pTab
!=0

56525 int 
j
 = 
p
->
iColumn
;

56526 if( 
j
>=0 )

56529 const char *
zColl
 = 
p
->
pTab
->
aCol
[
j
].zColl;

56530 
pColl
 = 
	`sqlite3FindCollSeq
(
db
, ((db)->
enc
), 
zColl
, 0);

56534 if( 
p
->
flags
 & 0x000100 )

56537 if( 
p
->
pLeft
 && (p->pLeft->
flags
 & 0x000100)!=0 )

56540 
p
 = p->
pLeft
;

56542 
Expr
 *
pNext
 = 
p
->
pRight
;

56548 if( 
p
->
x
.
pList
!=0 && (!(((p)->
flags
&(0x000800))!=0)) )

56551 int 
i
;

56552 for(
i
=0; (i<
p
->
x
.
pList
->
nExpr
); i++)

56555 if( (((
p
->
x
.
pList
->
a
[
i
].
pExpr
)->
flags
&(0x000100))!=0) )

56558 
pNext
 = 
p
->
x
.
pList
->
a
[
i
].
pExpr
;

56563 
p
 = 
pNext
;

56569 if( 
	`sqlite3CheckCollSeq
(
pParse
, 
pColl
) )

56572 
pColl
 = 0;

56574 return 
pColl
;

56575 
	}
}

56582 static char 
	$sqlite3CompareAffinity
(
Expr
 *
pExpr
, char 
aff2
)

56585 char 
aff1
 = 
	`sqlite3ExprAffinity
(
pExpr
);

56586 if( 
aff1
 && 
aff2
 )

56592 if( ((
aff1
)>='C') || ((
aff2
)>='C') )

56599 }else if( !
aff1
 && !
aff2
 )

56609 return (
aff1
 + 
aff2
);

56611 
	}
}

56617 static char 
	$comparisonAffinity
(
Expr
 *
pExpr
)

56620 char 
aff
;

56625 
aff
 = 
	`sqlite3ExprAffinity
(
pExpr
->
pLeft
);

56626 if( 
pExpr
->
pRight
 )

56629 
aff
 = 
	`sqlite3CompareAffinity
(
pExpr
->
pRight
, aff);

56630 }else if( (((
pExpr
)->
flags
&(0x000800))!=0) )

56633 
aff
 = 
	`sqlite3CompareAffinity
(
pExpr
->
x
.
pSelect
->
pEList
->
a
[0].pExpr, aff);

56634 }else if( !
aff
 )

56637 
aff
 = 'A';

56639 return 
aff
;

56640 
	}
}

56648 static int 
	$sqlite3IndexAffinityOk
(
Expr
 *
pExpr
, char 
idx_affinity
)

56651 char 
aff
 = 
	`comparisonAffinity
(
pExpr
);

56652 switch( 
aff
 )

56658 return 
idx_affinity
=='B';

56660 return ((
idx_affinity
)>='C');

56662 
	}
}

56668 static 
u8
 
	$binaryCompareP5
(
Expr
 *
pExpr1
, Expr *
pExpr2
, int 
jumpIfNull
)

56671 
u8
 
aff
 = (char)
	`sqlite3ExprAffinity
(
pExpr2
);

56672 
aff
 = (
u8
)
	`sqlite3CompareAffinity
(
pExpr1
, aff) | (u8)
jumpIfNull
;

56673 return 
aff
;

56674 
	}
}

56676 static 
CollSeq
 *
	$sqlite3BinaryCompareCollSeq
(

56677 
Parse
 *
pParse
,

56678 
Expr
 *
pLeft
,

56679 
Expr
 *
pRight


56683 
CollSeq
 *
pColl
;

56685 if( 
pLeft
->
flags
 & 0x000100 )

56688 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pLeft
);

56689 }else if( 
pRight
 && (pRight->
flags
 & 0x000100)!=0 )

56692 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pRight
);

56694 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pLeft
);

56695 if( !
pColl
 )

56698 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pRight
);

56701 return 
pColl
;

56702 
	}
}

56707 static int 
	$codeCompare
(

56708 
Parse
 *
pParse
,

56709 
Expr
 *
pLeft
,

56710 
Expr
 *
pRight
,

56711 int 
opcode
,

56712 int 
in1
, int 
in2
,

56713 int 
dest
,

56714 int 
jumpIfNull


56718 int 
p5
;

56719 int 
addr
;

56720 
CollSeq
 *
p4
;

56722 
p4
 = 
	`sqlite3BinaryCompareCollSeq
(
pParse
, 
pLeft
, 
pRight
);

56723 
p5
 = 
	`binaryCompareP5
(
pLeft
, 
pRight
, 
jumpIfNull
);

56724 
addr
 = 
	`sqlite3VdbeAddOp4
(
pParse
->
pVdbe
, 
opcode
, 
in2
, 
dest
, 
in1
,

56725 (void*)
p4
, (-4));

56726 
	`sqlite3VdbeChangeP5
(
pParse
->
pVdbe
, (
u8
)
p5
);

56727 return 
addr
;

56728 
	}
}

56736 static int 
	$sqlite3ExprCheckHeight
(
Parse
 *
pParse
, int 
nHeight
)

56739 int 
rc
 = 0;

56740 int 
mxHeight
 = 
pParse
->
db
->
aLimit
[3];

56741 if( 
nHeight
>
mxHeight
 )

56744 
	`sqlite3ErrorMsg
(
pParse
,

56745 "Expression tree is too large (maximum depth %d)", 
mxHeight


56747 
rc
 = 1;

56749 return 
rc
;

56750 
	}
}

56752 static void 
	$heightOfExpr
(
Expr
 *
p
, int *
pnHeight
)

56755 if( 
p
 )

56758 if( 
p
->
nHeight
>*
pnHeight
 )

56761 *
pnHeight
 = 
p
->
nHeight
;

56764 
	}
}

56765 static void 
	$heightOfExprList
(
ExprList
 *
p
, int *
pnHeight
)

56768 if( 
p
 )

56771 int 
i
;

56772 for(
i
=0; i<
p
->
nExpr
; i++)

56775 
	`heightOfExpr
(
p
->
a
[
i
].
pExpr
, 
pnHeight
);

56778 
	}
}

56779 static void 
	$heightOfSelect
(
Select
 *
p
, int *
pnHeight
)

56782 if( 
p
 )

56785 
	`heightOfExpr
(
p
->
pWhere
, 
pnHeight
);

56786 
	`heightOfExpr
(
p
->
pHaving
, 
pnHeight
);

56787 
	`heightOfExpr
(
p
->
pLimit
, 
pnHeight
);

56788 
	`heightOfExpr
(
p
->
pOffset
, 
pnHeight
);

56789 
	`heightOfExprList
(
p
->
pEList
, 
pnHeight
);

56790 
	`heightOfExprList
(
p
->
pGroupBy
, 
pnHeight
);

56791 
	`heightOfExprList
(
p
->
pOrderBy
, 
pnHeight
);

56792 
	`heightOfSelect
(
p
->
pPrior
, 
pnHeight
);

56794 
	}
}

56796 static void 
	$exprSetHeight
(
Expr
 *
p
)

56799 int 
nHeight
 = 0;

56800 
	`heightOfExpr
(
p
->
pLeft
, &
nHeight
);

56801 
	`heightOfExpr
(
p
->
pRight
, &
nHeight
);

56802 if( (((
p
)->
flags
&(0x000800))!=0) )

56805 
	`heightOfSelect
(
p
->
x
.
pSelect
, &
nHeight
);

56806 }else if( 
p
->
x
.
pList
 )

56809 
	`heightOfExprList
(
p
->
x
.
pList
, &
nHeight
);

56810 
p
->
flags
 |= (0x000100|0x200000) & 
	`sqlite3ExprListFlags
(p->
x
.
pList
);

56812 
p
->
nHeight
 = nHeight + 1;

56813 
	}
}

56815 static void 
	$sqlite3ExprSetHeightAndFlags
(
Parse
 *
pParse
, 
Expr
 *
p
)

56818 if( 
pParse
->
nErr
 ) return;

56819 
	`exprSetHeight
(
p
);

56820 
	`sqlite3ExprCheckHeight
(
pParse
, 
p
->
nHeight
);

56821 
	}
}

56827 static int 
	$sqlite3SelectExprHeight
(
Select
 *
p
)

56830 int 
nHeight
 = 0;

56831 
	`heightOfSelect
(
p
, &
nHeight
);

56832 return 
nHeight
;

56833 
	}
}

56835 static 
Expr
 *
	$sqlite3ExprAlloc
(

56836 
sqlite3
 *
db
,

56837 int 
op
,

56838 const 
Token
 *
pToken
,

56839 int 
dequote


56843 
Expr
 *
pNew
;

56844 int 
nExtra
 = 0;

56845 int 
iValue
 = 0;

56848 if( 
pToken
 )

56851 if( 
op
!=132 || 
pToken
->
z
==0

56852 || 
	`sqlite3GetInt32
(
pToken
->
z
, &
iValue
)==0 )

56855 
nExtra
 = 
pToken
->
n
+1;

56859 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(
Expr
)+
nExtra
);

56860 if( 
pNew
 )

56863 
	`memset
(
pNew
, 0, sizeof(
Expr
));

56864 
pNew
->
op
 = (
u8
)op;

56865 
pNew
->
iAgg
 = -1;

56866 if( 
pToken
 )

56869 if( 
nExtra
==0 )

56872 
pNew
->
flags
 |= 0x000400;

56873 
pNew
->
u
.
iValue
 = iValue;

56875 int 
c
;

56876 
pNew
->
u
.
zToken
 = (char*)&pNew[1];

56878 if( 
pToken
->
n
 ) 
	`memcpy
(
pNew
->
u
.
zToken
, pToken->
z
, pToken->n);

56879 
pNew
->
u
.
zToken
[
pToken
->
n
] = 0;

56880 if( 
dequote
 && 
nExtra
>=3

56881 && ((
c
 = 
pToken
->
z
[0])=='\'' || c=='"' || c=='[' || c=='`') )

56884 
	`sqlite3Dequote
(
pNew
->
u
.
zToken
);

56885 if( 
c
=='"' ) 
pNew
->
flags
 |= 0x000040;

56890 
pNew
->
nHeight
 = 1;

56893 return 
pNew
;

56894 
	}
}

56900 static 
Expr
 *
	$sqlite3Expr
(

56901 
sqlite3
 *
db
,

56902 int 
op
,

56903 const char *
zToken


56907 
Token
 
x
;

56908 
x
.
z
 = 
zToken
;

56909 
x
.
n
 = 
zToken
 ? 
	`sqlite3Strlen30
(zToken) : 0;

56910 return 
	`sqlite3ExprAlloc
(
db
, 
op
, &
x
, 0);

56911 
	}
}

56919 static void 
	$sqlite3ExprAttachSubtrees
(

56920 
sqlite3
 *
db
,

56921 
Expr
 *
pRoot
,

56922 
Expr
 *
pLeft
,

56923 
Expr
 *
pRight


56927 if( 
pRoot
==0 )

56931 
	`sqlite3ExprDelete
(
db
, 
pLeft
);

56932 
	`sqlite3ExprDelete
(
db
, 
pRight
);

56934 if( 
pRight
 )

56937 
pRoot
->
pRight
 = pRight;

56938 
pRoot
->
flags
 |= (0x000100|0x200000) & 
pRight
->flags;

56940 if( 
pLeft
 )

56943 
pRoot
->
pLeft
 = pLeft;

56944 
pRoot
->
flags
 |= (0x000100|0x200000) & 
pLeft
->flags;

56946 
	`exprSetHeight
(
pRoot
);

56948 
	}
}

56950 static 
Expr
 *
	$sqlite3PExpr
(

56951 
Parse
 *
pParse
,

56952 int 
op
,

56953 
Expr
 *
pLeft
,

56954 
Expr
 *
pRight
,

56955 const 
Token
 *
pToken


56959 
Expr
 *
p
;

56960 if( 
op
==72 && 
pParse
->
nErr
==0 )

56964 
p
 = 
	`sqlite3ExprAnd
(
pParse
->
db
, 
pLeft
, 
pRight
);

56966 
p
 = 
	`sqlite3ExprAlloc
(
pParse
->
db
, 
op
 & 0xff, 
pToken
, 1);

56967 
	`sqlite3ExprAttachSubtrees
(
pParse
->
db
, 
p
, 
pLeft
, 
pRight
);

56969 if( 
p
 ) {

56970 
	`sqlite3ExprCheckHeight
(
pParse
, 
p
->
nHeight
);

56972 return 
p
;

56973 
	}
}

56975 static int 
	$exprAlwaysTrue
(
Expr
 *
p
)

56978 int 
v
 = 0;

56979 if( (((
p
)->
flags
&(0x000001))!=0) ) return 0;

56980 if( !
	`sqlite3ExprIsInteger
(
p
, &
v
) ) return 0;

56981 return 
v
!=0;

56982 
	}
}

56983 static int 
	$exprAlwaysFalse
(
Expr
 *
p
)

56986 int 
v
 = 0;

56987 if( (((
p
)->
flags
&(0x000001))!=0) ) return 0;

56988 if( !
	`sqlite3ExprIsInteger
(
p
, &
v
) ) return 0;

56989 return 
v
==0;

56990 
	}
}

56992 static 
Expr
 *
	$sqlite3ExprAnd
(
sqlite3
 *
db
, 
Expr
 *
pLeft
, Expr *
pRight
)

56995 if( 
pLeft
==0 )

56998 return 
pRight
;

56999 }else if( 
pRight
==0 )

57002 return 
pLeft
;

57003 }else if( 
	`exprAlwaysFalse
(
pLeft
) || exprAlwaysFalse(
pRight
) )

57006 
	`sqlite3ExprDelete
(
db
, 
pLeft
);

57007 
	`sqlite3ExprDelete
(
db
, 
pRight
);

57008 return 
	`sqlite3ExprAlloc
(
db
, 132, &
sqlite3IntTokens
[0], 0);

57010 
Expr
 *
pNew
 = 
	`sqlite3ExprAlloc
(
db
, 72, 0, 0);

57011 
	`sqlite3ExprAttachSubtrees
(
db
, 
pNew
, 
pLeft
, 
pRight
);

57012 return 
pNew
;

57014 
	}
}

57020 static 
Expr
 *
	$sqlite3ExprFunction
(
Parse
 *
pParse
, 
ExprList
 *
pList
, 
Token
 *
pToken
)

57023 
Expr
 *
pNew
;

57024 
sqlite3
 *
db
 = 
pParse
->db;

57026 
pNew
 = 
	`sqlite3ExprAlloc
(
db
, 151, 
pToken
, 1);

57027 if( 
pNew
==0 )

57030 
	`sqlite3ExprListDelete
(
db
, 
pList
);

57033 
pNew
->
x
.
pList
 = pList;

57035 
	`sqlite3ExprSetHeightAndFlags
(
pParse
, 
pNew
);

57036 return 
pNew
;

57037 
	}
}

57039 static void 
	$sqlite3ExprAssignVarNumber
(
Parse
 *
pParse
, 
Expr
 *
pExpr
)

57042 
sqlite3
 *
db
 = 
pParse
->db;

57043 const char *
z
;

57045 if( 
pExpr
==0 ) return;

57047 
z
 = 
pExpr
->
u
.
zToken
;

57050 if( 
z
[1]==0 )

57055 
pExpr
->
iColumn
 = (
ynVar
)(++
pParse
->
nVar
);

57057 
ynVar
 
x
 = 0;

57058 
u32
 
n
 = 
	`sqlite3Strlen30
(
z
);

57059 if( 
z
[0]=='?' )

57064 
i64
 
i
;

57065 int 
bOk
 = 0==
	`sqlite3Atoi64
(&
z
[1], &
i
, 
n
-1, 1);

57066 
pExpr
->
iColumn
 = 
x
 = (
ynVar
)
i
;

57071 if( 
bOk
==0 || 
i
<1 || i>
db
->
aLimit
[9] )

57074 
	`sqlite3ErrorMsg
(
pParse
, "variable number must be between ?1 and ?%d",

57075 
db
->
aLimit
[9]);

57076 
x
 = 0;

57078 if( 
i
>
pParse
->
nVar
 )

57081 
pParse
->
nVar
 = (int)
i
;

57088 
ynVar
 
i
;

57089 for(
i
=0; i<
pParse
->
nzVar
; i++)

57092 if( 
pParse
->
azVar
[
i
] && 
	`strcmp
(pParse->azVar[i],
z
)==0 )

57095 
pExpr
->
iColumn
 = 
x
 = (
ynVar
)
i
+1;

57099 if( 
x
==0 ) x = 
pExpr
->
iColumn
 = (
ynVar
)(++
pParse
->
nVar
);

57101 if( 
x
>0 )

57104 if( 
x
>
pParse
->
nzVar
 )

57107 char **
a
;

57108 
a
 = 
	`sqlite3DbRealloc
(
db
, 
pParse
->
azVar
, 
x
*sizeof(a[0]));

57109 if( 
a
==0 )

57115 
pParse
->
azVar
 = 
a
;

57116 
	`memset
(&
a
[
pParse
->
nzVar
], 0, (
x
-pParse->nzVar)*sizeof(a[0]));

57117 
pParse
->
nzVar
 = 
x
;

57119 if( 
z
[0]!='?' || 
pParse
->
azVar
[
x
-1]==0 )

57122 
	`sqlite3DbFree
(
db
, 
pParse
->
azVar
[
x
-1]);

57123 
pParse
->
azVar
[
x
-1] = 
	`sqlite3DbStrNDup
(
db
, 
z
, 
n
);

57127 if( !
pParse
->
nErr
 && pParse->
nVar
>
db
->
aLimit
[9] )

57130 
	`sqlite3ErrorMsg
(
pParse
, "too many SQL variables");

57132 
	}
}

57137 static void 
	$sqlite3ExprDelete
(
sqlite3
 *
db
, 
Expr
 *
p
)

57140 if( 
p
==0 ) return;

57143 if( !(((
p
)->
flags
&(0x004000))!=0) )

57148 
	`sqlite3ExprDelete
(
db
, 
p
->
pLeft
);

57149 
	`sqlite3ExprDelete
(
db
, 
p
->
pRight
);

57150 if( (((
p
)->
flags
&(0x010000))!=0) ) 
	`sqlite3DbFree
(
db
, p->
u
.
zToken
);

57151 if( (((
p
)->
flags
&(0x000800))!=0) )

57154 
	`sqlite3SelectDelete
(
db
, 
p
->
x
.
pSelect
);

57156 
	`sqlite3ExprListDelete
(
db
, 
p
->
x
.
pList
);

57159 if( !(((
p
)->
flags
&(0x008000))!=0) )

57162 
	`sqlite3DbFree
(
db
, 
p
);

57164 
	}
}

57171 static int 
	$exprStructSize
(
Expr
 *
p
)

57174 if( (((
p
)->
flags
&(0x004000))!=0) ) return 
	`__builtin_offsetof
 (
Expr
, 
pLeft
);

57175 if( (((
p
)->
flags
&(0x002000))!=0) ) return 
	`__builtin_offsetof
 (
Expr
, 
iTable
);

57176 return sizeof(
Expr
);

57177 
	}
}

57179 static int 
	$dupedExprStructSize
(
Expr
 *
p
, int 
flags
)

57182 int 
nSize
;

57186 if( 0==(
flags
&0x0001) )

57189 
nSize
 = sizeof(
Expr
);

57195 if( 
p
->
pLeft
 || p->
x
.
pList
 )

57198 
nSize
 = 
	`__builtin_offsetof
 (
Expr
, 
iTable
) | 0x002000;

57201 
nSize
 = 
	`__builtin_offsetof
 (
Expr
, 
pLeft
) | 0x004000;

57204 return 
nSize
;

57205 
	}
}

57212 static int 
	$dupedExprNodeSize
(
Expr
 *
p
, int 
flags
)

57215 int 
nByte
 = 
	`dupedExprStructSize
(
p
, 
flags
) & 0xfff;

57216 if( !(((
p
)->
flags
&(0x000400))!=0) && p->
u
.
zToken
 )

57219 
nByte
 += 
	`sqlite3Strlen30
(
p
->
u
.
zToken
)+1;

57221 return (((
nByte
)+7)&~7);

57222 
	}
}

57224 static int 
	$dupedExprSize
(
Expr
 *
p
, int 
flags
)

57227 int 
nByte
 = 0;

57228 if( 
p
 )

57231 
nByte
 = 
	`dupedExprNodeSize
(
p
, 
flags
);

57232 if( 
flags
&0x0001 )

57235 
nByte
 += 
	`dupedExprSize
(
p
->
pLeft
, 
flags
) + dupedExprSize(p->
pRight
, flags);

57238 return 
nByte
;

57239 
	}
}

57241 static 
Expr
 *
	$exprDup
(
sqlite3
 *
db
, 
Expr
 *
p
, int 
flags
, 
u8
 **
pzBuffer
)

57244 
Expr
 *
pNew
 = 0;

57247 if( 
p
 )

57250 const int 
isReduced
 = (
flags
&0x0001);

57251 
u8
 *
zAlloc
;

57252 
u32
 
staticFlag
 = 0;

57257 if( 
pzBuffer
 )

57260 
zAlloc
 = *
pzBuffer
;

57261 
staticFlag
 = 0x008000;

57263 
zAlloc
 = 
	`sqlite3DbMallocRawNN
(
db
, 
	`dupedExprSize
(
p
, 
flags
));

57265 
pNew
 = (
Expr
 *)
zAlloc
;

57267 if( 
pNew
 )

57275 const unsigned 
nStructSize
 = 
	`dupedExprStructSize
(
p
, 
flags
);

57276 const int 
nNewSize
 = 
nStructSize
 & 0xfff;

57277 int 
nToken
;

57278 if( !(((
p
)->
flags
&(0x000400))!=0) && p->
u
.
zToken
 )

57281 
nToken
 = 
	`sqlite3Strlen30
(
p
->
u
.
zToken
) + 1;

57283 
nToken
 = 0;

57285 if( 
isReduced
 )

57289 
	`memcpy
(
zAlloc
, 
p
, 
nNewSize
);

57291 
u32
 
nSize
 = (u32)
	`exprStructSize
(
p
);

57292 
	`memcpy
(
zAlloc
, 
p
, 
nSize
);

57293 if( 
nSize
<sizeof(
Expr
) )

57296 
	`memset
(&
zAlloc
[
nSize
], 0, sizeof(
Expr
)-nSize);

57301 
pNew
->
flags
 &= ~(0x002000|0x004000|0x008000|0x010000);

57302 
pNew
->
flags
 |= 
nStructSize
 & (0x002000|0x004000);

57303 
pNew
->
flags
 |= 
staticFlag
;

57306 if( 
nToken
 )

57309 char *
zToken
 = 
pNew
->
u
.zToken = (char*)&
zAlloc
[
nNewSize
];

57310 
	`memcpy
(
zToken
, 
p
->
u
.zToken, 
nToken
);

57313 if( 0==((
p
->
flags
|
pNew
->flags) & 0x004000) )

57317 if( (((
p
)->
flags
&(0x000800))!=0) )

57320 
pNew
->
x
.
pSelect
 = 
	`sqlite3SelectDup
(
db
, 
p
->x.pSelect, 
isReduced
);

57322 
pNew
->
x
.
pList
 = 
	`sqlite3ExprListDup
(
db
, 
p
->x.pList, 
isReduced
);

57327 if( (((
pNew
)->
flags
&(0x002000|0x004000))!=0) )

57330 
zAlloc
 += 
	`dupedExprNodeSize
(
p
, 
flags
);

57331 if( (((
pNew
)->
flags
&(0x002000))!=0) )

57334 
pNew
->
pLeft
 = 
	`exprDup
(
db
, 
p
->pLeft, 0x0001, &
zAlloc
);

57335 
pNew
->
pRight
 = 
	`exprDup
(
db
, 
p
->pRight, 0x0001, &
zAlloc
);

57337 if( 
pzBuffer
 )

57340 *
pzBuffer
 = 
zAlloc
;

57343 if( !(((
p
)->
flags
&(0x004000))!=0) )

57346 
pNew
->
pLeft
 = 
	`sqlite3ExprDup
(
db
, 
p
->pLeft, 0);

57347 
pNew
->
pRight
 = 
	`sqlite3ExprDup
(
db
, 
p
->pRight, 0);

57353 return 
pNew
;

57354 
	}
}

57362 static 
With
 *
	$withDup
(
sqlite3
 *
db
, 
With
 *
p
)

57365 
With
 *
pRet
 = 0;

57366 if( 
p
 )

57369 int 
nByte
 = sizeof(*
p
) + sizeof(p->
a
[0]) * (p->
nCte
-1);

57370 
pRet
 = 
	`sqlite3DbMallocZero
(
db
, 
nByte
);

57371 if( 
pRet
 )

57374 int 
i
;

57375 
pRet
->
nCte
 = 
p
->nCte;

57376 for(
i
=0; i<
p
->
nCte
; i++)

57379 
pRet
->
a
[
i
].
pSelect
 = 
	`sqlite3SelectDup
(
db
, 
p
->a[i].pSelect, 0);

57380 
pRet
->
a
[
i
].
pCols
 = 
	`sqlite3ExprListDup
(
db
, 
p
->a[i].pCols, 0);

57381 
pRet
->
a
[
i
].
zName
 = 
	`sqlite3DbStrDup
(
db
, 
p
->a[i].zName);

57385 return 
pRet
;

57386 
	}
}

57388 static 
Expr
 *
	$sqlite3ExprDup
(
sqlite3
 *
db
, 
Expr
 *
p
, int 
flags
)

57392 return 
	`exprDup
(
db
, 
p
, 
flags
, 0);

57393 
	}
}

57394 static 
ExprList
 *
	$sqlite3ExprListDup
(
sqlite3
 *
db
, 
ExprList
 *
p
, int 
flags
)

57397 
ExprList
 *
pNew
;

57398 struct 
ExprList_item
 *
pItem
, *
pOldItem
;

57399 int 
i
;

57401 if( 
p
==0 ) return 0;

57402 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(*pNew) );

57403 if( 
pNew
==0 ) return 0;

57404 
pNew
->
nExpr
 = 
i
 = 
p
->nExpr;

57405 if( (
flags
 & 0x0001)==0 ) for(
i
=1; i<
p
->
nExpr
; i+=i)

57408 
pNew
->
a
 = 
pItem
 = 
	`sqlite3DbMallocRawNN
(
db
, 
i
*sizeof(
p
->a[0]) );

57409 if( 
pItem
==0 )

57412 
	`sqlite3DbFree
(
db
, 
pNew
);

57415 
pOldItem
 = 
p
->
a
;

57416 for(
i
=0; i<
p
->
nExpr
; i++, 
pItem
++, 
pOldItem
++)

57419 
Expr
 *
pOldExpr
 = 
pOldItem
->
pExpr
;

57420 
pItem
->
pExpr
 = 
	`sqlite3ExprDup
(
db
, 
pOldExpr
, 
flags
);

57421 
pItem
->
zName
 = 
	`sqlite3DbStrDup
(
db
, 
pOldItem
->zName);

57422 
pItem
->
zSpan
 = 
	`sqlite3DbStrDup
(
db
, 
pOldItem
->zSpan);

57423 
pItem
->
sortOrder
 = 
pOldItem
->sortOrder;

57424 
pItem
->
done
 = 0;

57425 
pItem
->
bSpanIsTab
 = 
pOldItem
->bSpanIsTab;

57426 
pItem
->
u
 = 
pOldItem
->u;

57428 return 
pNew
;

57429 
	}
}

57431 static 
SrcList
 *
	$sqlite3SrcListDup
(
sqlite3
 *
db
, 
SrcList
 *
p
, int 
flags
)

57434 
SrcList
 *
pNew
;

57435 int 
i
;

57436 int 
nByte
;

57438 if( 
p
==0 ) return 0;

57439 
nByte
 = sizeof(*
p
) + (p->
nSrc
>0 ? sizeof(p->
a
[0]) * (p->nSrc-1) : 0);

57440 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, 
nByte
 );

57441 if( 
pNew
==0 ) return 0;

57442 
pNew
->
nSrc
 = pNew->
nAlloc
 = 
p
->nSrc;

57443 for(
i
=0; i<
p
->
nSrc
; i++)

57446 struct 
SrcList_item
 *
pNewItem
 = &
pNew
->
a
[
i
];

57447 struct 
SrcList_item
 *
pOldItem
 = &
p
->
a
[
i
];

57448 
Table
 *
pTab
;

57449 
pNewItem
->
pSchema
 = 
pOldItem
->pSchema;

57450 
pNewItem
->
zDatabase
 = 
	`sqlite3DbStrDup
(
db
, 
pOldItem
->zDatabase);

57451 
pNewItem
->
zName
 = 
	`sqlite3DbStrDup
(
db
, 
pOldItem
->zName);

57452 
pNewItem
->
zAlias
 = 
	`sqlite3DbStrDup
(
db
, 
pOldItem
->zAlias);

57453 
pNewItem
->
fg
 = 
pOldItem
->fg;

57454 
pNewItem
->
iCursor
 = 
pOldItem
->iCursor;

57455 
pNewItem
->
addrFillSub
 = 
pOldItem
->addrFillSub;

57456 
pNewItem
->
regReturn
 = 
pOldItem
->regReturn;

57457 if( 
pNewItem
->
fg
.
isIndexedBy
 )

57460 
pNewItem
->
u1
.
zIndexedBy
 = 
	`sqlite3DbStrDup
(
db
, 
pOldItem
->u1.zIndexedBy);

57462 
pNewItem
->
pIBIndex
 = 
pOldItem
->pIBIndex;

57463 if( 
pNewItem
->
fg
.
isTabFunc
 )

57466 
pNewItem
->
u1
.
pFuncArg
 =

57467 
	`sqlite3ExprListDup
(
db
, 
pOldItem
->
u1
.
pFuncArg
, 
flags
);

57469 
pTab
 = 
pNewItem
->pTab = 
pOldItem
->pTab;

57470 if( 
pTab
 )

57473 
pTab
->
nRef
++;

57475 
pNewItem
->
pSelect
 = 
	`sqlite3SelectDup
(
db
, 
pOldItem
->pSelect, 
flags
);

57476 
pNewItem
->
pOn
 = 
	`sqlite3ExprDup
(
db
, 
pOldItem
->pOn, 
flags
);

57477 
pNewItem
->
pUsing
 = 
	`sqlite3IdListDup
(
db
, 
pOldItem
->pUsing);

57478 
pNewItem
->
colUsed
 = 
pOldItem
->colUsed;

57480 return 
pNew
;

57481 
	}
}

57482 static 
IdList
 *
	$sqlite3IdListDup
(
sqlite3
 *
db
, 
IdList
 *
p
)

57485 
IdList
 *
pNew
;

57486 int 
i
;

57488 if( 
p
==0 ) return 0;

57489 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(*pNew) );

57490 if( 
pNew
==0 ) return 0;

57491 
pNew
->
nId
 = 
p
->nId;

57492 
pNew
->
a
 = 
	`sqlite3DbMallocRawNN
(
db
, 
p
->
nId
*sizeof(p->a[0]) );

57493 if( 
pNew
->
a
==0 )

57496 
	`sqlite3DbFree
(
db
, 
pNew
);

57502 for(
i
=0; i<
p
->
nId
; i++)

57505 struct 
IdList_item
 *
pNewItem
 = &
pNew
->
a
[
i
];

57506 struct 
IdList_item
 *
pOldItem
 = &
p
->
a
[
i
];

57507 
pNewItem
->
zName
 = 
	`sqlite3DbStrDup
(
db
, 
pOldItem
->zName);

57508 
pNewItem
->
idx
 = 
pOldItem
->idx;

57510 return 
pNew
;

57511 
	}
}

57512 static 
Select
 *
	$sqlite3SelectDup
(
sqlite3
 *
db
, 
Select
 *
p
, int 
flags
)

57515 
Select
 *
pNew
, *
pPrior
;

57517 if( 
p
==0 ) return 0;

57518 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(*
p
) );

57519 if( 
pNew
==0 ) return 0;

57520 
pNew
->
pEList
 = 
	`sqlite3ExprListDup
(
db
, 
p
->pEList, 
flags
);

57521 
pNew
->
pSrc
 = 
	`sqlite3SrcListDup
(
db
, 
p
->pSrc, 
flags
);

57522 
pNew
->
pWhere
 = 
	`sqlite3ExprDup
(
db
, 
p
->pWhere, 
flags
);

57523 
pNew
->
pGroupBy
 = 
	`sqlite3ExprListDup
(
db
, 
p
->pGroupBy, 
flags
);

57524 
pNew
->
pHaving
 = 
	`sqlite3ExprDup
(
db
, 
p
->pHaving, 
flags
);

57525 
pNew
->
pOrderBy
 = 
	`sqlite3ExprListDup
(
db
, 
p
->pOrderBy, 
flags
);

57526 
pNew
->
op
 = 
p
->op;

57527 
pNew
->
pPrior
 = pPrior = 
	`sqlite3SelectDup
(
db
, 
p
->pPrior, 
flags
);

57528 if( 
pPrior
 ) pPrior->
pNext
 = 
pNew
;

57529 
pNew
->
pNext
 = 0;

57530 
pNew
->
pLimit
 = 
	`sqlite3ExprDup
(
db
, 
p
->pLimit, 
flags
);

57531 
pNew
->
pOffset
 = 
	`sqlite3ExprDup
(
db
, 
p
->pOffset, 
flags
);

57532 
pNew
->
iLimit
 = 0;

57533 
pNew
->
iOffset
 = 0;

57534 
pNew
->
selFlags
 = 
p
->selFlags & ~0x00010;

57535 
pNew
->
addrOpenEphm
[0] = -1;

57536 
pNew
->
addrOpenEphm
[1] = -1;

57537 
pNew
->
nSelectRow
 = 
p
->nSelectRow;

57538 
pNew
->
pWith
 = 
	`withDup
(
db
, 
p
->pWith);

57540 return 
pNew
;

57541 
	}
}

57543 static 
ExprList
 *
	$sqlite3ExprListAppend
(

57544 
Parse
 *
pParse
,

57545 
ExprList
 *
pList
,

57546 
Expr
 *
pExpr


57550 
sqlite3
 *
db
 = 
pParse
->db;

57552 if( 
pList
==0 )

57555 
pList
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(
ExprList
) );

57556 if( 
pList
==0 )

57559 goto 
no_mem
;

57561 
pList
->
nExpr
 = 0;

57562 
pList
->
a
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(pList->a[0]));

57563 if( 
pList
->
a
==0 ) goto 
no_mem
;

57564 }else if( (
pList
->
nExpr
 & (pList->nExpr-1))==0 )

57567 struct 
ExprList_item
 *
a
;

57569 
a
 = 
	`sqlite3DbRealloc
(
db
, 
pList
->a, pList->
nExpr
*2*sizeof(pList->a[0]));

57570 if( 
a
==0 )

57573 goto 
no_mem
;

57575 
pList
->
a
 = a;

57581 struct 
ExprList_item
 *
pItem
 = &
pList
->
a
[pList->
nExpr
++];

57582 
	`memset
(
pItem
, 0, sizeof(*pItem));

57583 
pItem
->
pExpr
 = pExpr;

57585 return 
pList
;

57587 
no_mem
:

57589 
	`sqlite3ExprDelete
(
db
, 
pExpr
);

57590 
	`sqlite3ExprListDelete
(
db
, 
pList
);

57592 
	}
}

57597 static void 
	$sqlite3ExprListSetSortOrder
(
ExprList
 *
p
, int 
iSortOrder
)

57600 if( 
p
==0 ) return;

57603 if( 
iSortOrder
<0 )

57609 
p
->
a
[p->
nExpr
-1].
sortOrder
 = (
u8
)
iSortOrder
;

57610 
	}
}

57612 static void 
	$sqlite3ExprListSetName
(

57613 
Parse
 *
pParse
,

57614 
ExprList
 *
pList
,

57615 
Token
 *
pName
,

57616 int 
dequote


57621 if( 
pList
 )

57624 struct 
ExprList_item
 *
pItem
;

57626 
pItem
 = &
pList
->
a
[pList->
nExpr
-1];

57628 
pItem
->
zName
 = 
	`sqlite3DbStrNDup
(
pParse
->
db
, 
pName
->
z
, pName->
n
);

57629 if( 
dequote
 && 
pItem
->
zName
 ) 
	`sqlite3Dequote
(pItem->zName);

57631 
	}
}

57633 static void 
	$sqlite3ExprListSetSpan
(

57634 
Parse
 *
pParse
,

57635 
ExprList
 *
pList
,

57636 
ExprSpan
 *
pSpan


57640 
sqlite3
 *
db
 = 
pParse
->db;

57642 if( 
pList
 )

57645 struct 
ExprList_item
 *
pItem
 = &
pList
->
a
[pList->
nExpr
-1];

57648 
	`sqlite3DbFree
(
db
, 
pItem
->
zSpan
);

57649 
pItem
->
zSpan
 = 
	`sqlite3DbStrNDup
(
db
, (char*)
pSpan
->
zStart
,

57650 (int)(
pSpan
->
zEnd
 - pSpan->
zStart
));

57652 
	}
}

57658 static void 
	$sqlite3ExprListCheckLength
(

57659 
Parse
 *
pParse
,

57660 
ExprList
 *
pEList
,

57661 const char *
zObject


57665 int 
mx
 = 
pParse
->
db
->
aLimit
[2];

57668 if( 
pEList
 && pEList->
nExpr
>
mx
 )

57671 
	`sqlite3ErrorMsg
(
pParse
, "too many columns in %s", 
zObject
);

57673 
	}
}

57678 static void 
	$sqlite3ExprListDelete
(
sqlite3
 *
db
, 
ExprList
 *
pList
)

57681 int 
i
;

57682 struct 
ExprList_item
 *
pItem
;

57683 if( 
pList
==0 ) return;

57685 for(
pItem
=
pList
->
a
, 
i
=0; i<pList->
nExpr
; i++, pItem++)

57688 
	`sqlite3ExprDelete
(
db
, 
pItem
->
pExpr
);

57689 
	`sqlite3DbFree
(
db
, 
pItem
->
zName
);

57690 
	`sqlite3DbFree
(
db
, 
pItem
->
zSpan
);

57692 
	`sqlite3DbFree
(
db
, 
pList
->
a
);

57693 
	`sqlite3DbFree
(
db
, 
pList
);

57694 
	}
}

57700 static 
u32
 
	$sqlite3ExprListFlags
(const 
ExprList
 *
pList
)

57703 int 
i
;

57704 
u32
 
m
 = 0;

57705 if( 
pList
 )

57708 for(
i
=0; i<
pList
->
nExpr
; i++)

57711 
Expr
 *
pExpr
 = 
pList
->
a
[
i
].pExpr;

57713 
m
 |= 
pExpr
->
flags
;

57716 return 
m
;

57717 
	}
}

57719 static int 
	$exprNodeIsConstant
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

57726 if( 
pWalker
->
eCode
==2 && (((
pExpr
)->
flags
&(0x000001))!=0) )

57729 
pWalker
->
eCode
 = 0;

57733 switch( 
pExpr
->
op
 )

57740 if( 
pWalker
->
eCode
>=4 || (((
pExpr
)->
flags
&(0x080000))!=0) )

57745 
pWalker
->
eCode
 = 0;

57756 if( 
pWalker
->
eCode
==3 && 
pExpr
->
iTable
==pWalker->
u
.
iCur
 )

57761 
pWalker
->
eCode
 = 0;

57765 if( 
pWalker
->
eCode
==5 )

57771 
pExpr
->
op
 = 101;

57772 }else if( 
pWalker
->
eCode
==4 )

57777 
pWalker
->
eCode
 = 0;

57786 
	}
}

57787 static int 
	$selectNodeIsConstant
(
Walker
 *
pWalker
, 
Select
 *
NotUsed
)

57790 (void)(
NotUsed
);

57791 
pWalker
->
eCode
 = 0;

57793 
	}
}

57794 static int 
	$exprIsConst
(
Expr
 *
p
, int 
initFlag
, int 
iCur
)

57797 
Walker
 
w
;

57798 
	`memset
(&
w
, 0, sizeof(w));

57799 
w
.
eCode
 = 
initFlag
;

57800 
w
.
xExprCallback
 = 
exprNodeIsConstant
;

57801 
w
.
xSelectCallback
 = 
selectNodeIsConstant
;

57802 
w
.
u
.
iCur
 = iCur;

57803 
	`sqlite3WalkExpr
(&
w
, 
p
);

57804 return 
w
.
eCode
;

57805 
	}
}

57807 static int 
	$sqlite3ExprIsConstant
(
Expr
 *
p
)

57810 return 
	`exprIsConst
(
p
, 1, 0);

57811 
	}
}

57819 static int 
	$sqlite3ExprIsConstantNotJoin
(
Expr
 *
p
)

57822 return 
	`exprIsConst
(
p
, 2, 0);

57823 
	}
}

57831 static int 
	$sqlite3ExprIsTableConstant
(
Expr
 *
p
, int 
iCur
)

57834 return 
	`exprIsConst
(
p
, 3, 
iCur
);

57835 
	}
}

57837 static int 
	$sqlite3ExprIsConstantOrFunction
(
Expr
 *
p
, 
u8
 
isInit
)

57841 return 
	`exprIsConst
(
p
, 4+
isInit
, 0);

57842 
	}
}

57844 static int 
	$sqlite3ExprIsInteger
(
Expr
 *
p
, int *
pValue
)

57847 int 
rc
 = 0;

57854 if( 
p
->
flags
 & 0x000400 )

57857 *
pValue
 = 
p
->
u
.
iValue
;

57860 switch( 
p
->
op
 )

57864 
rc
 = 
	`sqlite3ExprIsInteger
(
p
->
pLeft
, 
pValue
);

57868 int 
v
;

57869 if( 
	`sqlite3ExprIsInteger
(
p
->
pLeft
, &
v
) )

57873 *
pValue
 = -
v
;

57874 
rc
 = 1;

57880 return 
rc
;

57881 
	}
}

57883 static int 
	$sqlite3ExprCanBeNull
(const 
Expr
 *
p
)

57886 
u8
 
op
;

57887 while( 
p
->
op
==156 || p->op==155 )

57889 
p
 = p->
pLeft
; }

57890 
op
 = 
p
->op;

57891 if( 
op
==157 ) op = 
p
->
op2
;

57892 switch( 
op
 )

57902 return (((
p
)->
flags
&(0x100000))!=0) ||

57903 (
p
->
iColumn
>=0 && p->
pTab
->
aCol
[p->iColumn].
notNull
==0);

57907 
	}
}

57909 static int 
	$sqlite3ExprNeedsNoAffinityChange
(const 
Expr
 *
p
, char 
aff
)

57912 
u8
 
op
;

57913 if( 
aff
=='A' ) return 1;

57914 while( 
p
->
op
==156 || p->op==155 )

57916 
p
 = p->
pLeft
; }

57917 
op
 = 
p
->op;

57918 if( 
op
==157 ) op = 
p
->
op2
;

57919 switch( 
op
 )

57923 return 
aff
=='D' || aff=='C';

57926 return 
aff
=='E' || aff=='C';

57929 return 
aff
=='B';

57936 return 
p
->
iColumn
<0

57937 && (
aff
=='D' || aff=='C');

57943 
	}
}

57948 static int 
	$sqlite3IsRowid
(const char *
z
)

57951 if( 
	`sqlite3StrICmp
(
z
, "_ROWID_")==0 ) return 1;

57952 if( 
	`sqlite3StrICmp
(
z
, "ROWID")==0 ) return 1;

57953 if( 
	`sqlite3StrICmp
(
z
, "OID")==0 ) return 1;

57955 
	}
}

57957 static 
Select
 *
	$isCandidateForInOpt
(
Expr
 *
pX
)

57960 
Select
 *
p
;

57961 
SrcList
 *
pSrc
;

57962 
ExprList
 *
pEList
;

57963 
Expr
 *
pRes
;

57964 
Table
 *
pTab
;

57965 if( !(((
pX
)->
flags
&(0x000800))!=0) ) return 0;

57966 if( (((
pX
)->
flags
&(0x000020))!=0) ) return 0;

57967 
p
 = 
pX
->
x
.
pSelect
;

57968 if( 
p
->
pPrior
 ) return 0;

57969 if( 
p
->
selFlags
 & (0x00001|0x00008) )

57977 if( 
p
->
pLimit
 ) return 0;

57979 if( 
p
->
pWhere
 ) return 0;

57980 
pSrc
 = 
p
->pSrc;

57982 if( 
pSrc
->
nSrc
!=1 ) return 0;

57983 if( 
pSrc
->
a
[0].
pSelect
 ) return 0;

57984 
pTab
 = 
pSrc
->
a
[0].pTab;

57987 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) ) return 0;

57988 
pEList
 = 
p
->pEList;

57989 if( 
pEList
->
nExpr
!=1 ) return 0;

57990 
pRes
 = 
pEList
->
a
[0].
pExpr
;

57991 if( 
pRes
->
op
!=152 ) return 0;

57993 return 
p
;

57994 
	}
}

58001 static int 
	$sqlite3CodeOnce
(
Parse
 *
pParse
)

58004 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

58005 return 
	`sqlite3VdbeAddOp1
(
v
, 44, 
pParse
->
nOnce
++);

58006 
	}
}

58014 static void 
	$sqlite3SetHasNullFlag
(
Vdbe
 *
v
, int 
iCur
, int 
regHasNull
)

58017 int 
addr1
;

58018 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
regHasNull
);

58019 
addr1
 = 
	`sqlite3VdbeAddOp1
(
v
, 108, 
iCur
); ;

58020 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iCur
, 0, 
regHasNull
);

58021 
	`sqlite3VdbeChangeP5
(
v
, 0x80);

58023 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

58024 
	}
}

58032 static int 
	$sqlite3InRhsIsConstant
(
Expr
 *
pIn
)

58035 
Expr
 *
pLHS
;

58036 int 
res
;

58038 
pLHS
 = 
pIn
->
pLeft
;

58039 
pIn
->
pLeft
 = 0;

58040 
res
 = 
	`sqlite3ExprIsConstant
(
pIn
);

58041 
pIn
->
pLeft
 = 
pLHS
;

58042 return 
res
;

58043 
	}
}

58045 static int 
	$sqlite3FindInIndex
(
Parse
 *
pParse
, 
Expr
 *
pX
, 
u32
 
inFlags
, int *
prRhsHasNull
)

58048 
Select
 *
p
;

58049 int 
eType
 = 0;

58050 int 
iTab
 = 
pParse
->
nTab
++;

58051 int 
mustBeUnique
;

58052 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

58055 
mustBeUnique
 = (
inFlags
 & 0x0004)!=0;

58061 if( 
pParse
->
nErr
==0 && (
p
 = 
	`isCandidateForInOpt
(
pX
))!=0 )

58064 
sqlite3
 *
db
 = 
pParse
->db;

58065 
Table
 *
pTab
;

58066 
Expr
 *
pExpr
;

58067 
i16
 
iCol
;

58068 
i16
 
iDb
;

58073 
pTab
 = 
p
->
pSrc
->
a
[0].pTab;

58074 
pExpr
 = 
p
->
pEList
->
a
[0].pExpr;

58075 
iCol
 = (
i16
)
pExpr
->
iColumn
;

58078 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

58079 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

58080 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 0, pTab->
zName
);

58087 if( 
iCol
<0 )

58090 int 
iAddr
 = 
	`sqlite3CodeOnce
(
pParse
);

58093 
	`sqlite3OpenTable
(
pParse
, 
iTab
, 
iDb
, 
pTab
, 54);

58094 
eType
 = 1;

58096 
	`sqlite3VdbeJumpHere
(
v
, 
iAddr
);

58098 
Index
 *
pIdx
;

58103 
CollSeq
 *
pReq
 = 
	`sqlite3BinaryCompareCollSeq
(
pParse
, 
pX
->
pLeft
, 
pExpr
);

58109 int 
affinity_ok
 = 
	`sqlite3IndexAffinityOk
(
pX
, 
pTab
->
aCol
[
iCol
].
affinity
);

58111 for(
pIdx
=
pTab
->
pIndex
; pIdx && 
eType
==0 && 
affinity_ok
; pIdx=pIdx->
pNext
)

58114 if( (
pIdx
->
aiColumn
[0]==
iCol
)

58115 && 
	`sqlite3FindCollSeq
(
db
, ((db)->
enc
), 
pIdx
->
azColl
[0], 0)==
pReq


58116 && (!
mustBeUnique
 || (
pIdx
->
nKeyCol
==1 && ((pIdx)->
onError
!=0)))

58120 int 
iAddr
 = 
	`sqlite3CodeOnce
(
pParse
); ;

58121 
	`sqlite3VdbeAddOp3
(
v
, 54, 
iTab
, 
pIdx
->
tnum
, 
iDb
);

58122 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pIdx
);

58125 
eType
 = 3 + 
pIdx
->
aSortOrder
[0];

58127 if( 
prRhsHasNull
 && !
pTab
->
aCol
[
iCol
].
notNull
 )

58130 *
prRhsHasNull
 = ++
pParse
->
nMem
;

58131 
	`sqlite3SetHasNullFlag
(
v
, 
iTab
, *
prRhsHasNull
);

58133 
	`sqlite3VdbeJumpHere
(
v
, 
iAddr
);

58139 if( 
eType
==0

58140 && (
inFlags
 & 0x0001)

58141 && !(((
pX
)->
flags
&(0x000800))!=0)

58142 && (!
	`sqlite3InRhsIsConstant
(
pX
) || pX->
x
.
pList
->
nExpr
<=2)

58146 
eType
 = 5;

58150 if( 
eType
==0 )

58156 
u32
 
savedNQueryLoop
 = 
pParse
->
nQueryLoop
;

58157 int 
rMayHaveNull
 = 0;

58158 
eType
 = 2;

58159 if( 
inFlags
 & 0x0004 )

58162 
pParse
->
nQueryLoop
 = 0;

58163 if( 
pX
->
pLeft
->
iColumn
<0 && !(((pX)->
flags
&(0x000800))!=0) )

58166 
eType
 = 1;

58168 }else if( 
prRhsHasNull
 )

58171 *
prRhsHasNull
 = 
rMayHaveNull
 = ++
pParse
->
nMem
;

58173 
	`sqlite3CodeSubselect
(
pParse
, 
pX
, 
rMayHaveNull
, 
eType
==1);

58174 
pParse
->
nQueryLoop
 = 
savedNQueryLoop
;

58176 
pX
->
iTable
 = 
iTab
;

58178 return 
eType
;

58179 
	}
}

58181 static int 
	$sqlite3CodeSubselect
(

58182 
Parse
 *
pParse
,

58183 
Expr
 *
pExpr
,

58184 int 
rHasNullFlag
,

58185 int 
isRowid


58189 int 
jmpIfDynamic
 = -1;

58190 int 
rReg
 = 0;

58191 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

58192 if( (
v
==0) ) return 0;

58193 
	`sqlite3ExprCachePush
(
pParse
);

58195 if( !(((
pExpr
)->
flags
&(0x000020))!=0) )

58198 
jmpIfDynamic
 = 
	`sqlite3CodeOnce
(
pParse
); ;

58202 if( 
pParse
->
explain
==2 )

58205 char *
zMsg
 = 
	`sqlite3MPrintf
(
pParse
->
db
, "EXECUTE %s%s SUBQUERY %d",

58206 
jmpIfDynamic
>=0?"":"CORRELATED ",

58207 
pExpr
->
op
==75?"LIST":"SCALAR",

58208 
pParse
->
iNextSelectId


58210 
	`sqlite3VdbeAddOp4
(
v
, 161, 
pParse
->
iSelectId
, 0, 0, 
zMsg
, (-1));

58214 switch( 
pExpr
->
op
 )

58218 char 
affinity
;

58219 int 
addr
;

58220 
Expr
 *
pLeft
 = 
pExpr
->pLeft;

58221 
KeyInfo
 *
pKeyInfo
 = 0;

58223 
affinity
 = 
	`sqlite3ExprAffinity
(
pLeft
);

58225 
pExpr
->
iTable
 = 
pParse
->
nTab
++;

58226 
addr
 = 
	`sqlite3VdbeAddOp2
(
v
, 57, 
pExpr
->
iTable
, !
isRowid
);

58227 
pKeyInfo
 = 
isRowid
 ? 0 : 
	`sqlite3KeyInfoAlloc
(
pParse
->
db
, 1, 1);

58229 if( (((
pExpr
)->
flags
&(0x000800))!=0) )

58237 
Select
 *
pSelect
 = 
pExpr
->
x
.pSelect;

58238 
SelectDest
 
dest
;

58239 
ExprList
 *
pEList
;

58242 
	`sqlite3SelectDestInit
(&
dest
, 11, 
pExpr
->
iTable
);

58243 
dest
.
affSdst
 = (
u8
)
affinity
;

58245 
pSelect
->
iLimit
 = 0;

58248 if( 
	`sqlite3Select
(
pParse
, 
pSelect
, &
dest
) )

58251 
	`sqlite3KeyInfoUnref
(
pKeyInfo
);

58254 
pEList
 = 
pSelect
->pEList;

58259 
pKeyInfo
->
aColl
[0] = 
	`sqlite3BinaryCompareCollSeq
(
pParse
, 
pExpr
->
pLeft
,

58260 
pEList
->
a
[0].
pExpr
);

58261 }else if( (
pExpr
->
x
.
pList
!=0) )

58271 int 
i
;

58272 
ExprList
 *
pList
 = 
pExpr
->
x
.pList;

58273 struct 
ExprList_item
 *
pItem
;

58274 int 
r1
, 
r2
, 
r3
;

58276 if( !
affinity
 )

58279 
affinity
 = 'A';

58281 if( 
pKeyInfo
 )

58285 
pKeyInfo
->
aColl
[0] = 
	`sqlite3ExprCollSeq
(
pParse
, 
pExpr
->
pLeft
);

58289 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

58290 
r2
 = 
	`sqlite3GetTempReg
(
pParse
);

58291 if( 
isRowid
 ) 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
r2
);

58292 for(
i
=
pList
->
nExpr
, 
pItem
=pList->
a
; i>0; i--, pItem++)

58295 
Expr
 *
pE2
 = 
pItem
->
pExpr
;

58296 int 
iValToIns
;

58303 if( 
jmpIfDynamic
>=0 && !
	`sqlite3ExprIsConstant
(
pE2
) )

58306 
	`sqlite3VdbeChangeToNoop
(
v
, 
jmpIfDynamic
);

58307 
jmpIfDynamic
 = -1;

58311 if( 
isRowid
 && 
	`sqlite3ExprIsInteger
(
pE2
, &
iValToIns
) )

58314 
	`sqlite3VdbeAddOp3
(
v
, 84, 
pExpr
->
iTable
, 
r2
, 
iValToIns
);

58316 
r3
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pE2
, 
r1
);

58317 if( 
isRowid
 )

58320 
	`sqlite3VdbeAddOp2
(
v
, 38, 
r3
,

58321 
	`sqlite3VdbeCurrentAddr
(
v
)+2);

58323 
	`sqlite3VdbeAddOp3
(
v
, 75, 
pExpr
->
iTable
, 
r2
, 
r3
);

58325 
	`sqlite3VdbeAddOp4
(
v
, 49, 
r3
, 1, 
r2
, &
affinity
, 1);

58326 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
r3
, 1);

58327 
	`sqlite3VdbeAddOp2
(
v
, 110, 
pExpr
->
iTable
, 
r2
);

58331 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

58332 
	`sqlite3ReleaseTempReg
(
pParse
, 
r2
);

58334 if( 
pKeyInfo
 )

58337 
	`sqlite3VdbeChangeP4
(
v
, 
addr
, (void *)
pKeyInfo
, (-6));

58351 
Select
 *
pSel
;

58352 
SelectDest
 
dest
;

58359 
pSel
 = 
pExpr
->
x
.
pSelect
;

58360 
	`sqlite3SelectDestInit
(&
dest
, 0, ++
pParse
->
nMem
);

58361 if( 
pExpr
->
op
==119 )

58364 
dest
.
eDest
 = 10;

58365 
dest
.
iSdst
 = dest.
iSDParm
;

58366 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
dest
.
iSDParm
);

58369 
dest
.
eDest
 = 3;

58370 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
dest
.
iSDParm
);

58373 
	`sqlite3ExprDelete
(
pParse
->
db
, 
pSel
->
pLimit
);

58374 
pSel
->
pLimit
 = 
	`sqlite3PExpr
(
pParse
, 132, 0, 0,

58375 &
sqlite3IntTokens
[1]);

58376 
pSel
->
iLimit
 = 0;

58377 
pSel
->
selFlags
 &= ~0x00200;

58378 if( 
	`sqlite3Select
(
pParse
, 
pSel
, &
dest
) )

58383 
rReg
 = 
dest
.
iSDParm
;

58389 if( 
rHasNullFlag
 )

58392 
	`sqlite3SetHasNullFlag
(
v
, 
pExpr
->
iTable
, 
rHasNullFlag
);

58395 if( 
jmpIfDynamic
>=0 )

58398 
	`sqlite3VdbeJumpHere
(
v
, 
jmpIfDynamic
);

58400 
	`sqlite3ExprCachePop
(
pParse
);

58402 return 
rReg
;

58403 
	}
}

58405 static void 
	$sqlite3ExprCodeIN
(

58406 
Parse
 *
pParse
,

58407 
Expr
 *
pExpr
,

58408 int 
destIfFalse
,

58409 int 
destIfNull


58413 int 
rRhsHasNull
 = 0;

58414 char 
affinity
;

58415 int 
eType
;

58416 int 
r1
;

58417 
Vdbe
 *
v
;

58422 
v
 = 
pParse
->
pVdbe
;

58425 
eType
 = 
	`sqlite3FindInIndex
(
pParse
, 
pExpr
,

58427 
destIfFalse
==
destIfNull
 ? 0 : &
rRhsHasNull
);

58433 
affinity
 = 
	`comparisonAffinity
(
pExpr
);

58437 
	`sqlite3ExprCachePush
(
pParse
);

58438 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

58439 
	`sqlite3ExprCode
(
pParse
, 
pExpr
->
pLeft
, 
r1
);

58445 if( 
eType
==5 )

58448 
ExprList
 *
pList
 = 
pExpr
->
x
.pList;

58449 
CollSeq
 *
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pExpr
->
pLeft
);

58450 int 
labelOk
 = 
	`sqlite3VdbeMakeLabel
(
v
);

58451 int 
r2
, 
regToFree
;

58452 int 
regCkNull
 = 0;

58453 int 
ii
;

58455 if( 
destIfNull
!=
destIfFalse
 )

58458 
regCkNull
 = 
	`sqlite3GetTempReg
(
pParse
);

58459 
	`sqlite3VdbeAddOp3
(
v
, 85, 
r1
, r1, 
regCkNull
);

58461 for(
ii
=0; ii<
pList
->
nExpr
; ii++)

58464 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pList
->
a
[
ii
].
pExpr
, &
regToFree
);

58465 if( 
regCkNull
 && 
	`sqlite3ExprCanBeNull
(
pList
->
a
[
ii
].
pExpr
) )

58468 
	`sqlite3VdbeAddOp3
(
v
, 85, 
regCkNull
, 
r2
, regCkNull);

58470 if( 
ii
<
pList
->
nExpr
-1 || 
destIfNull
!=
destIfFalse
 )

58473 
	`sqlite3VdbeAddOp4
(
v
, 79, 
r1
, 
labelOk
, 
r2
,

58474 (void*)
pColl
, (-4));

58477 
	`sqlite3VdbeChangeP5
(
v
, 
affinity
);

58480 
	`sqlite3VdbeAddOp4
(
v
, 78, 
r1
, 
destIfFalse
, 
r2
,

58481 (void*)
pColl
, (-4)); ;

58482 
	`sqlite3VdbeChangeP5
(
v
, 
affinity
 | 0x10);

58484 
	`sqlite3ReleaseTempReg
(
pParse
, 
regToFree
);

58486 if( 
regCkNull
 )

58489 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regCkNull
, 
destIfNull
); ;

58490 
	`sqlite3VdbeGoto
(
v
, 
destIfFalse
);

58492 
	`sqlite3VdbeResolveLabel
(
v
, 
labelOk
);

58493 
	`sqlite3ReleaseTempReg
(
pParse
, 
regCkNull
);

58499 if( 
	`sqlite3ExprCanBeNull
(
pExpr
->
pLeft
) )

58502 if( 
destIfNull
==
destIfFalse
 )

58507 
	`sqlite3VdbeAddOp2
(
v
, 76, 
r1
, 
destIfNull
); ;

58509 int 
addr1
 = 
	`sqlite3VdbeAddOp1
(
v
, 77, 
r1
); ;

58510 
	`sqlite3VdbeAddOp2
(
v
, 108, 
pExpr
->
iTable
, 
destIfFalse
);

58512 
	`sqlite3VdbeGoto
(
v
, 
destIfNull
);

58513 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

58517 if( 
eType
==1 )

58522 
	`sqlite3VdbeAddOp2
(
v
, 38, 
r1
, 
destIfFalse
); ;

58523 
	`sqlite3VdbeAddOp3
(
v
, 70, 
pExpr
->
iTable
, 
destIfFalse
, 
r1
);

58528 
	`sqlite3VdbeAddOp4
(
v
, 48, 
r1
, 1, 0, &
affinity
, 1);

58537 if( 
rRhsHasNull
==0 )

58547 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
pExpr
->
iTable
, 
destIfFalse
, 
r1
, 1);

58554 int 
addr1
;

58562 
addr1
 = 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
pExpr
->
iTable
, 0, 
r1
, 1);

58564 
	`sqlite3VdbeAddOp2
(
v
, 76, 
rRhsHasNull
, 
destIfNull
);

58566 
	`sqlite3VdbeGoto
(
v
, 
destIfFalse
);

58567 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

58571 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

58572 
	`sqlite3ExprCachePop
(
pParse
);

58574 
	}
}

58576 static void 
	$codeReal
(
Vdbe
 *
v
, const char *
z
, int 
negateFlag
, int 
iMem
)

58579 if( (
z
!=0) )

58582 double 
value
;

58583 
	`sqlite3AtoF
(
z
, &
value
, 
	`sqlite3Strlen30
(z), 1);

58585 if( 
negateFlag
 ) 
value
 = -value;

58586 
	`sqlite3VdbeAddOp4Dup8
(
v
, 133, 0, 
iMem
, 0, (
u8
*)&
value
, (-12));

58588 
	}
}

58590 static void 
	$codeInteger
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
negFlag
, int 
iMem
)

58593 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

58594 if( 
pExpr
->
flags
 & 0x000400 )

58597 int 
i
 = 
pExpr
->
u
.
iValue
;

58599 if( 
negFlag
 ) 
i
 = -i;

58600 
	`sqlite3VdbeAddOp2
(
v
, 22, 
i
, 
iMem
);

58602 int 
c
;

58603 
i64
 
value
;

58604 const char *
z
 = 
pExpr
->
u
.
zToken
;

58606 
c
 = 
	`sqlite3DecOrHexToI64
(
z
, &
value
);

58607 if( 
c
==0 || (c==2 && 
negFlag
) )

58610 if( 
negFlag
 )

58612 
value
 = 
c
==2 ? (((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : -value; }

58613 
	`sqlite3VdbeAddOp4Dup8
(
v
, 23, 0, 
iMem
, 0, (
u8
*)&
value
, (-13));

58619 if( 
	`sqlite3_strnicmp
(
z
,"0x",2)==0 )

58622 
	`sqlite3ErrorMsg
(
pParse
, "hex literal too big: %s", 
z
);

58626 
	`codeReal
(
v
, 
z
, 
negFlag
, 
iMem
);

58631 
	}
}

58636 static void 
	$cacheEntryClear
(
Parse
 *
pParse
, struct 
yColCache
 *
p
)

58639 if( 
p
->
tempReg
 )

58642 if( 
pParse
->
nTempReg
<((int)(sizeof(pParse->
aTempReg
)/sizeof(pParse->aTempReg[0]))) )

58645 
pParse
->
aTempReg
[pParse->
nTempReg
++] = 
p
->
iReg
;

58647 
p
->
tempReg
 = 0;

58649 
	}
}

58656 static void 
	$sqlite3ExprCacheStore
(
Parse
 *
pParse
, int 
iTab
, int 
iCol
, int 
iReg
)

58659 int 
i
;

58660 int 
minLru
;

58661 int 
idxLru
;

58662 struct 
yColCache
 *
p
;

58672 if( (((
pParse
->
db
)->
dbOptFlags
&(0x0002))!=0) ) return;

58674 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

58677 if( 
p
->
iReg
==0 )

58680 
p
->
iLevel
 = 
pParse
->
iCacheLevel
;

58681 
p
->
iTable
 = 
iTab
;

58682 
p
->
iColumn
 = 
iCol
;

58683 
p
->
iReg
 = iReg;

58684 
p
->
tempReg
 = 0;

58685 
p
->
lru
 = 
pParse
->
iCacheCnt
++;

58691 
minLru
 = 0x7fffffff;

58692 
idxLru
 = -1;

58693 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

58696 if( 
p
->
lru
<
minLru
 )

58699 
idxLru
 = 
i
;

58700 
minLru
 = 
p
->
lru
;

58703 if( (
idxLru
>=0) )

58706 
p
 = &
pParse
->
aColCache
[
idxLru
];

58707 
p
->
iLevel
 = 
pParse
->
iCacheLevel
;

58708 
p
->
iTable
 = 
iTab
;

58709 
p
->
iColumn
 = 
iCol
;

58710 
p
->
iReg
 = iReg;

58711 
p
->
tempReg
 = 0;

58712 
p
->
lru
 = 
pParse
->
iCacheCnt
++;

58715 
	}
}

58721 static void 
	$sqlite3ExprCacheRemove
(
Parse
 *
pParse
, int 
iReg
, int 
nReg
)

58724 int 
i
;

58725 int 
iLast
 = 
iReg
 + 
nReg
 - 1;

58726 struct 
yColCache
 *
p
;

58727 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

58730 int 
r
 = 
p
->
iReg
;

58731 if( 
r
>=
iReg
 && r<=
iLast
 )

58734 
	`cacheEntryClear
(
pParse
, 
p
);

58735 
p
->
iReg
 = 0;

58738 
	}
}

58745 static void 
	$sqlite3ExprCachePush
(
Parse
 *
pParse
)

58748 
pParse
->
iCacheLevel
++;

58754 
	}
}

58761 static void 
	$sqlite3ExprCachePop
(
Parse
 *
pParse
)

58764 int 
i
;

58765 struct 
yColCache
 *
p
;

58767 
pParse
->
iCacheLevel
--;

58773 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

58776 if( 
p
->
iReg
 && p->
iLevel
>
pParse
->
iCacheLevel
 )

58779 
	`cacheEntryClear
(
pParse
, 
p
);

58780 
p
->
iReg
 = 0;

58783 
	}
}

58791 static void 
	$sqlite3ExprCachePinRegister
(
Parse
 *
pParse
, int 
iReg
)

58794 int 
i
;

58795 struct 
yColCache
 *
p
;

58796 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

58799 if( 
p
->
iReg
==iReg )

58802 
p
->
tempReg
 = 0;

58805 
	}
}

58810 static void 
	$sqlite3ExprCodeLoadIndexColumn
(

58811 
Parse
 *
pParse
,

58812 
Index
 *
pIdx
,

58813 int 
iTabCur
,

58814 int 
iIdxCol
,

58815 int 
regOut


58819 
i16
 
iTabCol
 = 
pIdx
->
aiColumn
[
iIdxCol
];

58820 if( 
iTabCol
==(-2) )

58825 
pParse
->
iSelfTab
 = 
iTabCur
;

58826 
	`sqlite3ExprCodeCopy
(
pParse
, 
pIdx
->
aColExpr
->
a
[
iIdxCol
].
pExpr
, 
regOut
);

58828 
	`sqlite3ExprCodeGetColumnOfTable
(
pParse
->
pVdbe
, 
pIdx
->
pTable
, 
iTabCur
,

58829 
iTabCol
, 
regOut
);

58831 
	}
}

58836 static void 
	$sqlite3ExprCodeGetColumnOfTable
(

58837 
Vdbe
 *
v
,

58838 
Table
 *
pTab
,

58839 int 
iTabCur
,

58840 int 
iCol
,

58841 int 
regOut


58845 if( 
iCol
<0 || iCol==
pTab
->
iPKey
 )

58848 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iTabCur
, 
regOut
);

58850 int 
op
 = (((
pTab
)->
tabFlags
 & 0x10)!=0) ? 153 : 47;

58851 int 
x
 = 
iCol
;

58852 if( !(((
pTab
)->
tabFlags
 & 0x20)==0) )

58855 
x
 = 
	`sqlite3ColumnOfIndex
(
	`sqlite3PrimaryKeyIndex
(
pTab
), 
iCol
);

58857 
	`sqlite3VdbeAddOp3
(
v
, 
op
, 
iTabCur
, 
x
, 
regOut
);

58859 if( 
iCol
>=0 )

58862 
	`sqlite3ColumnDefault
(
v
, 
pTab
, 
iCol
, 
regOut
);

58864 
	}
}

58866 static int 
	$sqlite3ExprCodeGetColumn
(

58867 
Parse
 *
pParse
,

58868 
Table
 *
pTab
,

58869 int 
iColumn
,

58870 int 
iTable
,

58871 int 
iReg
,

58872 
u8
 
p5


58876 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

58877 int 
i
;

58878 struct 
yColCache
 *
p
;

58880 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

58883 if( 
p
->
iReg
>0 && p->
iTable
==iTable && p->
iColumn
==iColumn )

58886 
p
->
lru
 = 
pParse
->
iCacheCnt
++;

58887 
	`sqlite3ExprCachePinRegister
(
pParse
, 
p
->
iReg
);

58888 return 
p
->
iReg
;

58892 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 
iTable
, 
iColumn
, 
iReg
);

58893 if( 
p5
 )

58896 
	`sqlite3VdbeChangeP5
(
v
, 
p5
);

58898 
	`sqlite3ExprCacheStore
(
pParse
, 
iTable
, 
iColumn
, 
iReg
);

58900 return 
iReg
;

58901 
	}
}

58902 static void 
	$sqlite3ExprCodeGetColumnToReg
(

58903 
Parse
 *
pParse
,

58904 
Table
 *
pTab
,

58905 int 
iColumn
,

58906 int 
iTable
,

58907 int 
iReg


58911 int 
r1
 = 
	`sqlite3ExprCodeGetColumn
(
pParse
, 
pTab
, 
iColumn
, 
iTable
, 
iReg
, 0);

58912 if( 
r1
!=
iReg
 ) 
	`sqlite3VdbeAddOp2
(
pParse
->
pVdbe
, 31, r1, iReg);

58913 
	}
}

58919 static void 
	$sqlite3ExprCacheClear
(
Parse
 *
pParse
)

58922 int 
i
;

58923 struct 
yColCache
 *
p
;

58930 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

58933 if( 
p
->
iReg
 )

58936 
	`cacheEntryClear
(
pParse
, 
p
);

58937 
p
->
iReg
 = 0;

58940 
	}
}

58946 static void 
	$sqlite3ExprCacheAffinityChange
(
Parse
 *
pParse
, int 
iStart
, int 
iCount
)

58949 
	`sqlite3ExprCacheRemove
(
pParse
, 
iStart
, 
iCount
);

58950 
	}
}

58956 static void 
	$sqlite3ExprCodeMove
(
Parse
 *
pParse
, int 
iFrom
, int 
iTo
, int 
nReg
)

58960 
	`sqlite3VdbeAddOp3
(
pParse
->
pVdbe
, 29, 
iFrom
, 
iTo
, 
nReg
);

58961 
	`sqlite3ExprCacheRemove
(
pParse
, 
iFrom
, 
nReg
);

58962 
	}
}

58964 static void 
	$exprToRegister
(
Expr
 *
p
, int 
iReg
)

58967 
p
->
op2
 = p->
op
;

58968 
p
->
op
 = 157;

58969 
p
->
iTable
 = 
iReg
;

58970 (
p
)->
flags
&=~(0x001000);

58971 
	}
}

58973 static int 
	$sqlite3ExprCodeTarget
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
target
)

58976 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

58977 int 
op
;

58978 int 
inReg
 = 
target
;

58979 int 
regFree1
 = 0;

58980 int 
regFree2
 = 0;

58981 int 
r1
, 
r2
, 
r3
, 
r4
;

58982 
sqlite3
 *
db
 = 
pParse
->db;

58983 
Expr
 
tempX
;

58986 if( 
v
==0 )

58993 if( 
pExpr
==0 )

58996 
op
 = 101;

58998 
op
 = 
pExpr
->op;

59000 switch( 
op
 )

59004 
AggInfo
 *
pAggInfo
 = 
pExpr
->pAggInfo;

59005 struct 
AggInfo_col
 *
pCol
 = &
pAggInfo
->
aCol
[
pExpr
->
iAgg
];

59006 if( !
pAggInfo
->
directMode
 )

59010 
inReg
 = 
pCol
->
iMem
;

59012 }else if( 
pAggInfo
->
useSortingIdx
 )

59015 
	`sqlite3VdbeAddOp3
(
v
, 47, 
pAggInfo
->
sortingIdxPTab
,

59016 
pCol
->
iSorterColumn
, 
target
);

59022 int 
iTab
 = 
pExpr
->
iTable
;

59023 if( 
iTab
<0 )

59026 if( 
pParse
->
ckBase
>0 )

59030 
inReg
 = 
pExpr
->
iColumn
 + 
pParse
->
ckBase
;

59035 
iTab
 = 
pParse
->
iSelfTab
;

59038 
inReg
 = 
	`sqlite3ExprCodeGetColumn
(
pParse
, 
pExpr
->
pTab
,

59039 
pExpr
->
iColumn
, 
iTab
, 
target
,

59040 
pExpr
->
op2
);

59044 
	`codeInteger
(
pParse
, 
pExpr
, 0, 
target
);

59050 
	`codeReal
(
v
, 
pExpr
->
u
.
zToken
, 0, 
target
);

59056 
	`sqlite3VdbeLoadString
(
v
, 
target
, 
pExpr
->
u
.
zToken
);

59060 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
target
);

59065 int 
n
;

59066 const char *
z
;

59067 char *
zBlob
;

59071 
z
 = &
pExpr
->
u
.
zToken
[2];

59072 
n
 = 
	`sqlite3Strlen30
(
z
) - 1;

59074 
zBlob
 = 
	`sqlite3HexToBlob
(
	`sqlite3VdbeDb
(
v
), 
z
, 
n
);

59075 
	`sqlite3VdbeAddOp4
(
v
, 27, 
n
/2, 
target
, 0, 
zBlob
, (-1));

59083 
	`sqlite3VdbeAddOp2
(
v
, 28, 
pExpr
->
iColumn
, 
target
);

59084 if( 
pExpr
->
u
.
zToken
[1]!=0 )

59089 
	`sqlite3VdbeChangeP4
(
v
, -1, 
pParse
->
azVar
[
pExpr
->
iColumn
-1], (-2));

59094 
inReg
 = 
pExpr
->
iTable
;

59100 
inReg
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pExpr
->
pLeft
, 
target
);

59101 if( 
inReg
!=
target
 )

59104 
	`sqlite3VdbeAddOp2
(
v
, 31, 
inReg
, 
target
);

59105 
inReg
 = 
target
;

59107 
	`sqlite3VdbeAddOp2
(
v
, 40, 
target
,

59108 
	`sqlite3AffinityType
(
pExpr
->
u
.
zToken
, 0));

59110 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
inReg
, 1);

59120 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

59121 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pRight
, &
regFree2
);

59122 
	`codeCompare
(
pParse
, 
pExpr
->
pLeft
, pExpr->
pRight
, 
op
,

59123 
r1
, 
r2
, 
inReg
, 0x20);

59138 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

59139 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pRight
, &
regFree2
);

59140 
op
 = (op==73) ? 79 : 78;

59141 
	`codeCompare
(
pParse
, 
pExpr
->
pLeft
, pExpr->
pRight
, 
op
,

59142 
r1
, 
r2
, 
inReg
, 0x20 | 0x80);

59172 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

59173 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pRight
, &
regFree2
);

59174 
	`sqlite3VdbeAddOp3
(
v
, 
op
, 
r2
, 
r1
, 
target
);

59180 
Expr
 *
pLeft
 = 
pExpr
->pLeft;

59182 if( 
pLeft
->
op
==132 )

59185 
	`codeInteger
(
pParse
, 
pLeft
, 1, 
target
);

59187 }else if( 
pLeft
->
op
==133 )

59191 
	`codeReal
(
v
, 
pLeft
->
u
.
zToken
, 1, 
target
);

59194 
tempX
.
op
 = 132;

59195 
tempX
.
flags
 = 0x000400|0x004000;

59196 
tempX
.
u
.
iValue
 = 0;

59197 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, &
tempX
, &
regFree1
);

59198 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree2
);

59199 
	`sqlite3VdbeAddOp3
(
v
, 90, 
r2
, 
r1
, 
target
);

59202 
inReg
 = 
target
;

59209 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

59211 
inReg
 = 
target
;

59212 
	`sqlite3VdbeAddOp2
(
v
, 
op
, 
r1
, 
inReg
);

59217 int 
addr
;

59220 
	`sqlite3VdbeAddOp2
(
v
, 22, 1, 
target
);

59221 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

59223 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 
op
, 
r1
);

59226 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
target
);

59227 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

59231 
AggInfo
 *
pInfo
 = 
pExpr
->
pAggInfo
;

59232 if( 
pInfo
==0 )

59236 
	`sqlite3ErrorMsg
(
pParse
, "misuse of aggregate: %s()", 
pExpr
->
u
.
zToken
);

59238 
inReg
 = 
pInfo
->
aFunc
[
pExpr
->
iAgg
].
iMem
;

59243 
ExprList
 *
pFarg
;

59244 int 
nFarg
;

59245 
FuncDef
 *
pDef
;

59246 const char *
zId
;

59247 
u32
 
constMask
 = 0;

59248 int 
i
;

59249 
u8
 
enc
 = ((
db
)->enc);

59250 
CollSeq
 *
pColl
 = 0;

59253 if( (((
pExpr
)->
flags
&(0x004000))!=0) )

59256 
pFarg
 = 0;

59258 
pFarg
 = 
pExpr
->
x
.
pList
;

59260 
nFarg
 = 
pFarg
 ? pFarg->
nExpr
 : 0;

59262 
zId
 = 
pExpr
->
u
.
zToken
;

59263 
pDef
 = 
	`sqlite3FindFunction
(
db
, 
zId
, 
nFarg
, 
enc
, 0);

59264 if( 
pDef
==0 || pDef->
xFinalize
!=0 )

59267 
	`sqlite3ErrorMsg
(
pParse
, "unknown function: %s()", 
zId
);

59275 if( 
pDef
->
funcFlags
 & 0x0200 )

59278 int 
endCoalesce
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59280 
	`sqlite3ExprCode
(
pParse
, 
pFarg
->
a
[0].
pExpr
, 
target
);

59281 for(
i
=1; i<
nFarg
; i++)

59284 
	`sqlite3VdbeAddOp2
(
v
, 77, 
target
, 
endCoalesce
);

59286 
	`sqlite3ExprCacheRemove
(
pParse
, 
target
, 1);

59287 
	`sqlite3ExprCachePush
(
pParse
);

59288 
	`sqlite3ExprCode
(
pParse
, 
pFarg
->
a
[
i
].
pExpr
, 
target
);

59289 
	`sqlite3ExprCachePop
(
pParse
);

59291 
	`sqlite3VdbeResolveLabel
(
v
, 
endCoalesce
);

59298 if( 
pDef
->
funcFlags
 & 0x0400 )

59302 
inReg
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pFarg
->
a
[0].
pExpr
, 
target
);

59306 for(
i
=0; i<
nFarg
; i++)

59309 if( 
i
<32 && 
	`sqlite3ExprIsConstant
(
pFarg
->
a
[i].
pExpr
) )

59313 
constMask
 |= (((unsigned int)1)<<(
i
));

59315 if( (
pDef
->
funcFlags
 & 0x0020)!=0 && !
pColl
 )

59318 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pFarg
->
a
[
i
].
pExpr
);

59321 if( 
pFarg
 )

59324 if( 
constMask
 )

59327 
r1
 = 
pParse
->
nMem
+1;

59328 
pParse
->
nMem
 += 
nFarg
;

59330 
r1
 = 
	`sqlite3GetTempRange
(
pParse
, 
nFarg
);

59338 if( (
pDef
->
funcFlags
 & (0x0040|0x0080))!=0 )

59341 
u8
 
exprOp
;

59344 
exprOp
 = 
pFarg
->
a
[0].
pExpr
->
op
;

59345 if( 
exprOp
==152 || exprOp==154 )

59351 
pFarg
->
a
[0].
pExpr
->
op2
 =

59352 
pDef
->
funcFlags
 & (0x40|0x80);

59356 
	`sqlite3ExprCachePush
(
pParse
);

59357 
	`sqlite3ExprCodeExprList
(
pParse
, 
pFarg
, 
r1
, 0,

59359 
	`sqlite3ExprCachePop
(
pParse
);

59361 
r1
 = 0;

59364 if( 
nFarg
>=2 && (
pExpr
->
flags
 & 0x000080) )

59367 
pDef
 = 
	`sqlite3VtabOverloadFunction
(
db
, pDef, 
nFarg
, 
pFarg
->
a
[1].
pExpr
);

59368 }else if( 
nFarg
>0 )

59371 
pDef
 = 
	`sqlite3VtabOverloadFunction
(
db
, pDef, 
nFarg
, 
pFarg
->
a
[0].
pExpr
);

59374 if( 
pDef
->
funcFlags
 & 0x0020 )

59377 if( !
pColl
 ) pColl = 
db
->
pDfltColl
;

59378 
	`sqlite3VdbeAddOp4
(
v
, 34, 0, 0, 0, (char *)
pColl
, (-4));

59380 
	`sqlite3VdbeAddOp4
(
v
, 35, 
constMask
, 
r1
, 
target
,

59381 (char*)
pDef
, (-5));

59382 
	`sqlite3VdbeChangeP5
(
v
, (
u8
)
nFarg
);

59383 if( 
nFarg
 && 
constMask
==0 )

59386 
	`sqlite3ReleaseTempRange
(
pParse
, 
r1
, 
nFarg
);

59395 
inReg
 = 
	`sqlite3CodeSubselect
(
pParse
, 
pExpr
, 0, 0);

59399 int 
destIfFalse
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59400 int 
destIfNull
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59401 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
target
);

59402 
	`sqlite3ExprCodeIN
(
pParse
, 
pExpr
, 
destIfFalse
, 
destIfNull
);

59403 
	`sqlite3VdbeAddOp2
(
v
, 22, 1, 
target
);

59404 
	`sqlite3VdbeResolveLabel
(
v
, 
destIfFalse
);

59405 
	`sqlite3VdbeAddOp2
(
v
, 37, 
target
, 0);

59406 
	`sqlite3VdbeResolveLabel
(
v
, 
destIfNull
);

59411 
Expr
 *
pLeft
 = 
pExpr
->pLeft;

59412 struct 
ExprList_item
 *
pLItem
 = 
pExpr
->
x
.
pList
->
a
;

59413 
Expr
 *
pRight
 = 
pLItem
->
pExpr
;

59415 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pLeft
, &
regFree1
);

59416 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pRight
, &
regFree2
);

59419 
r3
 = 
	`sqlite3GetTempReg
(
pParse
);

59420 
r4
 = 
	`sqlite3GetTempReg
(
pParse
);

59421 
	`codeCompare
(
pParse
, 
pLeft
, 
pRight
, 83,

59422 
r1
, 
r2
, 
r3
, 0x20); ;

59423 
pLItem
++;

59424 
pRight
 = 
pLItem
->
pExpr
;

59425 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree2
);

59426 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pRight
, &
regFree2
);

59428 
	`codeCompare
(
pParse
, 
pLeft
, 
pRight
, 81, 
r1
, 
r2
, 
r4
, 0x20);

59430 
	`sqlite3VdbeAddOp3
(
v
, 72, 
r3
, 
r4
, 
target
);

59431 
	`sqlite3ReleaseTempReg
(
pParse
, 
r3
);

59432 
	`sqlite3ReleaseTempReg
(
pParse
, 
r4
);

59438 
inReg
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pExpr
->
pLeft
, 
target
);

59444 
Table
 *
pTab
 = 
pExpr
->pTab;

59445 int 
p1
 = 
pExpr
->
iTable
 * (
pTab
->
nCol
+1) + 1 + pExpr->
iColumn
;

59452 
	`sqlite3VdbeAddOp2
(
v
, 134, 
p1
, 
target
);

59465 if( 
pExpr
->
iColumn
>=0

59466 && 
pTab
->
aCol
[
pExpr
->
iColumn
].
affinity
=='E'

59470 
	`sqlite3VdbeAddOp1
(
v
, 39, 
target
);

59477 int 
endLabel
;

59478 int 
nextCase
;

59479 int 
nExpr
;

59480 int 
i
;

59481 
ExprList
 *
pEList
;

59482 struct 
ExprList_item
 *
aListelem
;

59483 
Expr
 
opCompare
;

59484 
Expr
 *
pX
;

59485 
Expr
 *
pTest
 = 0;

59490 
pEList
 = 
pExpr
->
x
.
pList
;

59491 
aListelem
 = 
pEList
->
a
;

59492 
nExpr
 = 
pEList
->nExpr;

59493 
endLabel
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59494 if( (
pX
 = 
pExpr
->
pLeft
)!=0 )

59497 
tempX
 = *
pX
;

59499 
	`exprToRegister
(&
tempX
, 
	`sqlite3ExprCodeTemp
(
pParse
, 
pX
, &
regFree1
));

59501 
opCompare
.
op
 = 79;

59502 
opCompare
.
pLeft
 = &
tempX
;

59503 
pTest
 = &
opCompare
;

59508 
regFree1
 = 0;

59510 for(
i
=0; i<
nExpr
-1; i=i+2)

59513 
	`sqlite3ExprCachePush
(
pParse
);

59514 if( 
pX
 )

59518 
opCompare
.
pRight
 = 
aListelem
[
i
].
pExpr
;

59520 
pTest
 = 
aListelem
[
i
].
pExpr
;

59522 
nextCase
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59524 
	`sqlite3ExprIfFalse
(
pParse
, 
pTest
, 
nextCase
, 0x10);

59526 
	`sqlite3ExprCode
(
pParse
, 
aListelem
[
i
+1].
pExpr
, 
target
);

59527 
	`sqlite3VdbeGoto
(
v
, 
endLabel
);

59528 
	`sqlite3ExprCachePop
(
pParse
);

59529 
	`sqlite3VdbeResolveLabel
(
v
, 
nextCase
);

59531 if( (
nExpr
&1)!=0 )

59534 
	`sqlite3ExprCachePush
(
pParse
);

59535 
	`sqlite3ExprCode
(
pParse
, 
pEList
->
a
[
nExpr
-1].
pExpr
, 
target
);

59536 
	`sqlite3ExprCachePop
(
pParse
);

59538 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
target
);

59542 
	`sqlite3VdbeResolveLabel
(
v
, 
endLabel
);

59552 if( !
pParse
->
pTriggerTab
 )

59555 
	`sqlite3ErrorMsg
(
pParse
,

59559 if( 
pExpr
->
affinity
==2 )

59562 
	`sqlite3MayAbort
(
pParse
);

59565 if( 
pExpr
->
affinity
==4 )

59568 
	`sqlite3VdbeAddOp4
(

59569 
v
, 21, 0, 4, 0, 
pExpr
->
u
.
zToken
,0);

59572 
	`sqlite3HaltConstraint
(
pParse
, (19 | (7<<8)),

59573 
pExpr
->
affinity
, pExpr->
u
.
zToken
, 0, 0);

59580 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree1
);

59581 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree2
);

59582 return 
inReg
;

59583 
	}
}

59588 static void 
	$sqlite3ExprCodeAtInit
(

59589 
Parse
 *
pParse
,

59590 
Expr
 *
pExpr
,

59591 int 
regDest
,

59592 
u8
 
reusable


59596 
ExprList
 *
p
;

59598 
p
 = 
pParse
->
pConstExpr
;

59599 
pExpr
 = 
	`sqlite3ExprDup
(
pParse
->
db
, pExpr, 0);

59600 
p
 = 
	`sqlite3ExprListAppend
(
pParse
, p, 
pExpr
);

59601 if( 
p
 )

59604 struct 
ExprList_item
 *
pItem
 = &
p
->
a
[p->
nExpr
-1];

59605 
pItem
->
u
.
iConstExprReg
 = 
regDest
;

59606 
pItem
->
reusable
 = reusable;

59608 
pParse
->
pConstExpr
 = 
p
;

59609 
	}
}

59611 static int 
	$sqlite3ExprCodeTemp
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int *
pReg
)

59614 int 
r2
;

59615 
pExpr
 = 
	`sqlite3ExprSkipCollate
(pExpr);

59616 if( ((
pParse
)->
okConstFactor
)

59617 && 
pExpr
->
op
!=157

59618 && 
	`sqlite3ExprIsConstantNotJoin
(
pExpr
)

59622 
ExprList
 *
p
 = 
pParse
->
pConstExpr
;

59623 int 
i
;

59624 *
pReg
 = 0;

59625 if( 
p
 )

59628 struct 
ExprList_item
 *
pItem
;

59629 for(
pItem
=
p
->
a
, 
i
=p->
nExpr
; i>0; pItem++, i--)

59632 if( 
pItem
->
reusable
 && 
	`sqlite3ExprCompare
(pItem->
pExpr
,pExpr,-1)==0 )

59635 return 
pItem
->
u
.
iConstExprReg
;

59639 
r2
 = ++
pParse
->
nMem
;

59640 
	`sqlite3ExprCodeAtInit
(
pParse
, 
pExpr
, 
r2
, 1);

59642 int 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

59643 
r2
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pExpr
, 
r1
);

59644 if( 
r2
==
r1
 )

59647 *
pReg
 = 
r1
;

59649 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

59650 *
pReg
 = 0;

59653 return 
r2
;

59654 
	}
}

59661 static void 
	$sqlite3ExprCode
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
target
)

59664 int 
inReg
;

59667 if( 
pExpr
 && pExpr->
op
==157 )

59670 
	`sqlite3VdbeAddOp2
(
pParse
->
pVdbe
, 30, 
pExpr
->
iTable
, 
target
);

59672 
inReg
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pExpr
, 
target
);

59674 if( 
inReg
!=
target
 && 
pParse
->
pVdbe
 )

59677 
	`sqlite3VdbeAddOp2
(
pParse
->
pVdbe
, 31, 
inReg
, 
target
);

59680 
	}
}

59687 static void 
	$sqlite3ExprCodeCopy
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
target
)

59690 
sqlite3
 *
db
 = 
pParse
->db;

59691 
pExpr
 = 
	`sqlite3ExprDup
(
db
, pExpr, 0);

59692 if( !
db
->
mallocFailed
 ) 
	`sqlite3ExprCode
(
pParse
, 
pExpr
, 
target
);

59693 
	`sqlite3ExprDelete
(
db
, 
pExpr
);

59694 
	}
}

59702 static void 
	$sqlite3ExprCodeFactorable
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
target
)

59705 if( 
pParse
->
okConstFactor
 && 
	`sqlite3ExprIsConstant
(
pExpr
) )

59708 
	`sqlite3ExprCodeAtInit
(
pParse
, 
pExpr
, 
target
, 0);

59710 
	`sqlite3ExprCode
(
pParse
, 
pExpr
, 
target
);

59712 
	}
}

59714 static void 
	$sqlite3ExprCodeAndCache
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
target
)

59717 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

59718 int 
iMem
;

59722 
	`sqlite3ExprCode
(
pParse
, 
pExpr
, 
target
);

59723 
iMem
 = ++
pParse
->
nMem
;

59724 
	`sqlite3VdbeAddOp2
(
v
, 30, 
target
, 
iMem
);

59725 
	`exprToRegister
(
pExpr
, 
iMem
);

59726 
	}
}

59728 static int 
	$sqlite3ExprCodeExprList
(

59729 
Parse
 *
pParse
,

59730 
ExprList
 *
pList
,

59731 int 
target
,

59732 int 
srcReg
,

59733 
u8
 
flags


59737 struct 
ExprList_item
 *
pItem
;

59738 int 
i
, 
j
, 
n
;

59739 
u8
 
copyOp
 = (
flags
 & 0x01) ? 30 : 31;

59740 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

59744 
n
 = 
pList
->
nExpr
;

59745 if( !((
pParse
)->
okConstFactor
) ) 
flags
 &= ~0x02;

59746 for(
pItem
=
pList
->
a
, 
i
=0; i<
n
; i++, pItem++)

59749 
Expr
 *
pExpr
 = 
pItem
->pExpr;

59750 if( (
flags
 & 0x04)!=0 && (
j
 = 
pList
->
a
[
i
].
u
.
x
.
iOrderByCol
)>0 )

59753 
	`sqlite3VdbeAddOp2
(
v
, 
copyOp
, 
j
+
srcReg
-1, 
target
+
i
);

59754 }else if( (
flags
 & 0x02)!=0 && 
	`sqlite3ExprIsConstant
(
pExpr
) )

59757 
	`sqlite3ExprCodeAtInit
(
pParse
, 
pExpr
, 
target
+
i
, 0);

59759 int 
inReg
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pExpr
, 
target
+
i
);

59760 if( 
inReg
!=
target
+
i
 )

59763 
VdbeOp
 *
pOp
;

59764 if( 
copyOp
==30

59765 && (
pOp
=
	`sqlite3VdbeGetOp
(
v
, -1))->
opcode
==30

59766 && 
pOp
->
p1
+pOp->
p3
+1==
inReg


59767 && 
pOp
->
p2
+pOp->
p3
+1==
target
+
i


59771 
pOp
->
p3
++;

59773 
	`sqlite3VdbeAddOp2
(
v
, 
copyOp
, 
inReg
, 
target
+
i
);

59778 return 
n
;

59779 
	}
}

59781 static void 
	$exprCodeBetween
(

59782 
Parse
 *
pParse
,

59783 
Expr
 *
pExpr
,

59784 int 
dest
,

59785 int 
jumpIfTrue
,

59786 int 
jumpIfNull


59790 
Expr
 
exprAnd
;

59791 
Expr
 
compLeft
;

59792 
Expr
 
compRight
;

59793 
Expr
 
exprX
;

59794 int 
regFree1
 = 0;

59797 
exprX
 = *
pExpr
->
pLeft
;

59798 
exprAnd
.
op
 = 72;

59799 
exprAnd
.
pLeft
 = &
compLeft
;

59800 
exprAnd
.
pRight
 = &
compRight
;

59801 
compLeft
.
op
 = 83;

59802 
compLeft
.
pLeft
 = &
exprX
;

59803 
compLeft
.
pRight
 = 
pExpr
->
x
.
pList
->
a
[0].pExpr;

59804 
compRight
.
op
 = 81;

59805 
compRight
.
pLeft
 = &
exprX
;

59806 
compRight
.
pRight
 = 
pExpr
->
x
.
pList
->
a
[1].pExpr;

59807 
	`exprToRegister
(&
exprX
, 
	`sqlite3ExprCodeTemp
(
pParse
, &exprX, &
regFree1
));

59808 if( 
jumpIfTrue
 )

59811 
	`sqlite3ExprIfTrue
(
pParse
, &
exprAnd
, 
dest
, 
jumpIfNull
);

59813 
	`sqlite3ExprIfFalse
(
pParse
, &
exprAnd
, 
dest
, 
jumpIfNull
);

59815 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree1
);

59826 
	}
}

59828 static void 
	$sqlite3ExprIfTrue
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
dest
, int 
jumpIfNull
)

59831 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

59832 int 
op
 = 0;

59833 int 
regFree1
 = 0;

59834 int 
regFree2
 = 0;

59835 int 
r1
, 
r2
;

59838 if( (
v
==0) ) return;

59839 if( (
pExpr
==0) ) return;

59840 
op
 = 
pExpr
->op;

59841 switch( 
op
 )

59845 int 
d2
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59847 
	`sqlite3ExprIfFalse
(
pParse
, 
pExpr
->
pLeft
, 
d2
,
jumpIfNull
^0x10);

59848 
	`sqlite3ExprCachePush
(
pParse
);

59849 
	`sqlite3ExprIfTrue
(
pParse
, 
pExpr
->
pRight
, 
dest
, 
jumpIfNull
);

59850 
	`sqlite3VdbeResolveLabel
(
v
, 
d2
);

59851 
	`sqlite3ExprCachePop
(
pParse
);

59856 
	`sqlite3ExprIfTrue
(
pParse
, 
pExpr
->
pLeft
, 
dest
, 
jumpIfNull
);

59857 
	`sqlite3ExprCachePush
(
pParse
);

59858 
	`sqlite3ExprIfTrue
(
pParse
, 
pExpr
->
pRight
, 
dest
, 
jumpIfNull
);

59859 
	`sqlite3ExprCachePop
(
pParse
);

59864 
	`sqlite3ExprIfFalse
(
pParse
, 
pExpr
->
pLeft
, 
dest
, 
jumpIfNull
);

59871 
op
 = (op==73) ? 79 : 78;

59872 
jumpIfNull
 = 0x80;

59881 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

59882 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pRight
, &
regFree2
);

59883 
	`codeCompare
(
pParse
, 
pExpr
->
pLeft
, pExpr->
pRight
, 
op
,

59884 
r1
, 
r2
, 
dest
, 
jumpIfNull
);

59903 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

59904 
	`sqlite3VdbeAddOp2
(
v
, 
op
, 
r1
, 
dest
);

59912 
	`exprCodeBetween
(
pParse
, 
pExpr
, 
dest
, 1, 
jumpIfNull
);

59917 int 
destIfFalse
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59918 int 
destIfNull
 = 
jumpIfNull
 ? 
dest
 : 
destIfFalse
;

59919 
	`sqlite3ExprCodeIN
(
pParse
, 
pExpr
, 
destIfFalse
, 
destIfNull
);

59920 
	`sqlite3VdbeGoto
(
v
, 
dest
);

59921 
	`sqlite3VdbeResolveLabel
(
v
, 
destIfFalse
);

59926 if( 
	`exprAlwaysTrue
(
pExpr
) )

59929 
	`sqlite3VdbeGoto
(
v
, 
dest
);

59930 }else if( 
	`exprAlwaysFalse
(
pExpr
) )

59935 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
, &
regFree1
);

59936 
	`sqlite3VdbeAddOp3
(
v
, 45, 
r1
, 
dest
, 
jumpIfNull
!=0);

59944 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree1
);

59945 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree2
);

59946 
	}
}

59948 static void 
	$sqlite3ExprIfFalse
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
dest
, int 
jumpIfNull
)

59951 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

59952 int 
op
 = 0;

59953 int 
regFree1
 = 0;

59954 int 
regFree2
 = 0;

59955 int 
r1
, 
r2
;

59958 if( (
v
==0) ) return;

59959 if( 
pExpr
==0 ) return;

59961 
op
 = ((
pExpr
->op+(76&1))^1)-(76&1);

59974 switch( 
pExpr
->
op
 )

59979 
	`sqlite3ExprIfFalse
(
pParse
, 
pExpr
->
pLeft
, 
dest
, 
jumpIfNull
);

59980 
	`sqlite3ExprCachePush
(
pParse
);

59981 
	`sqlite3ExprIfFalse
(
pParse
, 
pExpr
->
pRight
, 
dest
, 
jumpIfNull
);

59982 
	`sqlite3ExprCachePop
(
pParse
);

59986 int 
d2
 = 
	`sqlite3VdbeMakeLabel
(
v
);

59988 
	`sqlite3ExprIfTrue
(
pParse
, 
pExpr
->
pLeft
, 
d2
, 
jumpIfNull
^0x10);

59989 
	`sqlite3ExprCachePush
(
pParse
);

59990 
	`sqlite3ExprIfFalse
(
pParse
, 
pExpr
->
pRight
, 
dest
, 
jumpIfNull
);

59991 
	`sqlite3VdbeResolveLabel
(
v
, 
d2
);

59992 
	`sqlite3ExprCachePop
(
pParse
);

59997 
	`sqlite3ExprIfTrue
(
pParse
, 
pExpr
->
pLeft
, 
dest
, 
jumpIfNull
);

60004 
op
 = (
pExpr
->op==73) ? 78 : 79;

60005 
jumpIfNull
 = 0x80;

60014 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

60015 
r2
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pRight
, &
regFree2
);

60016 
	`codeCompare
(
pParse
, 
pExpr
->
pLeft
, pExpr->
pRight
, 
op
,

60017 
r1
, 
r2
, 
dest
, 
jumpIfNull
);

60034 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
->
pLeft
, &
regFree1
);

60035 
	`sqlite3VdbeAddOp2
(
v
, 
op
, 
r1
, 
dest
);

60043 
	`exprCodeBetween
(
pParse
, 
pExpr
, 
dest
, 0, 
jumpIfNull
);

60048 if( 
jumpIfNull
 )

60051 
	`sqlite3ExprCodeIN
(
pParse
, 
pExpr
, 
dest
, dest);

60053 int 
destIfNull
 = 
	`sqlite3VdbeMakeLabel
(
v
);

60054 
	`sqlite3ExprCodeIN
(
pParse
, 
pExpr
, 
dest
, 
destIfNull
);

60055 
	`sqlite3VdbeResolveLabel
(
v
, 
destIfNull
);

60061 if( 
	`exprAlwaysFalse
(
pExpr
) )

60064 
	`sqlite3VdbeGoto
(
v
, 
dest
);

60065 }else if( 
	`exprAlwaysTrue
(
pExpr
) )

60070 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pExpr
, &
regFree1
);

60071 
	`sqlite3VdbeAddOp3
(
v
, 46, 
r1
, 
dest
, 
jumpIfNull
!=0);

60079 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree1
);

60080 
	`sqlite3ReleaseTempReg
(
pParse
, 
regFree2
);

60081 
	}
}

60088 static void 
	$sqlite3ExprIfFalseDup
(
Parse
 *
pParse
, 
Expr
 *
pExpr
, int 
dest
,int 
jumpIfNull
)

60091 
sqlite3
 *
db
 = 
pParse
->db;

60092 
Expr
 *
pCopy
 = 
	`sqlite3ExprDup
(
db
, 
pExpr
, 0);

60093 if( 
db
->
mallocFailed
==0 )

60096 
	`sqlite3ExprIfFalse
(
pParse
, 
pCopy
, 
dest
, 
jumpIfNull
);

60098 
	`sqlite3ExprDelete
(
db
, 
pCopy
);

60099 
	}
}

60101 static int 
	$sqlite3ExprCompare
(
Expr
 *
pA
, Expr *
pB
, int 
iTab
)

60104 
u32
 
combinedFlags
;

60105 if( 
pA
==0 || 
pB
==0 )

60108 return 
pB
==
pA
 ? 0 : 2;

60110 
combinedFlags
 = 
pA
->
flags
 | 
pB
->flags;

60111 if( 
combinedFlags
 & 0x000400 )

60114 if( (
pA
->
flags
&
pB
->flags&0x000400)!=0 && pA->
u
.
iValue
==pB->u.iValue )

60121 if( 
pA
->
op
!=
pB
->op )

60124 if( 
pA
->
op
==95 && 
	`sqlite3ExprCompare
(pA->
pLeft
, 
pB
, 
iTab
)<2 )

60129 if( 
pB
->
op
==95 && 
	`sqlite3ExprCompare
(
pA
, pB->
pLeft
, 
iTab
)<2 )

60136 if( 
pA
->
op
!=152 && pA->op!=154 && pA->
u
.
zToken
 )

60139 if( 
pA
->
op
==151 )

60142 if( 
	`sqlite3StrICmp
(
pA
->
u
.
zToken
,
pB
->u.zToken)!=0 ) return 2;

60143 }else if( 
	`strcmp
(
pA
->
u
.
zToken
,
pB
->u.zToken)!=0 )

60146 return 
pA
->
op
==95 ? 1 : 2;

60149 if( (
pA
->
flags
 & 0x000010)!=(
pB
->flags & 0x000010) ) return 2;

60150 if( ((
combinedFlags
 & 0x004000)==0) )

60153 if( 
combinedFlags
 & 0x000800 ) return 2;

60154 if( 
	`sqlite3ExprCompare
(
pA
->
pLeft
, 
pB
->pLeft, 
iTab
) ) return 2;

60155 if( 
	`sqlite3ExprCompare
(
pA
->
pRight
, 
pB
->pRight, 
iTab
) ) return 2;

60156 if( 
	`sqlite3ExprListCompare
(
pA
->
x
.
pList
, 
pB
->x.pList, 
iTab
) ) return 2;

60157 if( ((
combinedFlags
 & 0x002000)==0) && 
pA
->
op
!=97 )

60160 if( 
pA
->
iColumn
!=
pB
->iColumn ) return 2;

60161 if( 
pA
->
iTable
!=
pB
->iTable

60162 && (
pA
->
iTable
!=
iTab
 || (
pB
->iTable>=0)) ) return 2;

60166 
	}
}

60168 static int 
	$sqlite3ExprListCompare
(
ExprList
 *
pA
, ExprList *
pB
, int 
iTab
)

60171 int 
i
;

60172 if( 
pA
==0 && 
pB
==0 ) return 0;

60173 if( 
pA
==0 || 
pB
==0 ) return 1;

60174 if( 
pA
->
nExpr
!=
pB
->nExpr ) return 1;

60175 for(
i
=0; i<
pA
->
nExpr
; i++)

60178 
Expr
 *
pExprA
 = 
pA
->
a
[
i
].
pExpr
;

60179 
Expr
 *
pExprB
 = 
pB
->
a
[
i
].
pExpr
;

60180 if( 
pA
->
a
[
i
].
sortOrder
!=
pB
->a[i].sortOrder ) return 1;

60181 if( 
	`sqlite3ExprCompare
(
pExprA
, 
pExprB
, 
iTab
) ) return 1;

60184 
	}
}

60186 static int 
	$sqlite3ExprImpliesExpr
(
Expr
 *
pE1
, Expr *
pE2
, int 
iTab
)

60189 if( 
	`sqlite3ExprCompare
(
pE1
, 
pE2
, 
iTab
)==0 )

60194 if( 
pE2
->
op
==71

60195 && (
	`sqlite3ExprImpliesExpr
(
pE1
, 
pE2
->
pLeft
, 
iTab
)

60196 || 
	`sqlite3ExprImpliesExpr
(
pE1
, 
pE2
->
pRight
, 
iTab
) )

60202 if( 
pE2
->
op
==77

60203 && 
	`sqlite3ExprCompare
(
pE1
->
pLeft
, 
pE2
->pLeft, 
iTab
)==0

60204 && (
pE1
->
op
!=76 && pE1->op!=73)

60211 
	}
}

60219 struct 
	sSrcCount
 {

60220 
SrcList
 *
	mpSrc
;

60221 int 
	mnThis
;

60222 int 
	mnOther
;

60228 static int 
	$exprSrcCount
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

60236 if( 
pExpr
->
op
==152 || (pExpr->op==154) )

60239 int 
i
;

60240 struct 
SrcCount
 *
p
 = 
pWalker
->
u
.
pSrcCount
;

60241 
SrcList
 *
pSrc
 = 
p
->pSrc;

60242 int 
nSrc
 = 
pSrc
 ? pSrc->nSrc : 0;

60243 for(
i
=0; i<
nSrc
; i++)

60246 if( 
pExpr
->
iTable
==
pSrc
->
a
[
i
].
iCursor
 ) break;

60248 if( 
i
<
nSrc
 )

60251 
p
->
nThis
++;

60253 
p
->
nOther
++;

60257 
	}
}

60265 static int 
	$sqlite3FunctionUsesThisSrc
(
Expr
 *
pExpr
, 
SrcList
 *
pSrcList
)

60268 
Walker
 
w
;

60269 struct 
SrcCount
 
cnt
;

60271 
	`memset
(&
w
, 0, sizeof(w));

60272 
w
.
xExprCallback
 = 
exprSrcCount
;

60273 
w
.
u
.
pSrcCount
 = &
cnt
;

60274 
cnt
.
pSrc
 = 
pSrcList
;

60275 
cnt
.
nThis
 = 0;

60276 
cnt
.
nOther
 = 0;

60277 
	`sqlite3WalkExprList
(&
w
, 
pExpr
->
x
.
pList
);

60278 return 
cnt
.
nThis
>0 || cnt.
nOther
==0;

60279 
	}
}

60285 static int 
	$addAggInfoColumn
(
sqlite3
 *
db
, 
AggInfo
 *
pInfo
)

60288 int 
i
;

60289 
pInfo
->
aCol
 = 
	`sqlite3ArrayAllocate
(

60290 
db
,

60291 
pInfo
->
aCol
,

60292 sizeof(
pInfo
->
aCol
[0]),

60293 &
pInfo
->
nColumn
,

60294 &
i


60296 return 
i
;

60297 
	}
}

60303 static int 
	$addAggInfoFunc
(
sqlite3
 *
db
, 
AggInfo
 *
pInfo
)

60306 int 
i
;

60307 
pInfo
->
aFunc
 = 
	`sqlite3ArrayAllocate
(

60308 
db
,

60309 
pInfo
->
aFunc
,

60310 sizeof(
pInfo
->
aFunc
[0]),

60311 &
pInfo
->
nFunc
,

60312 &
i


60314 return 
i
;

60315 
	}
}

60322 static int 
	$analyzeAggregate
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

60325 int 
i
;

60326 
NameContext
 *
pNC
 = 
pWalker
->
u
.pNC;

60327 
Parse
 *
pParse
 = 
pNC
->pParse;

60328 
SrcList
 *
pSrcList
 = 
pNC
->pSrcList;

60329 
AggInfo
 *
pAggInfo
 = 
pNC
->pAggInfo;

60331 switch( 
pExpr
->
op
 )

60340 if( (
pSrcList
!=0) )

60343 struct 
SrcList_item
 *
pItem
 = 
pSrcList
->
a
;

60344 for(
i
=0; i<
pSrcList
->
nSrc
; i++, 
pItem
++)

60347 struct 
AggInfo_col
 *
pCol
;

60349 if( 
pExpr
->
iTable
==
pItem
->
iCursor
 )

60358 int 
k
;

60359 
pCol
 = 
pAggInfo
->
aCol
;

60360 for(
k
=0; k<
pAggInfo
->
nColumn
; k++, 
pCol
++)

60363 if( 
pCol
->
iTable
==
pExpr
->iTable &&

60364 
pCol
->
iColumn
==
pExpr
->iColumn )

60370 if( (
k
>=
pAggInfo
->
nColumn
)

60371 && (
k
 = 
	`addAggInfoColumn
(
pParse
->
db
, 
pAggInfo
))>=0

60375 
pCol
 = &
pAggInfo
->
aCol
[
k
];

60376 
pCol
->
pTab
 = 
pExpr
->pTab;

60377 
pCol
->
iTable
 = 
pExpr
->iTable;

60378 
pCol
->
iColumn
 = 
pExpr
->iColumn;

60379 
pCol
->
iMem
 = ++
pParse
->
nMem
;

60380 
pCol
->
iSorterColumn
 = -1;

60381 
pCol
->
pExpr
 = pExpr;

60382 if( 
pAggInfo
->
pGroupBy
 )

60385 int 
j
, 
n
;

60386 
ExprList
 *
pGB
 = 
pAggInfo
->
pGroupBy
;

60387 struct 
ExprList_item
 *
pTerm
 = 
pGB
->
a
;

60388 
n
 = 
pGB
->
nExpr
;

60389 for(
j
=0; j<
n
; j++, 
pTerm
++)

60392 
Expr
 *
pE
 = 
pTerm
->
pExpr
;

60393 if( 
pE
->
op
==152 && pE->
iTable
==
pExpr
->iTable &&

60394 
pE
->
iColumn
==
pExpr
->iColumn )

60397 
pCol
->
iSorterColumn
 = 
j
;

60402 if( 
pCol
->
iSorterColumn
<0 )

60405 
pCol
->
iSorterColumn
 = 
pAggInfo
->
nSortingColumn
++;

60414 
pExpr
->
pAggInfo
 = pAggInfo;

60415 
pExpr
->
op
 = 154;

60416 
pExpr
->
iAgg
 = (
i16
)
k
;

60424 if( (
pNC
->
ncFlags
 & 0x0008)==0

60425 && 
pWalker
->
walkerDepth
==
pExpr
->
op2


60432 struct 
AggInfo_func
 *
pItem
 = 
pAggInfo
->
aFunc
;

60433 for(
i
=0; i<
pAggInfo
->
nFunc
; i++, 
pItem
++)

60436 if( 
	`sqlite3ExprCompare
(
pItem
->
pExpr
, pExpr, -1)==0 )

60442 if( 
i
>=
pAggInfo
->
nFunc
 )

60447 
u8
 
enc
 = ((
pParse
->
db
)->enc);

60448 
i
 = 
	`addAggInfoFunc
(
pParse
->
db
, 
pAggInfo
);

60449 if( 
i
>=0 )

60453 
pItem
 = &
pAggInfo
->
aFunc
[
i
];

60454 
pItem
->
pExpr
 = pExpr;

60455 
pItem
->
iMem
 = ++
pParse
->
nMem
;

60457 
pItem
->
pFunc
 = 
	`sqlite3FindFunction
(
pParse
->
db
,

60458 
pExpr
->
u
.
zToken
,

60459 
pExpr
->
x
.
pList
 ? pExpr->x.pList->
nExpr
 : 0, 
enc
, 0);

60460 if( 
pExpr
->
flags
 & 0x000010 )

60463 
pItem
->
iDistinct
 = 
pParse
->
nTab
++;

60465 
pItem
->
iDistinct
 = -1;

60473 
pExpr
->
iAgg
 = (
i16
)
i
;

60474 
pExpr
->
pAggInfo
 = pAggInfo;

60482 
	}
}

60483 static int 
	$analyzeAggregatesInSelect
(
Walker
 *
pWalker
, 
Select
 *
pSelect
)

60486 (void)(
pWalker
);

60487 (void)(
pSelect
);

60489 
	}
}

60491 static void 
	$sqlite3ExprAnalyzeAggregates
(
NameContext
 *
pNC
, 
Expr
 *
pExpr
)

60494 
Walker
 
w
;

60495 
	`memset
(&
w
, 0, sizeof(w));

60496 
w
.
xExprCallback
 = 
analyzeAggregate
;

60497 
w
.
xSelectCallback
 = 
analyzeAggregatesInSelect
;

60498 
w
.
u
.
pNC
 = pNC;

60500 
	`sqlite3WalkExpr
(&
w
, 
pExpr
);

60501 
	}
}

60509 static void 
	$sqlite3ExprAnalyzeAggList
(
NameContext
 *
pNC
, 
ExprList
 *
pList
)

60512 struct 
ExprList_item
 *
pItem
;

60513 int 
i
;

60514 if( 
pList
 )

60517 for(
pItem
=
pList
->
a
, 
i
=0; i<pList->
nExpr
; i++, pItem++)

60520 
	`sqlite3ExprAnalyzeAggregates
(
pNC
, 
pItem
->
pExpr
);

60523 
	}
}

60528 static int 
	$sqlite3GetTempReg
(
Parse
 *
pParse
)

60531 if( 
pParse
->
nTempReg
==0 )

60534 return ++
pParse
->
nMem
;

60536 return 
pParse
->
aTempReg
[--pParse->
nTempReg
];

60537 
	}
}

60539 static void 
	$sqlite3ReleaseTempReg
(
Parse
 *
pParse
, int 
iReg
)

60542 if( 
iReg
 && 
pParse
->
nTempReg
<((int)(sizeof(pParse->
aTempReg
)/sizeof(pParse->aTempReg[0]))) )

60545 int 
i
;

60546 struct 
yColCache
 *
p
;

60547 for(
i
=0, 
p
=
pParse
->
aColCache
; i<10; i++, p++)

60550 if( 
p
->
iReg
==iReg )

60553 
p
->
tempReg
 = 1;

60557 
pParse
->
aTempReg
[pParse->
nTempReg
++] = 
iReg
;

60559 
	}
}

60564 static int 
	$sqlite3GetTempRange
(
Parse
 *
pParse
, int 
nReg
)

60567 int 
i
, 
n
;

60568 
i
 = 
pParse
->
iRangeReg
;

60569 
n
 = 
pParse
->
nRangeReg
;

60570 if( 
nReg
<=
n
 )

60574 
pParse
->
iRangeReg
 += 
nReg
;

60575 
pParse
->
nRangeReg
 -= 
nReg
;

60577 
i
 = 
pParse
->
nMem
+1;

60578 
pParse
->
nMem
 += 
nReg
;

60580 return 
i
;

60581 
	}
}

60582 static void 
	$sqlite3ReleaseTempRange
(
Parse
 *
pParse
, int 
iReg
, int 
nReg
)

60585 
	`sqlite3ExprCacheRemove
(
pParse
, 
iReg
, 
nReg
);

60586 if( 
nReg
>
pParse
->
nRangeReg
 )

60589 
pParse
->
nRangeReg
 = 
nReg
;

60590 
pParse
->
iRangeReg
 = 
iReg
;

60592 
	}
}

60597 static void 
	$sqlite3ClearTempRegCache
(
Parse
 *
pParse
)

60600 
pParse
->
nTempReg
 = 0;

60601 
pParse
->
nRangeReg
 = 0;

60602 
	}
}

60604 static void 
	$renameTableFunc
(

60605 
sqlite3_context
 *
context
,

60606 int 
NotUsed
,

60607 
sqlite3_value
 **
argv


60611 unsigned char const *
zSql
 = 
	`sqlite3_value_text
(
argv
[0]);

60612 unsigned char const *
zTableName
 = 
	`sqlite3_value_text
(
argv
[1]);

60614 int 
token
;

60615 
Token
 
tname
;

60616 unsigned char const *
zCsr
 = 
zSql
;

60617 int 
len
 = 0;

60618 char *
zRet
;

60620 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

60622 (void)(
NotUsed
);

60628 if( 
zSql
 )

60632 if( !*
zCsr
 )

60640 
tname
.
z
 = (char*)
zCsr
;

60641 
tname
.
n
 = 
len
;

60647 
zCsr
 += 
len
;

60648 
len
 = 
	`sqlite3GetToken
(
zCsr
, &
token
);

60649 } while( 
token
==160 );

60651 } while( 
token
!=22 && token!=125 );

60653 
zRet
 = 
	`sqlite3MPrintf
(
db
, "%.*s\"%w\"%s", (int)(((
u8
*)
tname
.
z
) - 
zSql
),

60654 
zSql
, 
zTableName
, 
tname
.
z
+tname.
n
);

60655 
	`sqlite3_result_text
(
context
, 
zRet
, -1, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

60657 
	}
}

60659 static void 
	$renameParentFunc
(

60660 
sqlite3_context
 *
context
,

60661 int 
NotUsed
,

60662 
sqlite3_value
 **
argv


60666 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

60667 char *
zOutput
 = 0;

60668 char *
zResult
;

60669 unsigned char const *
zInput
 = 
	`sqlite3_value_text
(
argv
[0]);

60670 unsigned char const *
zOld
 = 
	`sqlite3_value_text
(
argv
[1]);

60671 unsigned char const *
zNew
 = 
	`sqlite3_value_text
(
argv
[2]);

60673 unsigned const char *
z
;

60674 int 
n
;

60675 int 
token
;

60677 (void)(
NotUsed
);

60678 if( 
zInput
==0 || 
zOld
==0 ) return;

60679 for(
z
=
zInput
; *z; z=z+
n
)

60682 
n
 = 
	`sqlite3GetToken
(
z
, &
token
);

60683 if( 
token
==105 )

60686 char *
zParent
;

60688 
z
 += 
n
;

60689 
n
 = 
	`sqlite3GetToken
(
z
, &
token
);

60690 }while( 
token
==160 );

60692 if( 
token
==161 ) break;

60693 
zParent
 = 
	`sqlite3DbStrNDup
(
db
, (const char *)
z
, 
n
);

60694 if( 
zParent
==0 ) break;

60695 
	`sqlite3Dequote
(
zParent
);

60696 if( 0==
	`sqlite3StrICmp
((const char *)
zOld
, 
zParent
) )

60699 char *
zOut
 = 
	`sqlite3MPrintf
(
db
, "%s%.*s\"%w\"",

60700 (
zOutput
?zOutput:""), (int)(
z
-
zInput
), zInput, (const char *)
zNew


60702 
	`sqlite3DbFree
(
db
, 
zOutput
);

60703 
zOutput
 = 
zOut
;

60704 
zInput
 = &
z
[
n
];

60706 
	`sqlite3DbFree
(
db
, 
zParent
);

60710 
zResult
 = 
	`sqlite3MPrintf
(
db
, "%s%s", (
zOutput
?zOutput:""), 
zInput
),

60711 
	`sqlite3_result_text
(
context
, 
zResult
, -1, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

60712 
	`sqlite3DbFree
(
db
, 
zOutput
);

60713 
	}
}

60715 static void 
	$renameTriggerFunc
(

60716 
sqlite3_context
 *
context
,

60717 int 
NotUsed
,

60718 
sqlite3_value
 **
argv


60722 unsigned char const *
zSql
 = 
	`sqlite3_value_text
(
argv
[0]);

60723 unsigned char const *
zTableName
 = 
	`sqlite3_value_text
(
argv
[1]);

60725 int 
token
;

60726 
Token
 
tname
;

60727 int 
dist
 = 3;

60728 unsigned char const *
zCsr
 = 
zSql
;

60729 int 
len
 = 0;

60730 char *
zRet
;

60731 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

60733 (void)(
NotUsed
);

60740 if( 
zSql
 )

60745 if( !*
zCsr
 )

60753 
tname
.
z
 = (char*)
zCsr
;

60754 
tname
.
n
 = 
len
;

60760 
zCsr
 += 
len
;

60761 
len
 = 
	`sqlite3GetToken
(
zCsr
, &
token
);

60762 }while( 
token
==160 );

60765 
dist
++;

60766 if( 
token
==122 || token==107 )

60769 
dist
 = 0;

60771 } while( 
dist
!=2 || (
token
!=137 && token!=46 && token!=5) );

60776 
zRet
 = 
	`sqlite3MPrintf
(
db
, "%.*s\"%w\"%s", (int)(((
u8
*)
tname
.
z
) - 
zSql
),

60777 
zSql
, 
zTableName
, 
tname
.
z
+tname.
n
);

60778 
	`sqlite3_result_text
(
context
, 
zRet
, -1, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

60780 
	}
}

60786 static void 
	$sqlite3AlterFunctions
(void)

60789 static 
FuncDef
 
aAlterTableFuncs
[] = {

60790 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
renameTableFunc
, 0, "sqlite_rename_table", {0} },

60792 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
renameTriggerFunc
, 0, "sqlite_rename_trigger", {0} },

60795 {3, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
renameParentFunc
, 0, "sqlite_rename_parent", {0} },

60798 
	`sqlite3InsertBuiltinFuncs
(
aAlterTableFuncs
, ((int)(sizeof(aAlterTableFuncs)/sizeof(aAlterTableFuncs[0]))));

60799 
	}
}

60801 static char *
	$whereOrName
(
sqlite3
 *
db
, char *
zWhere
, char *
zConstant
)

60804 char *
zNew
;

60805 if( !
zWhere
 )

60808 
zNew
 = 
	`sqlite3MPrintf
(
db
, "name=%Q", 
zConstant
);

60810 
zNew
 = 
	`sqlite3MPrintf
(
db
, "%s OR name=%Q", 
zWhere
, 
zConstant
);

60811 
	`sqlite3DbFree
(
db
, 
zWhere
);

60813 return 
zNew
;

60814 
	}
}

60816 static char *
	$whereForeignKeys
(
Parse
 *
pParse
, 
Table
 *
pTab
)

60819 
FKey
 *
p
;

60820 char *
zWhere
 = 0;

60821 for(
p
=
	`sqlite3FkReferences
(
pTab
); p; p=p->
pNextTo
)

60824 
zWhere
 = 
	`whereOrName
(
pParse
->
db
, zWhere, 
p
->
pFrom
->
zName
);

60826 return 
zWhere
;

60827 
	}
}

60829 static char *
	$whereTempTriggers
(
Parse
 *
pParse
, 
Table
 *
pTab
)

60832 
Trigger
 *
pTrig
;

60833 char *
zWhere
 = 0;

60834 const 
Schema
 *
pTempSchema
 = 
pParse
->
db
->
aDb
[1].
pSchema
;

60841 if( 
pTab
->
pSchema
!=
pTempSchema
 )

60844 
sqlite3
 *
db
 = 
pParse
->db;

60845 for(
pTrig
=
	`sqlite3TriggerList
(
pParse
, 
pTab
); pTrig; pTrig=pTrig->
pNext
)

60848 if( 
pTrig
->
pSchema
==
pTempSchema
 )

60851 
zWhere
 = 
	`whereOrName
(
db
, zWhere, 
pTrig
->
zName
);

60855 if( 
zWhere
 )

60858 char *
zNew
 = 
	`sqlite3MPrintf
(
pParse
->
db
, "type='trigger' AND (%s)", 
zWhere
);

60859 
	`sqlite3DbFree
(
pParse
->
db
, 
zWhere
);

60860 
zWhere
 = 
zNew
;

60862 return 
zWhere
;

60863 
	}
}

60865 static void 
	$reloadTableSchema
(
Parse
 *
pParse
, 
Table
 *
pTab
, const char *
zName
)

60868 
Vdbe
 *
v
;

60869 char *
zWhere
;

60870 int 
iDb
;

60872 
Trigger
 *
pTrig
;

60875 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

60876 if( (
v
==0) ) return;

60878 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

60883 for(
pTrig
=
	`sqlite3TriggerList
(
pParse
, 
pTab
); pTrig; pTrig=pTrig->
pNext
)

60886 int 
iTrigDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTrig
->
pSchema
);

60888 
	`sqlite3VdbeAddOp4
(
v
, 127, 
iTrigDb
, 0, 0, 
pTrig
->
zName
, 0);

60893 
	`sqlite3VdbeAddOp4
(
v
, 125, 
iDb
, 0, 0, 
pTab
->
zName
, 0);

60896 
zWhere
 = 
	`sqlite3MPrintf
(
pParse
->
db
, "tbl_name=%Q", 
zName
);

60897 if( !
zWhere
 ) return;

60898 
	`sqlite3VdbeAddParseSchemaOp
(
v
, 
iDb
, 
zWhere
);

60904 if( (
zWhere
=
	`whereTempTriggers
(
pParse
, 
pTab
))!=0 )

60907 
	`sqlite3VdbeAddParseSchemaOp
(
v
, 1, 
zWhere
);

60910 
	}
}

60912 static int 
	$isSystemTable
(
Parse
 *
pParse
, const char *
zName
)

60915 if( 
	`sqlite3Strlen30
(
zName
)>6 && 0==
	`sqlite3_strnicmp
(zName, "sqlite_", 7) )

60918 
	`sqlite3ErrorMsg
(
pParse
, "table %s may not be altered", 
zName
);

60922 
	}
}

60928 static void 
	$sqlite3AlterRenameTable
(

60929 
Parse
 *
pParse
,

60930 
SrcList
 *
pSrc
,

60931 
Token
 *
pName


60935 int 
iDb
;

60936 char *
zDb
;

60937 
Table
 *
pTab
;

60938 char *
zName
 = 0;

60939 
sqlite3
 *
db
 = 
pParse
->db;

60940 int 
nTabName
;

60941 const char *
zTabName
;

60942 
Vdbe
 *
v
;

60944 char *
zWhere
 = 0;

60946 
VTable
 *
pVTab
 = 0;

60947 int 
savedDbFlags
;

60949 
savedDbFlags
 = 
db
->
flags
;

60950 if( (
db
->
mallocFailed
) ) goto 
exit_rename_table
;

60954 
pTab
 = 
	`sqlite3LocateTableItem
(
pParse
, 0, &
pSrc
->
a
[0]);

60955 if( !
pTab
 ) goto 
exit_rename_table
;

60956 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

60957 
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

60958 
db
->
flags
 |= 0x00200000;

60961 
zName
 = 
	`sqlite3NameFromToken
(
db
, 
pName
);

60962 if( !
zName
 ) goto 
exit_rename_table
;

60967 if( 
	`sqlite3FindTable
(
db
, 
zName
, 
zDb
) || 
	`sqlite3FindIndex
(db, zName, zDb) )

60970 
	`sqlite3ErrorMsg
(
pParse
,

60971 "there is already another table or index with this name: %s", 
zName
);

60972 goto 
exit_rename_table
;

60978 if( 0!=
	`isSystemTable
(
pParse
, 
pTab
->
zName
) )

60981 goto 
exit_rename_table
;

60983 if( 0!=
	`sqlite3CheckObjectName
(
pParse
, 
zName
) )

60986 
exit_rename_table
;

60990 if( 
pTab
->
pSelect
 )

60993 
	`sqlite3ErrorMsg
(
pParse
, "view %s may not be altered", 
pTab
->
zName
);

60994 goto 
exit_rename_table
;

61000 if( 
	`sqlite3AuthCheck
(
pParse
, 26, 
zDb
, 
pTab
->
zName
, 0) )

61003 goto 
exit_rename_table
;

61008 if( 
	`sqlite3ViewGetColumnNames
(
pParse
, 
pTab
) )

61011 goto 
exit_rename_table
;

61013 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

61016 
pVTab
 = 
	`sqlite3GetVTable
(
db
, 
pTab
);

61017 if( 
pVTab
->
pVtab
->
pModule
->
xRename
==0 )

61020 
pVTab
 = 0;

61030 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

61031 if( 
v
==0 )

61034 goto 
exit_rename_table
;

61036 
	`sqlite3BeginWriteOperation
(
pParse
, 
pVTab
!=0, 
iDb
);

61037 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

61045 if( 
pVTab
 )

61048 int 
i
 = ++
pParse
->
nMem
;

61049 
	`sqlite3VdbeLoadString
(
v
, 
i
, 
zName
);

61050 
	`sqlite3VdbeAddOp4
(
v
, 155, 
i
, 0, 0,(const char*)
pVTab
, (-10));

61051 
	`sqlite3MayAbort
(
pParse
);

61056 
zTabName
 = 
pTab
->
zName
;

61057 
nTabName
 = 
	`sqlite3Utf8CharLen
(
zTabName
, -1);

61060 if( 
db
->
flags
&0x00080000 )

61066 if( (
zWhere
=
	`whereForeignKeys
(
pParse
, 
pTab
))!=0 )

61069 
	`sqlite3NestedParse
(
pParse
,

61072 "WHERE %s;", 
zDb
, ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master"), 
zTabName
, 
zName
, 
zWhere
);

61073 
	`sqlite3DbFree
(
db
, 
zWhere
);

61079 
	`sqlite3NestedParse
(
pParse
,

61096 
zDb
, ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master"), 
zName
, zName, zName,

61098 
zName
,

61100 
zName
, 
nTabName
, 
zTabName


61107 if( 
	`sqlite3FindTable
(
db
, "sqlite_sequence", 
zDb
) )

61110 
	`sqlite3NestedParse
(
pParse
,

61112 
zDb
, 
zName
, 
pTab
->zName);

61121 if( (
zWhere
=
	`whereTempTriggers
(
pParse
, 
pTab
))!=0 )

61124 
	`sqlite3NestedParse
(
pParse
,

61128 "WHERE %s;", 
zName
, zName, 
zWhere
);

61129 
	`sqlite3DbFree
(
db
, 
zWhere
);

61134 if( 
db
->
flags
&0x00080000 )

61137 
FKey
 *
p
;

61138 for(
p
=
	`sqlite3FkReferences
(
pTab
); p; p=p->
pNextTo
)

61141 
Table
 *
pFrom
 = 
p
->pFrom;

61142 if( 
pFrom
!=
pTab
 )

61145 
	`reloadTableSchema
(
pParse
, 
p
->
pFrom
, pFrom->
zName
);

61152 
	`reloadTableSchema
(
pParse
, 
pTab
, 
zName
);

61154 
exit_rename_table
:

61155 
	`sqlite3SrcListDelete
(
db
, 
pSrc
);

61156 
	`sqlite3DbFree
(
db
, 
zName
);

61157 
db
->
flags
 = 
savedDbFlags
;

61158 
	}
}

61160 static void 
	$sqlite3AlterFinishAddColumn
(
Parse
 *
pParse
, 
Token
 *
pColDef
)

61163 
Table
 *
pNew
;

61164 
Table
 *
pTab
;

61165 int 
iDb
;

61166 const char *
zDb
;

61167 const char *
zTab
;

61168 char *
zCol
;

61169 
Column
 *
pCol
;

61170 
Expr
 *
pDflt
;

61171 
sqlite3
 *
db
;

61172 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

61174 
db
 = 
pParse
->db;

61175 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 ) return;

61177 
pNew
 = 
pParse
->
pNewTable
;

61181 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pNew
->
pSchema
);

61182 
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

61183 
zTab
 = &
pNew
->
zName
[16];

61184 
pCol
 = &
pNew
->
aCol
[pNew->
nCol
-1];

61185 
pDflt
 = 
pCol
->pDflt;

61186 
pTab
 = 
	`sqlite3FindTable
(
db
, 
zTab
, 
zDb
);

61191 if( 
	`sqlite3AuthCheck
(
pParse
, 26, 
zDb
, 
pTab
->
zName
, 0) )

61203 if( 
pDflt
 && pDflt->
pLeft
->
op
==101 )

61206 
pDflt
 = 0;

61213 if( 
pCol
->
colFlags
 & 0x0001 )

61216 
	`sqlite3ErrorMsg
(
pParse
, "Cannot add a PRIMARY KEY column");

61219 if( 
pNew
->
pIndex
 )

61222 
	`sqlite3ErrorMsg
(
pParse
, "Cannot add a UNIQUE column");

61225 if( (
db
->
flags
&0x00080000) && 
pNew
->
pFKey
 && 
pDflt
 )

61228 
	`sqlite3ErrorMsg
(
pParse
,

61232 if( 
pCol
->
notNull
 && !
pDflt
 )

61235 
	`sqlite3ErrorMsg
(
pParse
,

61243 if( 
pDflt
 )

61246 
sqlite3_value
 *
pVal
 = 0;

61247 int 
rc
;

61248 
rc
 = 
	`sqlite3ValueFromExpr
(
db
, 
pDflt
, 1, 'A', &
pVal
);

61250 if( 
rc
!=0 )

61256 if( !
pVal
 )

61259 
	`sqlite3ErrorMsg
(
pParse
, "Cannot add a column with non-constant default");

61262 
	`sqlite3ValueFree
(
pVal
);

61266 
zCol
 = 
	`sqlite3DbStrNDup
(
db
, (char*)
pColDef
->
z
, pColDef->
n
);

61267 if( 
zCol
 )

61270 char *
zEnd
 = &
zCol
[
pColDef
->
n
-1];

61271 int 
savedDbFlags
 = 
db
->
flags
;

61272 while( 
zEnd
>
zCol
 && (*zEnd==';' || (
sqlite3CtypeMap
[(unsigned char)(*zEnd)]&0x01)) )

61275 *
zEnd
-- = '\0';

61277 
db
->
flags
 |= 0x00200000;

61278 
	`sqlite3NestedParse
(
pParse
,

61282 
zDb
, ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master"), 
pNew
->
addColOffset
, 
zCol
, pNew->addColOffset+1,

61283 
zTab


61285 
	`sqlite3DbFree
(
db
, 
zCol
);

61286 
db
->
flags
 = 
savedDbFlags
;

61289 
	`sqlite3VdbeAddOp3
(
v
, 52, 
iDb
, 2,

61293 
	`reloadTableSchema
(
pParse
, 
pTab
, pTab->
zName
);

61294 
	}
}

61296 static void 
	$sqlite3AlterBeginAddColumn
(
Parse
 *
pParse
, 
SrcList
 *
pSrc
)

61299 
Table
 *
pNew
;

61300 
Table
 *
pTab
;

61301 
Vdbe
 *
v
;

61302 int 
iDb
;

61303 int 
i
;

61304 int 
nAlloc
;

61305 
sqlite3
 *
db
 = 
pParse
->db;

61310 if( 
db
->
mallocFailed
 ) goto 
exit_begin_add_column
;

61311 
pTab
 = 
	`sqlite3LocateTableItem
(
pParse
, 0, &
pSrc
->
a
[0]);

61312 if( !
pTab
 ) goto 
exit_begin_add_column
;

61315 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

61318 
	`sqlite3ErrorMsg
(
pParse
, "virtual tables may not be altered");

61319 goto 
exit_begin_add_column
;

61324 if( 
pTab
->
pSelect
 )

61327 
	`sqlite3ErrorMsg
(
pParse
, "Cannot add a column to a view");

61328 goto 
exit_begin_add_column
;

61330 if( 0!=
	`isSystemTable
(
pParse
, 
pTab
->
zName
) )

61333 goto 
exit_begin_add_column
;

61337 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

61339 
pNew
 = (
Table
*)
	`sqlite3DbMallocZero
(
db
, sizeof(Table));

61340 if( !
pNew
 ) goto 
exit_begin_add_column
;

61341 
pParse
->
pNewTable
 = 
pNew
;

61342 
pNew
->
nRef
 = 1;

61343 
pNew
->
nCol
 = 
pTab
->nCol;

61345 
nAlloc
 = (((
pNew
->
nCol
-1)/8)*8)+8;

61347 
pNew
->
aCol
 = (
Column
*)
	`sqlite3DbMallocZero
(
db
, sizeof(Column)*
nAlloc
);

61348 
pNew
->
zName
 = 
	`sqlite3MPrintf
(
db
, "sqlite_altertab_%s", 
pTab
->zName);

61349 if( !
pNew
->
aCol
 || !pNew->
zName
 )

61353 goto 
exit_begin_add_column
;

61355 
	`memcpy
(
pNew
->
aCol
, 
pTab
->aCol, sizeof(
Column
)*pNew->
nCol
);

61356 for(
i
=0; i<
pNew
->
nCol
; i++)

61359 
Column
 *
pCol
 = &
pNew
->
aCol
[
i
];

61360 
pCol
->
zName
 = 
	`sqlite3DbStrDup
(
db
, pCol->zName);

61361 
pCol
->
zColl
 = 0;

61362 
pCol
->
pDflt
 = 0;

61364 
pNew
->
pSchema
 = 
db
->
aDb
[
iDb
].pSchema;

61365 
pNew
->
addColOffset
 = 
pTab
->addColOffset;

61366 
pNew
->
nRef
 = 1;

61369 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

61370 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

61371 if( !
v
 ) goto 
exit_begin_add_column
;

61372 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

61374 
exit_begin_add_column
:

61375 
	`sqlite3SrcListDelete
(
db
, 
pSrc
);

61377 
	}
}

61379 static void 
	$openStatTable
(

61380 
Parse
 *
pParse
,

61381 int 
iDb
,

61382 int 
iStatCur
,

61383 const char *
zWhere
,

61384 const char *
zWhereType


61389 const char *
zName
;

61390 const char *
zCols
;

61391 } 
aTable
[] = {

61404 int 
i
;

61405 
sqlite3
 *
db
 = 
pParse
->db;

61406 
Db
 *
pDb
;

61407 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

61408 int 
aRoot
[((int)(sizeof(
aTable
)/sizeof(aTable[0])))];

61409 
u8
 
aCreateTbl
[((int)(sizeof(
aTable
)/sizeof(aTable[0])))];

61411 if( 
v
==0 ) return;

61414 
pDb
 = &
db
->
aDb
[
iDb
];

61419 for(
i
=0; i<((int)(sizeof(
aTable
)/sizeof(aTable[0]))); i++)

61422 const char *
zTab
 = 
aTable
[
i
].
zName
;

61423 
Table
 *
pStat
;

61424 if( (
pStat
 = 
	`sqlite3FindTable
(
db
, 
zTab
, 
pDb
->
zName
))==0 )

61427 if( 
aTable
[
i
].
zCols
 )

61434 
	`sqlite3NestedParse
(
pParse
,

61435 "CREATE TABLE %Q.%s(%s)", 
pDb
->
zName
, 
zTab
, 
aTable
[
i
].
zCols


61437 
aRoot
[
i
] = 
pParse
->
regRoot
;

61438 
aCreateTbl
[
i
] = 0x10;

61444 
aRoot
[
i
] = 
pStat
->
tnum
;

61445 
aCreateTbl
[
i
] = 0;

61446 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
aRoot
[
i
], 1, 
zTab
);

61447 if( 
zWhere
 )

61450 
	`sqlite3NestedParse
(
pParse
,

61452 
pDb
->
zName
, 
zTab
, 
zWhereType
, 
zWhere


61456 
	`sqlite3VdbeAddOp2
(
v
, 119, 
aRoot
[
i
], 
iDb
);

61462 for(
i
=0; 
aTable
[i].
zCols
; i++)

61466 
	`sqlite3VdbeAddOp4Int
(
v
, 55, 
iStatCur
+
i
, 
aRoot
[i], 
iDb
, 3);

61467 
	`sqlite3VdbeChangeP5
(
v
, 
aCreateTbl
[
i
]);

61470 
	}
}

61472 typedef struct 
Stat4Accum
 
	tStat4Accum
;

61473 typedef struct 
Stat4Sample
 
	tStat4Sample
;

61474 struct 
	sStat4Sample
 {

61475 
tRowcnt
 *
	manEq
;

61476 
tRowcnt
 *
	manDLt
;

61479 struct 
	sStat4Accum
 {

61480 
tRowcnt
 
	mnRow
;

61481 
tRowcnt
 
	mnPSample
;

61482 int 
	mnCol
;

61483 int 
	mnKeyCol
;

61484 int 
	mmxSample
;

61485 
Stat4Sample
 
	mcurrent
;

61486 
u32
 
	miPrn
;

61487 
Stat4Sample
 *
	maBest
;

61488 int 
	miMin
;

61489 int 
	mnSample
;

61490 int 
	miGet
;

61491 
Stat4Sample
 *
	ma
;

61492 
sqlite3
 *
	mdb
;

61495 static void 
	$stat4Destructor
(void *
pOld
)

61498 
Stat4Accum
 *
p
 = (Stat4Accum*)
pOld
;

61505 
	`sqlite3DbFree
(
p
->
db
, p);

61506 
	}
}

61508 static void 
	$statInit
(

61509 
sqlite3_context
 *
context
,

61510 int 
argc
,

61511 
sqlite3_value
 **
argv


61515 
Stat4Accum
 *
p
;

61516 int 
nCol
;

61517 int 
nKeyCol
;

61518 int 
nColUp
;

61519 int 
n
;

61520 
sqlite3
 *
db
;

61526 (void)(
argc
);

61527 
nCol
 = 
	`sqlite3_value_int
(
argv
[0]);

61529 
nColUp
 = sizeof(
tRowcnt
)<8 ? (
nCol
+1)&~1 : nCol;

61530 
nKeyCol
 = 
	`sqlite3_value_int
(
argv
[1]);

61535 
n
 = sizeof(*
p
)

61536 + sizeof(
tRowcnt
)*
nColUp


61537 + sizeof(
tRowcnt
)*
nColUp


61544 
db
 = 
	`sqlite3_context_db_handle
(
context
);

61545 
p
 = 
	`sqlite3DbMallocZero
(
db
, 
n
);

61546 if( 
p
==0 )

61549 
	`sqlite3_result_error_nomem
(
context
);

61553 
p
->
db
 = db;

61554 
p
->
nRow
 = 0;

61555 
p
->
nCol
 = nCol;

61556 
p
->
nKeyCol
 = nKeyCol;

61557 
p
->
current
.
anDLt
 = (
tRowcnt
*)&p[1];

61558 
p
->
current
.
anEq
 = &p->current.
anDLt
[
nColUp
];

61560 
	`sqlite3_result_blob
(
context
, 
p
, sizeof(*p), 
stat4Destructor
);

61561 
	}
}

61562 static const 
FuncDef
 
	gstatInitFuncdef
 = {

61567 
statInit
,

61573 static void 
	$samplePushPrevious
(
Stat4Accum
 *
p
, int 
iChng
)

61577 (void)(
p
);

61578 (void)(
iChng
);

61580 
	}
}

61582 static void 
	$statPush
(

61583 
sqlite3_context
 *
context
,

61584 int 
argc
,

61585 
sqlite3_value
 **
argv


61589 int 
i
;

61592 
Stat4Accum
 *
p
 = (Stat4Accum*)
	`sqlite3_value_blob
(
argv
[0]);

61593 int 
iChng
 = 
	`sqlite3_value_int
(
argv
[1]);

61595 (void)(
argc
);

61596 (void)(
context
);

61600 if( 
p
->
nRow
==0 )

61604 for(
i
=0; i<
p
->
nCol
; i++) p->
current
.
anEq
[i] = 1;

61607 
	`samplePushPrevious
(
p
, 
iChng
);

61611 for(
i
=0; i<
iChng
; i++)

61614 
p
->
current
.
anEq
[
i
]++;

61616 for(
i
=
iChng
; i<
p
->
nCol
; i++)

61619 
p
->
current
.
anDLt
[
i
]++;

61623 
p
->
current
.
anEq
[
i
] = 1;

61626 
p
->
nRow
++;

61628 
	}
}

61629 static const 
FuncDef
 
	gstatPushFuncdef
 = {

61634 
statPush
,

61640 static void 
	$statGet
(

61641 
sqlite3_context
 *
context
,

61642 int 
argc
,

61643 
sqlite3_value
 **
argv


61647 
Stat4Accum
 *
p
 = (Stat4Accum*)
	`sqlite3_value_blob
(
argv
[0]);

61653 char *
z
;

61654 int 
i
;

61656 char *
zRet
 = 
	`sqlite3MallocZero
( (
p
->
nKeyCol
+1)*25 );

61657 if( 
zRet
==0 )

61660 
	`sqlite3_result_error_nomem
(
context
);

61664 
	`sqlite3_snprintf
(24, 
zRet
, "%llu", (
u64
)
p
->
nRow
);

61665 
z
 = 
zRet
 + 
	`sqlite3Strlen30
(zRet);

61666 for(
i
=0; i<
p
->
nKeyCol
; i++)

61669 
u64
 
nDistinct
 = 
p
->
current
.
anDLt
[
i
] + 1;

61670 
u64
 
iVal
 = (
p
->
nRow
 + 
nDistinct
 - 1) / nDistinct;

61671 
	`sqlite3_snprintf
(24, 
z
, " %llu", 
iVal
);

61672 
z
 += 
	`sqlite3Strlen30
(z);

61677 
	`sqlite3_result_text
(
context
, 
zRet
, -1, 
sqlite3_free
);

61680 (void)(
argc
);

61682 
	}
}

61683 static const 
FuncDef
 
	gstatGetFuncdef
 = {

61688 
statGet
,

61694 static void 
	$callStatGet
(
Vdbe
 *
v
, int 
regStat4
, int 
iParam
, int 
regOut
)

61703 (void)(
iParam
);

61705 
	`sqlite3VdbeAddOp4
(
v
, 35, 0, 
regStat4
, 
regOut
,

61706 (char*)&
statGetFuncdef
, (-5));

61707 
	`sqlite3VdbeChangeP5
(
v
, 1 + (0 +0));

61708 
	}
}

61714 static void 
	$analyzeOneTable
(

61715 
Parse
 *
pParse
,

61716 
Table
 *
pTab
,

61717 
Index
 *
pOnlyIdx
,

61718 int 
iStatCur
,

61719 int 
iMem
,

61720 int 
iTab


61724 
sqlite3
 *
db
 = 
pParse
->db;

61725 
Index
 *
pIdx
;

61726 int 
iIdxCur
;

61727 int 
iTabCur
;

61728 
Vdbe
 *
v
;

61729 int 
i
;

61730 int 
jZeroRows
 = -1;

61731 int 
iDb
;

61732 
u8
 
needTableCnt
 = 1;

61733 int 
regNewRowid
 = 
iMem
++;

61734 int 
regStat4
 = 
iMem
++;

61735 int 
regChng
 = 
iMem
++;

61739 int 
regTemp
 = 
iMem
++;

61740 int 
regTabname
 = 
iMem
++;

61741 int 
regIdxname
 = 
iMem
++;

61742 int 
regStat1
 = 
iMem
++;

61743 int 
regPrev
 = 
iMem
;

61745 
pParse
->
nMem
 = ((pParse->nMem)>(
iMem
)?(pParse->nMem):(iMem));

61746 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

61747 if( 
v
==0 || (
pTab
==0) )

61752 if( 
pTab
->
tnum
==0 )

61758 if( 
	`sqlite3_strlike
("sqlite_%", 
pTab
->
zName
, 0)==0 )

61765 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

61769 if( 
	`sqlite3AuthCheck
(
pParse
, 28, 
pTab
->
zName
, 0,

61770 
db
->
aDb
[
iDb
].
zName
 ) )

61781 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 0, pTab->
zName
);

61782 
iTabCur
 = 
iTab
++;

61783 
iIdxCur
 = 
iTab
++;

61784 
pParse
->
nTab
 = ((pParse->nTab)>(
iTab
)?(pParse->nTab):(iTab));

61785 
	`sqlite3OpenTable
(
pParse
, 
iTabCur
, 
iDb
, 
pTab
, 54);

61786 
	`sqlite3VdbeLoadString
(
v
, 
regTabname
, 
pTab
->
zName
);

61788 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

61791 int 
nCol
;

61792 int 
addrRewind
;

61793 int 
addrNextRow
;

61794 const char *
zIdxName
;

61795 int 
nColTest
;

61797 if( 
pOnlyIdx
 && pOnlyIdx!=
pIdx
 ) continue;

61798 if( 
pIdx
->
pPartIdxWhere
==0 ) 
needTableCnt
 = 0;

61799 if( !(((
pTab
)->
tabFlags
 & 0x20)==0) && ((
pIdx
)->
idxType
==2) )

61802 
nCol
 = 
pIdx
->
nKeyCol
;

61803 
zIdxName
 = 
pTab
->
zName
;

61804 
nColTest
 = 
nCol
 - 1;

61806 
nCol
 = 
pIdx
->
nColumn
;

61807 
zIdxName
 = 
pIdx
->
zName
;

61808 
nColTest
 = 
pIdx
->
uniqNotNull
 ? pIdx->
nKeyCol
-1 : 
nCol
-1;

61812 
	`sqlite3VdbeLoadString
(
v
, 
regIdxname
, 
zIdxName
);

61815 
pParse
->
nMem
 = ((pParse->nMem)>(
regPrev
+
nColTest
)?(pParse->nMem):(regPrev+nColTest));

61819 
	`sqlite3VdbeAddOp3
(
v
, 54, 
iIdxCur
, 
pIdx
->
tnum
, 
iDb
);

61820 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pIdx
);

61823 
	`sqlite3VdbeAddOp2
(
v
, 22, 
nCol
, 
regStat4
+1);

61824 
	`sqlite3VdbeAddOp2
(
v
, 22, 
pIdx
->
nKeyCol
, 
regStat4
+2);

61825 
	`sqlite3VdbeAddOp4
(
v
, 35, 0, 
regStat4
+1, regStat4,

61826 (char*)&
statInitFuncdef
, (-5));

61827 
	`sqlite3VdbeChangeP5
(
v
, 2+(0 +0));

61829 
addrRewind
 = 
	`sqlite3VdbeAddOp1
(
v
, 108, 
iIdxCur
);

61831 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
regChng
);

61832 
addrNextRow
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

61834 if( 
nColTest
>0 )

61837 int 
endDistinctTest
 = 
	`sqlite3VdbeMakeLabel
(
v
);

61838 int *
aGotoChng
;

61839 
aGotoChng
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(int)*
nColTest
);

61840 if( 
aGotoChng
==0 ) continue;

61842 
	`sqlite3VdbeAddOp0
(
v
, 13);

61843 
addrNextRow
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

61844 if( 
nColTest
==1 && 
pIdx
->
nKeyCol
==1 && ((pIdx)->
onError
!=0) )

61850 
	`sqlite3VdbeAddOp2
(
v
, 77, 
regPrev
, 
endDistinctTest
);

61853 for(
i
=0; i<
nColTest
; i++)

61856 char *
pColl
 = (char*)
	`sqlite3LocateCollSeq
(
pParse
, 
pIdx
->
azColl
[
i
]);

61857 
	`sqlite3VdbeAddOp2
(
v
, 22, 
i
, 
regChng
);

61858 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iIdxCur
, 
i
, 
regTemp
);

61859 
aGotoChng
[
i
] =

61860 
	`sqlite3VdbeAddOp4
(
v
, 78, 
regTemp
, 0, 
regPrev
+
i
, 
pColl
, (-4));

61861 
	`sqlite3VdbeChangeP5
(
v
, 0x80);

61864 
	`sqlite3VdbeAddOp2
(
v
, 22, 
nColTest
, 
regChng
);

61865 
	`sqlite3VdbeGoto
(
v
, 
endDistinctTest
);

61867 
	`sqlite3VdbeJumpHere
(
v
, 
addrNextRow
-1);

61868 for(
i
=0; i<
nColTest
; i++)

61871 
	`sqlite3VdbeJumpHere
(
v
, 
aGotoChng
[
i
]);

61872 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iIdxCur
, 
i
, 
regPrev
+i);

61874 
	`sqlite3VdbeResolveLabel
(
v
, 
endDistinctTest
);

61875 
	`sqlite3DbFree
(
db
, 
aGotoChng
);

61879 
	`sqlite3VdbeAddOp4
(
v
, 35, 1, 
regStat4
, 
regTemp
,

61880 (char*)&
statPushFuncdef
, (-5));

61881 
	`sqlite3VdbeChangeP5
(
v
, 2+(0 +0));

61882 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iIdxCur
, 
addrNextRow
); ;

61885 
	`callStatGet
(
v
, 
regStat4
, 0, 
regStat1
);

61887 
	`sqlite3VdbeAddOp4
(
v
, 49, 
regTabname
, 3, 
regTemp
, "BBB", 0);

61888 
	`sqlite3VdbeAddOp2
(
v
, 74, 
iStatCur
, 
regNewRowid
);

61889 
	`sqlite3VdbeAddOp3
(
v
, 75, 
iStatCur
, 
regTemp
, 
regNewRowid
);

61890 
	`sqlite3VdbeChangeP5
(
v
, 0x08);

61892 
	`sqlite3VdbeJumpHere
(
v
, 
addrRewind
);

61899 if( 
pOnlyIdx
==0 && 
needTableCnt
 )

61903 
	`sqlite3VdbeAddOp2
(
v
, 50, 
iTabCur
, 
regStat1
);

61904 
jZeroRows
 = 
	`sqlite3VdbeAddOp1
(
v
, 46, 
regStat1
); ;

61905 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regIdxname
);

61907 
	`sqlite3VdbeAddOp4
(
v
, 49, 
regTabname
, 3, 
regTemp
, "BBB", 0);

61908 
	`sqlite3VdbeAddOp2
(
v
, 74, 
iStatCur
, 
regNewRowid
);

61909 
	`sqlite3VdbeAddOp3
(
v
, 75, 
iStatCur
, 
regTemp
, 
regNewRowid
);

61910 
	`sqlite3VdbeChangeP5
(
v
, 0x08);

61911 
	`sqlite3VdbeJumpHere
(
v
, 
jZeroRows
);

61913 
	}
}

61920 static void 
	$loadAnalysis
(
Parse
 *
pParse
, int 
iDb
)

61923 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

61924 if( 
v
 )

61927 
	`sqlite3VdbeAddOp1
(
v
, 124, 
iDb
);

61929 
	}
}

61934 static void 
	$analyzeDatabase
(
Parse
 *
pParse
, int 
iDb
)

61937 
sqlite3
 *
db
 = 
pParse
->db;

61938 
Schema
 *
pSchema
 = 
db
->
aDb
[
iDb
].pSchema;

61939 
HashElem
 *
k
;

61940 int 
iStatCur
;

61941 int 
iMem
;

61942 int 
iTab
;

61944 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

61945 
iStatCur
 = 
pParse
->
nTab
;

61946 
pParse
->
nTab
 += 3;

61947 
	`openStatTable
(
pParse
, 
iDb
, 
iStatCur
, 0, 0);

61948 
iMem
 = 
pParse
->
nMem
+1;

61949 
iTab
 = 
pParse
->
nTab
;

61951 for(
k
=((&
pSchema
->
tblHash
)->
first
); k; k=((k)->
next
))

61954 
Table
 *
pTab
 = (Table*)((
k
)->
data
);

61955 
	`analyzeOneTable
(
pParse
, 
pTab
, 0, 
iStatCur
, 
iMem
, 
iTab
);

61957 
	`loadAnalysis
(
pParse
, 
iDb
);

61958 
	}
}

61965 static void 
	$analyzeTable
(
Parse
 *
pParse
, 
Table
 *
pTab
, 
Index
 *
pOnlyIdx
)

61968 int 
iDb
;

61969 int 
iStatCur
;

61973 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

61974 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

61975 
iStatCur
 = 
pParse
->
nTab
;

61976 
pParse
->
nTab
 += 3;

61977 if( 
pOnlyIdx
 )

61980 
	`openStatTable
(
pParse
, 
iDb
, 
iStatCur
, 
pOnlyIdx
->
zName
, "idx");

61982 
	`openStatTable
(
pParse
, 
iDb
, 
iStatCur
, 
pTab
->
zName
, "tbl");

61984 
	`analyzeOneTable
(
pParse
, 
pTab
, 
pOnlyIdx
, 
iStatCur
,pParse->
nMem
+1,pParse->
nTab
);

61985 
	`loadAnalysis
(
pParse
, 
iDb
);

61986 
	}
}

61988 static void 
	$sqlite3Analyze
(
Parse
 *
pParse
, 
Token
 *
pName1
, Token *
pName2
)

61991 
sqlite3
 *
db
 = 
pParse
->db;

61992 int 
iDb
;

61993 int 
i
;

61994 char *
z
, *
zDb
;

61995 
Table
 *
pTab
;

61996 
Index
 *
pIdx
;

61997 
Token
 *
pTableName
;

61998 
Vdbe
 *
v
;

62003 if( 0!=
	`sqlite3ReadSchema
(
pParse
) )

62010 if( 
pName1
==0 )

62014 for(
i
=0; i<
db
->
nDb
; i++)

62017 if( 
i
==1 ) continue;

62018 
	`analyzeDatabase
(
pParse
, 
i
);

62020 }else if( 
pName2
->
n
==0 )

62024 
iDb
 = 
	`sqlite3FindDb
(
db
, 
pName1
);

62025 if( 
iDb
>=0 )

62028 
	`analyzeDatabase
(
pParse
, 
iDb
);

62030 
z
 = 
	`sqlite3NameFromToken
(
db
, 
pName1
);

62031 if( 
z
 )

62034 if( (
pIdx
 = 
	`sqlite3FindIndex
(
db
, 
z
, 0))!=0 )

62037 
	`analyzeTable
(
pParse
, 
pIdx
->
pTable
, pIdx);

62038 }else if( (
pTab
 = 
	`sqlite3LocateTable
(
pParse
, 0, 
z
, 0))!=0 )

62041 
	`analyzeTable
(
pParse
, 
pTab
, 0);

62043 
	`sqlite3DbFree
(
db
, 
z
);

62048 
iDb
 = 
	`sqlite3TwoPartName
(
pParse
, 
pName1
, 
pName2
, &
pTableName
);

62049 if( 
iDb
>=0 )

62052 
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

62053 
z
 = 
	`sqlite3NameFromToken
(
db
, 
pTableName
);

62054 if( 
z
 )

62057 if( (
pIdx
 = 
	`sqlite3FindIndex
(
db
, 
z
, 
zDb
))!=0 )

62060 
	`analyzeTable
(
pParse
, 
pIdx
->
pTable
, pIdx);

62061 }else if( (
pTab
 = 
	`sqlite3LocateTable
(
pParse
, 0, 
z
, 
zDb
))!=0 )

62064 
	`analyzeTable
(
pParse
, 
pTab
, 0);

62066 
	`sqlite3DbFree
(
db
, 
z
);

62070 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

62071 if( 
v
 ) 
	`sqlite3VdbeAddOp0
(v, 147);

62072 
	}
}

62078 typedef struct 
analysisInfo
 
	tanalysisInfo
;

62079 struct 
	sanalysisInfo
 {

62080 
sqlite3
 *
	mdb
;

62081 const char *
	mzDatabase
;

62089 static void 
	$decodeIntArray
(

62090 char *
zIntArray
,

62091 int 
nOut
,

62092 
tRowcnt
 *
aOut
,

62093 
LogEst
 *
aLog
,

62094 
Index
 *
pIndex


62098 char *
z
 = 
zIntArray
;

62099 int 
c
;

62100 int 
i
;

62101 
tRowcnt
 
v
;

62108 for(
i
=0; *
z
 && i<
nOut
; i++)

62111 
v
 = 0;

62112 while( (
c
=
z
[0])>='0' && c<='9' )

62115 
v
 = v*10 + 
c
 - '0';

62116 
z
++;

62123 (void)(
aOut
);

62125 
aLog
[
i
] = 
	`sqlite3LogEst
(
v
);

62127 if( *
z
==' ' ) z++;

62134 
pIndex
->
bUnordered
 = 0;

62135 
pIndex
->
noSkipScan
 = 0;

62136 while( 
z
[0] )

62139 if( 
	`sqlite3_strglob
("unordered*", 
z
)==0 )

62142 
pIndex
->
bUnordered
 = 1;

62143 }else if( 
	`sqlite3_strglob
("sz=[0-9]*", 
z
)==0 )

62146 
pIndex
->
szIdxRow
 = 
	`sqlite3LogEst
(
	`sqlite3Atoi
(
z
+3));

62147 }else if( 
	`sqlite3_strglob
("noskipscan*", 
z
)==0 )

62150 
pIndex
->
noSkipScan
 = 1;

62157 while( 
z
[0]!=0 && z[0]!=' ' ) z++;

62158 while( 
z
[0]==' ' ) z++;

62161 
	}
}

62163 static int 
	$analysisLoader
(void *
pData
, int 
argc
, char **
argv
, char **
NotUsed
)

62166 
analysisInfo
 *
pInfo
 = (analysisInfo*)
pData
;

62167 
Index
 *
pIndex
;

62168 
Table
 *
pTable
;

62169 const char *
z
;

62172 (void)(
NotUsed
),(void)(
argc
);

62174 if( 
argv
==0 || argv[0]==0 || argv[2]==0 )

62179 
pTable
 = 
	`sqlite3FindTable
(
pInfo
->
db
, 
argv
[0], pInfo->
zDatabase
);

62180 if( 
pTable
==0 )

62185 if( 
argv
[1]==0 )

62188 
pIndex
 = 0;

62189 }else if( 
	`sqlite3_stricmp
(
argv
[0],argv[1])==0 )

62192 
pIndex
 = 
	`sqlite3PrimaryKeyIndex
(
pTable
);

62194 
pIndex
 = 
	`sqlite3FindIndex
(
pInfo
->
db
, 
argv
[1], pInfo->
zDatabase
);

62196 
z
 = 
argv
[2];

62198 if( 
pIndex
 )

62201 
tRowcnt
 *
aiRowEst
 = 0;

62202 int 
nCol
 = 
pIndex
->
nKeyCol
+1;

62204 
pIndex
->
bUnordered
 = 0;

62205 
	`decodeIntArray
((char*)
z
, 
nCol
, 
aiRowEst
, 
pIndex
->
aiRowLogEst
, pIndex);

62206 if( 
pIndex
->
pPartIdxWhere
==0 ) 
pTable
->
nRowLogEst
 = pIndex->
aiRowLogEst
[0];

62208 
Index
 
fakeIdx
;

62209 
fakeIdx
.
szIdxRow
 = 
pTable
->
szTabRow
;

62213 
	`decodeIntArray
((char*)
z
, 1, 0, &
pTable
->
nRowLogEst
, &
fakeIdx
);

62214 
pTable
->
szTabRow
 = 
fakeIdx
.
szIdxRow
;

62218 
	}
}

62224 static void 
	$sqlite3DeleteIndexSamples
(
sqlite3
 *
db
, 
Index
 *
pIdx
)

62228 (void)(
db
);

62229 (void)(
pIdx
);

62231 
	}
}

62233 static int 
	$sqlite3AnalysisLoad
(
sqlite3
 *
db
, int 
iDb
)

62236 
analysisInfo
 
sInfo
;

62237 
HashElem
 *
i
;

62238 char *
zSql
;

62239 int 
rc
;

62246 for(
i
=((&
db
->
aDb
[
iDb
].
pSchema
->
idxHash
)->
first
);i;i=((i)->
next
))

62249 
Index
 *
pIdx
 = ((
i
)->
data
);

62250 
	`sqlite3DefaultRowEst
(
pIdx
);

62258 
sInfo
.
db
 = db;

62259 
sInfo
.
zDatabase
 = 
db
->
aDb
[
iDb
].
zName
;

62260 if( 
	`sqlite3FindTable
(
db
, "sqlite_stat1", 
sInfo
.
zDatabase
)==0 )

62267 
zSql
 = 
	`sqlite3MPrintf
(
db
,

62268 "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", 
sInfo
.
zDatabase
);

62269 if( 
zSql
==0 )

62272 
rc
 = 7;

62274 
rc
 = 
	`sqlite3_exec
(
db
, 
zSql
, 
analysisLoader
, &
sInfo
, 0);

62275 
	`sqlite3DbFree
(
db
, 
zSql
);

62278 if( 
rc
==7 )

62281 
	`sqlite3OomFault
(
db
);

62283 return 
rc
;

62284 
	}
}

62286 static int 
	$resolveAttachExpr
(
NameContext
 *
pName
, 
Expr
 *
pExpr
)

62288 int 
rc
 = 0;

62289 if( 
pExpr
 )

62292 if( 
pExpr
->
op
!=27 )

62295 
rc
 = 
	`sqlite3ResolveExprNames
(
pName
, 
pExpr
);

62297 
pExpr
->
op
 = 97;

62300 return 
rc
;

62301 
	}
}

62303 static void 
	$attachFunc
(

62304 
sqlite3_context
 *
context
,

62305 int 
NotUsed
,

62306 
sqlite3_value
 **
argv


62310 int 
i
;

62311 int 
rc
 = 0;

62312 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

62313 const char *
zName
;

62314 const char *
zFile
;

62315 char *
zPath
 = 0;

62316 char *
zErr
 = 0;

62317 unsigned int 
flags
;

62318 
Db
 *
aNew
;

62319 char *
zErrDyn
 = 0;

62320 
sqlite3_vfs
 *
pVfs
;

62322 (void)(
NotUsed
);

62324 
zFile
 = (const char *)
	`sqlite3_value_text
(
argv
[0]);

62325 
zName
 = (const char *)
	`sqlite3_value_text
(
argv
[1]);

62326 if( 
zFile
==0 ) zFile = "";

62327 if( 
zName
==0 ) zName = "";

62335 if( 
db
->
nDb
>=db->
aLimit
[7]+2 )

62338 
zErrDyn
 = 
	`sqlite3MPrintf
(
db
, "too many attached databases - max %d",

62339 
db
->
aLimit
[7]

62341 goto 
attach_error
;

62343 if( !
db
->
autoCommit
 )

62346 
zErrDyn
 = 
	`sqlite3MPrintf
(
db
, "cannot ATTACH database within transaction");

62347 goto 
attach_error
;

62349 for(
i
=0; i<
db
->
nDb
; i++)

62352 char *
z
 = 
db
->
aDb
[
i
].
zName
;

62354 if( 
	`sqlite3StrICmp
(
z
, 
zName
)==0 )

62357 
zErrDyn
 = 
	`sqlite3MPrintf
(
db
, "database %s is already in use", 
zName
);

62358 goto 
attach_error
;

62365 if( 
db
->
aDb
==db->
aDbStatic
 )

62368 
aNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(db->
aDb
[0])*3 );

62369 if( 
aNew
==0 ) return;

62370 
	`memcpy
(
aNew
, 
db
->
aDb
, sizeof(db->aDb[0])*2);

62372 
aNew
 = 
	`sqlite3DbRealloc
(
db
, db->
aDb
, sizeof(db->aDb[0])*(db->
nDb
+1) );

62373 if( 
aNew
==0 ) return;

62375 
db
->
aDb
 = 
aNew
;

62376 
aNew
 = &
db
->
aDb
[db->
nDb
];

62377 
	`memset
(
aNew
, 0, sizeof(*aNew));

62383 
flags
 = 
db
->
openFlags
;

62384 
rc
 = 
	`sqlite3ParseUri
(
db
->
pVfs
->
zName
, 
zFile
, &
flags
, &pVfs, &
zPath
, &
zErr
);

62385 if( 
rc
!=0 )

62388 if( 
rc
==7 ) 
	`sqlite3OomFault
(
db
);

62389 
	`sqlite3_result_error
(
context
, 
zErr
, -1);

62390 
	`sqlite3_free
(
zErr
);

62394 
flags
 |= 0x00000100;

62395 
rc
 = 
	`sqlite3BtreeOpen
(
pVfs
, 
zPath
, 
db
, &
aNew
->
pBt
, 0, 
flags
);

62396 
	`sqlite3_free
( 
zPath
 );

62397 
db
->
nDb
++;

62398 if( 
rc
==19 )

62401 
rc
 = 1;

62402 
zErrDyn
 = 
	`sqlite3MPrintf
(
db
, "database is already attached");

62403 }else if( 
rc
==0 )

62406 
Pager
 *
pPager
;

62407 
aNew
->
pSchema
 = 
	`sqlite3SchemaGet
(
db
, aNew->
pBt
);

62408 if( !
aNew
->
pSchema
 )

62411 
rc
 = 7;

62412 }else if( 
aNew
->
pSchema
->
file_format
 && aNew->pSchema->
enc
!=((
db
)->enc) )

62415 
zErrDyn
 = 
	`sqlite3MPrintf
(
db
,

62417 
rc
 = 1;

62419 
	`sqlite3BtreeEnter
(
aNew
->
pBt
);

62420 
pPager
 = 
	`sqlite3BtreePager
(
aNew
->
pBt
);

62421 
	`sqlite3PagerLockingMode
(
pPager
, 
db
->
dfltLockMode
);

62422 
	`sqlite3BtreeSecureDelete
(
aNew
->
pBt
,

62423 
	`sqlite3BtreeSecureDelete
(
db
->
aDb
[0].
pBt
,-1) );

62425 
	`sqlite3BtreeSetPagerFlags
(
aNew
->
pBt
,

62426 0x03 | (
db
->
flags
 & 0x38));

62428 
	`sqlite3BtreeLeave
(
aNew
->
pBt
);

62430 
aNew
->
safety_level
 = (0x03 -1)+1;

62431 
aNew
->
zName
 = 
	`sqlite3DbStrDup
(
db
, zName);

62432 if( 
rc
==0 && 
aNew
->
zName
==0 )

62435 
rc
 = 7;

62438 if( 
rc
==0 )

62441 
	`sqlite3BtreeEnterAll
(
db
);

62442 
rc
 = 
	`sqlite3Init
(
db
, &
zErrDyn
);

62443 
	`sqlite3BtreeLeaveAll
(
db
);

62446 if( 
rc
 )

62449 int 
iDb
 = 
db
->
nDb
 - 1;

62451 if( 
db
->
aDb
[
iDb
].
pBt
 )

62454 
	`sqlite3BtreeClose
(
db
->
aDb
[
iDb
].
pBt
);

62455 
db
->
aDb
[
iDb
].
pBt
 = 0;

62456 
db
->
aDb
[
iDb
].
pSchema
 = 0;

62458 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

62459 
db
->
nDb
 = 
iDb
;

62460 if( 
rc
==7 || rc==(10 | (12<<8)) )

62463 
	`sqlite3OomFault
(
db
);

62464 
	`sqlite3DbFree
(
db
, 
zErrDyn
);

62465 
zErrDyn
 = 
	`sqlite3MPrintf
(
db
, "out of memory");

62466 }else if( 
zErrDyn
==0 )

62469 
zErrDyn
 = 
	`sqlite3MPrintf
(
db
, "unable to open database: %s", 
zFile
);

62471 goto 
attach_error
;

62476 
attach_error
:

62478 if( 
zErrDyn
 )

62481 
	`sqlite3_result_error
(
context
, 
zErrDyn
, -1);

62482 
	`sqlite3DbFree
(
db
, 
zErrDyn
);

62484 if( 
rc
 ) 
	`sqlite3_result_error_code
(
context
, rc);

62485 
	}
}

62487 static void 
	$detachFunc
(

62488 
sqlite3_context
 *
context
,

62489 int 
NotUsed
,

62490 
sqlite3_value
 **
argv


62494 const char *
zName
 = (const char *)
	`sqlite3_value_text
(
argv
[0]);

62495 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

62496 int 
i
;

62497 
Db
 *
pDb
 = 0;

62498 char 
zErr
[128];

62500 (void)(
NotUsed
);

62502 if( 
zName
==0 ) zName = "";

62503 for(
i
=0; i<
db
->
nDb
; i++)

62506 
pDb
 = &
db
->
aDb
[
i
];

62507 if( 
pDb
->
pBt
==0 ) continue;

62508 if( 
	`sqlite3StrICmp
(
pDb
->
zName
, zName)==0 ) break;

62511 if( 
i
>=
db
->
nDb
 )

62514 
	`sqlite3_snprintf
(sizeof(
zErr
),zErr, "no such database: %s", 
zName
);

62515 goto 
detach_error
;

62517 if( 
i
<2 )

62520 
	`sqlite3_snprintf
(sizeof(
zErr
),zErr, "cannot detach database %s", 
zName
);

62521 goto 
detach_error
;

62523 if( !
db
->
autoCommit
 )

62526 
	`sqlite3_snprintf
(sizeof(
zErr
), zErr,

62528 goto 
detach_error
;

62530 if( 
	`sqlite3BtreeIsInReadTrans
(
pDb
->
pBt
) || 
	`sqlite3BtreeIsInBackup
(pDb->pBt) )

62533 
	`sqlite3_snprintf
(sizeof(
zErr
),zErr, "database %s is locked", 
zName
);

62534 goto 
detach_error
;

62537 
	`sqlite3BtreeClose
(
pDb
->
pBt
);

62538 
pDb
->
pBt
 = 0;

62539 
pDb
->
pSchema
 = 0;

62540 
	`sqlite3CollapseDatabaseArray
(
db
);

62543 
detach_error
:

62544 
	`sqlite3_result_error
(
context
, 
zErr
, -1);

62545 
	}
}

62551 static void 
	$codeAttach
(

62552 
Parse
 *
pParse
,

62553 int 
type
,

62554 
FuncDef
 const *
pFunc
,

62555 
Expr
 *
pAuthArg
,

62556 
Expr
 *
pFilename
,

62557 
Expr
 *
pDbname
,

62558 
Expr
 *
pKey


62562 int 
rc
;

62563 
NameContext
 
sName
;

62564 
Vdbe
 *
v
;

62565 
sqlite3
* 
db
 = 
pParse
->db;

62566 int 
regArgs
;

62568 
	`memset
(&
sName
, 0, sizeof(
NameContext
));

62569 
sName
.
pParse
 = pParse;

62572 0!=(
rc
 = 
	`resolveAttachExpr
(&
sName
, 
pFilename
)) ||

62573 0!=(
rc
 = 
	`resolveAttachExpr
(&
sName
, 
pDbname
)) ||

62574 0!=(
rc
 = 
	`resolveAttachExpr
(&
sName
, 
pKey
))

62578 goto 
attach_end
;

62582 if( 
pAuthArg
 )

62585 char *
zAuthArg
;

62586 if( 
pAuthArg
->
op
==97 )

62589 
zAuthArg
 = 
pAuthArg
->
u
.
zToken
;

62591 
zAuthArg
 = 0;

62593 
rc
 = 
	`sqlite3AuthCheck
(
pParse
, 
type
, 
zAuthArg
, 0, 0);

62594 if(
rc
!=0 )

62597 goto 
attach_end
;

62603 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

62604 
regArgs
 = 
	`sqlite3GetTempRange
(
pParse
, 4);

62605 
	`sqlite3ExprCode
(
pParse
, 
pFilename
, 
regArgs
);

62606 
	`sqlite3ExprCode
(
pParse
, 
pDbname
, 
regArgs
+1);

62607 
	`sqlite3ExprCode
(
pParse
, 
pKey
, 
regArgs
+2);

62610 if( 
v
 )

62613 
	`sqlite3VdbeAddOp4
(
v
, 35, 0, 
regArgs
+3-
pFunc
->
nArg
, regArgs+3,

62614 (char *)
pFunc
, (-5));

62616 
	`sqlite3VdbeChangeP5
(
v
, (
u8
)(
pFunc
->
nArg
));

62622 
	`sqlite3VdbeAddOp1
(
v
, 147, (
type
==24));

62625 
attach_end
:

62626 
	`sqlite3ExprDelete
(
db
, 
pFilename
);

62627 
	`sqlite3ExprDelete
(
db
, 
pDbname
);

62628 
	`sqlite3ExprDelete
(
db
, 
pKey
);

62629 
	}
}

62636 static void 
	$sqlite3Detach
(
Parse
 *
pParse
, 
Expr
 *
pDbname
)

62639 static const 
FuncDef
 
detach_func
 = {

62644 
detachFunc
,

62649 
	`codeAttach
(
pParse
, 25, &
detach_func
, 
pDbname
, 0, 0, pDbname);

62650 
	}
}

62657 static void 
	$sqlite3Attach
(
Parse
 *
pParse
, 
Expr
 *
p
, Expr *
pDbname
, Expr *
pKey
)

62660 static const 
FuncDef
 
attach_func
 = {

62665 
attachFunc
,

62670 
	`codeAttach
(
pParse
, 24, &
attach_func
, 
p
, p, 
pDbname
, 
pKey
);

62671 
	}
}

62678 static void 
	$sqlite3FixInit
(

62679 
DbFixer
 *
pFix
,

62680 
Parse
 *
pParse
,

62681 int 
iDb
,

62682 const char *
zType
,

62683 const 
Token
 *
pName


62687 
sqlite3
 *
db
;

62689 
db
 = 
pParse
->db;

62691 
pFix
->
pParse
 = pParse;

62692 
pFix
->
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

62693 
pFix
->
pSchema
 = 
db
->
aDb
[
iDb
].pSchema;

62694 
pFix
->
zType
 = zType;

62695 
pFix
->
pName
 = pName;

62696 
pFix
->
bVarOnly
 = (
iDb
==1);

62697 
	}
}

62699 static int 
	$sqlite3FixSrcList
(

62700 
DbFixer
 *
pFix
,

62701 
SrcList
 *
pList


62705 int 
i
;

62706 const char *
zDb
;

62707 struct 
SrcList_item
 *
pItem
;

62709 if( (
pList
==0) ) return 0;

62710 
zDb
 = 
pFix
->zDb;

62711 for(
i
=0, 
pItem
=
pList
->
a
; i<pList->
nSrc
; i++, pItem++)

62714 if( 
pFix
->
bVarOnly
==0 )

62717 if( 
pItem
->
zDatabase
 && 
	`sqlite3StrICmp
(pItem->zDatabase, 
zDb
) )

62720 
	`sqlite3ErrorMsg
(
pFix
->
pParse
,

62722 
pFix
->
zType
, pFix->
pName
, 
pItem
->
zDatabase
);

62725 
	`sqlite3DbFree
(
pFix
->
pParse
->
db
, 
pItem
->
zDatabase
);

62726 
pItem
->
zDatabase
 = 0;

62727 
pItem
->
pSchema
 = 
pFix
->pSchema;

62730 if( 
	`sqlite3FixSelect
(
pFix
, 
pItem
->
pSelect
) ) return 1;

62731 if( 
	`sqlite3FixExpr
(
pFix
, 
pItem
->
pOn
) ) return 1;

62735 
	}
}

62737 static int 
	$sqlite3FixSelect
(

62738 
DbFixer
 *
pFix
,

62739 
Select
 *
pSelect


62743 while( 
pSelect
 )

62746 if( 
	`sqlite3FixExprList
(
pFix
, 
pSelect
->
pEList
) )

62751 if( 
	`sqlite3FixSrcList
(
pFix
, 
pSelect
->
pSrc
) )

62756 if( 
	`sqlite3FixExpr
(
pFix
, 
pSelect
->
pWhere
) )

62761 if( 
	`sqlite3FixExprList
(
pFix
, 
pSelect
->
pGroupBy
) )

62766 if( 
	`sqlite3FixExpr
(
pFix
, 
pSelect
->
pHaving
) )

62771 if( 
	`sqlite3FixExprList
(
pFix
, 
pSelect
->
pOrderBy
) )

62776 if( 
	`sqlite3FixExpr
(
pFix
, 
pSelect
->
pLimit
) )

62781 if( 
	`sqlite3FixExpr
(
pFix
, 
pSelect
->
pOffset
) )

62786 
pSelect
 = pSelect->
pPrior
;

62789 
	}
}

62790 static int 
	$sqlite3FixExpr
(

62791 
DbFixer
 *
pFix
,

62792 
Expr
 *
pExpr


62796 while( 
pExpr
 )

62799 if( 
pExpr
->
op
==135 )

62802 if( 
pFix
->
pParse
->
db
->
init
.
busy
 )

62805 
pExpr
->
op
 = 101;

62807 
	`sqlite3ErrorMsg
(
pFix
->
pParse
, "%s cannot use variables", pFix->
zType
);

62811 if( (((
pExpr
)->
flags
&(0x004000))!=0) ) break;

62812 if( (((
pExpr
)->
flags
&(0x000800))!=0) )

62815 if( 
	`sqlite3FixSelect
(
pFix
, 
pExpr
->
x
.
pSelect
) ) return 1;

62817 if( 
	`sqlite3FixExprList
(
pFix
, 
pExpr
->
x
.
pList
) ) return 1;

62819 if( 
	`sqlite3FixExpr
(
pFix
, 
pExpr
->
pRight
) )

62824 
pExpr
 = pExpr->
pLeft
;

62827 
	}
}

62828 static int 
	$sqlite3FixExprList
(

62829 
DbFixer
 *
pFix
,

62830 
ExprList
 *
pList


62834 int 
i
;

62835 struct 
ExprList_item
 *
pItem
;

62836 if( 
pList
==0 ) return 0;

62837 for(
i
=0, 
pItem
=
pList
->
a
; i<pList->
nExpr
; i++, pItem++)

62840 if( 
	`sqlite3FixExpr
(
pFix
, 
pItem
->
pExpr
) )

62847 
	}
}

62851 static int 
	$sqlite3FixTriggerStep
(

62852 
DbFixer
 *
pFix
,

62853 
TriggerStep
 *
pStep


62857 while( 
pStep
 )

62860 if( 
	`sqlite3FixSelect
(
pFix
, 
pStep
->
pSelect
) )

62865 if( 
	`sqlite3FixExpr
(
pFix
, 
pStep
->
pWhere
) )

62870 if( 
	`sqlite3FixExprList
(
pFix
, 
pStep
->
pExprList
) )

62875 
pStep
 = pStep->
pNext
;

62878 
	}
}

62880 int 
sqlite3_set_authorizer
(

62881 
sqlite3
 *
db
,

62882 int (*
xAuth
)(void*,int,const char*,const char*,const char*,const char*),

62883 void *
pArg


62890 
	`sqlite3_mutex_enter
(
db
->
mutex
);

62891 
db
->
xAuth
 = (
sqlite3_xauth
)xAuth;

62892 
db
->
pAuthArg
 = 
pArg
;

62893 
	`sqlite3ExpirePreparedStatements
(
db
);

62894 
	`sqlite3_mutex_leave
(
db
->
mutex
);

62896 
	}
}

62902 static void 
	$sqliteAuthBadReturnCode
(
Parse
 *
pParse
)

62905 
	`sqlite3ErrorMsg
(
pParse
, "authorizer malfunction");

62906 
pParse
->
rc
 = 1;

62907 
	}
}

62909 static int 
	$sqlite3AuthReadCol
(

62910 
Parse
 *
pParse
,

62911 const char *
zTab
,

62912 const char *
zCol
,

62913 int 
iDb


62917 
sqlite3
 *
db
 = 
pParse
->db;

62918 char *
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

62919 int 
rc
;

62921 
rc
 = 
db
->
	`xAuth
(db->
pAuthArg
, 20, 
zTab
,
zCol
,
zDb
,
pParse
->
zAuthContext


62926 if( 
rc
==1 )

62929 if( 
db
->
nDb
>2 || 
iDb
!=0 )

62932 
	`sqlite3ErrorMsg
(
pParse
, "access to %s.%s.%s is prohibited",
zDb
,
zTab
,
zCol
);

62934 
	`sqlite3ErrorMsg
(
pParse
, "access to %s.%s is prohibited", 
zTab
, 
zCol
);

62936 
pParse
->
rc
 = 23;

62937 }else if( 
rc
!=2 && rc!=0 )

62940 
	`sqliteAuthBadReturnCode
(
pParse
);

62942 return 
rc
;

62943 
	}
}

62945 static void 
	$sqlite3AuthRead
(

62946 
Parse
 *
pParse
,

62947 
Expr
 *
pExpr
,

62948 
Schema
 *
pSchema
,

62949 
SrcList
 *
pTabList


62953 
sqlite3
 *
db
 = 
pParse
->db;

62954 
Table
 *
pTab
 = 0;

62955 const char *
zCol
;

62956 int 
iSrc
;

62957 int 
iDb
;

62958 int 
iCol
;

62960 if( 
db
->
xAuth
==0 ) return;

62961 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pSchema
);

62962 if( 
iDb
<0 )

62971 if( 
pExpr
->
op
==62 )

62974 
pTab
 = 
pParse
->
pTriggerTab
;

62977 for(
iSrc
=0; (iSrc<
pTabList
->
nSrc
); iSrc++)

62980 if( 
pExpr
->
iTable
==
pTabList
->
a
[
iSrc
].
iCursor
 )

62983 
pTab
 = 
pTabList
->
a
[
iSrc
].pTab;

62988 
iCol
 = 
pExpr
->
iColumn
;

62989 if( (
pTab
==0) ) return;

62991 if( 
iCol
>=0 )

62995 
zCol
 = 
pTab
->
aCol
[
iCol
].
zName
;

62996 }else if( 
pTab
->
iPKey
>=0 )

63000 
zCol
 = 
pTab
->
aCol
[pTab->
iPKey
].
zName
;

63002 
zCol
 = "ROWID";

63005 if( 2==
	`sqlite3AuthReadCol
(
pParse
, 
pTab
->
zName
, 
zCol
, 
iDb
) )

63008 
pExpr
->
op
 = 101;

63010 
	}
}

63018 static int 
	$sqlite3AuthCheck
(

63019 
Parse
 *
pParse
,

63020 int 
code
,

63021 const char *
zArg1
,

63022 const char *
zArg2
,

63023 const char *
zArg3


63027 
sqlite3
 *
db
 = 
pParse
->db;

63028 int 
rc
;

63033 if( 
db
->
init
.
busy
 || (
pParse
->
declareVtab
) )

63039 if( 
db
->
xAuth
==0 )

63044 
rc
 = 
db
->
	`xAuth
(db->
pAuthArg
, 
code
, 
zArg1
, 
zArg2
, 
zArg3
, 
pParse
->
zAuthContext


63049 if( 
rc
==1 )

63052 
	`sqlite3ErrorMsg
(
pParse
, "not authorized");

63053 
pParse
->
rc
 = 23;

63054 }else if( 
rc
!=0 && rc!=2 )

63057 
rc
 = 1;

63058 
	`sqliteAuthBadReturnCode
(
pParse
);

63060 return 
rc
;

63061 
	}
}

63068 static void 
	$sqlite3AuthContextPush
(

63069 
Parse
 *
pParse
,

63070 
AuthContext
 *
pContext
,

63071 const char *
zContext


63076 
pContext
->
pParse
 = pParse;

63077 
pContext
->
zAuthContext
 = 
pParse
->zAuthContext;

63078 
pParse
->
zAuthContext
 = 
zContext
;

63079 
	}
}

63085 static void 
	$sqlite3AuthContextPop
(
AuthContext
 *
pContext
)

63088 if( 
pContext
->
pParse
 )

63091 
pContext
->
pParse
->
zAuthContext
 = pContext->zAuthContext;

63092 
pContext
->
pParse
 = 0;

63094 
	}
}

63096 struct 
	sTableLock
 {

63097 int 
	miDb
;

63098 int 
	miTab
;

63099 
u8
 
	misWriteLock
;

63100 const char *
	mzName
;

63103 static void 
	$sqlite3TableLock
(

63104 
Parse
 *
pParse
,

63105 int 
iDb
,

63106 int 
iTab
,

63107 
u8
 
isWriteLock
,

63108 const char *
zName


63112 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

63113 int 
i
;

63114 int 
nBytes
;

63115 
TableLock
 *
p
;

63118 for(
i
=0; i<
pToplevel
->
nTableLock
; i++)

63121 
p
 = &
pToplevel
->
aTableLock
[
i
];

63122 if( 
p
->
iDb
==iDb && p->
iTab
==iTab )

63125 
p
->
isWriteLock
 = (p->isWriteLock || isWriteLock);

63130 
nBytes
 = sizeof(
TableLock
) * (
pToplevel
->
nTableLock
+1);

63131 
pToplevel
->
aTableLock
 =

63132 
	`sqlite3DbReallocOrFree
(
pToplevel
->
db
, pToplevel->
aTableLock
, 
nBytes
);

63133 if( 
pToplevel
->
aTableLock
 )

63136 
p
 = &
pToplevel
->
aTableLock
[pToplevel->
nTableLock
++];

63137 
p
->
iDb
 = iDb;

63138 
p
->
iTab
 = iTab;

63139 
p
->
isWriteLock
 = isWriteLock;

63140 
p
->
zName
 = zName;

63142 
pToplevel
->
nTableLock
 = 0;

63143 
	`sqlite3OomFault
(
pToplevel
->
db
);

63145 
	}
}

63151 static void 
	$codeTableLocks
(
Parse
 *
pParse
)

63154 int 
i
;

63155 
Vdbe
 *
pVdbe
;

63157 
pVdbe
 = 
	`sqlite3GetVdbe
(
pParse
);

63160 for(
i
=0; i<
pParse
->
nTableLock
; i++)

63163 
TableLock
 *
p
 = &
pParse
->
aTableLock
[
i
];

63164 int 
p1
 = 
p
->
iDb
;

63165 
	`sqlite3VdbeAddOp4
(
pVdbe
, 148, 
p1
, 
p
->
iTab
, p->
isWriteLock
,

63166 
p
->
zName
, (-2));

63168 
	}
}

63170 static void 
	$sqlite3FinishCoding
(
Parse
 *
pParse
)

63173 
sqlite3
 *
db
;

63174 
Vdbe
 *
v
;

63177 
db
 = 
pParse
->db;

63178 if( 
pParse
->
nested
 ) return;

63179 if( 
db
->
mallocFailed
 || 
pParse
->
nErr
 )

63182 if( 
pParse
->
rc
==0 ) pParse->rc = 1;

63189 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

63192 if( 
v
 )

63195 while( 
	`sqlite3VdbeDeletePriorOpcode
(
v
, 61) )

63198 
	`sqlite3VdbeAddOp0
(
v
, 21);

63200 if( 
db
->
mallocFailed
==0

63201 && ((
pParse
->
cookieMask
)!=0 || pParse->
pConstExpr
)

63205 int 
iDb
, 
i
;

63207 
	`sqlite3VdbeJumpHere
(
v
, 0);

63208 for(
iDb
=0; iDb<
db
->
nDb
; iDb++)

63211 if( (((
pParse
->
cookieMask
)&(((
yDbMask
)1)<<(
iDb
)))!=0)==0 ) continue;

63212 
	`sqlite3VdbeUsesBtree
(
v
, 
iDb
);

63213 
	`sqlite3VdbeAddOp4Int
(
v
,

63215 
iDb
,

63216 (((
pParse
->
writeMask
)&(((
yDbMask
)1)<<(
iDb
)))!=0),

63217 
pParse
->
cookieValue
[
iDb
],

63218 
db
->
aDb
[
iDb
].
pSchema
->
iGeneration


63220 if( 
db
->
init
.
busy
==0 ) 
	`sqlite3VdbeChangeP5
(
v
, 1);

63225 for(
i
=0; i<
pParse
->
nVtabLock
; i++)

63228 char *
vtab
 = (char *)
	`sqlite3GetVTable
(
db
, 
pParse
->
apVtabLock
[
i
]);

63229 
	`sqlite3VdbeAddOp4
(
v
, 149, 0, 0, 0, 
vtab
, (-10));

63231 
pParse
->
nVtabLock
 = 0;

63238 
	`codeTableLocks
(
pParse
);

63242 
	`sqlite3AutoincrementBegin
(
pParse
);

63245 if( 
pParse
->
pConstExpr
 )

63248 
ExprList
 *
pEL
 = 
pParse
->
pConstExpr
;

63249 
pParse
->
okConstFactor
 = 0;

63250 for(
i
=0; i<
pEL
->
nExpr
; i++)

63253 
	`sqlite3ExprCode
(
pParse
, 
pEL
->
a
[
i
].
pExpr
, pEL->a[i].
u
.
iConstExprReg
);

63258 
	`sqlite3VdbeGoto
(
v
, 1);

63265 if( 
v
 && 
pParse
->
nErr
==0 && !
db
->
mallocFailed
 )

63271 if( 
pParse
->
pAinc
!=0 && pParse->
nTab
==0 ) pParse->nTab = 1;

63272 
	`sqlite3VdbeMakeReady
(
v
, 
pParse
);

63273 
pParse
->
rc
 = 101;

63275 
pParse
->
rc
 = 1;

63278 
	}
}

63280 static void 
	$sqlite3NestedParse
(
Parse
 *
pParse
, const char *
zFormat
, ...)

63283 
va_list
 
ap
;

63284 char *
zSql
;

63285 char *
zErrMsg
 = 0;

63286 
sqlite3
 *
db
 = 
pParse
->db;

63288 char 
saveBuf
[(sizeof(
Parse
) - 
	`__builtin_offsetof
 (Parse, 
nVar
))];

63290 if( 
pParse
->
nErr
 ) return;

63292 
	`__builtin_va_start
(
ap
,
zFormat
);

63293 
zSql
 = 
	`sqlite3VMPrintf
(
db
, 
zFormat
, 
ap
);

63294 
	`__builtin_va_end
(
ap
);

63295 if( 
zSql
==0 )

63300 
pParse
->
nested
++;

63301 
	`memcpy
(
saveBuf
, &
pParse
->
nVar
, (sizeof(
Parse
) - 
	`__builtin_offsetof
 (Parse, nVar)));

63302 
	`memset
(&
pParse
->
nVar
, 0, (sizeof(
Parse
) - 
	`__builtin_offsetof
 (Parse, nVar)));

63303 
	`sqlite3RunParser
(
pParse
, 
zSql
, &
zErrMsg
);

63304 
	`sqlite3DbFree
(
db
, 
zErrMsg
);

63305 
	`sqlite3DbFree
(
db
, 
zSql
);

63306 
	`memcpy
(&
pParse
->
nVar
, 
saveBuf
, (sizeof(
Parse
) - 
	`__builtin_offsetof
 (Parse, nVar)));

63307 
pParse
->
nested
--;

63308 
	}
}

63310 static 
Table
 *
	$sqlite3FindTable
(
sqlite3
 *
db
, const char *
zName
, const char *
zDatabase
)

63313 
Table
 *
p
 = 0;

63314 int 
i
;

63325 for(
i
=0; i<
db
->
nDb
; i++)

63328 int 
j
 = (
i
<2) ? i^1 : i;

63329 if( 
zDatabase
!=0 && 
	`sqlite3StrICmp
(zDatabase, 
db
->
aDb
[
j
].
zName
) ) continue;

63331 
p
 = 
	`sqlite3HashFind
(&
db
->
aDb
[
j
].
pSchema
->
tblHash
, 
zName
);

63332 if( 
p
 ) break;

63334 return 
p
;

63335 
	}
}

63337 static 
Table
 *
	$sqlite3LocateTable
(

63338 
Parse
 *
pParse
,

63339 int 
isView
,

63340 const char *
zName
,

63341 const char *
zDbase


63345 
Table
 *
p
;

63349 if( 0!=
	`sqlite3ReadSchema
(
pParse
) )

63355 
p
 = 
	`sqlite3FindTable
(
pParse
->
db
, 
zName
, 
zDbase
);

63356 if( 
p
==0 )

63359 const char *
zMsg
 = 
isView
 ? "no such view" : "no such table";

63361 if( 
	`sqlite3FindDbName
(
pParse
->
db
, 
zDbase
)<1 )

63367 
Module
 *
pMod
 = (Module*)
	`sqlite3HashFind
(&
pParse
->
db
->
aModule
, 
zName
);

63368 if( 
pMod
 && 
	`sqlite3VtabEponymousTableInit
(
pParse
, pMod) )

63371 return 
pMod
->
pEpoTab
;

63375 if( 
zDbase
 )

63378 
	`sqlite3ErrorMsg
(
pParse
, "%s: %s.%s", 
zMsg
, 
zDbase
, 
zName
);

63380 
	`sqlite3ErrorMsg
(
pParse
, "%s: %s", 
zMsg
, 
zName
);

63382 
pParse
->
checkSchema
 = 1;

63385 return 
p
;

63386 
	}
}

63388 static 
Table
 *
	$sqlite3LocateTableItem
(

63389 
Parse
 *
pParse
,

63390 int 
isView
,

63391 struct 
SrcList_item
 *
p


63395 const char *
zDb
;

63397 if( 
p
->
pSchema
 )

63400 int 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
p
->
pSchema
);

63401 
zDb
 = 
pParse
->
db
->
aDb
[
iDb
].
zName
;

63403 
zDb
 = 
p
->
zDatabase
;

63405 return 
	`sqlite3LocateTable
(
pParse
, 
isView
, 
p
->
zName
, 
zDb
);

63406 
	}
}

63408 static 
Index
 *
	$sqlite3FindIndex
(
sqlite3
 *
db
, const char *
zName
, const char *
zDb
)

63411 
Index
 *
p
 = 0;

63412 int 
i
;

63415 for(
i
=0; i<
db
->
nDb
; i++)

63418 int 
j
 = (
i
<2) ? i^1 : i;

63419 
Schema
 *
pSchema
 = 
db
->
aDb
[
j
].pSchema;

63421 if( 
zDb
 && 
	`sqlite3StrICmp
(zDb, 
db
->
aDb
[
j
].
zName
) ) continue;

63423 
p
 = 
	`sqlite3HashFind
(&
pSchema
->
idxHash
, 
zName
);

63424 if( 
p
 ) break;

63426 return 
p
;

63427 
	}
}

63432 static void 
	$freeIndex
(
sqlite3
 *
db
, 
Index
 *
p
)

63436 
	`sqlite3DeleteIndexSamples
(
db
, 
p
);

63438 
	`sqlite3ExprDelete
(
db
, 
p
->
pPartIdxWhere
);

63439 
	`sqlite3ExprListDelete
(
db
, 
p
->
aColExpr
);

63440 
	`sqlite3DbFree
(
db
, 
p
->
zColAff
);

63441 if( 
p
->
isResized
 ) 
	`sqlite3DbFree
(
db
, (void *)p->
azColl
);

63445 
	`sqlite3DbFree
(
db
, 
p
);

63446 
	}
}

63454 static void 
	$sqlite3UnlinkAndDeleteIndex
(
sqlite3
 *
db
, int 
iDb
, const char *
zIdxName
)

63457 
Index
 *
pIndex
;

63458 
Hash
 *
pHash
;

63461 
pHash
 = &
db
->
aDb
[
iDb
].
pSchema
->
idxHash
;

63462 
pIndex
 = 
	`sqlite3HashInsert
(
pHash
, 
zIdxName
, 0);

63463 if( (
pIndex
) )

63466 if( 
pIndex
->
pTable
->pIndex==pIndex )

63469 
pIndex
->
pTable
->pIndex = pIndex->
pNext
;

63471 
Index
 *
p
;

63474 
p
 = 
pIndex
->
pTable
->pIndex;

63475 while( (
p
) && p->
pNext
!=
pIndex
 )

63477 
p
 = p->
pNext
; }

63478 if( (
p
 && p->
pNext
==
pIndex
) )

63481 
p
->
pNext
 = 
pIndex
->pNext;

63484 
	`freeIndex
(
db
, 
pIndex
);

63486 
db
->
flags
 |= 0x00000002;

63487 
	}
}

63489 static void 
	$sqlite3CollapseDatabaseArray
(
sqlite3
 *
db
)

63492 int 
i
, 
j
;

63493 for(
i
=
j
=2; i<
db
->
nDb
; i++)

63496 struct 
Db
 *
pDb
 = &
db
->
aDb
[
i
];

63497 if( 
pDb
->
pBt
==0 )

63500 
	`sqlite3DbFree
(
db
, 
pDb
->
zName
);

63501 
pDb
->
zName
 = 0;

63504 if( 
j
<
i
 )

63507 
db
->
aDb
[
j
] = db->aDb[
i
];

63509 
j
++;

63511 
db
->
nDb
 = 
j
;

63512 if( 
db
->
nDb
<=2 && db->
aDb
!=db->
aDbStatic
 )

63515 
	`memcpy
(
db
->
aDbStatic
, db->
aDb
, 2*sizeof(db->aDb[0]));

63516 
	`sqlite3DbFree
(
db
, db->
aDb
);

63517 
db
->
aDb
 = db->
aDbStatic
;

63519 
	}
}

63525 static void 
	$sqlite3ResetOneSchema
(
sqlite3
 *
db
, int 
iDb
)

63528 
Db
 *
pDb
;

63532 
pDb
 = &
db
->
aDb
[
iDb
];

63535 
	`sqlite3SchemaClear
(
pDb
->
pSchema
);

63541 if( 
iDb
!=1 )

63544 
pDb
 = &
db
->
aDb
[1];

63546 
	`sqlite3SchemaClear
(
pDb
->
pSchema
);

63549 
	}
}

63555 static void 
	$sqlite3ResetAllSchemasOfConnection
(
sqlite3
 *
db
)

63558 int 
i
;

63559 
	`sqlite3BtreeEnterAll
(
db
);

63560 for(
i
=0; i<
db
->
nDb
; i++)

63563 
Db
 *
pDb
 = &
db
->
aDb
[
i
];

63564 if( 
pDb
->
pSchema
 )

63567 
	`sqlite3SchemaClear
(
pDb
->
pSchema
);

63570 
db
->
flags
 &= ~0x00000002;

63571 
	`sqlite3VtabUnlockList
(
db
);

63572 
	`sqlite3BtreeLeaveAll
(
db
);

63573 
	`sqlite3CollapseDatabaseArray
(
db
);

63574 
	}
}

63579 static void 
	$sqlite3CommitInternalChanges
(
sqlite3
 *
db
)

63582 
db
->
flags
 &= ~0x00000002;

63583 
	}
}

63589 static void 
	$sqlite3DeleteColumnNames
(
sqlite3
 *
db
, 
Table
 *
pTable
)

63592 int 
i
;

63593 
Column
 *
pCol
;

63595 if( (
pCol
 = 
pTable
->
aCol
)!=0 )

63598 for(
i
=0; i<
pTable
->
nCol
; i++, 
pCol
++)

63601 
	`sqlite3DbFree
(
db
, 
pCol
->
zName
);

63602 
	`sqlite3ExprDelete
(
db
, 
pCol
->
pDflt
);

63603 
	`sqlite3DbFree
(
db
, 
pCol
->
zColl
);

63605 
	`sqlite3DbFree
(
db
, 
pTable
->
aCol
);

63607 
	}
}

63609 static void 
	$sqlite3DeleteTable
(
sqlite3
 *
db
, 
Table
 *
pTable
)

63612 
Index
 *
pIndex
, *
pNext
;

63618 if( !
pTable
 ) return;

63619 if( ((!
db
 || db->
pnBytesFreed
==0) && (--
pTable
->
nRef
)>0) ) return;

63628 for(
pIndex
 = 
pTable
->pIndex; pIndex; pIndex=
pNext
)

63631 
pNext
 = 
pIndex
->pNext;

63633 if( !
db
 || db->
pnBytesFreed
==0 )

63636 char *
zName
 = 
pIndex
->zName;

63637 
	`sqlite3HashInsert
(

63638 &
pIndex
->
pSchema
->
idxHash
, 
zName
, 0

63643 
	`freeIndex
(
db
, 
pIndex
);

63647 
	`sqlite3FkDelete
(
db
, 
pTable
);

63651 
	`sqlite3DeleteColumnNames
(
db
, 
pTable
);

63652 
	`sqlite3DbFree
(
db
, 
pTable
->
zName
);

63653 
	`sqlite3DbFree
(
db
, 
pTable
->
zColAff
);

63654 
	`sqlite3SelectDelete
(
db
, 
pTable
->
pSelect
);

63655 
	`sqlite3ExprListDelete
(
db
, 
pTable
->
pCheck
);

63657 
	`sqlite3VtabClear
(
db
, 
pTable
);

63659 
	`sqlite3DbFree
(
db
, 
pTable
);

63663 
	}
}

63669 static void 
	$sqlite3UnlinkAndDeleteTable
(
sqlite3
 *
db
, int 
iDb
, const char *
zTabName
)

63672 
Table
 *
p
;

63673 
Db
 *
pDb
;

63680 
pDb
 = &
db
->
aDb
[
iDb
];

63681 
p
 = 
	`sqlite3HashInsert
(&
pDb
->
pSchema
->
tblHash
, 
zTabName
, 0);

63682 
	`sqlite3DeleteTable
(
db
, 
p
);

63683 
db
->
flags
 |= 0x00000002;

63684 
	}
}

63686 static char *
	$sqlite3NameFromToken
(
sqlite3
 *
db
, 
Token
 *
pName
)

63689 char *
zName
;

63690 if( 
pName
 )

63693 
zName
 = 
	`sqlite3DbStrNDup
(
db
, (char*)
pName
->
z
, pName->
n
);

63694 
	`sqlite3Dequote
(
zName
);

63696 
zName
 = 0;

63698 return 
zName
;

63699 
	}
}

63705 static void 
	$sqlite3OpenMasterTable
(
Parse
 *
p
, int 
iDb
)

63708 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
p
);

63709 
	`sqlite3TableLock
(
p
, 
iDb
, 1, 1, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"));

63710 
	`sqlite3VdbeAddOp4Int
(
v
, 55, 0, 1, 
iDb
, 5);

63711 if( 
p
->
nTab
==0 )

63714 
p
->
nTab
 = 1;

63716 
	}
}

63724 static int 
	$sqlite3FindDbName
(
sqlite3
 *
db
, const char *
zName
)

63727 int 
i
 = -1;

63728 if( 
zName
 )

63731 
Db
 *
pDb
;

63732 for(
i
=(
db
->
nDb
-1), 
pDb
=&db->
aDb
[i]; i>=0; i--, pDb--)

63735 if( 0==
	`sqlite3StrICmp
(
pDb
->
zName
, zName) ) break;

63738 return 
i
;

63739 
	}
}

63747 static int 
	$sqlite3FindDb
(
sqlite3
 *
db
, 
Token
 *
pName
)

63750 int 
i
;

63751 char *
zName
;

63752 
zName
 = 
	`sqlite3NameFromToken
(
db
, 
pName
);

63753 
i
 = 
	`sqlite3FindDbName
(
db
, 
zName
);

63754 
	`sqlite3DbFree
(
db
, 
zName
);

63755 return 
i
;

63756 
	}
}

63758 static int 
	$sqlite3TwoPartName
(

63759 
Parse
 *
pParse
,

63760 
Token
 *
pName1
,

63761 
Token
 *
pName2
,

63762 
Token
 **
pUnqual


63766 int 
iDb
;

63767 
sqlite3
 *
db
 = 
pParse
->db;

63770 if( 
pName2
->
n
>0 )

63773 if( 
db
->
init
.
busy
 ) {

63774 
	`sqlite3ErrorMsg
(
pParse
, "corrupt database");

63777 *
pUnqual
 = 
pName2
;

63778 
iDb
 = 
	`sqlite3FindDb
(
db
, 
pName1
);

63779 if( 
iDb
<0 )

63782 
	`sqlite3ErrorMsg
(
pParse
, "unknown database %T", 
pName1
);

63787 
iDb
 = 
db
->
init
.iDb;

63788 *
pUnqual
 = 
pName1
;

63790 return 
iDb
;

63791 
	}
}

63793 static int 
	$sqlite3CheckObjectName
(
Parse
 *
pParse
, const char *
zName
)

63796 if( !
pParse
->
db
->
init
.
busy
 && pParse->
nested
==0

63797 && (
pParse
->
db
->
flags
 & 0x00000800)==0

63798 && 0==
	`sqlite3_strnicmp
(
zName
, "sqlite_", 7) )

63801 
	`sqlite3ErrorMsg
(
pParse
, "object name reserved for internal use: %s", 
zName
);

63805 
	}
}

63810 static 
Index
 *
	$sqlite3PrimaryKeyIndex
(
Table
 *
pTab
)

63813 
Index
 *
p
;

63814 for(
p
=
pTab
->
pIndex
; p && !((p)->
idxType
==2); p=p->
pNext
)

63817 return 
p
;

63818 
	}
}

63824 static 
i16
 
	$sqlite3ColumnOfIndex
(
Index
 *
pIdx
, 
i16
 
iCol
)

63827 int 
i
;

63828 for(
i
=0; i<
pIdx
->
nColumn
; i++)

63831 if( 
iCol
==
pIdx
->
aiColumn
[
i
] ) return i;

63834 
	}
}

63836 static void 
	$sqlite3StartTable
(

63837 
Parse
 *
pParse
,

63838 
Token
 *
pName1
,

63839 
Token
 *
pName2
,

63840 int 
isTemp
,

63841 int 
isView
,

63842 int 
isVirtual
,

63843 int 
noErr


63847 
Table
 *
pTable
;

63848 char *
zName
 = 0;

63849 
sqlite3
 *
db
 = 
pParse
->db;

63850 
Vdbe
 *
v
;

63851 int 
iDb
;

63852 
Token
 *
pName
;

63854 if( 
db
->
init
.
busy
 && db->init.
newTnum
==1 )

63858 
iDb
 = 
db
->
init
.iDb;

63859 
zName
 = 
	`sqlite3DbStrDup
(
db
, ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master"));

63860 
pName
 = 
pName1
;

63863 
iDb
 = 
	`sqlite3TwoPartName
(
pParse
, 
pName1
, 
pName2
, &
pName
);

63864 if( 
iDb
<0 ) return;

63865 if( !0 && 
isTemp
 && 
pName2
->
n
>0 && 
iDb
!=1 )

63870 
	`sqlite3ErrorMsg
(
pParse
, "temporary table name must be unqualified");

63873 if( !0 && 
isTemp
 ) 
iDb
 = 1;

63874 
zName
 = 
	`sqlite3NameFromToken
(
db
, 
pName
);

63876 
pParse
->
sNameToken
 = *
pName
;

63877 if( 
zName
==0 ) return;

63878 if( 0!=
	`sqlite3CheckObjectName
(
pParse
, 
zName
) )

63881 goto 
begin_table_error
;

63883 if( 
db
->
init
.
iDb
==1 ) 
isTemp
 = 1;

63888 static const 
u8
 
aCode
[] = {

63894 char *
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

63895 if( 
	`sqlite3AuthCheck
(
pParse
, 18, ((!0)&&(
isTemp
==1)?"sqlite_temp_master":"sqlite_master"), 0, 
zDb
) )

63898 goto 
begin_table_error
;

63900 if( !
isVirtual
 && 
	`sqlite3AuthCheck
(
pParse
, (int)
aCode
[
isTemp
+2*
isView
],

63901 
zName
, 0, 
zDb
) )

63904 goto 
begin_table_error
;

63908 if( !(
pParse
->
declareVtab
) )

63911 char *
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

63912 if( 0!=
	`sqlite3ReadSchema
(
pParse
) )

63915 goto 
begin_table_error
;

63917 
pTable
 = 
	`sqlite3FindTable
(
db
, 
zName
, 
zDb
);

63918 if( 
pTable
 )

63921 if( !
noErr
 )

63924 
	`sqlite3ErrorMsg
(
pParse
, "table %T already exists", 
pName
);

63927 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

63929 goto 
begin_table_error
;

63931 if( 
	`sqlite3FindIndex
(
db
, 
zName
, 
zDb
)!=0 )

63934 
	`sqlite3ErrorMsg
(
pParse
, "there is already an index named %s", 
zName
);

63935 goto 
begin_table_error
;

63939 
pTable
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
Table
));

63940 if( 
pTable
==0 )

63944 
pParse
->
rc
 = 7;

63945 
pParse
->
nErr
++;

63946 goto 
begin_table_error
;

63948 
pTable
->
zName
 = zName;

63949 
pTable
->
iPKey
 = -1;

63950 
pTable
->
pSchema
 = 
db
->
aDb
[
iDb
].pSchema;

63951 
pTable
->
nRef
 = 1;

63952 
pTable
->
nRowLogEst
 = 200; ((void) (0));

63954 
pParse
->
pNewTable
 = 
pTable
;

63961 if( !
pParse
->
nested
 && 
	`strcmp
(
zName
, "sqlite_sequence")==0 )

63965 
pTable
->
pSchema
->
pSeqTab
 = pTable;

63968 if( !
db
->
init
.
busy
 && (
v
 = 
	`sqlite3GetVdbe
(
pParse
))!=0 )

63971 int 
addr1
;

63972 int 
fileFormat
;

63973 int 
reg1
, 
reg2
, 
reg3
;

63975 static const char 
nullRow
[] = { 6, 0, 0, 0, 0, 0 };

63976 
	`sqlite3BeginWriteOperation
(
pParse
, 1, 
iDb
);

63979 if( 
isVirtual
 )

63982 
	`sqlite3VdbeAddOp0
(
v
, 149);

63989 
reg1
 = 
pParse
->
regRowid
 = ++pParse->
nMem
;

63990 
reg2
 = 
pParse
->
regRoot
 = ++pParse->
nMem
;

63991 
reg3
 = ++
pParse
->
nMem
;

63992 
	`sqlite3VdbeAddOp3
(
v
, 51, 
iDb
, 
reg3
, 2);

63993 
	`sqlite3VdbeUsesBtree
(
v
, 
iDb
);

63994 
addr1
 = 
	`sqlite3VdbeAddOp1
(
v
, 45, 
reg3
); ;

63995 
fileFormat
 = (
db
->
flags
 & 0x00008000)!=0 ?

63997 
	`sqlite3VdbeAddOp3
(
v
, 52, 
iDb
, 2, 
fileFormat
);

63998 
	`sqlite3VdbeAddOp3
(
v
, 52, 
iDb
, 5, ((
db
)->
enc
));

63999 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

64001 if( 
isView
 || 
isVirtual
 )

64004 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
reg2
);

64008 
pParse
->
addrCrTab
 = 
	`sqlite3VdbeAddOp2
(
v
, 122, 
iDb
, 
reg2
);

64010 
	`sqlite3OpenMasterTable
(
pParse
, 
iDb
);

64011 
	`sqlite3VdbeAddOp2
(
v
, 74, 0, 
reg1
);

64012 
	`sqlite3VdbeAddOp4
(
v
, 27, 6, 
reg3
, 0, 
nullRow
, (-2));

64013 
	`sqlite3VdbeAddOp3
(
v
, 75, 0, 
reg3
, 
reg1
);

64014 
	`sqlite3VdbeChangeP5
(
v
, 0x08);

64015 
	`sqlite3VdbeAddOp0
(
v
, 61);

64022 
begin_table_error
:

64023 
	`sqlite3DbFree
(
db
, 
zName
);

64025 
	}
}

64027 static void 
	$sqlite3AddColumn
(
Parse
 *
pParse
, 
Token
 *
pName
, Token *
pType
)

64030 
Table
 *
p
;

64031 int 
i
;

64032 char *
z
;

64033 char *
zType
;

64034 
Column
 *
pCol
;

64035 
sqlite3
 *
db
 = 
pParse
->db;

64036 if( (
p
 = 
pParse
->
pNewTable
)==0 ) return;

64038 if( 
p
->
nCol
+1>
db
->
aLimit
[2] )

64041 
	`sqlite3ErrorMsg
(
pParse
, "too many columns on %s", 
p
->
zName
);

64045 
z
 = 
	`sqlite3DbMallocRaw
(
db
, 
pName
->
n
 + 
pType
->n + 2);

64046 if( 
z
==0 ) return;

64047 
	`memcpy
(
z
, 
pName
->z, pName->
n
);

64048 
z
[
pName
->
n
] = 0;

64049 
	`sqlite3Dequote
(
z
);

64050 for(
i
=0; i<
p
->
nCol
; i++)

64053 if( 
	`sqlite3_stricmp
(
z
, 
p
->
aCol
[
i
].
zName
)==0 )

64056 
	`sqlite3ErrorMsg
(
pParse
, "duplicate column name: %s", 
z
);

64057 
	`sqlite3DbFree
(
db
, 
z
);

64061 if( (
p
->
nCol
 & 0x7)==0 )

64064 
Column
 *
aNew
;

64065 
aNew
 = 
	`sqlite3DbRealloc
(
db
,
p
->
aCol
,(p->
nCol
+8)*sizeof(p->aCol[0]));

64066 if( 
aNew
==0 )

64069 
	`sqlite3DbFree
(
db
, 
z
);

64072 
p
->
aCol
 = 
aNew
;

64074 
pCol
 = &
p
->
aCol
[p->
nCol
];

64075 
	`memset
(
pCol
, 0, sizeof(
p
->
aCol
[0]));

64076 
pCol
->
zName
 = 
z
;

64079 if( 
pType
->
n
==0 )

64084 
pCol
->
affinity
 = 'A';

64085 
pCol
->
szEst
 = 1;

64087 
zType
 = 
z
 + 
	`sqlite3Strlen30
(z) + 1;

64088 
	`memcpy
(
zType
, 
pType
->
z
, pType->
n
);

64089 
zType
[
pType
->
n
] = 0;

64090 
pCol
->
affinity
 = 
	`sqlite3AffinityType
(
zType
, &pCol->
szEst
);

64091 
pCol
->
colFlags
 |= 0x0004;

64093 
p
->
nCol
++;

64094 
pParse
->
constraintName
.
n
 = 0;

64095 
	}
}

64103 static void 
	$sqlite3AddNotNull
(
Parse
 *
pParse
, int 
onError
)

64106 
Table
 *
p
;

64107 
p
 = 
pParse
->
pNewTable
;

64108 if( 
p
==0 || (p->
nCol
<1) ) return;

64109 
p
->
aCol
[p->
nCol
-1].
notNull
 = (
u8
)
onError
;

64110 
	}
}

64112 static char 
	$sqlite3AffinityType
(const char *
zIn
, 
u8
 *
pszEst
)

64115 
u32
 
h
 = 0;

64116 char 
aff
 = 'C';

64117 const char *
zChar
 = 0;

64120 while( 
zIn
[0] )

64123 
h
 = (h<<8) + 
sqlite3UpperToLower
[(*
zIn
)&0xff];

64124 
zIn
++;

64125 if( 
h
==(('c'<<24)+('h'<<16)+('a'<<8)+'r') )

64128 
aff
 = 'B';

64129 
zChar
 = 
zIn
;

64130 }else if( 
h
==(('c'<<24)+('l'<<16)+('o'<<8)+'b') )

64133 
aff
 = 'B';

64134 }else if( 
h
==(('t'<<24)+('e'<<16)+('x'<<8)+'t') )

64137 
aff
 = 'B';

64138 }else if( 
h
==(('b'<<24)+('l'<<16)+('o'<<8)+'b')

64139 && (
aff
=='C' || aff=='E') )

64142 
aff
 = 'A';

64143 if( 
zIn
[0]=='(' ) 
zChar
 = zIn;

64145 }else if( 
h
==(('r'<<24)+('e'<<16)+('a'<<8)+'l')

64146 && 
aff
=='C' )

64149 
aff
 = 'E';

64150 }else if( 
h
==(('f'<<24)+('l'<<16)+('o'<<8)+'a')

64151 && 
aff
=='C' )

64154 
aff
 = 'E';

64155 }else if( 
h
==(('d'<<24)+('o'<<16)+('u'<<8)+'b')

64156 && 
aff
=='C' )

64159 
aff
 = 'E';

64161 }else if( (
h
&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') )

64164 
aff
 = 'D';

64171 if( 
pszEst
 )

64174 *
pszEst
 = 1;

64175 if( 
aff
<'C' )

64178 if( 
zChar
 )

64181 while( 
zChar
[0] )

64184 if( (
sqlite3CtypeMap
[(unsigned char)(
zChar
[0])]&0x04) )

64187 int 
v
 = 0;

64188 
	`sqlite3GetInt32
(
zChar
, &
v
);

64189 
v
 = v/4 + 1;

64190 if( 
v
>255 ) v = 255;

64191 *
pszEst
 = 
v
;

64194 
zChar
++;

64197 *
pszEst
 = 5;

64201 return 
aff
;

64202 
	}
}

64204 static void 
	$sqlite3AddDefaultValue
(
Parse
 *
pParse
, 
ExprSpan
 *
pSpan
)

64207 
Table
 *
p
;

64208 
Column
 *
pCol
;

64209 
sqlite3
 *
db
 = 
pParse
->db;

64210 
p
 = 
pParse
->
pNewTable
;

64211 if( 
p
!=0 )

64214 
pCol
 = &(
p
->
aCol
[p->
nCol
-1]);

64215 if( !
	`sqlite3ExprIsConstantOrFunction
(
pSpan
->
pExpr
, 
db
->
init
.
busy
) )

64218 
	`sqlite3ErrorMsg
(
pParse
, "default value of column [%s] is not constant",

64219 
pCol
->
zName
);

64225 
Expr
 
x
;

64226 
	`sqlite3ExprDelete
(
db
, 
pCol
->
pDflt
);

64227 
	`memset
(&
x
, 0, sizeof(x));

64228 
x
.
op
 = 159;

64229 
x
.
u
.
zToken
 = 
	`sqlite3DbStrNDup
(
db
, (char*)
pSpan
->
zStart
,

64230 (int)(
pSpan
->
zEnd
 - pSpan->
zStart
));

64231 
x
.
pLeft
 = 
pSpan
->
pExpr
;

64232 
x
.
flags
 = 0x001000;

64233 
pCol
->
pDflt
 = 
	`sqlite3ExprDup
(
db
, &
x
, 0x0001);

64234 
	`sqlite3DbFree
(
db
, 
x
.
u
.
zToken
);

64237 
	`sqlite3ExprDelete
(
db
, 
pSpan
->
pExpr
);

64238 
	}
}

64240 static void 
	$sqlite3StringToId
(
Expr
 *
p
)

64243 if( 
p
->
op
==97 )

64246 
p
->
op
 = 27;

64247 }else if( 
p
->
op
==95 && p->
pLeft
->op==97 )

64250 
p
->
pLeft
->
op
 = 27;

64252 
	}
}

64254 static void 
	$sqlite3AddPrimaryKey
(

64255 
Parse
 *
pParse
,

64256 
ExprList
 *
pList
,

64257 int 
onError
,

64258 int 
autoInc
,

64259 int 
sortOrder


64263 
Table
 *
pTab
 = 
pParse
->
pNewTable
;

64264 
Column
 *
pCol
 = 0;

64265 int 
iCol
 = -1, 
i
;

64266 int 
nTerm
;

64267 if( 
pTab
==0 || (
pParse
->
declareVtab
) ) goto 
primary_key_exit
;

64268 if( 
pTab
->
tabFlags
 & 0x04 )

64271 
	`sqlite3ErrorMsg
(
pParse
,

64272 "table \"%s\" has more than one primary key", 
pTab
->
zName
);

64273 goto 
primary_key_exit
;

64275 
pTab
->
tabFlags
 |= 0x04;

64276 if( 
pList
==0 )

64279 
iCol
 = 
pTab
->
nCol
 - 1;

64280 
pCol
 = &
pTab
->
aCol
[
iCol
];

64281 
pCol
->
colFlags
 |= 0x0001;

64282 
nTerm
 = 1;

64284 
nTerm
 = 
pList
->
nExpr
;

64285 for(
i
=0; i<
nTerm
; i++)

64288 
Expr
 *
pCExpr
 = 
	`sqlite3ExprSkipCollate
(
pList
->
a
[
i
].
pExpr
);

64290 
	`sqlite3StringToId
(
pCExpr
);

64291 if( 
pCExpr
->
op
==27 )

64294 const char *
zCName
 = 
pCExpr
->
u
.
zToken
;

64295 for(
iCol
=0; iCol<
pTab
->
nCol
; iCol++)

64298 if( 
	`sqlite3StrICmp
(
zCName
, 
pTab
->
aCol
[
iCol
].
zName
)==0 )

64301 
pCol
 = &
pTab
->
aCol
[
iCol
];

64302 
pCol
->
colFlags
 |= 0x0001;

64309 if( 
nTerm
==1

64310 && 
pCol


64311 && 
	`sqlite3StrICmp
(
	`sqlite3ColumnType
(
pCol
,""), "INTEGER")==0

64312 && 
sortOrder
!=1

64316 
pTab
->
iPKey
 = 
iCol
;

64317 
pTab
->
keyConf
 = (
u8
)
onError
;

64319 
pTab
->
tabFlags
 |= 
autoInc
*0x08;

64320 if( 
pList
 ) 
pParse
->
iPkSortOrder
 = pList->
a
[0].
sortOrder
;

64321 }else if( 
autoInc
 )

64325 
	`sqlite3ErrorMsg
(
pParse
, "AUTOINCREMENT is only allowed on an "

64329 
Index
 *
p
;

64330 
p
 = 
	`sqlite3CreateIndex
(
pParse
, 0, 0, 0, 
pList
, 
onError
, 0,

64331 0, 
sortOrder
, 0);

64332 if( 
p
 )

64335 
p
->
idxType
 = 2;

64337 
pList
 = 0;

64340 
primary_key_exit
:

64341 
	`sqlite3ExprListDelete
(
pParse
->
db
, 
pList
);

64343 
	}
}

64348 static void 
	$sqlite3AddCheckConstraint
(

64349 
Parse
 *
pParse
,

64350 
Expr
 *
pCheckExpr


64355 
Table
 *
pTab
 = 
pParse
->
pNewTable
;

64356 
sqlite3
 *
db
 = 
pParse
->db;

64357 if( 
pTab
 && !(
pParse
->
declareVtab
)

64358 && !
	`sqlite3BtreeIsReadonly
(
db
->
aDb
[db->
init
.
iDb
].
pBt
)

64362 
pTab
->
pCheck
 = 
	`sqlite3ExprListAppend
(
pParse
, pTab->pCheck, 
pCheckExpr
);

64363 if( 
pParse
->
constraintName
.
n
 )

64366 
	`sqlite3ExprListSetName
(
pParse
, 
pTab
->
pCheck
, &pParse->
constraintName
, 1);

64371 
	`sqlite3ExprDelete
(
pParse
->
db
, 
pCheckExpr
);

64373 
	}
}

64379 static void 
	$sqlite3AddCollateType
(
Parse
 *
pParse
, 
Token
 *
pToken
)

64382 
Table
 *
p
;

64383 int 
i
;

64384 char *
zColl
;

64385 
sqlite3
 *
db
;

64387 if( (
p
 = 
pParse
->
pNewTable
)==0 ) return;

64388 
i
 = 
p
->
nCol
-1;

64389 
db
 = 
pParse
->db;

64390 
zColl
 = 
	`sqlite3NameFromToken
(
db
, 
pToken
);

64391 if( !
zColl
 ) return;

64393 if( 
	`sqlite3LocateCollSeq
(
pParse
, 
zColl
) )

64396 
Index
 *
pIdx
;

64397 
	`sqlite3DbFree
(
db
, 
p
->
aCol
[
i
].
zColl
);

64398 
p
->
aCol
[
i
].
zColl
 = zColl;

64404 for(
pIdx
=
p
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

64408 if( 
pIdx
->
aiColumn
[0]==
i
 )

64411 
pIdx
->
azColl
[0] = 
p
->
aCol
[
i
].
zColl
;

64415 
	`sqlite3DbFree
(
db
, 
zColl
);

64417 
	}
}

64419 static 
CollSeq
 *
	$sqlite3LocateCollSeq
(
Parse
 *
pParse
, const char *
zName
)

64422 
sqlite3
 *
db
 = 
pParse
->db;

64423 
u8
 
enc
 = ((
db
)->enc);

64424 
u8
 
initbusy
 = 
db
->
init
.
busy
;

64425 
CollSeq
 *
pColl
;

64427 
pColl
 = 
	`sqlite3FindCollSeq
(
db
, 
enc
, 
zName
, 
initbusy
);

64428 if( !
initbusy
 && (!
pColl
 || !pColl->
xCmp
) )

64431 
pColl
 = 
	`sqlite3GetCollSeq
(
pParse
, 
enc
, pColl, 
zName
);

64434 return 
pColl
;

64435 
	}
}

64437 static void 
	$sqlite3ChangeCookie
(
Parse
 *
pParse
, int 
iDb
)

64440 
sqlite3
 *
db
 = 
pParse
->db;

64441 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

64443 
	`sqlite3VdbeAddOp3
(
v
, 52, 
iDb
, 1,

64444 
db
->
aDb
[
iDb
].
pSchema
->
schema_cookie
+1);

64445 
	}
}

64447 static int 
	$identLength
(const char *
z
)

64450 int 
n
;

64451 for(
n
=0; *
z
; n++, z++)

64454 if( *
z
=='"' )

64456 
n
++; }

64458 return 
n
 + 2;

64459 
	}
}

64461 static void 
	$identPut
(char *
z
, int *
pIdx
, char *
zSignedIdent
)

64464 unsigned char *
zIdent
 = (unsigned char*)
zSignedIdent
;

64465 int 
i
, 
j
, 
needQuote
;

64466 
i
 = *
pIdx
;

64468 for(
j
=0; 
zIdent
[j]; j++)

64471 if( !(
sqlite3CtypeMap
[(unsigned char)(
zIdent
[
j
])]&0x06) && zIdent[j]!='_' ) break;

64473 
needQuote
 = (
sqlite3CtypeMap
[(unsigned char)(
zIdent
[0])]&0x04)

64474 || 
	`sqlite3KeywordCode
(
zIdent
, 
j
)!=27

64475 || 
zIdent
[
j
]!=0

64476 || 
j
==0;

64478 if( 
needQuote
 ) 
z
[
i
++] = '"';

64479 for(
j
=0; 
zIdent
[j]; j++)

64482 
z
[
i
++] = 
zIdent
[
j
];

64483 if( 
zIdent
[
j
]=='"' ) 
z
[
i
++] = '"';

64485 if( 
needQuote
 ) 
z
[
i
++] = '"';

64486 
z
[
i
] = 0;

64487 *
pIdx
 = 
i
;

64488 
	}
}

64495 static char *
	$createTableStmt
(
sqlite3
 *
db
, 
Table
 *
p
)

64498 int 
i
, 
k
, 
n
;

64499 char *
zStmt
;

64500 char *
zSep
, *
zSep2
, *
zEnd
;

64501 
Column
 *
pCol
;

64502 
n
 = 0;

64503 for(
pCol
 = 
p
->
aCol
, 
i
=0; i<p->
nCol
; i++, pCol++)

64506 
n
 += 
	`identLength
(
pCol
->
zName
) + 5;

64508 
n
 += 
	`identLength
(
p
->
zName
);

64509 if( 
n
<50 )

64512 
zSep
 = "";

64513 
zSep2
 = ",";

64514 
zEnd
 = ")";

64516 
zSep
 = "\n ";

64517 
zSep2
 = ",\n ";

64518 
zEnd
 = "\n)";

64520 
n
 += 35 + 6*
p
->
nCol
;

64521 
zStmt
 = 
	`sqlite3DbMallocRaw
(0, 
n
);

64522 if( 
zStmt
==0 )

64525 
	`sqlite3OomFault
(
db
);

64528 
	`sqlite3_snprintf
(
n
, 
zStmt
, "CREATE TABLE ");

64529 
k
 = 
	`sqlite3Strlen30
(
zStmt
);

64530 
	`identPut
(
zStmt
, &
k
, 
p
->
zName
);

64531 
zStmt
[
k
++] = '(';

64532 for(
pCol
=
p
->
aCol
, 
i
=0; i<p->
nCol
; i++, pCol++)

64535 static const char * const 
azType
[] = {

64542 int 
len
;

64543 const char *
zType
;

64545 
	`sqlite3_snprintf
(
n
-
k
, &
zStmt
[k], 
zSep
);

64546 
k
 += 
	`sqlite3Strlen30
(&
zStmt
[k]);

64547 
zSep
 = 
zSep2
;

64548 
	`identPut
(
zStmt
, &
k
, 
pCol
->
zName
);

64557 
zType
 = 
azType
[
pCol
->
affinity
 - 'A'];

64558 
len
 = 
	`sqlite3Strlen30
(
zType
);

64561 
	`memcpy
(&
zStmt
[
k
], 
zType
, 
len
);

64562 
k
 += 
len
;

64565 
	`sqlite3_snprintf
(
n
-
k
, &
zStmt
[k], "%s", 
zEnd
);

64566 return 
zStmt
;

64567 
	}
}

64573 static int 
	$resizeIndexObject
(
sqlite3
 *
db
, 
Index
 *
pIdx
, int 
N
)

64576 char *
zExtra
;

64577 int 
nByte
;

64578 if( 
pIdx
->
nColumn
>=
N
 ) return 0;

64580 
nByte
 = (sizeof(char*) + sizeof(
i16
) + 1)*
N
;

64581 
zExtra
 = 
	`sqlite3DbMallocZero
(
db
, 
nByte
);

64582 if( 
zExtra
==0 ) return 7;

64583 
	`memcpy
(
zExtra
, 
pIdx
->
azColl
, sizeof(char*)*pIdx->
nColumn
);

64584 
pIdx
->
azColl
 = (const char**)
zExtra
;

64585 
zExtra
 += sizeof(char*)*
N
;

64586 
	`memcpy
(
zExtra
, 
pIdx
->
aiColumn
, sizeof(
i16
)*pIdx->
nColumn
);

64587 
pIdx
->
aiColumn
 = (
i16
*)
zExtra
;

64588 
zExtra
 += sizeof(
i16
)*
N
;

64589 
	`memcpy
(
zExtra
, 
pIdx
->
aSortOrder
, pIdx->
nColumn
);

64590 
pIdx
->
aSortOrder
 = (
u8
*)
zExtra
;

64591 
pIdx
->
nColumn
 = 
N
;

64592 
pIdx
->
isResized
 = 1;

64594 
	}
}

64599 static void 
	$estimateTableWidth
(
Table
 *
pTab
)

64602 unsigned 
wTable
 = 0;

64603 const 
Column
 *
pTabCol
;

64604 int 
i
;

64605 for(
i
=
pTab
->
nCol
, 
pTabCol
=pTab->
aCol
; i>0; i--, pTabCol++)

64608 
wTable
 += 
pTabCol
->
szEst
;

64610 if( 
pTab
->
iPKey
<0 ) 
wTable
++;

64611 
pTab
->
szTabRow
 = 
	`sqlite3LogEst
(
wTable
*4);

64612 
	}
}

64617 static void 
	$estimateIndexWidth
(
Index
 *
pIdx
)

64620 unsigned 
wIndex
 = 0;

64621 int 
i
;

64622 const 
Column
 *
aCol
 = 
pIdx
->
pTable
->aCol;

64623 for(
i
=0; i<
pIdx
->
nColumn
; i++)

64626 
i16
 
x
 = 
pIdx
->
aiColumn
[
i
];

64628 
wIndex
 += 
x
<0 ? 1 : 
aCol
[
pIdx
->
aiColumn
[
i
]].
szEst
;

64630 
pIdx
->
szIdxRow
 = 
	`sqlite3LogEst
(
wIndex
*4);

64631 
	}
}

64635 static int 
	$hasColumn
(const 
i16
 *
aiCol
, int 
nCol
, int 
x
)

64638 while( 
nCol
-- > 0 ) if( 
x
==*(
aiCol
++) ) return 1;

64640 
	}
}

64642 static void 
	$convertToWithoutRowidTable
(
Parse
 *
pParse
, 
Table
 *
pTab
)

64645 
Index
 *
pIdx
;

64646 
Index
 *
pPk
;

64647 int 
nPk
;

64648 int 
i
, 
j
;

64649 
sqlite3
 *
db
 = 
pParse
->db;

64650 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

64656 if( 
pParse
->
addrCrTab
 )

64660 
	`sqlite3VdbeChangeOpcode
(
v
, 
pParse
->
addrCrTab
, 121);

64666 if( 
pTab
->
iPKey
>=0 )

64669 
ExprList
 *
pList
;

64670 
Token
 
ipkToken
;

64671 
	`sqlite3TokenInit
(&
ipkToken
, 
pTab
->
aCol
[pTab->
iPKey
].
zName
);

64672 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
, 0,

64673 
	`sqlite3ExprAlloc
(
db
, 27, &
ipkToken
, 0));

64674 if( 
pList
==0 ) return;

64675 
pList
->
a
[0].
sortOrder
 = 
pParse
->
iPkSortOrder
;

64677 
pPk
 = 
	`sqlite3CreateIndex
(
pParse
, 0, 0, 0, 
pList
, 
pTab
->
keyConf
, 0, 0, 0, 0);

64678 if( 
pPk
==0 ) return;

64679 
pPk
->
idxType
 = 2;

64680 
pTab
->
iPKey
 = -1;

64682 
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

64688 if( 
v
 )

64692 
	`sqlite3VdbeChangeOpcode
(
v
, 
pPk
->
tnum
, 13);

64700 for(
i
=
j
=1; i<
pPk
->
nKeyCol
; i++)

64703 if( 
	`hasColumn
(
pPk
->
aiColumn
, 
j
, pPk->aiColumn[
i
]) )

64706 
pPk
->
nColumn
--;

64708 
pPk
->
aiColumn
[
j
++] = pPk->aiColumn[
i
];

64711 
pPk
->
nKeyCol
 = 
j
;

64713 
pPk
->
isCovering
 = 1;

64715 
nPk
 = 
pPk
->
nKeyCol
;

64719 if( !
db
->
init
.
imposterTable
 )

64722 for(
i
=0; i<
nPk
; i++)

64725 
pTab
->
aCol
[
pPk
->
aiColumn
[
i
]].
notNull
 = 2;

64727 
pPk
->
uniqNotNull
 = 1;

64731 
pPk
->
tnum
 = 
pTab
->tnum;

64736 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

64739 int 
n
;

64740 if( ((
pIdx
)->
idxType
==2) ) continue;

64741 for(
i
=
n
=0; i<
nPk
; i++)

64744 if( !
	`hasColumn
(
pIdx
->
aiColumn
, pIdx->
nKeyCol
, 
pPk
->aiColumn[
i
]) ) 
n
++;

64746 if( 
n
==0 )

64750 
pIdx
->
nColumn
 = pIdx->
nKeyCol
;

64753 if( 
	`resizeIndexObject
(
db
, 
pIdx
, pIdx->
nKeyCol
+
n
) ) return;

64754 for(
i
=0, 
j
=
pIdx
->
nKeyCol
; i<
nPk
; i++)

64757 if( !
	`hasColumn
(
pIdx
->
aiColumn
, pIdx->
nKeyCol
, 
pPk
->aiColumn[
i
]) )

64760 
pIdx
->
aiColumn
[
j
] = 
pPk
->aiColumn[
i
];

64761 
pIdx
->
azColl
[
j
] = 
pPk
->azColl[
i
];

64762 
j
++;

64771 if( 
nPk
<
pTab
->
nCol
 )

64774 if( 
	`resizeIndexObject
(
db
, 
pPk
, 
pTab
->
nCol
) ) return;

64775 for(
i
=0, 
j
=
nPk
; i<
pTab
->
nCol
; i++)

64778 if( !
	`hasColumn
(
pPk
->
aiColumn
, 
j
, 
i
) )

64782 
pPk
->
aiColumn
[
j
] = 
i
;

64783 
pPk
->
azColl
[
j
] = 
sqlite3StrBINARY
;

64784 
j
++;

64790 
pPk
->
nColumn
 = 
pTab
->
nCol
;

64792 
	}
}

64794 static void 
	$sqlite3EndTable
(

64795 
Parse
 *
pParse
,

64796 
Token
 *
pCons
,

64797 
Token
 *
pEnd
,

64798 
u8
 
tabOpts
,

64799 
Select
 *
pSelect


64803 
Table
 *
p
;

64804 
sqlite3
 *
db
 = 
pParse
->db;

64805 int 
iDb
;

64806 
Index
 *
pIdx
;

64808 if( 
pEnd
==0 && 
pSelect
==0 )

64814 
p
 = 
pParse
->
pNewTable
;

64815 if( 
p
==0 ) return;

64819 if( 
db
->
init
.
busy
 )

64822 
p
->
tnum
 = 
db
->
init
.
newTnum
;

64823 if( 
p
->
tnum
==1 ) p->
tabFlags
 |= 0x01;

64827 if( 
tabOpts
 & 0x20 )

64830 if( (
p
->
tabFlags
 & 0x08) )

64833 
	`sqlite3ErrorMsg
(
pParse
,

64837 if( (
p
->
tabFlags
 & 0x04)==0 )

64840 
	`sqlite3ErrorMsg
(
pParse
, "PRIMARY KEY missing on table %s", 
p
->
zName
);

64842 
p
->
tabFlags
 |= 0x20 | 0x40;

64843 
	`convertToWithoutRowidTable
(
pParse
, 
p
);

64847 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
p
->
pSchema
);

64852 if( 
p
->
pCheck
 )

64855 
	`sqlite3ResolveSelfReference
(
pParse
, 
p
, 0x0004, 0, p->
pCheck
);

64860 
	`estimateTableWidth
(
p
);

64861 for(
pIdx
=
p
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

64864 
	`estimateIndexWidth
(
pIdx
);

64873 if( !
db
->
init
.
busy
 )

64876 int 
n
;

64877 
Vdbe
 *
v
;

64878 char *
zType
;

64879 char *
zType2
;

64880 char *
zStmt
;

64882 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

64883 if( (
v
==0) ) return;

64885 
	`sqlite3VdbeAddOp1
(
v
, 61, 0);

64890 if( 
p
->
pSelect
==0 )

64894 
zType
 = "table";

64895 
zType2
 = "TABLE";

64899 
zType
 = "view";

64900 
zType2
 = "VIEW";

64904 if( 
pSelect
 )

64907 
SelectDest
 
dest
;

64908 int 
regYield
;

64909 int 
addrTop
;

64910 int 
regRec
;

64911 int 
regRowid
;

64912 int 
addrInsLoop
;

64913 
Table
 *
pSelTab
;

64915 
regYield
 = ++
pParse
->
nMem
;

64916 
regRec
 = ++
pParse
->
nMem
;

64917 
regRowid
 = ++
pParse
->
nMem
;

64919 
	`sqlite3MayAbort
(
pParse
);

64920 
	`sqlite3VdbeAddOp3
(
v
, 55, 1, 
pParse
->
regRoot
, 
iDb
);

64921 
	`sqlite3VdbeChangeP5
(
v
, 0x10);

64922 
pParse
->
nTab
 = 2;

64923 
addrTop
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 1;

64924 
	`sqlite3VdbeAddOp3
(
v
, 16, 
regYield
, 0, 
addrTop
);

64925 
	`sqlite3SelectDestInit
(&
dest
, 13, 
regYield
);

64926 
	`sqlite3Select
(
pParse
, 
pSelect
, &
dest
);

64927 
	`sqlite3VdbeEndCoroutine
(
v
, 
regYield
);

64928 
	`sqlite3VdbeJumpHere
(
v
, 
addrTop
 - 1);

64929 if( 
pParse
->
nErr
 ) return;

64930 
pSelTab
 = 
	`sqlite3ResultSetOfSelect
(
pParse
, 
pSelect
);

64931 if( 
pSelTab
==0 ) return;

64933 
p
->
nCol
 = 
pSelTab
->nCol;

64934 
p
->
aCol
 = 
pSelTab
->aCol;

64935 
pSelTab
->
nCol
 = 0;

64936 
pSelTab
->
aCol
 = 0;

64937 
	`sqlite3DeleteTable
(
db
, 
pSelTab
);

64938 
addrInsLoop
 = 
	`sqlite3VdbeAddOp1
(
v
, 18, 
dest
.
iSDParm
);

64940 
	`sqlite3VdbeAddOp3
(
v
, 49, 
dest
.
iSdst
, dest.
nSdst
, 
regRec
);

64941 
	`sqlite3TableAffinity
(
v
, 
p
, 0);

64942 
	`sqlite3VdbeAddOp2
(
v
, 74, 1, 
regRowid
);

64943 
	`sqlite3VdbeAddOp3
(
v
, 75, 1, 
regRec
, 
regRowid
);

64944 
	`sqlite3VdbeGoto
(
v
, 
addrInsLoop
);

64945 
	`sqlite3VdbeJumpHere
(
v
, 
addrInsLoop
);

64946 
	`sqlite3VdbeAddOp1
(
v
, 61, 1);

64950 if( 
pSelect
 )

64953 
zStmt
 = 
	`createTableStmt
(
db
, 
p
);

64955 
Token
 *
pEnd2
 = 
tabOpts
 ? &
pParse
->
sLastToken
 : 
pEnd
;

64956 
n
 = (int)(
pEnd2
->
z
 - 
pParse
->
sNameToken
.z);

64957 if( 
pEnd2
->
z
[0]!=';' ) 
n
 += pEnd2->n;

64958 
zStmt
 = 
	`sqlite3MPrintf
(
db
,

64959 "CREATE %s %.*s", 
zType2
, 
n
, 
pParse
->
sNameToken
.
z


64967 
	`sqlite3NestedParse
(
pParse
,

64971 
db
->
aDb
[
iDb
].
zName
, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"),

64972 
zType
,

64973 
p
->
zName
,

64974 
p
->
zName
,

64975 
pParse
->
regRoot
,

64976 
zStmt
,

64977 
pParse
->
regRowid


64979 
	`sqlite3DbFree
(
db
, 
zStmt
);

64980 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

64986 if( 
p
->
tabFlags
 & 0x08 )

64989 
Db
 *
pDb
 = &
db
->
aDb
[
iDb
];

64991 if( 
pDb
->
pSchema
->
pSeqTab
==0 )

64994 
	`sqlite3NestedParse
(
pParse
,

64996 
pDb
->
zName


65003 
	`sqlite3VdbeAddParseSchemaOp
(
v
, 
iDb
,

65004 
	`sqlite3MPrintf
(
db
, "tbl_name='%q' AND type!='trigger'", 
p
->
zName
));

65010 if( 
db
->
init
.
busy
 )

65013 
Table
 *
pOld
;

65014 
Schema
 *
pSchema
 = 
p
->pSchema;

65016 
pOld
 = 
	`sqlite3HashInsert
(&
pSchema
->
tblHash
, 
p
->
zName
, p);

65017 if( 
pOld
 )

65021 
	`sqlite3OomFault
(
db
);

65024 
pParse
->
pNewTable
 = 0;

65025 
db
->
flags
 |= 0x00000002;

65028 if( !
p
->
pSelect
 )

65031 const char *
zName
 = (const char *)
pParse
->
sNameToken
.
z
;

65032 int 
nName
;

65034 if( 
pCons
->
z
==0 )

65037 
pCons
 = 
pEnd
;

65039 
nName
 = (int)((const char *)
pCons
->
z
 - 
zName
);

65040 
p
->
addColOffset
 = 13 + 
	`sqlite3Utf8CharLen
(
zName
, 
nName
);

65044 
	}
}

65050 static void 
	$sqlite3CreateView
(

65051 
Parse
 *
pParse
,

65052 
Token
 *
pBegin
,

65053 
Token
 *
pName1
,

65054 
Token
 *
pName2
,

65055 
ExprList
 *
pCNames
,

65056 
Select
 *
pSelect
,

65057 int 
isTemp
,

65058 int 
noErr


65062 
Table
 *
p
;

65063 int 
n
;

65064 const char *
z
;

65065 
Token
 
sEnd
;

65066 
DbFixer
 
sFix
;

65067 
Token
 *
pName
 = 0;

65068 int 
iDb
;

65069 
sqlite3
 *
db
 = 
pParse
->db;

65071 if( 
pParse
->
nVar
>0 )

65074 
	`sqlite3ErrorMsg
(
pParse
, "parameters are not allowed in views");

65075 goto 
create_view_fail
;

65077 
	`sqlite3StartTable
(
pParse
, 
pName1
, 
pName2
, 
isTemp
, 1, 0, 
noErr
);

65078 
p
 = 
pParse
->
pNewTable
;

65079 if( 
p
==0 || 
pParse
->
nErr
 ) goto 
create_view_fail
;

65080 
	`sqlite3TwoPartName
(
pParse
, 
pName1
, 
pName2
, &
pName
);

65081 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
p
->
pSchema
);

65082 
	`sqlite3FixInit
(&
sFix
, 
pParse
, 
iDb
, "view", 
pName
);

65083 if( 
	`sqlite3FixSelect
(&
sFix
, 
pSelect
) ) goto 
create_view_fail
;

65090 
p
->
pSelect
 = 
	`sqlite3SelectDup
(
db
, pSelect, 0x0001);

65091 
p
->
pCheck
 = 
	`sqlite3ExprListDup
(
db
, 
pCNames
, 0x0001);

65092 if( 
db
->
mallocFailed
 ) goto 
create_view_fail
;

65097 
sEnd
 = 
pParse
->
sLastToken
;

65099 if( 
sEnd
.
z
[0]!=';' )

65102 
sEnd
.
z
 += sEnd.
n
;

65104 
sEnd
.
n
 = 0;

65105 
n
 = (int)(
sEnd
.
z
 - 
pBegin
->z);

65107 
z
 = 
pBegin
->z;

65108 while( (
sqlite3CtypeMap
[(unsigned char)(
z
[
n
-1])]&0x01) )

65110 
n
--; }

65111 
sEnd
.
z
 = &z[
n
-1];

65112 
sEnd
.
n
 = 1;

65115 
	`sqlite3EndTable
(
pParse
, 0, &
sEnd
, 0, 0);

65117 
create_view_fail
:

65118 
	`sqlite3SelectDelete
(
db
, 
pSelect
);

65119 
	`sqlite3ExprListDelete
(
db
, 
pCNames
);

65121 
	}
}

65123 static int 
	$sqlite3ViewGetColumnNames
(
Parse
 *
pParse
, 
Table
 *
pTable
)

65126 
Table
 *
pSelTab
;

65127 
Select
 *
pSel
;

65128 int 
nErr
 = 0;

65129 int 
n
;

65130 
sqlite3
 *
db
 = 
pParse
->db;

65131 
sqlite3_xauth
 
xAuth
;

65136 if( 
	`sqlite3VtabCallConnect
(
pParse
, 
pTable
) )

65141 if( (((
pTable
)->
tabFlags
 & 0x10)!=0) ) return 0;

65148 if( 
pTable
->
nCol
>0 ) return 0;

65150 if( 
pTable
->
nCol
<0 )

65153 
	`sqlite3ErrorMsg
(
pParse
, "view %s is circularly defined", 
pTable
->
zName
);

65159 if( 
pTable
->
pCheck
 )

65162 
db
->
lookaside
.
bDisable
++;

65163 
	`sqlite3ColumnsFromExprList
(
pParse
, 
pTable
->
pCheck
,

65164 &
pTable
->
nCol
, &pTable->
aCol
);

65165 
db
->
lookaside
.
bDisable
--;

65167 
pSel
 = 
	`sqlite3SelectDup
(
db
, 
pTable
->
pSelect
, 0);

65168 if( 
pSel
 )

65171 
n
 = 
pParse
->
nTab
;

65172 
	`sqlite3SrcListAssignCursors
(
pParse
, 
pSel
->
pSrc
);

65173 
pTable
->
nCol
 = -1;

65174 
db
->
lookaside
.
bDisable
++;

65176 
xAuth
 = 
db
->xAuth;

65177 
db
->
xAuth
 = 0;

65178 
pSelTab
 = 
	`sqlite3ResultSetOfSelect
(
pParse
, 
pSel
);

65179 
db
->
xAuth
 = xAuth;

65183 
db
->
lookaside
.
bDisable
--;

65184 
pParse
->
nTab
 = 
n
;

65185 if( 
pSelTab
 )

65189 
pTable
->
nCol
 = 
pSelTab
->nCol;

65190 
pTable
->
aCol
 = 
pSelTab
->aCol;

65191 
pSelTab
->
nCol
 = 0;

65192 
pSelTab
->
aCol
 = 0;

65193 
	`sqlite3DeleteTable
(
db
, 
pSelTab
);

65196 
pTable
->
nCol
 = 0;

65197 
nErr
++;

65199 
	`sqlite3SelectDelete
(
db
, 
pSel
);

65201 
nErr
++;

65204 
pTable
->
pSchema
->
schemaFlags
 |= 0x0002;

65206 return 
nErr
;

65207 
	}
}

65214 static void 
	$sqliteViewResetAll
(
sqlite3
 *
db
, int 
idx
)

65217 
HashElem
 *
i
;

65219 if( !(((
db
)->
aDb
[
idx
].
pSchema
->
schemaFlags
&(0x0002))==(0x0002)) ) return;

65220 for(
i
=((&
db
->
aDb
[
idx
].
pSchema
->
tblHash
)->
first
); i;i=((i)->
next
))

65223 
Table
 *
pTab
 = ((
i
)->
data
);

65224 if( 
pTab
->
pSelect
 )

65227 
	`sqlite3DeleteColumnNames
(
db
, 
pTab
);

65228 
pTab
->
aCol
 = 0;

65229 
pTab
->
nCol
 = 0;

65232 (
db
)->
aDb
[
idx
].
pSchema
->
schemaFlags
&=~(0x0002);

65233 
	}
}

65235 static void 
	$sqlite3RootPageMoved
(
sqlite3
 *
db
, int 
iDb
, int 
iFrom
, int 
iTo
)

65238 
HashElem
 *
pElem
;

65239 
Hash
 *
pHash
;

65240 
Db
 *
pDb
;

65243 
pDb
 = &
db
->
aDb
[
iDb
];

65244 
pHash
 = &
pDb
->
pSchema
->
tblHash
;

65245 for(
pElem
=((
pHash
)->
first
); pElem; pElem=((pElem)->
next
))

65248 
Table
 *
pTab
 = ((
pElem
)->
data
);

65249 if( 
pTab
->
tnum
==
iFrom
 )

65252 
pTab
->
tnum
 = 
iTo
;

65255 
pHash
 = &
pDb
->
pSchema
->
idxHash
;

65256 for(
pElem
=((
pHash
)->
first
); pElem; pElem=((pElem)->
next
))

65259 
Index
 *
pIdx
 = ((
pElem
)->
data
);

65260 if( 
pIdx
->
tnum
==
iFrom
 )

65263 
pIdx
->
tnum
 = 
iTo
;

65266 
	}
}

65268 static void 
	$destroyRootPage
(
Parse
 *
pParse
, int 
iTable
, int 
iDb
)

65271 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

65272 int 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

65274 
	`sqlite3VdbeAddOp3
(
v
, 118, 
iTable
, 
r1
, 
iDb
);

65275 
	`sqlite3MayAbort
(
pParse
);

65277 
	`sqlite3NestedParse
(
pParse
,

65279 
pParse
->
db
->
aDb
[
iDb
].
zName
, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), 
iTable
, 
r1
, r1);

65281 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

65282 
	}
}

65290 static void 
	$destroyTable
(
Parse
 *
pParse
, 
Table
 *
pTab
)

65294 int 
iTab
 = 
pTab
->
tnum
;

65295 int 
iDestroyed
 = 0;

65300 
Index
 *
pIdx
;

65301 int 
iLargest
 = 0;

65303 if( 
iDestroyed
==0 || 
iTab
<iDestroyed )

65306 
iLargest
 = 
iTab
;

65308 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

65311 int 
iIdx
 = 
pIdx
->
tnum
;

65313 if( (
iDestroyed
==0 || (
iIdx
<iDestroyed)) && iIdx>
iLargest
 )

65316 
iLargest
 = 
iIdx
;

65319 if( 
iLargest
==0 )

65324 int 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

65326 
	`destroyRootPage
(
pParse
, 
iLargest
, 
iDb
);

65327 
iDestroyed
 = 
iLargest
;

65331 
	}
}

65337 static void 
	$sqlite3ClearStatTables
(

65338 
Parse
 *
pParse
,

65339 int 
iDb
,

65340 const char *
zType
,

65341 const char *
zName


65345 int 
i
;

65346 const char *
zDbName
 = 
pParse
->
db
->
aDb
[
iDb
].
zName
;

65347 for(
i
=1; i<=4; i++)

65350 char 
zTab
[24];

65351 
	`sqlite3_snprintf
(sizeof(
zTab
),zTab,"sqlite_stat%d",
i
);

65352 if( 
	`sqlite3FindTable
(
pParse
->
db
, 
zTab
, 
zDbName
) )

65355 
	`sqlite3NestedParse
(
pParse
,

65357 
zDbName
, 
zTab
, 
zType
, 
zName


65361 
	}
}

65366 static void 
	$sqlite3CodeDropTable
(
Parse
 *
pParse
, 
Table
 *
pTab
, int 
iDb
, int 
isView
)

65369 
Vdbe
 *
v
;

65370 
sqlite3
 *
db
 = 
pParse
->db;

65371 
Trigger
 *
pTrigger
;

65372 
Db
 *
pDb
 = &
db
->
aDb
[
iDb
];

65374 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

65376 
	`sqlite3BeginWriteOperation
(
pParse
, 1, 
iDb
);

65379 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

65382 
	`sqlite3VdbeAddOp0
(
v
, 149);

65390 
pTrigger
 = 
	`sqlite3TriggerList
(
pParse
, 
pTab
);

65391 while( 
pTrigger
 )

65396 
	`sqlite3DropTriggerPtr
(
pParse
, 
pTrigger
);

65397 
pTrigger
 = pTrigger->
pNext
;

65406 if( 
pTab
->
tabFlags
 & 0x08 )

65409 
	`sqlite3NestedParse
(
pParse
,

65411 
pDb
->
zName
, 
pTab
->zName

65415 
	`sqlite3NestedParse
(
pParse
,

65417 
pDb
->
zName
, ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master"), 
pTab
->zName);

65418 if( !
isView
 && !(((
pTab
)->
tabFlags
 & 0x10)!=0) )

65421 
	`destroyTable
(
pParse
, 
pTab
);

65427 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

65430 
	`sqlite3VdbeAddOp4
(
v
, 151, 
iDb
, 0, 0, 
pTab
->
zName
, 0);

65432 
	`sqlite3VdbeAddOp4
(
v
, 125, 
iDb
, 0, 0, 
pTab
->
zName
, 0);

65433 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

65434 
	`sqliteViewResetAll
(
db
, 
iDb
);

65435 
	}
}

65441 static void 
	$sqlite3DropTable
(
Parse
 *
pParse
, 
SrcList
 *
pName
, int 
isView
, int 
noErr
)

65444 
Table
 *
pTab
;

65445 
Vdbe
 *
v
;

65446 
sqlite3
 *
db
 = 
pParse
->db;

65447 int 
iDb
;

65449 if( 
db
->
mallocFailed
 )

65452 goto 
exit_drop_table
;

65456 if( 
	`sqlite3ReadSchema
(
pParse
) ) goto 
exit_drop_table
;

65457 if( 
noErr
 ) 
db
->
suppressErr
++;

65458 
pTab
 = 
	`sqlite3LocateTableItem
(
pParse
, 
isView
, &
pName
->
a
[0]);

65459 if( 
noErr
 ) 
db
->
suppressErr
--;

65461 if( 
pTab
==0 )

65464 if( 
noErr
 ) 
	`sqlite3CodeVerifyNamedSchema
(
pParse
, 
pName
->
a
[0].
zDatabase
);

65465 goto 
exit_drop_table
;

65467 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

65473 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) && 
	`sqlite3ViewGetColumnNames
(
pParse
, pTab) )

65476 goto 
exit_drop_table
;

65480 int 
code
;

65481 const char *
zTab
 = ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master");

65482 const char *
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

65483 const char *
zArg2
 = 0;

65484 if( 
	`sqlite3AuthCheck
(
pParse
, 9, 
zTab
, 0, 
zDb
))

65487 goto 
exit_drop_table
;

65489 if( 
isView
 )

65492 if( !0 && 
iDb
==1 )

65495 
code
 = 15;

65497 
code
 = 17;

65500 }else if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

65503 
code
 = 30;

65504 
zArg2
 = 
	`sqlite3GetVTable
(
db
, 
pTab
)->
pMod
->
zName
;

65507 if( !0 && 
iDb
==1 )

65510 
code
 = 13;

65512 
code
 = 11;

65515 if( 
	`sqlite3AuthCheck
(
pParse
, 
code
, 
pTab
->
zName
, 
zArg2
, 
zDb
) )

65518 goto 
exit_drop_table
;

65520 if( 
	`sqlite3AuthCheck
(
pParse
, 9, 
pTab
->
zName
, 0, 
zDb
) )

65523 goto 
exit_drop_table
;

65527 if( 
	`sqlite3_strnicmp
(
pTab
->
zName
, "sqlite_", 7)==0

65528 && 
	`sqlite3_strnicmp
(
pTab
->
zName
, "sqlite_stat", 11)!=0 )

65531 
	`sqlite3ErrorMsg
(
pParse
, "table %s may not be dropped", 
pTab
->
zName
);

65532 goto 
exit_drop_table
;

65539 if( 
isView
 && 
pTab
->
pSelect
==0 )

65542 
	`sqlite3ErrorMsg
(
pParse
, "use DROP TABLE to delete table %s", 
pTab
->
zName
);

65543 goto 
exit_drop_table
;

65545 if( !
isView
 && 
pTab
->
pSelect
 )

65548 
	`sqlite3ErrorMsg
(
pParse
, "use DROP VIEW to delete view %s", 
pTab
->
zName
);

65549 goto 
exit_drop_table
;

65556 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

65557 if( 
v
 )

65560 
	`sqlite3BeginWriteOperation
(
pParse
, 1, 
iDb
);

65561 
	`sqlite3ClearStatTables
(
pParse
, 
iDb
, "tbl", 
pTab
->
zName
);

65562 
	`sqlite3FkDropTable
(
pParse
, 
pName
, 
pTab
);

65563 
	`sqlite3CodeDropTable
(
pParse
, 
pTab
, 
iDb
, 
isView
);

65566 
exit_drop_table
:

65567 
	`sqlite3SrcListDelete
(
db
, 
pName
);

65568 
	}
}

65570 static void 
	$sqlite3CreateForeignKey
(

65571 
Parse
 *
pParse
,

65572 
ExprList
 *
pFromCol
,

65573 
Token
 *
pTo
,

65574 
ExprList
 *
pToCol
,

65575 int 
flags


65579 
sqlite3
 *
db
 = 
pParse
->db;

65581 
FKey
 *
pFKey
 = 0;

65582 
FKey
 *
pNextTo
;

65583 
Table
 *
p
 = 
pParse
->
pNewTable
;

65584 int 
nByte
;

65585 int 
i
;

65586 int 
nCol
;

65587 char *
z
;

65590 if( 
p
==0 || (
pParse
->
declareVtab
) ) goto 
fk_end
;

65591 if( 
pFromCol
==0 )

65594 int 
iCol
 = 
p
->
nCol
-1;

65595 if( (
iCol
<0) ) goto 
fk_end
;

65596 if( 
pToCol
 && pToCol->
nExpr
!=1 )

65599 
	`sqlite3ErrorMsg
(
pParse
, "foreign key on %s"

65601 
p
->
aCol
[
iCol
].
zName
, 
pTo
);

65602 goto 
fk_end
;

65604 
nCol
 = 1;

65605 }else if( 
pToCol
 && pToCol->
nExpr
!=
pFromCol
->nExpr )

65608 
	`sqlite3ErrorMsg
(
pParse
,

65611 goto 
fk_end
;

65613 
nCol
 = 
pFromCol
->
nExpr
;

65615 
nByte
 = sizeof(*
pFKey
) + (
nCol
-1)*sizeof(pFKey->
aCol
[0]) + 
pTo
->
n
 + 1;

65616 if( 
pToCol
 )

65619 for(
i
=0; i<
pToCol
->
nExpr
; i++)

65622 
nByte
 += 
	`sqlite3Strlen30
(
pToCol
->
a
[
i
].
zName
) + 1;

65625 
pFKey
 = 
	`sqlite3DbMallocZero
(
db
, 
nByte
 );

65626 if( 
pFKey
==0 )

65629 goto 
fk_end
;

65631 
pFKey
->
pFrom
 = 
p
;

65632 
pFKey
->
pNextFrom
 = 
p
->pFKey;

65633 
z
 = (char*)&
pFKey
->
aCol
[
nCol
];

65634 
pFKey
->
zTo
 = 
z
;

65635 
	`memcpy
(
z
, 
pTo
->z, pTo->
n
);

65636 
z
[
pTo
->
n
] = 0;

65637 
	`sqlite3Dequote
(
z
);

65638 
z
 += 
pTo
->
n
+1;

65639 
pFKey
->
nCol
 = nCol;

65640 if( 
pFromCol
==0 )

65643 
pFKey
->
aCol
[0].
iFrom
 = 
p
->
nCol
-1;

65645 for(
i
=0; i<
nCol
; i++)

65648 int 
j
;

65649 for(
j
=0; j<
p
->
nCol
; j++)

65652 if( 
	`sqlite3StrICmp
(
p
->
aCol
[
j
].
zName
, 
pFromCol
->
a
[
i
].zName)==0 )

65655 
pFKey
->
aCol
[
i
].
iFrom
 = 
j
;

65659 if( 
j
>=
p
->
nCol
 )

65662 
	`sqlite3ErrorMsg
(
pParse
,

65664 
pFromCol
->
a
[
i
].
zName
);

65665 goto 
fk_end
;

65669 if( 
pToCol
 )

65672 for(
i
=0; i<
nCol
; i++)

65675 int 
n
 = 
	`sqlite3Strlen30
(
pToCol
->
a
[
i
].
zName
);

65676 
pFKey
->
aCol
[
i
].
zCol
 = 
z
;

65677 
	`memcpy
(
z
, 
pToCol
->
a
[
i
].
zName
, 
n
);

65678 
z
[
n
] = 0;

65679 
z
 += 
n
+1;

65682 
pFKey
->
isDeferred
 = 0;

65683 
pFKey
->
aAction
[0] = (
u8
)(
flags
 & 0xff);

65684 
pFKey
->
aAction
[1] = (
u8
)((
flags
 >> 8 ) & 0xff);

65687 
pNextTo
 = (
FKey
 *)
	`sqlite3HashInsert
(&
p
->
pSchema
->
fkeyHash
,

65688 
pFKey
->
zTo
, (void *)pFKey

65690 if( 
pNextTo
==
pFKey
 )

65693 
	`sqlite3OomFault
(
db
);

65694 goto 
fk_end
;

65696 if( 
pNextTo
 )

65700 
pFKey
->
pNextTo
 = pNextTo;

65701 
pNextTo
->
pPrevTo
 = 
pFKey
;

65706 
p
->
pFKey
 = pFKey;

65707 
pFKey
 = 0;

65709 
fk_end
:

65710 
	`sqlite3DbFree
(
db
, 
pFKey
);

65712 
	`sqlite3ExprListDelete
(
db
, 
pFromCol
);

65713 
	`sqlite3ExprListDelete
(
db
, 
pToCol
);

65714 
	}
}

65716 static void 
	$sqlite3DeferForeignKey
(
Parse
 *
pParse
, int 
isDeferred
)

65720 
Table
 *
pTab
;

65721 
FKey
 *
pFKey
;

65722 if( (
pTab
 = 
pParse
->
pNewTable
)==0 || (
pFKey
 = pTab->pFKey)==0 ) return;

65724 
pFKey
->
isDeferred
 = (
u8
)isDeferred;

65726 
	}
}

65728 static void 
	$sqlite3RefillIndex
(
Parse
 *
pParse
, 
Index
 *
pIndex
, int 
memRootPage
)

65731 
Table
 *
pTab
 = 
pIndex
->
pTable
;

65732 int 
iTab
 = 
pParse
->
nTab
++;

65733 int 
iIdx
 = 
pParse
->
nTab
++;

65734 int 
iSorter
;

65735 int 
addr1
;

65736 int 
addr2
;

65737 int 
tnum
;

65738 int 
iPartIdxLabel
;

65739 
Vdbe
 *
v
;

65740 
KeyInfo
 *
pKey
;

65741 int 
regRecord
;

65742 
sqlite3
 *
db
 = 
pParse
->db;

65743 int 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pIndex
->
pSchema
);

65746 if( 
	`sqlite3AuthCheck
(
pParse
, 27, 
pIndex
->
zName
, 0,

65747 
db
->
aDb
[
iDb
].
zName
 ) )

65755 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 1, pTab->
zName
);

65757 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

65758 if( 
v
==0 ) return;

65759 if( 
memRootPage
>=0 )

65762 
tnum
 = 
memRootPage
;

65764 
tnum
 = 
pIndex
->tnum;

65766 
pKey
 = 
	`sqlite3KeyInfoOfIndex
(
pParse
, 
pIndex
);

65769 
iSorter
 = 
pParse
->
nTab
++;

65770 
	`sqlite3VdbeAddOp4
(
v
, 58, 
iSorter
, 0, 
pIndex
->
nKeyCol
, (char*)

65771 
	`sqlite3KeyInfoRef
(
pKey
), (-6));

65775 
	`sqlite3OpenTable
(
pParse
, 
iTab
, 
iDb
, 
pTab
, 54);

65776 
addr1
 = 
	`sqlite3VdbeAddOp2
(
v
, 108, 
iTab
, 0); ;

65777 
regRecord
 = 
	`sqlite3GetTempReg
(
pParse
);

65779 
	`sqlite3GenerateIndexKey
(
pParse
,
pIndex
,
iTab
,
regRecord
,0,&
iPartIdxLabel
,0,0);

65780 
	`sqlite3VdbeAddOp2
(
v
, 109, 
iSorter
, 
regRecord
);

65781 
	`sqlite3ResolvePartIdxLabel
(
pParse
, 
iPartIdxLabel
);

65782 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iTab
, 
addr1
+1); ;

65783 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

65784 if( 
memRootPage
<0 ) 
	`sqlite3VdbeAddOp2
(
v
, 119, 
tnum
, 
iDb
);

65785 
	`sqlite3VdbeAddOp4
(
v
, 55, 
iIdx
, 
tnum
, 
iDb
,

65786 (char *)
pKey
, (-6));

65787 
	`sqlite3VdbeChangeP5
(
v
, 0x01|((
memRootPage
>=0)?0x10:0));

65789 
addr1
 = 
	`sqlite3VdbeAddOp2
(
v
, 106, 
iSorter
, 0); ;

65791 if( ((
pIndex
)->
onError
!=0) && 
pKey
!=0 )

65794 int 
j2
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 3;

65795 
	`sqlite3VdbeGoto
(
v
, 
j2
);

65796 
addr2
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

65797 
	`sqlite3VdbeAddOp4Int
(
v
, 99, 
iSorter
, 
j2
, 
regRecord
,

65798 
pIndex
->
nKeyCol
); ;

65799 
	`sqlite3UniqueConstraint
(
pParse
, 2, 
pIndex
);

65801 
addr2
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

65803 
	`sqlite3VdbeAddOp3
(
v
, 100, 
iSorter
, 
regRecord
, 
iIdx
);

65804 
	`sqlite3VdbeAddOp3
(
v
, 105, 
iIdx
, 0, -1);

65805 
	`sqlite3VdbeAddOp3
(
v
, 110, 
iIdx
, 
regRecord
, 0);

65806 
	`sqlite3VdbeChangeP5
(
v
, 0x10);

65807 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRecord
);

65808 
	`sqlite3VdbeAddOp2
(
v
, 3, 
iSorter
, 
addr2
); ;

65809 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

65811 
	`sqlite3VdbeAddOp1
(
v
, 61, 
iTab
);

65812 
	`sqlite3VdbeAddOp1
(
v
, 61, 
iIdx
);

65813 
	`sqlite3VdbeAddOp1
(
v
, 61, 
iSorter
);

65814 
	}
}

65816 static 
Index
 *
	$sqlite3AllocateIndexObject
(

65817 
sqlite3
 *
db
,

65818 
i16
 
nCol
,

65819 int 
nExtra
,

65820 char **
ppExtra


65824 
Index
 *
p
;

65825 int 
nByte
;

65827 
nByte
 = (((sizeof(
Index
))+7)&~7) +

65828 (((sizeof(char*)*
nCol
)+7)&~7) +

65829 (((sizeof(
LogEst
)*(
nCol
+1) + sizeof(
i16
)*nCol + sizeof(
u8
)*nCol)+7)&~7)

65832 
p
 = 
	`sqlite3DbMallocZero
(
db
, 
nByte
 + 
nExtra
);

65833 if( 
p
 )

65836 char *
pExtra
 = ((char*)
p
)+(((sizeof(
Index
))+7)&~7);

65837 
p
->
azColl
 = (const char**)
pExtra
; pExtra += (((sizeof(char*)*
nCol
)+7)&~7);

65838 
p
->
aiRowLogEst
 = (
LogEst
*)
pExtra
; pExtra += sizeof(LogEst)*(
nCol
+1);

65839 
p
->
aiColumn
 = (
i16
*)
pExtra
; pExtra += sizeof(i16)*
nCol
;

65840 
p
->
aSortOrder
 = (
u8
*)
pExtra
;

65841 
p
->
nColumn
 = 
nCol
;

65842 
p
->
nKeyCol
 = 
nCol
 - 1;

65843 *
ppExtra
 = ((char*)
p
) + 
nByte
;

65845 return 
p
;

65846 
	}
}

65848 static 
Index
 *
	$sqlite3CreateIndex
(

65849 
Parse
 *
pParse
,

65850 
Token
 *
pName1
,

65851 
Token
 *
pName2
,

65852 
SrcList
 *
pTblName
,

65853 
ExprList
 *
pList
,

65854 int 
onError
,

65855 
Token
 *
pStart
,

65856 
Expr
 *
pPIWhere
,

65857 int 
sortOrder
,

65858 int 
ifNotExist


65862 
Index
 *
pRet
 = 0;

65863 
Table
 *
pTab
 = 0;

65864 
Index
 *
pIndex
 = 0;

65865 char *
zName
 = 0;

65866 int 
nName
;

65867 int 
i
, 
j
;

65868 
DbFixer
 
sFix
;

65869 int 
sortOrderMask
;

65870 
sqlite3
 *
db
 = 
pParse
->db;

65871 
Db
 *
pDb
;

65872 int 
iDb
;

65873 
Token
 *
pName
 = 0;

65874 struct 
ExprList_item
 *
pListItem
;

65875 int 
nExtra
 = 0;

65876 int 
nExtraCol
;

65877 char *
zExtra
 = 0;

65878 
Index
 *
pPk
 = 0;

65880 if( 
db
->
mallocFailed
 || (
pParse
->
declareVtab
) || pParse->
nErr
>0 )

65883 goto 
exit_create_index
;

65885 if( 0!=
	`sqlite3ReadSchema
(
pParse
) )

65888 goto 
exit_create_index
;

65894 if( 
pTblName
!=0 )

65903 
iDb
 = 
	`sqlite3TwoPartName
(
pParse
, 
pName1
, 
pName2
, &
pName
);

65904 if( 
iDb
<0 ) goto 
exit_create_index
;

65912 if( !
db
->
init
.
busy
 )

65915 
pTab
 = 
	`sqlite3SrcListLookup
(
pParse
, 
pTblName
);

65916 if( 
pName2
->
n
==0 && 
pTab
 && pTab->
pSchema
==
db
->
aDb
[1].pSchema )

65919 
iDb
 = 1;

65924 
	`sqlite3FixInit
(&
sFix
, 
pParse
, 
iDb
, "index", 
pName
);

65925 if( 
	`sqlite3FixSrcList
(&
sFix
, 
pTblName
) )

65932 
pTab
 = 
	`sqlite3LocateTableItem
(
pParse
, 0, &
pTblName
->
a
[0]);

65934 if( 
pTab
==0 ) goto 
exit_create_index
;

65935 if( 
iDb
==1 && 
db
->
aDb
[iDb].
pSchema
!=
pTab
->pSchema )

65938 
	`sqlite3ErrorMsg
(
pParse
,

65940 
pTab
->
zName
);

65941 goto 
exit_create_index
;

65943 if( !(((
pTab
)->
tabFlags
 & 0x20)==0) ) 
pPk
 = 
	`sqlite3PrimaryKeyIndex
(pTab);

65947 
pTab
 = 
pParse
->
pNewTable
;

65948 if( !
pTab
 ) goto 
exit_create_index
;

65949 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

65951 
pDb
 = &
db
->
aDb
[
iDb
];

65955 if( 
	`sqlite3_strnicmp
(
pTab
->
zName
, "sqlite_", 7)==0

65956 && 
db
->
init
.
busy
==0

65960 && 
	`sqlite3_strnicmp
(&
pTab
->
zName
[7],"altertab_",9)!=0 )

65963 
	`sqlite3ErrorMsg
(
pParse
, "table %s may not be indexed", 
pTab
->
zName
);

65964 goto 
exit_create_index
;

65967 if( 
pTab
->
pSelect
 )

65970 
	`sqlite3ErrorMsg
(
pParse
, "views may not be indexed");

65971 goto 
exit_create_index
;

65975 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

65978 
	`sqlite3ErrorMsg
(
pParse
, "virtual tables may not be indexed");

65979 goto 
exit_create_index
;

65982 if( 
pName
 )

65985 
zName
 = 
	`sqlite3NameFromToken
(
db
, 
pName
);

65986 if( 
zName
==0 ) goto 
exit_create_index
;

65988 if( 0!=
	`sqlite3CheckObjectName
(
pParse
, 
zName
) )

65991 goto 
exit_create_index
;

65993 if( !
db
->
init
.
busy
 )

65996 if( 
	`sqlite3FindTable
(
db
, 
zName
, 0)!=0 )

65999 
	`sqlite3ErrorMsg
(
pParse
, "there is already a table named %s", 
zName
);

66000 goto 
exit_create_index
;

66003 if( 
	`sqlite3FindIndex
(
db
, 
zName
, 
pDb
->zName)!=0 )

66006 if( !
ifNotExist
 )

66009 
	`sqlite3ErrorMsg
(
pParse
, "index %s already exists", 
zName
);

66012 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

66014 goto 
exit_create_index
;

66017 int 
n
;

66018 
Index
 *
pLoop
;

66019 for(
pLoop
=
pTab
->
pIndex
, 
n
=1; pLoop; pLoop=pLoop->
pNext
, n++)

66022 
zName
 = 
	`sqlite3MPrintf
(
db
, "sqlite_autoindex_%s_%d", 
pTab
->zName, 
n
);

66023 if( 
zName
==0 )

66026 goto 
exit_create_index
;

66034 const char *
zDb
 = 
pDb
->
zName
;

66035 if( 
	`sqlite3AuthCheck
(
pParse
, 18, ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master"), 0, 
zDb
) )

66038 goto 
exit_create_index
;

66040 
i
 = 1;

66041 if( !0 && 
iDb
==1 ) 
i
 = 3;

66042 if( 
	`sqlite3AuthCheck
(
pParse
, 
i
, 
zName
, 
pTab
->zName, 
zDb
) )

66045 goto 
exit_create_index
;

66054 if( 
pList
==0 )

66057 
Token
 
prevCol
;

66058 
	`sqlite3TokenInit
(&
prevCol
, 
pTab
->
aCol
[pTab->
nCol
-1].
zName
);

66059 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
, 0,

66060 
	`sqlite3ExprAlloc
(
db
, 27, &
prevCol
, 0));

66061 if( 
pList
==0 ) goto 
exit_create_index
;

66063 
	`sqlite3ExprListSetSortOrder
(
pList
, 
sortOrder
);

66065 
	`sqlite3ExprListCheckLength
(
pParse
, 
pList
, "index");

66071 for(
i
=0; i<
pList
->
nExpr
; i++)

66074 
Expr
 *
pExpr
 = 
pList
->
a
[
i
].pExpr;

66076 if( 
pExpr
->
op
==95 )

66079 
nExtra
 += (1 + 
	`sqlite3Strlen30
(
pExpr
->
u
.
zToken
));

66086 
nName
 = 
	`sqlite3Strlen30
(
zName
);

66087 
nExtraCol
 = 
pPk
 ? pPk->
nKeyCol
 : 1;

66088 
pIndex
 = 
	`sqlite3AllocateIndexObject
(
db
, 
pList
->
nExpr
 + 
nExtraCol
,

66089 
nName
 + 
nExtra
 + 1, &
zExtra
);

66090 if( 
db
->
mallocFailed
 )

66093 goto 
exit_create_index
;

66097 
pIndex
->
zName
 = 
zExtra
;

66098 
zExtra
 += 
nName
 + 1;

66099 
	`memcpy
(
pIndex
->
zName
, zName, 
nName
+1);

66100 
pIndex
->
pTable
 = 
pTab
;

66101 
pIndex
->
onError
 = (
u8
)onError;

66102 
pIndex
->
uniqNotNull
 = 
onError
!=0;

66103 
pIndex
->
idxType
 = 
pName
 ? 0 : 1;

66104 
pIndex
->
pSchema
 = 
db
->
aDb
[
iDb
].pSchema;

66105 
pIndex
->
nKeyCol
 = 
pList
->
nExpr
;

66106 if( 
pPIWhere
 )

66109 
	`sqlite3ResolveSelfReference
(
pParse
, 
pTab
, 0x0010, 
pPIWhere
, 0);

66110 
pIndex
->
pPartIdxWhere
 = 
pPIWhere
;

66111 
pPIWhere
 = 0;

66117 if( 
pDb
->
pSchema
->
file_format
>=4 )

66120 
sortOrderMask
 = -1;

66122 
sortOrderMask
 = 0;

66125 for(
i
=0, 
pListItem
=
pList
->
a
; i<pList->
nExpr
; i++, pListItem++)

66128 
Expr
 *
pCExpr
;

66129 int 
requestedSortOrder
;

66130 const char *
zColl
;

66132 
	`sqlite3StringToId
(
pListItem
->
pExpr
);

66133 
	`sqlite3ResolveSelfReference
(
pParse
, 
pTab
, 0x0020, 
pListItem
->
pExpr
, 0);

66134 if( 
pParse
->
nErr
 ) goto 
exit_create_index
;

66135 
pCExpr
 = 
	`sqlite3ExprSkipCollate
(
pListItem
->
pExpr
);

66136 if( 
pCExpr
->
op
!=152 )

66139 if( 
pTab
==
pParse
->
pNewTable
 )

66142 
	`sqlite3ErrorMsg
(
pParse
, "expressions prohibited in PRIMARY KEY and "

66144 goto 
exit_create_index
;

66146 if( 
pIndex
->
aColExpr
==0 )

66149 
ExprList
 *
pCopy
 = 
	`sqlite3ExprListDup
(
db
, 
pList
, 0);

66150 
pIndex
->
aColExpr
 = 
pCopy
;

66151 if( !
db
->
mallocFailed
 )

66155 
pListItem
 = &
pCopy
->
a
[
i
];

66158 
j
 = (-2);

66159 
pIndex
->
aiColumn
[
i
] = (-2);

66160 
pIndex
->
uniqNotNull
 = 0;

66162 
j
 = 
pCExpr
->
iColumn
;

66164 if( 
j
<0 )

66167 
j
 = 
pTab
->
iPKey
;

66168 }else if( 
pTab
->
aCol
[
j
].
notNull
==0 )

66171 
pIndex
->
uniqNotNull
 = 0;

66173 
pIndex
->
aiColumn
[
i
] = (
i16
)
j
;

66175 
zColl
 = 0;

66176 if( 
pListItem
->
pExpr
->
op
==95 )

66179 int 
nColl
;

66180 
zColl
 = 
pListItem
->
pExpr
->
u
.
zToken
;

66181 
nColl
 = 
	`sqlite3Strlen30
(
zColl
) + 1;

66183 
	`memcpy
(
zExtra
, 
zColl
, 
nColl
);

66184 
zColl
 = 
zExtra
;

66185 
zExtra
 += 
nColl
;

66186 
nExtra
 -= 
nColl
;

66187 }else if( 
j
>=0 )

66190 
zColl
 = 
pTab
->
aCol
[
j
].zColl;

66192 if( !
zColl
 ) zColl = 
sqlite3StrBINARY
;

66193 if( !
db
->
init
.
busy
 && !
	`sqlite3LocateCollSeq
(
pParse
, 
zColl
) )

66196 goto 
exit_create_index
;

66198 
pIndex
->
azColl
[
i
] = 
zColl
;

66199 
requestedSortOrder
 = 
pListItem
->
sortOrder
 & 
sortOrderMask
;

66200 
pIndex
->
aSortOrder
[
i
] = (
u8
)
requestedSortOrder
;

66207 if( 
pPk
 )

66210 for(
j
=0; j<
pPk
->
nKeyCol
; j++)

66213 int 
x
 = 
pPk
->
aiColumn
[
j
];

66215 if( 
	`hasColumn
(
pIndex
->
aiColumn
, pIndex->
nKeyCol
, 
x
) )

66218 
pIndex
->
nColumn
--;

66220 
pIndex
->
aiColumn
[
i
] = 
x
;

66221 
pIndex
->
azColl
[
i
] = 
pPk
->azColl[
j
];

66222 
pIndex
->
aSortOrder
[
i
] = 
pPk
->aSortOrder[
j
];

66223 
i
++;

66228 
pIndex
->
aiColumn
[
i
] = (-1);

66229 
pIndex
->
azColl
[
i
] = 
sqlite3StrBINARY
;

66231 
	`sqlite3DefaultRowEst
(
pIndex
);

66232 if( 
pParse
->
pNewTable
==0 ) 
	`estimateIndexWidth
(
pIndex
);

66238 if( 
pTblName
!=0 && 
pIndex
->
nColumn
>=
pTab
->
nCol
 )

66241 
pIndex
->
isCovering
 = 1;

66242 for(
j
=0; j<
pTab
->
nCol
; j++)

66245 if( 
j
==
pTab
->
iPKey
 ) continue;

66246 if( 
	`sqlite3ColumnOfIndex
(
pIndex
,
j
)>=0 ) continue;

66247 
pIndex
->
isCovering
 = 0;

66252 if( 
pTab
==
pParse
->
pNewTable
 )

66256 
Index
 *
pIdx
;

66257 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

66260 int 
k
;

66265 if( 
pIdx
->
nKeyCol
!=
pIndex
->nKeyCol ) continue;

66266 for(
k
=0; k<
pIdx
->
nKeyCol
; k++)

66269 const char *
z1
;

66270 const char *
z2
;

66272 if( 
pIdx
->
aiColumn
[
k
]!=
pIndex
->aiColumn[k] ) break;

66273 
z1
 = 
pIdx
->
azColl
[
k
];

66274 
z2
 = 
pIndex
->
azColl
[
k
];

66275 if( 
	`sqlite3StrICmp
(
z1
, 
z2
) ) break;

66277 if( 
k
==
pIdx
->
nKeyCol
 )

66280 if( 
pIdx
->
onError
!=
pIndex
->onError )

66290 if( !(
pIdx
->
onError
==10 || 
pIndex
->onError==10) )

66293 
	`sqlite3ErrorMsg
(
pParse
,

66296 if( 
pIdx
->
onError
==10 )

66299 
pIdx
->
onError
 = 
pIndex
->onError;

66302 
pRet
 = 
pIdx
;

66303 goto 
exit_create_index
;

66312 if( 
db
->
init
.
busy
 )

66315 
Index
 *
p
;

66317 
p
 = 
	`sqlite3HashInsert
(&
pIndex
->
pSchema
->
idxHash
,

66318 
pIndex
->
zName
, pIndex);

66319 if( 
p
 )

66323 
	`sqlite3OomFault
(
db
);

66324 goto 
exit_create_index
;

66326 
db
->
flags
 |= 0x00000002;

66327 if( 
pTblName
!=0 )

66330 
pIndex
->
tnum
 = 
db
->
init
.
newTnum
;

66334 else if( (((
pTab
)->
tabFlags
 & 0x20)==0) || 
pTblName
!=0 )

66337 
Vdbe
 *
v
;

66338 char *
zStmt
;

66339 int 
iMem
 = ++
pParse
->
nMem
;

66341 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

66342 if( 
v
==0 ) goto 
exit_create_index
;

66344 
	`sqlite3BeginWriteOperation
(
pParse
, 1, 
iDb
);

66352 
pIndex
->
tnum
 = 
	`sqlite3VdbeAddOp0
(
v
, 160);

66353 
	`sqlite3VdbeAddOp2
(
v
, 121, 
iDb
, 
iMem
);

66358 if( 
pStart
 )

66361 int 
n
 = (int)(
pParse
->
sLastToken
.
z
 - 
pName
->z) + pParse->sLastToken.n;

66362 if( 
pName
->
z
[
n
-1]==';' ) n--;

66364 
zStmt
 = 
	`sqlite3MPrintf
(
db
, "CREATE%s INDEX %.*s",

66365 
onError
==0 ? "" : " UNIQUE", 
n
, 
pName
->
z
);

66369 
zStmt
 = 0;

66374 
	`sqlite3NestedParse
(
pParse
,

66376 
db
->
aDb
[
iDb
].
zName
, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"),

66377 
pIndex
->
zName
,

66378 
pTab
->
zName
,

66379 
iMem
,

66380 
zStmt


66382 
	`sqlite3DbFree
(
db
, 
zStmt
);

66387 if( 
pTblName
 )

66390 
	`sqlite3RefillIndex
(
pParse
, 
pIndex
, 
iMem
);

66391 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

66392 
	`sqlite3VdbeAddParseSchemaOp
(
v
, 
iDb
,

66393 
	`sqlite3MPrintf
(
db
, "name='%q' AND type='index'", 
pIndex
->
zName
));

66394 
	`sqlite3VdbeAddOp1
(
v
, 147, 0);

66397 
	`sqlite3VdbeJumpHere
(
v
, 
pIndex
->
tnum
);

66406 if( 
db
->
init
.
busy
 || 
pTblName
==0 )

66409 if( 
onError
!=5 || 
pTab
->
pIndex
==0

66410 || 
pTab
->
pIndex
->
onError
==5)

66413 
pIndex
->
pNext
 = 
pTab
->pIndex;

66414 
pTab
->
pIndex
 = pIndex;

66416 
Index
 *
pOther
 = 
pTab
->
pIndex
;

66417 while( 
pOther
->
pNext
 && pOther->pNext->
onError
!=5 )

66420 
pOther
 = pOther->
pNext
;

66422 
pIndex
->
pNext
 = 
pOther
->pNext;

66423 
pOther
->
pNext
 = 
pIndex
;

66425 
pRet
 = 
pIndex
;

66426 
pIndex
 = 0;

66430 
exit_create_index
:

66431 if( 
pIndex
 ) 
	`freeIndex
(
db
, pIndex);

66432 
	`sqlite3ExprDelete
(
db
, 
pPIWhere
);

66433 
	`sqlite3ExprListDelete
(
db
, 
pList
);

66434 
	`sqlite3SrcListDelete
(
db
, 
pTblName
);

66435 
	`sqlite3DbFree
(
db
, 
zName
);

66436 return 
pRet
;

66437 
	}
}

66439 static void 
	$sqlite3DefaultRowEst
(
Index
 *
pIdx
)

66443 
LogEst
 
aVal
[] = { 33, 32, 30, 28, 26 };

66444 
LogEst
 *
a
 = 
pIdx
->
aiRowLogEst
;

66445 int 
nCopy
 = ((((int)(sizeof(
aVal
)/sizeof(aVal[0]))))<(
pIdx
->
nKeyCol
)?(((int)(sizeof(aVal)/sizeof(aVal[0])))):(pIdx->nKeyCol));

66446 int 
i
;

66451 
a
[0] = 
pIdx
->
pTable
->
nRowLogEst
;

66452 if( 
a
[0]<33 ) a[0] = 33; ((void) (0));

66456 
	`memcpy
(&
a
[1], 
aVal
, 
nCopy
*sizeof(
LogEst
));

66457 for(
i
=
nCopy
+1; i<=
pIdx
->
nKeyCol
; i++)

66460 
a
[
i
] = 23; ((void) (0));

66464 if( ((
pIdx
)->
onError
!=0) ) 
a
[pIdx->
nKeyCol
] = 0;

66465 
	}
}

66471 static void 
	$sqlite3DropIndex
(
Parse
 *
pParse
, 
SrcList
 *
pName
, int 
ifExists
)

66474 
Index
 *
pIndex
;

66475 
Vdbe
 *
v
;

66476 
sqlite3
 *
db
 = 
pParse
->db;

66477 int 
iDb
;

66480 if( 
db
->
mallocFailed
 )

66483 goto 
exit_drop_index
;

66486 if( 0!=
	`sqlite3ReadSchema
(
pParse
) )

66489 goto 
exit_drop_index
;

66491 
pIndex
 = 
	`sqlite3FindIndex
(
db
, 
pName
->
a
[0].
zName
, pName->a[0].
zDatabase
);

66492 if( 
pIndex
==0 )

66495 if( !
ifExists
 )

66498 
	`sqlite3ErrorMsg
(
pParse
, "no such index: %S", 
pName
, 0);

66500 
	`sqlite3CodeVerifyNamedSchema
(
pParse
, 
pName
->
a
[0].
zDatabase
);

66502 
pParse
->
checkSchema
 = 1;

66503 goto 
exit_drop_index
;

66505 if( 
pIndex
->
idxType
!=0 )

66508 
	`sqlite3ErrorMsg
(
pParse
, "index associated with UNIQUE "

66510 goto 
exit_drop_index
;

66512 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pIndex
->
pSchema
);

66515 int 
code
 = 10;

66516 
Table
 *
pTab
 = 
pIndex
->
pTable
;

66517 const char *
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

66518 const char *
zTab
 = ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master");

66519 if( 
	`sqlite3AuthCheck
(
pParse
, 9, 
zTab
, 0, 
zDb
) )

66522 goto 
exit_drop_index
;

66524 if( !0 && 
iDb
 ) 
code
 = 12;

66525 if( 
	`sqlite3AuthCheck
(
pParse
, 
code
, 
pIndex
->
zName
, 
pTab
->zName, 
zDb
) )

66528 goto 
exit_drop_index
;

66534 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

66535 if( 
v
 )

66538 
	`sqlite3BeginWriteOperation
(
pParse
, 1, 
iDb
);

66539 
	`sqlite3NestedParse
(
pParse
,

66541 
db
->
aDb
[
iDb
].
zName
, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), 
pIndex
->zName

66543 
	`sqlite3ClearStatTables
(
pParse
, 
iDb
, "idx", 
pIndex
->
zName
);

66544 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

66545 
	`destroyRootPage
(
pParse
, 
pIndex
->
tnum
, 
iDb
);

66546 
	`sqlite3VdbeAddOp4
(
v
, 126, 
iDb
, 0, 0, 
pIndex
->
zName
, 0);

66549 
exit_drop_index
:

66550 
	`sqlite3SrcListDelete
(
db
, 
pName
);

66551 
	}
}

66553 static void *
	$sqlite3ArrayAllocate
(

66554 
sqlite3
 *
db
,

66555 void *
pArray
,

66556 int 
szEntry
,

66557 int *
pnEntry
,

66558 int *
pIdx


66562 char *
z
;

66563 int 
n
 = *
pnEntry
;

66564 if( (
n
 & (n-1))==0 )

66567 int 
sz
 = (
n
==0) ? 1 : 2*n;

66568 void *
pNew
 = 
	`sqlite3DbRealloc
(
db
, 
pArray
, 
sz
*
szEntry
);

66569 if( 
pNew
==0 )

66572 *
pIdx
 = -1;

66573 return 
pArray
;

66575 
pArray
 = 
pNew
;

66577 
z
 = (char*)
pArray
;

66578 
	`memset
(&
z
[
n
 * 
szEntry
], 0, szEntry);

66579 *
pIdx
 = 
n
;

66580 ++*
pnEntry
;

66581 return 
pArray
;

66582 
	}
}

66590 static 
IdList
 *
	$sqlite3IdListAppend
(
sqlite3
 *
db
, 
IdList
 *
pList
, 
Token
 *
pToken
)

66593 int 
i
;

66594 if( 
pList
==0 )

66597 
pList
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
IdList
) );

66598 if( 
pList
==0 ) return 0;

66600 
pList
->
a
 = 
	`sqlite3ArrayAllocate
(

66601 
db
,

66602 
pList
->
a
,

66603 sizeof(
pList
->
a
[0]),

66604 &
pList
->
nId
,

66605 &
i


66607 if( 
i
<0 )

66610 
	`sqlite3IdListDelete
(
db
, 
pList
);

66613 
pList
->
a
[
i
].
zName
 = 
	`sqlite3NameFromToken
(
db
, 
pToken
);

66614 return 
pList
;

66615 
	}
}

66620 static void 
	$sqlite3IdListDelete
(
sqlite3
 *
db
, 
IdList
 *
pList
)

66623 int 
i
;

66624 if( 
pList
==0 ) return;

66625 for(
i
=0; i<
pList
->
nId
; i++)

66628 
	`sqlite3DbFree
(
db
, 
pList
->
a
[
i
].
zName
);

66630 
	`sqlite3DbFree
(
db
, 
pList
->
a
);

66631 
	`sqlite3DbFree
(
db
, 
pList
);

66632 
	}
}

66638 static int 
	$sqlite3IdListIndex
(
IdList
 *
pList
, const char *
zName
)

66641 int 
i
;

66642 if( 
pList
==0 ) return -1;

66643 for(
i
=0; i<
pList
->
nId
; i++)

66646 if( 
	`sqlite3StrICmp
(
pList
->
a
[
i
].
zName
, zName)==0 ) return i;

66649 
	}
}

66651 static 
SrcList
 *
	$sqlite3SrcListEnlarge
(

66652 
sqlite3
 *
db
,

66653 
SrcList
 *
pSrc
,

66654 int 
nExtra
,

66655 int 
iStart


66659 int 
i
;

66668 if( (
u32
)
pSrc
->
nSrc
+
nExtra
>pSrc->
nAlloc
 )

66671 
SrcList
 *
pNew
;

66672 int 
nAlloc
 = 
pSrc
->
nSrc
+
nExtra
;

66673 int 
nGot
;

66674 
pNew
 = 
	`sqlite3DbRealloc
(
db
, 
pSrc
,

66675 sizeof(*
pSrc
) + (
nAlloc
-1)*sizeof(pSrc->
a
[0]) );

66676 if( 
pNew
==0 )

66680 return 
pSrc
;

66682 
pSrc
 = 
pNew
;

66683 
nGot
 = (
	`sqlite3DbMallocSize
(
db
, 
pNew
) - sizeof(*
pSrc
))/sizeof(pSrc->
a
[0])+1;

66684 
pSrc
->
nAlloc
 = 
nGot
;

66689 for(
i
=
pSrc
->
nSrc
-1; i>=
iStart
; i--)

66692 
pSrc
->
a
[
i
+
nExtra
] = pSrc->a[i];

66694 
pSrc
->
nSrc
 += 
nExtra
;

66697 
	`memset
(&
pSrc
->
a
[
iStart
], 0, sizeof(pSrc->a[0])*
nExtra
);

66698 for(
i
=
iStart
; i<iStart+
nExtra
; i++)

66701 
pSrc
->
a
[
i
].
iCursor
 = -1;

66705 return 
pSrc
;

66706 
	}
}

66708 static 
SrcList
 *
	$sqlite3SrcListAppend
(

66709 
sqlite3
 *
db
,

66710 
SrcList
 *
pList
,

66711 
Token
 *
pTable
,

66712 
Token
 *
pDatabase


66716 struct 
SrcList_item
 *
pItem
;

66719 if( 
pList
==0 )

66722 
pList
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(
SrcList
) );

66723 if( 
pList
==0 ) return 0;

66724 
pList
->
nAlloc
 = 1;

66725 
pList
->
nSrc
 = 0;

66727 
pList
 = 
	`sqlite3SrcListEnlarge
(
db
, pList, 1, pList->
nSrc
);

66728 if( 
db
->
mallocFailed
 )

66731 
	`sqlite3SrcListDelete
(
db
, 
pList
);

66734 
pItem
 = &
pList
->
a
[pList->
nSrc
-1];

66735 if( 
pDatabase
 && pDatabase->
z
==0 )

66738 
pDatabase
 = 0;

66740 if( 
pDatabase
 )

66743 
Token
 *
pTemp
 = 
pDatabase
;

66744 
pDatabase
 = 
pTable
;

66745 
pTable
 = 
pTemp
;

66747 
pItem
->
zName
 = 
	`sqlite3NameFromToken
(
db
, 
pTable
);

66748 
pItem
->
zDatabase
 = 
	`sqlite3NameFromToken
(
db
, 
pDatabase
);

66749 return 
pList
;

66750 
	}
}

66755 static void 
	$sqlite3SrcListAssignCursors
(
Parse
 *
pParse
, 
SrcList
 *
pList
)

66758 int 
i
;

66759 struct 
SrcList_item
 *
pItem
;

66761 if( 
pList
 )

66764 for(
i
=0, 
pItem
=
pList
->
a
; i<pList->
nSrc
; i++, pItem++)

66767 if( 
pItem
->
iCursor
>=0 ) break;

66768 
pItem
->
iCursor
 = 
pParse
->
nTab
++;

66769 if( 
pItem
->
pSelect
 )

66772 
	`sqlite3SrcListAssignCursors
(
pParse
, 
pItem
->
pSelect
->
pSrc
);

66776 
	}
}

66781 static void 
	$sqlite3SrcListDelete
(
sqlite3
 *
db
, 
SrcList
 *
pList
)

66784 int 
i
;

66785 struct 
SrcList_item
 *
pItem
;

66786 if( 
pList
==0 ) return;

66787 for(
pItem
=
pList
->
a
, 
i
=0; i<pList->
nSrc
; i++, pItem++)

66790 
	`sqlite3DbFree
(
db
, 
pItem
->
zDatabase
);

66791 
	`sqlite3DbFree
(
db
, 
pItem
->
zName
);

66792 
	`sqlite3DbFree
(
db
, 
pItem
->
zAlias
);

66793 if( 
pItem
->
fg
.
isIndexedBy
 ) 
	`sqlite3DbFree
(
db
, pItem->
u1
.
zIndexedBy
);

66794 if( 
pItem
->
fg
.
isTabFunc
 ) 
	`sqlite3ExprListDelete
(
db
, pItem->
u1
.
pFuncArg
);

66795 
	`sqlite3DeleteTable
(
db
, 
pItem
->
pTab
);

66796 
	`sqlite3SelectDelete
(
db
, 
pItem
->
pSelect
);

66797 
	`sqlite3ExprDelete
(
db
, 
pItem
->
pOn
);

66798 
	`sqlite3IdListDelete
(
db
, 
pItem
->
pUsing
);

66800 
	`sqlite3DbFree
(
db
, 
pList
);

66801 
	}
}

66803 static 
SrcList
 *
	$sqlite3SrcListAppendFromTerm
(

66804 
Parse
 *
pParse
,

66805 
SrcList
 *
p
,

66806 
Token
 *
pTable
,

66807 
Token
 *
pDatabase
,

66808 
Token
 *
pAlias
,

66809 
Select
 *
pSubquery
,

66810 
Expr
 *
pOn
,

66811 
IdList
 *
pUsing


66815 struct 
SrcList_item
 *
pItem
;

66816 
sqlite3
 *
db
 = 
pParse
->db;

66817 if( !
p
 && (
pOn
 || 
pUsing
) )

66820 
	`sqlite3ErrorMsg
(
pParse
, "a JOIN clause is required before %s",

66821 (
pOn
 ? "ON" : "USING")

66823 goto 
append_from_error
;

66825 
p
 = 
	`sqlite3SrcListAppend
(
db
, p, 
pTable
, 
pDatabase
);

66826 if( 
p
==0 || (p->
nSrc
==0) )

66829 goto 
append_from_error
;

66831 
pItem
 = &
p
->
a
[p->
nSrc
-1];

66833 if( 
pAlias
->
n
 )

66836 
pItem
->
zAlias
 = 
	`sqlite3NameFromToken
(
db
, 
pAlias
);

66838 
pItem
->
pSelect
 = 
pSubquery
;

66839 
pItem
->
pOn
 = pOn;

66840 
pItem
->
pUsing
 = pUsing;

66841 return 
p
;

66843 
append_from_error
:

66845 
	`sqlite3ExprDelete
(
db
, 
pOn
);

66846 
	`sqlite3IdListDelete
(
db
, 
pUsing
);

66847 
	`sqlite3SelectDelete
(
db
, 
pSubquery
);

66849 
	}
}

66855 static void 
	$sqlite3SrcListIndexedBy
(
Parse
 *
pParse
, 
SrcList
 *
p
, 
Token
 *
pIndexedBy
)

66859 if( 
p
 && (p->
nSrc
>0) )

66862 struct 
SrcList_item
 *
pItem
 = &
p
->
a
[p->
nSrc
-1];

66866 if( 
pIndexedBy
->
n
==1 && !pIndexedBy->
z
 )

66871 
pItem
->
fg
.
notIndexed
 = 1;

66873 
pItem
->
u1
.
zIndexedBy
 = 
	`sqlite3NameFromToken
(
pParse
->
db
, 
pIndexedBy
);

66874 
pItem
->
fg
.
isIndexedBy
 = (pItem->
u1
.
zIndexedBy
!=0);

66877 
	}
}

66883 static void 
	$sqlite3SrcListFuncArgs
(
Parse
 *
pParse
, 
SrcList
 *
p
, 
ExprList
 *
pList
)

66886 if( 
p
 )

66889 struct 
SrcList_item
 *
pItem
 = &
p
->
a
[p->
nSrc
-1];

66893 
pItem
->
u1
.
pFuncArg
 = 
pList
;

66894 
pItem
->
fg
.
isTabFunc
 = 1;

66896 
	`sqlite3ExprListDelete
(
pParse
->
db
, 
pList
);

66898 
	}
}

66900 static void 
	$sqlite3SrcListShiftJoinType
(
SrcList
 *
p
)

66903 if( 
p
 )

66906 int 
i
;

66907 for(
i
=
p
->
nSrc
-1; i>0; i--)

66910 
p
->
a
[
i
].
fg
.
jointype
 = p->a[i-1].fg.jointype;

66912 
p
->
a
[0].
fg
.
jointype
 = 0;

66914 
	}
}

66919 static void 
	$sqlite3BeginTransaction
(
Parse
 *
pParse
, int 
type
)

66922 
sqlite3
 *
db
;

66923 
Vdbe
 *
v
;

66924 int 
i
;

66927 
db
 = 
pParse
->db;

66929 if( 
	`sqlite3AuthCheck
(
pParse
, 22, "BEGIN", 0, 0) )

66934 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

66935 if( !
v
 ) return;

66936 if( 
type
!=7 )

66939 for(
i
=0; i<
db
->
nDb
; i++)

66942 
	`sqlite3VdbeAddOp2
(
v
, 2, 
i
, (
type
==9)+1);

66943 
	`sqlite3VdbeUsesBtree
(
v
, 
i
);

66946 
	`sqlite3VdbeAddOp0
(
v
, 1);

66947 
	}
}

66952 static void 
	$sqlite3CommitTransaction
(
Parse
 *
pParse
)

66955 
Vdbe
 *
v
;

66959 if( 
	`sqlite3AuthCheck
(
pParse
, 22, "COMMIT", 0, 0) )

66964 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

66965 if( 
v
 )

66968 
	`sqlite3VdbeAddOp1
(
v
, 1, 1);

66970 
	}
}

66975 static void 
	$sqlite3RollbackTransaction
(
Parse
 *
pParse
)

66978 
Vdbe
 *
v
;

66982 if( 
	`sqlite3AuthCheck
(
pParse
, 22, "ROLLBACK", 0, 0) )

66987 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

66988 if( 
v
 )

66991 
	`sqlite3VdbeAddOp2
(
v
, 1, 1, 1);

66993 
	}
}

66999 static void 
	$sqlite3Savepoint
(
Parse
 *
pParse
, int 
op
, 
Token
 *
pName
)

67002 char *
zName
 = 
	`sqlite3NameFromToken
(
pParse
->
db
, 
pName
);

67003 if( 
zName
 )

67006 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

67008 static const char * const 
az
[] = { "BEGIN", "RELEASE", "ROLLBACK" };

67011 if( !
v
 || 
	`sqlite3AuthCheck
(
pParse
, 32, 
az
[
op
], 
zName
, 0) )

67014 
	`sqlite3DbFree
(
pParse
->
db
, 
zName
);

67017 
	`sqlite3VdbeAddOp4
(
v
, 0, 
op
, 0, 0, 
zName
, (-1));

67019 
	}
}

67025 static int 
	$sqlite3OpenTempDatabase
(
Parse
 *
pParse
)

67028 
sqlite3
 *
db
 = 
pParse
->db;

67029 if( 
db
->
aDb
[1].
pBt
==0 && !
pParse
->
explain
 )

67032 int 
rc
;

67033 
Btree
 *
pBt
;

67034 static const int 
flags
 =

67041 
rc
 = 
	`sqlite3BtreeOpen
(
db
->
pVfs
, 0, db, &
pBt
, 0, 
flags
);

67042 if( 
rc
!=0 )

67045 
	`sqlite3ErrorMsg
(
pParse
, "unable to open a temporary database "

67047 
pParse
->
rc
 = rc;

67050 
db
->
aDb
[1].
pBt
 = pBt;

67052 if( 7==
	`sqlite3BtreeSetPageSize
(
pBt
, 
db
->
nextPagesize
, -1, 0) )

67055 
	`sqlite3OomFault
(
db
);

67060 
	}
}

67068 static void 
	$sqlite3CodeVerifySchema
(
Parse
 *
pParse
, int 
iDb
)

67071 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

67072 
sqlite3
 *
db
 = 
pToplevel
->db;

67078 if( (((
pToplevel
->
cookieMask
)&(((
yDbMask
)1)<<(
iDb
)))!=0)==0 )

67081 (
pToplevel
->
cookieMask
)|=(((
yDbMask
)1)<<(
iDb
));

67082 
pToplevel
->
cookieValue
[
iDb
] = 
db
->
aDb
[iDb].
pSchema
->
schema_cookie
;

67083 if( !0 && 
iDb
==1 )

67086 
	`sqlite3OpenTempDatabase
(
pToplevel
);

67089 
	}
}

67095 static void 
	$sqlite3CodeVerifyNamedSchema
(
Parse
 *
pParse
, const char *
zDb
)

67098 
sqlite3
 *
db
 = 
pParse
->db;

67099 int 
i
;

67100 for(
i
=0; i<
db
->
nDb
; i++)

67103 
Db
 *
pDb
 = &
db
->
aDb
[
i
];

67104 if( 
pDb
->
pBt
 && (!
zDb
 || 0==
	`sqlite3StrICmp
(zDb, pDb->
zName
)) )

67107 
	`sqlite3CodeVerifySchema
(
pParse
, 
i
);

67110 
	}
}

67112 static void 
	$sqlite3BeginWriteOperation
(
Parse
 *
pParse
, int 
setStatement
, int 
iDb
)

67115 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

67116 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

67117 (
pToplevel
->
writeMask
)|=(((
yDbMask
)1)<<(
iDb
));

67118 
pToplevel
->
isMultiWrite
 |= 
setStatement
;

67119 
	}
}

67121 static void 
	$sqlite3MultiWrite
(
Parse
 *
pParse
)

67124 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

67125 
pToplevel
->
isMultiWrite
 = 1;

67126 
	}
}

67128 static void 
	$sqlite3MayAbort
(
Parse
 *
pParse
)

67131 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

67132 
pToplevel
->
mayAbort
 = 1;

67133 
	}
}

67140 static void 
	$sqlite3HaltConstraint
(

67141 
Parse
 *
pParse
,

67142 int 
errCode
,

67143 int 
onError
,

67144 char *
p4
,

67145 
i8
 
p4type
,

67146 
u8
 
p5Errmsg


67150 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

67152 if( 
onError
==2 )

67155 
	`sqlite3MayAbort
(
pParse
);

67157 
	`sqlite3VdbeAddOp4
(
v
, 21, 
errCode
, 
onError
, 0, 
p4
, 
p4type
);

67158 
	`sqlite3VdbeChangeP5
(
v
, 
p5Errmsg
);

67159 
	}
}

67164 static void 
	$sqlite3UniqueConstraint
(

67165 
Parse
 *
pParse
,

67166 int 
onError
,

67167 
Index
 *
pIdx


67171 char *
zErr
;

67172 int 
j
;

67173 
StrAccum
 
errMsg
;

67174 
Table
 *
pTab
 = 
pIdx
->
pTable
;

67176 
	`sqlite3StrAccumInit
(&
errMsg
, 
pParse
->
db
, 0, 0, 200);

67177 if( 
pIdx
->
aColExpr
 )

67180 
	`sqlite3XPrintf
(&
errMsg
, "index '%q'", 
pIdx
->
zName
);

67182 for(
j
=0; j<
pIdx
->
nKeyCol
; j++)

67185 char *
zCol
;

67187 
zCol
 = 
pTab
->
aCol
[
pIdx
->
aiColumn
[
j
]].
zName
;

67188 if( 
j
 ) 
	`sqlite3StrAccumAppend
(&
errMsg
, ", ", 2);

67189 
	`sqlite3XPrintf
(&
errMsg
, "%s.%s", 
pTab
->
zName
, 
zCol
);

67192 
zErr
 = 
	`sqlite3StrAccumFinish
(&
errMsg
);

67193 
	`sqlite3HaltConstraint
(
pParse
,

67194 ((
pIdx
)->
idxType
==2) ? (19 | (6<<8))

67196 
onError
, 
zErr
, (-1), 2);

67197 
	}
}

67203 static void 
	$sqlite3RowidConstraint
(

67204 
Parse
 *
pParse
,

67205 int 
onError
,

67206 
Table
 *
pTab


67210 char *
zMsg
;

67211 int 
rc
;

67212 if( 
pTab
->
iPKey
>=0 )

67215 
zMsg
 = 
	`sqlite3MPrintf
(
pParse
->
db
, "%s.%s", 
pTab
->
zName
,

67216 
pTab
->
aCol
[pTab->
iPKey
].
zName
);

67217 
rc
 = (19 | (6<<8));

67219 
zMsg
 = 
	`sqlite3MPrintf
(
pParse
->
db
, "%s.rowid", 
pTab
->
zName
);

67220 
rc
 = (19 |(10<<8));

67222 
	`sqlite3HaltConstraint
(
pParse
, 
rc
, 
onError
, 
zMsg
, (-1),

67224 
	}
}

67231 static int 
	$collationMatch
(const char *
zColl
, 
Index
 *
pIndex
)

67234 int 
i
;

67236 for(
i
=0; i<
pIndex
->
nColumn
; i++)

67239 const char *
z
 = 
pIndex
->
azColl
[
i
];

67241 if( 
pIndex
->
aiColumn
[
i
]>=0 && 0==
	`sqlite3StrICmp
(
z
, 
zColl
) )

67248 
	}
}

67256 static void 
	$reindexTable
(
Parse
 *
pParse
, 
Table
 *
pTab
, char const *
zColl
)

67259 
Index
 *
pIndex
;

67261 for(
pIndex
=
pTab
->pIndex; pIndex; pIndex=pIndex->
pNext
)

67264 if( 
zColl
==0 || 
	`collationMatch
(zColl, 
pIndex
) )

67267 int 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

67268 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

67269 
	`sqlite3RefillIndex
(
pParse
, 
pIndex
, -1);

67272 
	}
}

67274 static void 
	$reindexDatabases
(
Parse
 *
pParse
, char const *
zColl
)

67277 
Db
 *
pDb
;

67278 int 
iDb
;

67279 
sqlite3
 *
db
 = 
pParse
->db;

67280 
HashElem
 *
k
;

67281 
Table
 *
pTab
;

67284 for(
iDb
=0, 
pDb
=
db
->
aDb
; iDb<db->
nDb
; iDb++, pDb++)

67288 for(
k
=((&
pDb
->
pSchema
->
tblHash
)->
first
); k; k=((k)->
next
))

67291 
pTab
 = (
Table
*)((
k
)->
data
);

67292 
	`reindexTable
(
pParse
, 
pTab
, 
zColl
);

67295 
	}
}

67297 static void 
	$sqlite3Reindex
(
Parse
 *
pParse
, 
Token
 *
pName1
, Token *
pName2
)

67300 
CollSeq
 *
pColl
;

67301 char *
z
;

67302 const char *
zDb
;

67303 
Table
 *
pTab
;

67304 
Index
 *
pIndex
;

67305 int 
iDb
;

67306 
sqlite3
 *
db
 = 
pParse
->db;

67307 
Token
 *
pObjName
;

67311 if( 0!=
	`sqlite3ReadSchema
(
pParse
) )

67317 if( 
pName1
==0 )

67320 
	`reindexDatabases
(
pParse
, 0);

67322 }else if( (
pName2
==0) || pName2->
z
==0 )

67325 char *
zColl
;

67327 
zColl
 = 
	`sqlite3NameFromToken
(
pParse
->
db
, 
pName1
);

67328 if( !
zColl
 ) return;

67329 
pColl
 = 
	`sqlite3FindCollSeq
(
db
, ((db)->
enc
), 
zColl
, 0);

67330 if( 
pColl
 )

67333 
	`reindexDatabases
(
pParse
, 
zColl
);

67334 
	`sqlite3DbFree
(
db
, 
zColl
);

67337 
	`sqlite3DbFree
(
db
, 
zColl
);

67339 
iDb
 = 
	`sqlite3TwoPartName
(
pParse
, 
pName1
, 
pName2
, &
pObjName
);

67340 if( 
iDb
<0 ) return;

67341 
z
 = 
	`sqlite3NameFromToken
(
db
, 
pObjName
);

67342 if( 
z
==0 ) return;

67343 
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

67344 
pTab
 = 
	`sqlite3FindTable
(
db
, 
z
, 
zDb
);

67345 if( 
pTab
 )

67348 
	`reindexTable
(
pParse
, 
pTab
, 0);

67349 
	`sqlite3DbFree
(
db
, 
z
);

67352 
pIndex
 = 
	`sqlite3FindIndex
(
db
, 
z
, 
zDb
);

67353 
	`sqlite3DbFree
(
db
, 
z
);

67354 if( 
pIndex
 )

67357 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

67358 
	`sqlite3RefillIndex
(
pParse
, 
pIndex
, -1);

67361 
	`sqlite3ErrorMsg
(
pParse
, "unable to identify the object to be reindexed");

67362 
	}
}

67364 static 
KeyInfo
 *
	$sqlite3KeyInfoOfIndex
(
Parse
 *
pParse
, 
Index
 *
pIdx
)

67367 int 
i
;

67368 int 
nCol
 = 
pIdx
->
nColumn
;

67369 int 
nKey
 = 
pIdx
->
nKeyCol
;

67370 
KeyInfo
 *
pKey
;

67371 if( 
pParse
->
nErr
 ) return 0;

67372 if( 
pIdx
->
uniqNotNull
 )

67375 
pKey
 = 
	`sqlite3KeyInfoAlloc
(
pParse
->
db
, 
nKey
, 
nCol
-nKey);

67377 
pKey
 = 
	`sqlite3KeyInfoAlloc
(
pParse
->
db
, 
nCol
, 0);

67379 if( 
pKey
 )

67383 for(
i
=0; i<
nCol
; i++)

67386 const char *
zColl
 = 
pIdx
->
azColl
[
i
];

67387 
pKey
->
aColl
[
i
] = 
zColl
==
sqlite3StrBINARY
 ? 0 :

67388 
	`sqlite3LocateCollSeq
(
pParse
, 
zColl
);

67389 
pKey
->
aSortOrder
[
i
] = 
pIdx
->aSortOrder[i];

67391 if( 
pParse
->
nErr
 )

67394 
	`sqlite3KeyInfoUnref
(
pKey
);

67395 
pKey
 = 0;

67398 return 
pKey
;

67399 
	}
}

67406 static 
With
 *
	$sqlite3WithAdd
(

67407 
Parse
 *
pParse
,

67408 
With
 *
pWith
,

67409 
Token
 *
pName
,

67410 
ExprList
 *
pArglist
,

67411 
Select
 *
pQuery


67415 
sqlite3
 *
db
 = 
pParse
->db;

67416 
With
 *
pNew
;

67417 char *
zName
;

67421 
zName
 = 
	`sqlite3NameFromToken
(
pParse
->
db
, 
pName
);

67422 if( 
zName
 && 
pWith
 )

67425 int 
i
;

67426 for(
i
=0; i<
pWith
->
nCte
; i++)

67429 if( 
	`sqlite3StrICmp
(
zName
, 
pWith
->
a
[
i
].zName)==0 )

67432 
	`sqlite3ErrorMsg
(
pParse
, "duplicate WITH table name: %s", 
zName
);

67437 if( 
pWith
 )

67440 int 
nByte
 = sizeof(*
pWith
) + (sizeof(pWith->
a
[1]) * pWith->
nCte
);

67441 
pNew
 = 
	`sqlite3DbRealloc
(
db
, 
pWith
, 
nByte
);

67443 
pNew
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(*
pWith
));

67447 if( 
db
->
mallocFailed
 )

67450 
	`sqlite3ExprListDelete
(
db
, 
pArglist
);

67451 
	`sqlite3SelectDelete
(
db
, 
pQuery
);

67452 
	`sqlite3DbFree
(
db
, 
zName
);

67453 
pNew
 = 
pWith
;

67455 
pNew
->
a
[pNew->
nCte
].
pSelect
 = 
pQuery
;

67456 
pNew
->
a
[pNew->
nCte
].
pCols
 = 
pArglist
;

67457 
pNew
->
a
[pNew->
nCte
].
zName
 = zName;

67458 
pNew
->
a
[pNew->
nCte
].
zCteErr
 = 0;

67459 
pNew
->
nCte
++;

67462 return 
pNew
;

67463 
	}
}

67468 static void 
	$sqlite3WithDelete
(
sqlite3
 *
db
, 
With
 *
pWith
)

67471 if( 
pWith
 )

67474 int 
i
;

67475 for(
i
=0; i<
pWith
->
nCte
; i++)

67478 struct 
Cte
 *
pCte
 = &
pWith
->
a
[
i
];

67479 
	`sqlite3ExprListDelete
(
db
, 
pCte
->
pCols
);

67480 
	`sqlite3SelectDelete
(
db
, 
pCte
->
pSelect
);

67481 
	`sqlite3DbFree
(
db
, 
pCte
->
zName
);

67483 
	`sqlite3DbFree
(
db
, 
pWith
);

67485 
	}
}

67487 static void 
	$callCollNeeded
(
sqlite3
 *
db
, int 
enc
, const char *
zName
)

67491 if( 
db
->
xCollNeeded
 )

67494 char *
zExternal
 = 
	`sqlite3DbStrDup
(
db
, 
zName
);

67495 if( !
zExternal
 ) return;

67496 
db
->
	`xCollNeeded
(db->
pCollNeededArg
, db, 
enc
, 
zExternal
);

67497 
	`sqlite3DbFree
(
db
, 
zExternal
);

67500 if( 
db
->
xCollNeeded16
 )

67503 char const *
zExternal
;

67504 
sqlite3_value
 *
pTmp
 = 
	`sqlite3ValueNew
(
db
);

67505 
	`sqlite3ValueSetStr
(
pTmp
, -1, 
zName
, 1, ((
sqlite3_destructor_type
)0));

67506 
zExternal
 = 
	`sqlite3ValueText
(
pTmp
, 2);

67507 if( 
zExternal
 )

67510 
db
->
	`xCollNeeded16
(db->
pCollNeededArg
, db, (int)((db)->
enc
), 
zExternal
);

67512 
	`sqlite3ValueFree
(
pTmp
);

67515 
	}
}

67517 static int 
	$synthCollSeq
(
sqlite3
 *
db
, 
CollSeq
 *
pColl
)

67520 
CollSeq
 *
pColl2
;

67521 char *
z
 = 
pColl
->
zName
;

67522 int 
i
;

67523 static const 
u8
 
aEnc
[] = { 3, 2, 1 };

67524 for(
i
=0; i<3; i++)

67527 
pColl2
 = 
	`sqlite3FindCollSeq
(
db
, 
aEnc
[
i
], 
z
, 0);

67528 if( 
pColl2
->
xCmp
!=0 )

67531 
	`memcpy
(
pColl
, 
pColl2
, sizeof(
CollSeq
));

67532 
pColl
->
xDel
 = 0;

67537 
	}
}

67539 static 
CollSeq
 *
	$sqlite3GetCollSeq
(

67540 
Parse
 *
pParse
,

67541 
u8
 
enc
,

67542 
CollSeq
 *
pColl
,

67543 const char *
zName


67547 
CollSeq
 *
p
;

67548 
sqlite3
 *
db
 = 
pParse
->db;

67550 
p
 = 
pColl
;

67551 if( !
p
 )

67554 
p
 = 
	`sqlite3FindCollSeq
(
db
, 
enc
, 
zName
, 0);

67556 if( !
p
 || !p->
xCmp
 )

67562 
	`callCollNeeded
(
db
, 
enc
, 
zName
);

67563 
p
 = 
	`sqlite3FindCollSeq
(
db
, 
enc
, 
zName
, 0);

67565 if( 
p
 && !p->
xCmp
 && 
	`synthCollSeq
(
db
, p) )

67568 
p
 = 0;

67571 if( 
p
==0 )

67574 
	`sqlite3ErrorMsg
(
pParse
, "no such collation sequence: %s", 
zName
);

67576 return 
p
;

67577 
	}
}

67579 static int 
	$sqlite3CheckCollSeq
(
Parse
 *
pParse
, 
CollSeq
 *
pColl
)

67582 if( 
pColl
 )

67585 const char *
zName
 = 
pColl
->zName;

67586 
sqlite3
 *
db
 = 
pParse
->db;

67587 
CollSeq
 *
p
 = 
	`sqlite3GetCollSeq
(
pParse
, ((
db
)->
enc
), 
pColl
, 
zName
);

67588 if( !
p
 )

67596 
	}
}

67598 static 
CollSeq
 *
	$findCollSeqEntry
(

67599 
sqlite3
 *
db
,

67600 const char *
zName
,

67601 int 
create


67605 
CollSeq
 *
pColl
;

67606 
pColl
 = 
	`sqlite3HashFind
(&
db
->
aCollSeq
, 
zName
);

67608 if( 0==
pColl
 && 
create
 )

67611 int 
nName
 = 
	`sqlite3Strlen30
(
zName
);

67612 
pColl
 = 
	`sqlite3DbMallocZero
(
db
, 3*sizeof(*pColl) + 
nName
 + 1);

67613 if( 
pColl
 )

67616 
CollSeq
 *
pDel
 = 0;

67617 
pColl
[0].
zName
 = (char*)&pColl[3];

67618 
pColl
[0].
enc
 = 1;

67619 
pColl
[1].
zName
 = (char*)&pColl[3];

67620 
pColl
[1].
enc
 = 2;

67621 
pColl
[2].
zName
 = (char*)&pColl[3];

67622 
pColl
[2].
enc
 = 3;

67623 
	`memcpy
(
pColl
[0].
zName
, zName, 
nName
);

67624 
pColl
[0].
zName
[
nName
] = 0;

67625 
pDel
 = 
	`sqlite3HashInsert
(&
db
->
aCollSeq
, 
pColl
[0].
zName
, pColl);

67632 if( 
pDel
!=0 )

67635 
	`sqlite3OomFault
(
db
);

67636 
	`sqlite3DbFree
(
db
, 
pDel
);

67637 
pColl
 = 0;

67641 return 
pColl
;

67642 
	}
}

67644 static 
CollSeq
 *
	$sqlite3FindCollSeq
(

67645 
sqlite3
 *
db
,

67646 
u8
 
enc
,

67647 const char *
zName
,

67648 int 
create


67652 
CollSeq
 *
pColl
;

67653 if( 
zName
 )

67656 
pColl
 = 
	`findCollSeqEntry
(
db
, 
zName
, 
create
);

67658 
pColl
 = 
db
->
pDfltColl
;

67662 if( 
pColl
 ) pColl += 
enc
-1;

67663 return 
pColl
;

67664 
	}
}

67666 static int 
	$matchQuality
(

67667 
FuncDef
 *
p
,

67668 int 
nArg
,

67669 
u8
 
enc


67673 int 
match
;

67676 if( 
nArg
==(-2) ) return (
p
->
xSFunc
==0) ? 0 : 6;

67679 if( 
p
->
nArg
!=nArg && p->nArg>=0 ) return 0;

67683 if( 
p
->
nArg
==nArg )

67686 
match
 = 4;

67688 
match
 = 1;

67692 if( 
enc
==(
p
->
funcFlags
 & 0x0003) )

67695 
match
 += 2;

67696 }else if( (
enc
 & 
p
->
funcFlags
 & 2)!=0 )

67699 
match
 += 1;

67702 return 
match
;

67703 
	}
}

67709 static 
FuncDef
 *
	$functionSearch
(

67710 int 
h
,

67711 const char *
zFunc


67715 
FuncDef
 *
p
;

67716 for(
p
=
sqlite3BuiltinFunctions
.
a
[
h
]; p; p=p->
u
.
pHash
)

67719 if( 
	`sqlite3StrICmp
(
p
->
zName
, 
zFunc
)==0 )

67722 return 
p
;

67726 
	}
}

67731 static void 
	$sqlite3InsertBuiltinFuncs
(

67732 
FuncDef
 *
aDef
,

67733 int 
nDef


67737 int 
i
;

67738 for(
i
=0; i<
nDef
; i++)

67741 
FuncDef
 *
pOther
;

67742 const char *
zName
 = 
aDef
[
i
].zName;

67743 int 
nName
 = 
	`sqlite3Strlen30
(
zName
);

67744 int 
h
 = (
sqlite3UpperToLower
[(
u8
)
zName
[0]] + 
nName
) % 23;

67745 
pOther
 = 
	`functionSearch
(
h
, 
zName
);

67746 if( 
pOther
 )

67750 
aDef
[
i
].
pNext
 = 
pOther
->pNext;

67751 
pOther
->
pNext
 = &
aDef
[
i
];

67753 
aDef
[
i
].
pNext
 = 0;

67754 
aDef
[
i
].
u
.
pHash
 = 
sqlite3BuiltinFunctions
.
a
[
h
];

67755 
sqlite3BuiltinFunctions
.
a
[
h
] = &
aDef
[
i
];

67758 
	}
}

67760 static 
FuncDef
 *
	$sqlite3FindFunction
(

67761 
sqlite3
 *
db
,

67762 const char *
zName
,

67763 int 
nArg
,

67764 
u8
 
enc
,

67765 
u8
 
createFlag


67769 
FuncDef
 *
p
;

67770 
FuncDef
 *
pBest
 = 0;

67771 int 
bestScore
 = 0;

67772 int 
h
;

67773 int 
nName
;

67777 
nName
 = 
	`sqlite3Strlen30
(
zName
);

67781 
p
 = (
FuncDef
*)
	`sqlite3HashFind
(&
db
->
aFunc
, 
zName
);

67782 while( 
p
 )

67785 int 
score
 = 
	`matchQuality
(
p
, 
nArg
, 
enc
);

67786 if( 
score
>
bestScore
 )

67789 
pBest
 = 
p
;

67790 
bestScore
 = 
score
;

67792 
p
 = p->
pNext
;

67795 if( !
createFlag
 && (
pBest
==0 || (
db
->
flags
 & 0x00200000)!=0) )

67798 
bestScore
 = 0;

67799 
h
 = (
sqlite3UpperToLower
[(
u8
)
zName
[0]] + 
nName
) % 23;

67800 
p
 = 
	`functionSearch
(
h
, 
zName
);

67801 while( 
p
 )

67804 int 
score
 = 
	`matchQuality
(
p
, 
nArg
, 
enc
);

67805 if( 
score
>
bestScore
 )

67808 
pBest
 = 
p
;

67809 
bestScore
 = 
score
;

67811 
p
 = p->
pNext
;

67819 if( 
createFlag
 && 
bestScore
<6 &&

67820 (
pBest
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(*pBest)+
nName
+1))!=0 )

67823 
FuncDef
 *
pOther
;

67824 
pBest
->
zName
 = (const char*)&pBest[1];

67825 
pBest
->
nArg
 = (
u16
)nArg;

67826 
pBest
->
funcFlags
 = 
enc
;

67827 
	`memcpy
((char*)&
pBest
[1], 
zName
, 
nName
+1);

67828 
pOther
 = (
FuncDef
*)
	`sqlite3HashInsert
(&
db
->
aFunc
, 
pBest
->
zName
, pBest);

67829 if( 
pOther
==
pBest
 )

67832 
	`sqlite3DbFree
(
db
, 
pBest
);

67833 
	`sqlite3OomFault
(
db
);

67836 
pBest
->
pNext
 = 
pOther
;

67840 if( 
pBest
 && (pBest->
xSFunc
 || 
createFlag
) )

67843 return 
pBest
;

67846 
	}
}

67848 static void 
	$sqlite3SchemaClear
(void *
p
)

67851 
Hash
 
temp1
;

67852 
Hash
 
temp2
;

67853 
HashElem
 *
pElem
;

67854 
Schema
 *
pSchema
 = (Schema *)
p
;

67856 
temp1
 = 
pSchema
->
tblHash
;

67857 
temp2
 = 
pSchema
->
trigHash
;

67858 
	`sqlite3HashInit
(&
pSchema
->
trigHash
);

67859 
	`sqlite3HashClear
(&
pSchema
->
idxHash
);

67860 for(
pElem
=((&
temp2
)->
first
); pElem; pElem=((pElem)->
next
))

67863 
	`sqlite3DeleteTrigger
(0, (
Trigger
*)((
pElem
)->
data
));

67865 
	`sqlite3HashClear
(&
temp2
);

67866 
	`sqlite3HashInit
(&
pSchema
->
tblHash
);

67867 for(
pElem
=((&
temp1
)->
first
); pElem; pElem=((pElem)->
next
))

67870 
Table
 *
pTab
 = ((
pElem
)->
data
);

67871 
	`sqlite3DeleteTable
(0, 
pTab
);

67873 
	`sqlite3HashClear
(&
temp1
);

67874 
	`sqlite3HashClear
(&
pSchema
->
fkeyHash
);

67875 
pSchema
->
pSeqTab
 = 0;

67876 if( 
pSchema
->
schemaFlags
 & 0x0001 )

67879 
pSchema
->
iGeneration
++;

67880 
pSchema
->
schemaFlags
 &= ~0x0001;

67882 
	}
}

67888 static 
Schema
 *
	$sqlite3SchemaGet
(
sqlite3
 *
db
, 
Btree
 *
pBt
)

67891 
Schema
 * 
p
;

67892 if( 
pBt
 )

67895 
p
 = (
Schema
 *)
	`sqlite3BtreeSchema
(
pBt
, sizeof(Schema), 
sqlite3SchemaClear
);

67897 
p
 = (
Schema
 *)
	`sqlite3DbMallocZero
(0, sizeof(Schema));

67899 if( !
p
 )

67902 
	`sqlite3OomFault
(
db
);

67903 }else if ( 0==
p
->
file_format
 )

67906 
	`sqlite3HashInit
(&
p
->
tblHash
);

67907 
	`sqlite3HashInit
(&
p
->
idxHash
);

67908 
	`sqlite3HashInit
(&
p
->
trigHash
);

67909 
	`sqlite3HashInit
(&
p
->
fkeyHash
);

67910 
p
->
enc
 = 1;

67912 return 
p
;

67913 
	}
}

67915 static 
Table
 *
	$sqlite3SrcListLookup
(
Parse
 *
pParse
, 
SrcList
 *
pSrc
)

67918 struct 
SrcList_item
 *
pItem
 = 
pSrc
->
a
;

67919 
Table
 *
pTab
;

67921 
pTab
 = 
	`sqlite3LocateTableItem
(
pParse
, 0, 
pItem
);

67922 
	`sqlite3DeleteTable
(
pParse
->
db
, 
pItem
->
pTab
);

67923 
pItem
->
pTab
 = pTab;

67924 if( 
pTab
 )

67927 
pTab
->
nRef
++;

67929 if( 
	`sqlite3IndexedByLookup
(
pParse
, 
pItem
) )

67932 
pTab
 = 0;

67934 return 
pTab
;

67935 
	}
}

67942 static int 
	$sqlite3IsReadOnly
(
Parse
 *
pParse
, 
Table
 *
pTab
, int 
viewOk
)

67946 if( ( (((
pTab
)->
tabFlags
 & 0x10)!=0)

67947 && 
	`sqlite3GetVTable
(
pParse
->
db
, 
pTab
)->
pMod
->
pModule
->
xUpdate
==0 )

67948 || ( (
pTab
->
tabFlags
 & 0x01)!=0

67949 && (
pParse
->
db
->
flags
 & 0x00000800)==0

67950 && 
pParse
->
nested
==0 )

67954 
	`sqlite3ErrorMsg
(
pParse
, "table %s may not be modified", 
pTab
->
zName
);

67959 if( !
viewOk
 && 
pTab
->
pSelect
 )

67962 
	`sqlite3ErrorMsg
(
pParse
,"cannot modify %s because it is a view",
pTab
->
zName
);

67967 
	}
}

67969 static void 
	$sqlite3MaterializeView
(

67970 
Parse
 *
pParse
,

67971 
Table
 *
pView
,

67972 
Expr
 *
pWhere
,

67973 int 
iCur


67977 
SelectDest
 
dest
;

67978 
Select
 *
pSel
;

67979 
SrcList
 *
pFrom
;

67980 
sqlite3
 *
db
 = 
pParse
->db;

67981 int 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pView
->
pSchema
);

67982 
pWhere
 = 
	`sqlite3ExprDup
(
db
, pWhere, 0);

67983 
pFrom
 = 
	`sqlite3SrcListAppend
(
db
, 0, 0, 0);

67984 if( 
pFrom
 )

67988 
pFrom
->
a
[0].
zName
 = 
	`sqlite3DbStrDup
(
db
, 
pView
->zName);

67989 
pFrom
->
a
[0].
zDatabase
 = 
	`sqlite3DbStrDup
(
db
, db->
aDb
[
iDb
].
zName
);

67993 
pSel
 = 
	`sqlite3SelectNew
(
pParse
, 0, 
pFrom
, 
pWhere
, 0, 0, 0,

67995 
	`sqlite3SelectDestInit
(&
dest
, 12, 
iCur
);

67996 
	`sqlite3Select
(
pParse
, 
pSel
, &
dest
);

67997 
	`sqlite3SelectDelete
(
db
, 
pSel
);

67998 
	}
}

68000 static void 
	$sqlite3DeleteFrom
(

68001 
Parse
 *
pParse
,

68002 
SrcList
 *
pTabList
,

68003 
Expr
 *
pWhere


68007 
Vdbe
 *
v
;

68008 
Table
 *
pTab
;

68009 const char *
zDb
;

68010 int 
i
;

68011 
WhereInfo
 *
pWInfo
;

68012 
Index
 *
pIdx
;

68013 int 
iTabCur
;

68014 int 
iDataCur
 = 0;

68015 int 
iIdxCur
 = 0;

68016 int 
nIdx
;

68017 
sqlite3
 *
db
;

68018 
AuthContext
 
sContext
;

68019 
NameContext
 
sNC
;

68020 int 
iDb
;

68021 int 
memCnt
 = -1;

68022 int 
rcauth
;

68023 int 
eOnePass
;

68024 int 
aiCurOnePass
[2];

68025 
u8
 *
aToOpen
 = 0;

68026 
Index
 *
pPk
;

68027 int 
iPk
 = 0;

68028 
i16
 
nPk
 = 1;

68029 int 
iKey
;

68030 
i16
 
nKey
;

68031 int 
iEphCur
 = 0;

68032 int 
iRowSet
 = 0;

68033 int 
addrBypass
 = 0;

68034 int 
addrLoop
 = 0;

68035 int 
addrEphOpen
 = 0;

68038 int 
isView
;

68039 
Trigger
 *
pTrigger
;

68040 int 
bComplex
;

68043 
	`memset
(&
sContext
, 0, sizeof(sContext));

68044 
db
 = 
pParse
->db;

68045 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 )

68048 goto 
delete_from_cleanup
;

68057 
pTab
 = 
	`sqlite3SrcListLookup
(
pParse
, 
pTabList
);

68058 if( 
pTab
==0 ) goto 
delete_from_cleanup
;

68064 
pTrigger
 = 
	`sqlite3TriggersExist
(
pParse
, 
pTab
, 109, 0, 0);

68065 
isView
 = 
pTab
->
pSelect
!=0;

68066 
bComplex
 = 
pTrigger
 || 
	`sqlite3FkRequired
(
pParse
, 
pTab
, 0, 0);

68068 if( 
	`sqlite3ViewGetColumnNames
(
pParse
, 
pTab
) )

68071 goto 
delete_from_cleanup
;

68074 if( 
	`sqlite3IsReadOnly
(
pParse
, 
pTab
, (
pTrigger
?1:0)) )

68077 goto 
delete_from_cleanup
;

68079 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

68081 
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

68082 
rcauth
 = 
	`sqlite3AuthCheck
(
pParse
, 9, 
pTab
->
zName
, 0, 
zDb
);

68084 if( 
rcauth
==1 )

68087 goto 
delete_from_cleanup
;

68094 
iTabCur
 = 
pTabList
->
a
[0].
iCursor
 = 
pParse
->
nTab
++;

68095 for(
nIdx
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, nIdx++)

68098 
pParse
->
nTab
++;

68103 if( 
isView
 )

68106 
	`sqlite3AuthContextPush
(
pParse
, &
sContext
, 
pTab
->
zName
);

68111 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

68112 if( 
v
==0 )

68115 goto 
delete_from_cleanup
;

68117 if( 
pParse
->
nested
==0 ) 
	`sqlite3VdbeCountChanges
(
v
);

68118 
	`sqlite3BeginWriteOperation
(
pParse
, 1, 
iDb
);

68124 if( 
isView
 )

68127 
	`sqlite3MaterializeView
(
pParse
, 
pTab
, 
pWhere
, 
iTabCur
);

68128 
iDataCur
 = 
iIdxCur
 = 
iTabCur
;

68134 
	`memset
(&
sNC
, 0, sizeof(sNC));

68135 
sNC
.
pParse
 = pParse;

68136 
sNC
.
pSrcList
 = 
pTabList
;

68137 if( 
	`sqlite3ResolveExprNames
(&
sNC
, 
pWhere
) )

68140 goto 
delete_from_cleanup
;

68146 if( 
db
->
flags
 & 0x00000080 )

68149 
memCnt
 = ++
pParse
->
nMem
;

68150 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
memCnt
);

68158 if( 
rcauth
==0

68159 && 
pWhere
==0

68160 && !
bComplex


68161 && !(((
pTab
)->
tabFlags
 & 0x10)!=0)

68166 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 1, pTab->
zName
);

68167 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

68170 
	`sqlite3VdbeAddOp4
(
v
, 119, 
pTab
->
tnum
, 
iDb
, 
memCnt
,

68171 
pTab
->
zName
, (-2));

68173 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

68177 
	`sqlite3VdbeAddOp2
(
v
, 119, 
pIdx
->
tnum
, 
iDb
);

68182 
u16
 
wcf
 = 0x0004|0x0008;

68183 
wcf
 |= (
bComplex
 ? 0 : 0x2000);

68184 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

68188 
pPk
 = 0;

68189 
nPk
 = 1;

68190 
iRowSet
 = ++
pParse
->
nMem
;

68191 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
iRowSet
);

68195 
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

68197 
nPk
 = 
pPk
->
nKeyCol
;

68198 
iPk
 = 
pParse
->
nMem
+1;

68199 
pParse
->
nMem
 += 
nPk
;

68200 
iEphCur
 = 
pParse
->
nTab
++;

68201 
addrEphOpen
 = 
	`sqlite3VdbeAddOp2
(
v
, 57, 
iEphCur
, 
nPk
);

68202 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pPk
);

68205 
pWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pTabList
, 
pWhere
, 0, 0, 
wcf
, 
iTabCur
+1);

68206 if( 
pWInfo
==0 ) goto 
delete_from_cleanup
;

68207 
eOnePass
 = 
	`sqlite3WhereOkOnePass
(
pWInfo
, 
aiCurOnePass
);

68212 if( 
db
->
flags
 & 0x00000080 )

68215 
	`sqlite3VdbeAddOp2
(
v
, 37, 
memCnt
, 1);

68219 if( 
pPk
 )

68222 for(
i
=0; i<
nPk
; i++)

68226 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 
iTabCur
,

68227 
pPk
->
aiColumn
[
i
], 
iPk
+i);

68229 
iKey
 = 
iPk
;

68231 
iKey
 = 
pParse
->
nMem
 + 1;

68232 
iKey
 = 
	`sqlite3ExprCodeGetColumn
(
pParse
, 
pTab
, -1, 
iTabCur
, iKey, 0);

68233 if( 
iKey
>
pParse
->
nMem
 ) pParse->nMem = iKey;

68236 if( 
eOnePass
!=0 )

68242 
nKey
 = 
nPk
;

68243 
aToOpen
 = 
	`sqlite3DbMallocRawNN
(
db
, 
nIdx
+2);

68244 if( 
aToOpen
==0 )

68247 
	`sqlite3WhereEnd
(
pWInfo
);

68248 goto 
delete_from_cleanup
;

68250 
	`memset
(
aToOpen
, 1, 
nIdx
+1);

68251 
aToOpen
[
nIdx
+1] = 0;

68252 if( 
aiCurOnePass
[0]>=0 ) 
aToOpen
[aiCurOnePass[0]-
iTabCur
] = 0;

68253 if( 
aiCurOnePass
[1]>=0 ) 
aToOpen
[aiCurOnePass[1]-
iTabCur
] = 0;

68254 if( 
addrEphOpen
 ) 
	`sqlite3VdbeChangeToNoop
(
v
, addrEphOpen);

68256 if( 
pPk
 )

68260 
iKey
 = ++
pParse
->
nMem
;

68261 
nKey
 = 0;

68262 
	`sqlite3VdbeAddOp4
(
v
, 49, 
iPk
, 
nPk
, 
iKey
,

68263 
	`sqlite3IndexAffinityStr
(
pParse
->
db
, 
pPk
), 
nPk
);

68264 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iEphCur
, 
iKey
);

68267 
nKey
 = 1;

68268 
	`sqlite3VdbeAddOp2
(
v
, 129, 
iRowSet
, 
iKey
);

68274 if( 
eOnePass
!=0 )

68277 
addrBypass
 = 
	`sqlite3VdbeMakeLabel
(
v
);

68279 
	`sqlite3WhereEnd
(
pWInfo
);

68287 if( !
isView
 )

68290 int 
iAddrOnce
 = 0;

68291 if( 
eOnePass
==2 )

68294 
iAddrOnce
 = 
	`sqlite3CodeOnce
(
pParse
); ;

68297 
	`sqlite3OpenTableAndIndices
(
pParse
, 
pTab
, 55, 0x08,

68298 
iTabCur
, 
aToOpen
, &
iDataCur
, &
iIdxCur
);

68301 if( 
eOnePass
==2 ) 
	`sqlite3VdbeJumpHere
(
v
, 
iAddrOnce
);

68307 if( 
eOnePass
!=0 )

68311 if( !(((
pTab
)->
tabFlags
 & 0x10)!=0) && 
aToOpen
[
iDataCur
-
iTabCur
] )

68315 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
iDataCur
, 
addrBypass
, 
iKey
, 
nKey
);

68318 }else if( 
pPk
 )

68321 
addrLoop
 = 
	`sqlite3VdbeAddOp1
(
v
, 108, 
iEphCur
); ;

68322 
	`sqlite3VdbeAddOp2
(
v
, 101, 
iEphCur
, 
iKey
);

68325 
addrLoop
 = 
	`sqlite3VdbeAddOp3
(
v
, 130, 
iRowSet
, 0, 
iKey
);

68332 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

68335 const char *
pVTab
 = (const char *)
	`sqlite3GetVTable
(
db
, 
pTab
);

68336 
	`sqlite3VtabMakeWritable
(
pParse
, 
pTab
);

68337 
	`sqlite3VdbeAddOp4
(
v
, 12, 0, 1, 
iKey
, 
pVTab
, (-10));

68338 
	`sqlite3VdbeChangeP5
(
v
, 2);

68340 
	`sqlite3MayAbort
(
pParse
);

68341 if( 
eOnePass
==1 && ((
pParse
)->
pToplevel
==0) )

68344 
pParse
->
isMultiWrite
 = 0;

68349 int 
count
 = (
pParse
->
nested
==0);

68350 int 
iIdxNoSeek
 = -1;

68351 if( 
bComplex
==0 && 
aiCurOnePass
[1]!=
iDataCur
 )

68354 
iIdxNoSeek
 = 
aiCurOnePass
[1];

68356 
	`sqlite3GenerateRowDelete
(
pParse
, 
pTab
, 
pTrigger
, 
iDataCur
, 
iIdxCur
,

68357 
iKey
, 
nKey
, 
count
, 10, 
eOnePass
, 
iIdxNoSeek
);

68361 if( 
eOnePass
!=0 )

68364 
	`sqlite3VdbeResolveLabel
(
v
, 
addrBypass
);

68365 
	`sqlite3WhereEnd
(
pWInfo
);

68366 }else if( 
pPk
 )

68369 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iEphCur
, 
addrLoop
+1); ;

68370 
	`sqlite3VdbeJumpHere
(
v
, 
addrLoop
);

68372 
	`sqlite3VdbeGoto
(
v
, 
addrLoop
);

68373 
	`sqlite3VdbeJumpHere
(
v
, 
addrLoop
);

68377 if( !
isView
 && !(((
pTab
)->
tabFlags
 & 0x10)!=0) )

68380 if( !
pPk
 ) 
	`sqlite3VdbeAddOp1
(
v
, 61, 
iDataCur
);

68381 for(
i
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; i++, pIdx=pIdx->
pNext
)

68384 
	`sqlite3VdbeAddOp1
(
v
, 61, 
iIdxCur
 + 
i
);

68393 if( 
pParse
->
nested
==0 && pParse->
pTriggerTab
==0 )

68396 
	`sqlite3AutoincrementEnd
(
pParse
);

68403 if( (
db
->
flags
&0x00000080) && !
pParse
->
nested
 && !pParse->
pTriggerTab
 )

68406 
	`sqlite3VdbeAddOp2
(
v
, 33, 
memCnt
, 1);

68407 
	`sqlite3VdbeSetNumCols
(
v
, 1);

68408 
	`sqlite3VdbeSetColName
(
v
, 0, 0, "rows deleted", ((
sqlite3_destructor_type
)0));

68411 
delete_from_cleanup
:

68412 
	`sqlite3AuthContextPop
(&
sContext
);

68413 
	`sqlite3SrcListDelete
(
db
, 
pTabList
);

68414 
	`sqlite3ExprDelete
(
db
, 
pWhere
);

68415 
	`sqlite3DbFree
(
db
, 
aToOpen
);

68417 
	}
}

68419 static void 
	$sqlite3GenerateRowDelete
(

68420 
Parse
 *
pParse
,

68421 
Table
 *
pTab
,

68422 
Trigger
 *
pTrigger
,

68423 int 
iDataCur
,

68424 int 
iIdxCur
,

68425 int 
iPk
,

68426 
i16
 
nPk
,

68427 
u8
 
count
,

68428 
u8
 
onconf
,

68429 
u8
 
eMode
,

68430 int 
iIdxNoSeek


68434 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

68435 int 
iOld
 = 0;

68436 int 
iLabel
;

68437 
u8
 
opSeek
;

68447 
iLabel
 = 
	`sqlite3VdbeMakeLabel
(
v
);

68448 
opSeek
 = (((
pTab
)->
tabFlags
 & 0x20)==0) ? 70 : 68;

68449 if( 
eMode
==0 )

68452 
	`sqlite3VdbeAddOp4Int
(
v
, 
opSeek
, 
iDataCur
, 
iLabel
, 
iPk
, 
nPk
);

68459 if( 
	`sqlite3FkRequired
(
pParse
, 
pTab
, 0, 0) || 
pTrigger
 )

68462 
u32
 
mask
;

68463 int 
iCol
;

68464 int 
addrStart
;

68468 
mask
 = 
	`sqlite3TriggerColmask
(

68469 
pParse
, 
pTrigger
, 0, 0, 1|2, 
pTab
, 
onconf


68471 
mask
 |= 
	`sqlite3FkOldmask
(
pParse
, 
pTab
);

68472 
iOld
 = 
pParse
->
nMem
+1;

68473 
pParse
->
nMem
 += (1 + 
pTab
->
nCol
);

68477 
	`sqlite3VdbeAddOp2
(
v
, 30, 
iPk
, 
iOld
);

68478 for(
iCol
=0; iCol<
pTab
->
nCol
; iCol++)

68483 if( 
mask
==0xffffffff || (
iCol
<=31 && (mask & (((unsigned int)1)<<(iCol)))!=0) )

68486 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 
iDataCur
, 
iCol
, 
iOld
+iCol+1);

68491 
addrStart
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

68492 
	`sqlite3CodeRowTrigger
(
pParse
, 
pTrigger
,

68493 109, 0, 1, 
pTab
, 
iOld
, 
onconf
, 
iLabel


68501 if( 
addrStart
<
	`sqlite3VdbeCurrentAddr
(
v
) )

68504 
	`sqlite3VdbeAddOp4Int
(
v
, 
opSeek
, 
iDataCur
, 
iLabel
, 
iPk
, 
nPk
);

68512 
	`sqlite3FkCheck
(
pParse
, 
pTab
, 
iOld
, 0, 0, 0);

68518 if( 
pTab
->
pSelect
==0 )

68521 
u8
 
p5
 = 0;

68522 
	`sqlite3GenerateRowIndexDelete
(
pParse
, 
pTab
, 
iDataCur
, 
iIdxCur
,0,
iIdxNoSeek
);

68523 
	`sqlite3VdbeAddOp2
(
v
, 95, 
iDataCur
, (
count
?0x01:0));

68524 if( 
count
 )

68527 
	`sqlite3VdbeChangeP4
(
v
, -1, 
pTab
->
zName
, 0);

68529 if( 
eMode
!=0 )

68532 
	`sqlite3VdbeChangeP5
(
v
, 0x04);

68534 if( 
iIdxNoSeek
>=0 )

68537 
	`sqlite3VdbeAddOp1
(
v
, 95, 
iIdxNoSeek
);

68539 if( 
eMode
==2 ) 
p5
 |= 0x02;

68540 
	`sqlite3VdbeChangeP5
(
v
, 
p5
);

68546 
	`sqlite3FkActions
(
pParse
, 
pTab
, 0, 
iOld
, 0, 0);

68549 
	`sqlite3CodeRowTrigger
(
pParse
, 
pTrigger
,

68550 109, 0, 2, 
pTab
, 
iOld
, 
onconf
, 
iLabel


68556 
	`sqlite3VdbeResolveLabel
(
v
, 
iLabel
);

68558 
	}
}

68560 static void 
	$sqlite3GenerateRowIndexDelete
(

68561 
Parse
 *
pParse
,

68562 
Table
 *
pTab
,

68563 int 
iDataCur
,

68564 int 
iIdxCur
,

68565 int *
aRegIdx
,

68566 int 
iIdxNoSeek


68570 int 
i
;

68571 int 
r1
 = -1;

68572 int 
iPartIdxLabel
;

68573 
Index
 *
pIdx
;

68574 
Index
 *
pPrior
 = 0;

68575 
Vdbe
 *
v
;

68576 
Index
 *
pPk
;

68578 
v
 = 
pParse
->
pVdbe
;

68579 
pPk
 = (((
pTab
)->
tabFlags
 & 0x20)==0) ? 0 : 
	`sqlite3PrimaryKeyIndex
(pTab);

68580 for(
i
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; i++, pIdx=pIdx->
pNext
)

68584 if( 
aRegIdx
!=0 && aRegIdx[
i
]==0 ) continue;

68585 if( 
pIdx
==
pPk
 ) continue;

68586 if( 
iIdxCur
+
i
==
iIdxNoSeek
 ) continue;

68588 
r1
 = 
	`sqlite3GenerateIndexKey
(
pParse
, 
pIdx
, 
iDataCur
, 0, 1,

68589 &
iPartIdxLabel
, 
pPrior
, 
r1
);

68590 
	`sqlite3VdbeAddOp3
(
v
, 111, 
iIdxCur
+
i
, 
r1
,

68591 
pIdx
->
uniqNotNull
 ? pIdx->
nKeyCol
 : pIdx->
nColumn
);

68592 
	`sqlite3ResolvePartIdxLabel
(
pParse
, 
iPartIdxLabel
);

68593 
pPrior
 = 
pIdx
;

68595 
	}
}

68597 static int 
	$sqlite3GenerateIndexKey
(

68598 
Parse
 *
pParse
,

68599 
Index
 *
pIdx
,

68600 int 
iDataCur
,

68601 int 
regOut
,

68602 int 
prefixOnly
,

68603 int *
piPartIdxLabel
,

68604 
Index
 *
pPrior
,

68605 int 
regPrior


68609 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

68610 int 
j
;

68611 int 
regBase
;

68612 int 
nCol
;

68614 if( 
piPartIdxLabel
 )

68617 if( 
pIdx
->
pPartIdxWhere
 )

68620 *
piPartIdxLabel
 = 
	`sqlite3VdbeMakeLabel
(
v
);

68621 
pParse
->
iSelfTab
 = 
iDataCur
;

68622 
	`sqlite3ExprCachePush
(
pParse
);

68623 
	`sqlite3ExprIfFalseDup
(
pParse
, 
pIdx
->
pPartIdxWhere
, *
piPartIdxLabel
,

68626 *
piPartIdxLabel
 = 0;

68629 
nCol
 = (
prefixOnly
 && 
pIdx
->
uniqNotNull
) ? pIdx->
nKeyCol
 : pIdx->
nColumn
;

68630 
regBase
 = 
	`sqlite3GetTempRange
(
pParse
, 
nCol
);

68631 if( 
pPrior
 && (
regBase
!=
regPrior
 || pPrior->
pPartIdxWhere
) ) pPrior = 0;

68632 for(
j
=0; j<
nCol
; j++)

68635 if( 
pPrior


68636 && 
pPrior
->
aiColumn
[
j
]==
pIdx
->aiColumn[j]

68637 && 
pPrior
->
aiColumn
[
j
]!=(-2)

68644 
	`sqlite3ExprCodeLoadIndexColumn
(
pParse
, 
pIdx
, 
iDataCur
, 
j
, 
regBase
+j);

68651 
	`sqlite3VdbeDeletePriorOpcode
(
v
, 39);

68653 if( 
regOut
 )

68656 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regBase
, 
nCol
, 
regOut
);

68658 
	`sqlite3ReleaseTempRange
(
pParse
, 
regBase
, 
nCol
);

68659 return 
regBase
;

68660 
	}
}

68667 static void 
	$sqlite3ResolvePartIdxLabel
(
Parse
 *
pParse
, int 
iLabel
)

68670 if( 
iLabel
 )

68673 
	`sqlite3VdbeResolveLabel
(
pParse
->
pVdbe
, 
iLabel
);

68674 
	`sqlite3ExprCachePop
(
pParse
);

68676 
	}
}

68678 static 
CollSeq
 *
	$sqlite3GetFuncCollSeq
(
sqlite3_context
 *
context
)

68681 
VdbeOp
 *
pOp
;

68683 
pOp
 = &
context
->
pVdbe
->
aOp
[context->
iOp
-1];

68686 return 
pOp
->
p4
.
pColl
;

68687 
	}
}

68693 static void 
	$sqlite3SkipAccumulatorLoad
(
sqlite3_context
 *
context
)

68696 
context
->
skipFlag
 = 1;

68697 
	}
}

68702 static void 
	$minmaxFunc
(

68703 
sqlite3_context
 *
context
,

68704 int 
argc
,

68705 
sqlite3_value
 **
argv


68709 int 
i
;

68710 int 
mask
;

68711 int 
iBest
;

68712 
CollSeq
 *
pColl
;

68715 
mask
 = 
	`sqlite3_user_data
(
context
)==0 ? 0 : -1;

68716 
pColl
 = 
	`sqlite3GetFuncCollSeq
(
context
);

68719 
iBest
 = 0;

68720 if( 
	`sqlite3_value_type
(
argv
[0])==5 ) return;

68721 for(
i
=1; i<
argc
; i++)

68724 if( 
	`sqlite3_value_type
(
argv
[
i
])==5 ) return;

68725 if( (
	`sqlite3MemCompare
(
argv
[
iBest
], argv[
i
], 
pColl
)^
mask
)>=0 )

68729 
iBest
 = 
i
;

68732 
	`sqlite3_result_value
(
context
, 
argv
[
iBest
]);

68733 
	}
}

68738 static void 
	$typeofFunc
(

68739 
sqlite3_context
 *
context
,

68740 int 
NotUsed
,

68741 
sqlite3_value
 **
argv


68745 const char *
z
 = 0;

68746 (void)(
NotUsed
);

68747 switch( 
	`sqlite3_value_type
(
argv
[0]) )

68750 case 1: 
z
 = "integer"; break;

68751 case 3: 
z
 = "text"; break;

68752 case 2: 
z
 = "real"; break;

68753 case 4: 
z
 = "blob"; break;

68754 default: 
z
 = "null"; break;

68756 
	`sqlite3_result_text
(
context
, 
z
, -1, ((
sqlite3_destructor_type
)0));

68757 
	}
}

68763 static void 
	$lengthFunc
(

68764 
sqlite3_context
 *
context
,

68765 int 
argc
,

68766 
sqlite3_value
 **
argv


68770 int 
len
;

68773 (void)(
argc
);

68774 switch( 
	`sqlite3_value_type
(
argv
[0]) )

68780 
	`sqlite3_result_int
(
context
, 
	`sqlite3_value_bytes
(
argv
[0]));

68784 const unsigned char *
z
 = 
	`sqlite3_value_text
(
argv
[0]);

68785 if( 
z
==0 ) return;

68786 
len
 = 0;

68787 while( *
z
 )

68790 
len
++;

68791 { if( (*(
z
++))>=0xc0 )

68793 while( (*
z
 & 0xc0)==0x80 )

68795 
z
++; } } };

68797 
	`sqlite3_result_int
(
context
, 
len
);

68801 
	`sqlite3_result_null
(
context
);

68805 
	}
}

68813 static void 
	$absFunc
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

68817 (void)(
argc
);

68818 switch( 
	`sqlite3_value_type
(
argv
[0]) )

68822 
i64
 
iVal
 = 
	`sqlite3_value_int64
(
argv
[0]);

68823 if( 
iVal
<0 )

68826 if( 
iVal
==(((
i64
)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) )

68832 
	`sqlite3_result_error
(
context
, "integer overflow", -1);

68835 
iVal
 = -iVal;

68837 
	`sqlite3_result_int64
(
context
, 
iVal
);

68842 
	`sqlite3_result_null
(
context
);

68851 double 
rVal
 = 
	`sqlite3_value_double
(
argv
[0]);

68852 if( 
rVal
<0 ) rVal = -rVal;

68853 
	`sqlite3_result_double
(
context
, 
rVal
);

68857 
	}
}

68859 static void 
	$instrFunc
(

68860 
sqlite3_context
 *
context
,

68861 int 
argc
,

68862 
sqlite3_value
 **
argv


68866 const unsigned char *
zHaystack
;

68867 const unsigned char *
zNeedle
;

68868 int 
nHaystack
;

68869 int 
nNeedle
;

68870 int 
typeHaystack
, 
typeNeedle
;

68871 int 
N
 = 1;

68872 int 
isText
;

68874 (void)(
argc
);

68875 
typeHaystack
 = 
	`sqlite3_value_type
(
argv
[0]);

68876 
typeNeedle
 = 
	`sqlite3_value_type
(
argv
[1]);

68877 if( 
typeHaystack
==5 || 
typeNeedle
==5 ) return;

68878 
nHaystack
 = 
	`sqlite3_value_bytes
(
argv
[0]);

68879 
nNeedle
 = 
	`sqlite3_value_bytes
(
argv
[1]);

68880 if( 
typeHaystack
==4 && 
typeNeedle
==4 )

68883 
zHaystack
 = 
	`sqlite3_value_blob
(
argv
[0]);

68884 
zNeedle
 = 
	`sqlite3_value_blob
(
argv
[1]);

68885 
isText
 = 0;

68887 
zHaystack
 = 
	`sqlite3_value_text
(
argv
[0]);

68888 
zNeedle
 = 
	`sqlite3_value_text
(
argv
[1]);

68889 
isText
 = 1;

68891 while( 
nNeedle
<=
nHaystack
 && 
	`memcmp
(
zHaystack
, 
zNeedle
, nNeedle)!=0 )

68894 
N
++;

68896 
nHaystack
--;

68897 
zHaystack
++;

68898 }while( 
isText
 && (
zHaystack
[0]&0xc0)==0x80 );

68900 if( 
nNeedle
>
nHaystack
 ) 
N
 = 0;

68901 
	`sqlite3_result_int
(
context
, 
N
);

68902 
	}
}

68907 static void 
	$printfFunc
(

68908 
sqlite3_context
 *
context
,

68909 int 
argc
,

68910 
sqlite3_value
 **
argv


68914 
PrintfArguments
 
x
;

68915 
StrAccum
 
str
;

68916 const char *
zFormat
;

68917 int 
n
;

68918 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

68920 if( 
argc
>=1 && (
zFormat
 = (const char*)
	`sqlite3_value_text
(
argv
[0]))!=0 )

68923 
x
.
nArg
 = 
argc
-1;

68924 
x
.
nUsed
 = 0;

68925 
x
.
apArg
 = 
argv
+1;

68926 
	`sqlite3StrAccumInit
(&
str
, 
db
, 0, 0, db->
aLimit
[0]);

68927 
str
.
printfFlags
 = 0x02;

68928 
	`sqlite3XPrintf
(&
str
, 
zFormat
, &
x
);

68929 
n
 = 
str
.
nChar
;

68930 
	`sqlite3_result_text
(
context
, 
	`sqlite3StrAccumFinish
(&
str
), 
n
,

68931 ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

68933 
	}
}

68935 static void 
	$substrFunc
(

68936 
sqlite3_context
 *
context
,

68937 int 
argc
,

68938 
sqlite3_value
 **
argv


68942 const unsigned char *
z
;

68943 const unsigned char *
z2
;

68944 int 
len
;

68945 int 
p0type
;

68946 
i64
 
p1
, 
p2
;

68947 int 
negP2
 = 0;

68950 if( 
	`sqlite3_value_type
(
argv
[1])==5

68951 || (
argc
==3 && 
	`sqlite3_value_type
(
argv
[2])==5)

68957 
p0type
 = 
	`sqlite3_value_type
(
argv
[0]);

68958 
p1
 = 
	`sqlite3_value_int
(
argv
[1]);

68959 if( 
p0type
==4 )

68962 
len
 = 
	`sqlite3_value_bytes
(
argv
[0]);

68963 
z
 = 
	`sqlite3_value_blob
(
argv
[0]);

68964 if( 
z
==0 ) return;

68967 
z
 = 
	`sqlite3_value_text
(
argv
[0]);

68968 if( 
z
==0 ) return;

68969 
len
 = 0;

68970 if( 
p1
<0 )

68973 for(
z2
=
z
; *z2; 
len
++)

68976 { if( (*(
z2
++))>=0xc0 )

68978 while( (*
z2
 & 0xc0)==0x80 )

68980 
z2
++; } } };

68985 if( 
argc
==3 )

68988 
p2
 = 
	`sqlite3_value_int
(
argv
[2]);

68989 if( 
p2
<0 )

68992 
p2
 = -p2;

68993 
negP2
 = 1;

68996 
p2
 = 
	`sqlite3_context_db_handle
(
context
)->
aLimit
[0];

68998 if( 
p1
<0 )

69001 
p1
 += 
len
;

69002 if( 
p1
<0 )

69005 
p2
 += 
p1
;

69006 if( 
p2
<0 ) p2 = 0;

69007 
p1
 = 0;

69009 }else if( 
p1
>0 )

69012 
p1
--;

69013 }else if( 
p2
>0 )

69016 
p2
--;

69018 if( 
negP2
 )

69021 
p1
 -= 
p2
;

69022 if( 
p1
<0 )

69025 
p2
 += 
p1
;

69026 
p1
 = 0;

69030 if( 
p0type
!=4 )

69033 while( *
z
 && 
p1
 )

69036 { if( (*(
z
++))>=0xc0 )

69038 while( (*
z
 & 0xc0)==0x80 )

69040 
z
++; } } };

69041 
p1
--;

69043 for(
z2
=
z
; *z2 && 
p2
; p2--)

69046 { if( (*(
z2
++))>=0xc0 )

69048 while( (*
z2
 & 0xc0)==0x80 )

69050 
z2
++; } } };

69052 
	`sqlite3_result_text64
(
context
, (char*)
z
, 
z2
-z, ((
sqlite3_destructor_type
)-1),

69055 if( 
p1
+
p2
>
len
 )

69058 
p2
 = 
len
-
p1
;

69059 if( 
p2
<0 ) p2 = 0;

69061 
	`sqlite3_result_blob64
(
context
, (char*)&
z
[
p1
], (
u64
)
p2
, ((
sqlite3_destructor_type
)-1));

69063 
	}
}

69069 static void 
	$roundFunc
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

69072 int 
n
 = 0;

69073 double 
r
;

69074 char *
zBuf
;

69076 if( 
argc
==2 )

69079 if( 5==
	`sqlite3_value_type
(
argv
[1]) ) return;

69080 
n
 = 
	`sqlite3_value_int
(
argv
[1]);

69081 if( 
n
>30 ) n = 30;

69082 if( 
n
<0 ) n = 0;

69084 if( 
	`sqlite3_value_type
(
argv
[0])==5 ) return;

69085 
r
 = 
	`sqlite3_value_double
(
argv
[0]);

69090 if( 
n
==0 && 
r
>=0 && r<(0xffffffff|(((
i64
)0x7fffffff)<<32))-1 )

69093 
r
 = (double)((
sqlite_int64
)(r+0.5));

69094 }else if( 
n
==0 && 
r
<0 && (-r)<(0xffffffff|(((
i64
)0x7fffffff)<<32))-1 )

69097 
r
 = -(double)((
sqlite_int64
)((-r)+0.5));

69099 
zBuf
 = 
	`sqlite3_mprintf
("%.*f",
n
,
r
);

69100 if( 
zBuf
==0 )

69103 
	`sqlite3_result_error_nomem
(
context
);

69106 
	`sqlite3AtoF
(
zBuf
, &
r
, 
	`sqlite3Strlen30
(zBuf), 1);

69107 
	`sqlite3_free
(
zBuf
);

69109 
	`sqlite3_result_double
(
context
, 
r
);

69110 
	}
}

69112 static void *
	$contextMalloc
(
sqlite3_context
 *
context
, 
i64
 
nByte
)

69115 char *
z
;

69116 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

69120 if( 
nByte
>
db
->
aLimit
[0] )

69123 
	`sqlite3_result_error_toobig
(
context
);

69124 
z
 = 0;

69126 
z
 = 
	`sqlite3Malloc
(
nByte
);

69127 if( !
z
 )

69130 
	`sqlite3_result_error_nomem
(
context
);

69133 return 
z
;

69134 
	}
}

69139 static void 
	$upperFunc
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

69142 char *
z1
;

69143 const char *
z2
;

69144 int 
i
, 
n
;

69145 (void)(
argc
);

69146 
z2
 = (char*)
	`sqlite3_value_text
(
argv
[0]);

69147 
n
 = 
	`sqlite3_value_bytes
(
argv
[0]);

69150 if( 
z2
 )

69153 
z1
 = 
	`contextMalloc
(
context
, ((
i64
)
n
)+1);

69154 if( 
z1
 )

69157 for(
i
=0; i<
n
; i++)

69160 
z1
[
i
] = (char)((
z2
[i])&~(
sqlite3CtypeMap
[(unsigned char)(z2[i])]&0x20));

69162 
	`sqlite3_result_text
(
context
, 
z1
, 
n
, 
sqlite3_free
);

69165 
	}
}

69166 static void 
	$lowerFunc
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

69169 char *
z1
;

69170 const char *
z2
;

69171 int 
i
, 
n
;

69172 (void)(
argc
);

69173 
z2
 = (char*)
	`sqlite3_value_text
(
argv
[0]);

69174 
n
 = 
	`sqlite3_value_bytes
(
argv
[0]);

69177 if( 
z2
 )

69180 
z1
 = 
	`contextMalloc
(
context
, ((
i64
)
n
)+1);

69181 if( 
z1
 )

69184 for(
i
=0; i<
n
; i++)

69187 
z1
[
i
] = (
sqlite3UpperToLower
[(unsigned char)(
z2
[i])]);

69189 
	`sqlite3_result_text
(
context
, 
z1
, 
n
, 
sqlite3_free
);

69192 
	}
}

69194 static void 
	$randomFunc
(

69195 
sqlite3_context
 *
context
,

69196 int 
NotUsed
,

69197 
sqlite3_value
 **
NotUsed2


69201 
sqlite_int64
 
r
;

69202 (void)(
NotUsed
),(void)(
NotUsed2
);

69203 
	`sqlite3_randomness
(sizeof(
r
), &r);

69204 if( 
r
<0 )

69208 
r
 = -(r & (0xffffffff|(((
i64
)0x7fffffff)<<32)));

69210 
	`sqlite3_result_int64
(
context
, 
r
);

69211 
	}
}

69217 static void 
	$randomBlob
(

69218 
sqlite3_context
 *
context
,

69219 int 
argc
,

69220 
sqlite3_value
 **
argv


69224 int 
n
;

69225 unsigned char *
p
;

69227 (void)(
argc
);

69228 
n
 = 
	`sqlite3_value_int
(
argv
[0]);

69229 if( 
n
<1 )

69232 
n
 = 1;

69234 
p
 = 
	`contextMalloc
(
context
, 
n
);

69235 if( 
p
 )

69238 
	`sqlite3_randomness
(
n
, 
p
);

69239 
	`sqlite3_result_blob
(
context
, (char*)
p
, 
n
, 
sqlite3_free
);

69241 
	}
}

69247 static void 
	$last_insert_rowid
(

69248 
sqlite3_context
 *
context
,

69249 int 
NotUsed
,

69250 
sqlite3_value
 **
NotUsed2


69254 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

69255 (void)(
NotUsed
),(void)(
NotUsed2
);

69259 
	`sqlite3_result_int64
(
context
, 
	`sqlite3_last_insert_rowid
(
db
));

69260 
	}
}

69262 static void 
	$changes
(

69263 
sqlite3_context
 *
context
,

69264 int 
NotUsed
,

69265 
sqlite3_value
 **
NotUsed2


69269 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

69270 (void)(
NotUsed
),(void)(
NotUsed2
);

69271 
	`sqlite3_result_int
(
context
, 
	`sqlite3_changes
(
db
));

69272 
	}
}

69278 static void 
	$total_changes
(

69279 
sqlite3_context
 *
context
,

69280 int 
NotUsed
,

69281 
sqlite3_value
 **
NotUsed2


69285 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

69286 (void)(
NotUsed
),(void)(
NotUsed2
);

69289 
	`sqlite3_result_int
(
context
, 
	`sqlite3_total_changes
(
db
));

69290 
	}
}

69295 struct 
	scompareInfo
 {

69296 
u8
 
	mmatchAll
;

69297 
u8
 
	mmatchOne
;

69298 
u8
 
	mmatchSet
;

69299 
u8
 
	mnoCase
;

69302 static const struct 
compareInfo
 
	gglobInfo
 = { '*', '?', '[', 0 };

69305 static const struct 
compareInfo
 
	glikeInfoNorm
 = { '%', '_', 0, 1 };

69308 static const struct 
compareInfo
 
	glikeInfoAlt
 = { '%', '_', 0, 0 };

69310 static int 
	$patternCompare
(

69311 const 
u8
 *
zPattern
,

69312 const 
u8
 *
zString
,

69313 const struct 
compareInfo
 *
pInfo
,

69314 
u32
 
matchOther


69318 
u32
 
c
, 
c2
;

69319 
u32
 
matchOne
 = 
pInfo
->matchOne;

69320 
u32
 
matchAll
 = 
pInfo
->matchAll;

69321 
u8
 
noCase
 = 
pInfo
->noCase;

69322 const 
u8
 *
zEscaped
 = 0;

69324 while( (
c
 = (
zPattern
[0]<0x80?*(zPattern++):
	`sqlite3Utf8Read
(&zPattern)))!=0 )

69327 if( 
c
==
matchAll
 )

69333 while( (
c
=(
zPattern
[0]<0x80?*(zPattern++):
	`sqlite3Utf8Read
(&zPattern))) == 
matchAll
 || c == 
matchOne
 )

69336 if( 
c
==
matchOne
 && 
	`sqlite3Utf8Read
(&
zString
)==0 )

69342 if( 
c
==0 )

69346 }else if( 
c
==
matchOther
 )

69349 if( 
pInfo
->
matchSet
==0 )

69352 
c
 = 
	`sqlite3Utf8Read
(&
zPattern
);

69353 if( 
c
==0 ) return 0;

69358 while( *
zString


69359 && 
	`patternCompare
(&
zPattern
[-1],
zString
,
pInfo
,
matchOther
)==0 )

69362 { if( (*(
zString
++))>=0xc0 )

69364 while( (*
zString
 & 0xc0)==0x80 )

69366 
zString
++; } } };

69368 return *
zString
!=0;

69372 if( 
c
<=0x80 )

69375 
u32
 
cx
;

69376 if( 
noCase
 )

69379 
cx
 = ((
c
)&~(
sqlite3CtypeMap
[(unsigned char)(c)]&0x20));

69380 
c
 = (
sqlite3UpperToLower
[(unsigned char)(c)]);

69382 
cx
 = 
c
;

69384 while( (
c2
 = *(
zString
++))!=0 )

69387 if( 
c2
!=
c
 && c2!=
cx
 ) continue;

69388 if( 
	`patternCompare
(
zPattern
,
zString
,
pInfo
,
matchOther
) ) return 1;

69391 while( (
c2
 = (
zString
[0]<0x80?*(zString++):
	`sqlite3Utf8Read
(&zString)))!=0 )

69394 if( 
c2
!=
c
 ) continue;

69395 if( 
	`patternCompare
(
zPattern
,
zString
,
pInfo
,
matchOther
) ) return 1;

69400 if( 
c
==
matchOther
 )

69403 if( 
pInfo
->
matchSet
==0 )

69406 
c
 = 
	`sqlite3Utf8Read
(&
zPattern
);

69407 if( 
c
==0 ) return 0;

69408 
zEscaped
 = 
zPattern
;

69410 
u32
 
prior_c
 = 0;

69411 int 
seen
 = 0;

69412 int 
invert
 = 0;

69413 
c
 = 
	`sqlite3Utf8Read
(&
zString
);

69414 if( 
c
==0 ) return 0;

69415 
c2
 = 
	`sqlite3Utf8Read
(&
zPattern
);

69416 if( 
c2
=='^' )

69419 
invert
 = 1;

69420 
c2
 = 
	`sqlite3Utf8Read
(&
zPattern
);

69422 if( 
c2
==']' )

69425 if( 
c
==']' ) 
seen
 = 1;

69426 
c2
 = 
	`sqlite3Utf8Read
(&
zPattern
);

69428 while( 
c2
 && c2!=']' )

69431 if( 
c2
=='-' && 
zPattern
[0]!=']' && zPattern[0]!=0 && 
prior_c
>0 )

69434 
c2
 = 
	`sqlite3Utf8Read
(&
zPattern
);

69435 if( 
c
>=
prior_c
 && c<=
c2
 ) 
seen
 = 1;

69436 
prior_c
 = 0;

69438 if( 
c
==
c2
 )

69441 
seen
 = 1;

69443 
prior_c
 = 
c2
;

69445 
c2
 = 
	`sqlite3Utf8Read
(&
zPattern
);

69447 if( 
c2
==0 || (
seen
 ^ 
invert
)==0 )

69455 
c2
 = (
zString
[0]<0x80?*(zString++):
	`sqlite3Utf8Read
(&zString));

69456 if( 
c
==
c2
 ) continue;

69457 if( 
noCase
 && 
c
<0x80 && 
c2
<0x80 && (
sqlite3UpperToLower
[(unsigned char)(c)])==(sqlite3UpperToLower[(unsigned char)(c2)]) )

69462 if( 
c
==
matchOne
 && 
zPattern
!=
zEscaped
 && 
c2
!=0 ) continue;

69465 return *
zString
==0;

69466 
	}
}

69471 int 
	$sqlite3_strglob
(const char *
zGlobPattern
, const char *
zString
)

69474 return 
	`patternCompare
((
u8
*)
zGlobPattern
, (u8*)
zString
, &
globInfo
, '[')==0;

69475 
	}
}

69480 int 
	$sqlite3_strlike
(const char *
zPattern
, const char *
zStr
, unsigned int 
esc
)

69483 return 
	`patternCompare
((
u8
*)
zPattern
, (u8*)
zStr
, &
likeInfoNorm
, 
esc
)==0;

69484 
	}
}

69486 static void 
	$likeFunc
(

69487 
sqlite3_context
 *
context
,

69488 int 
argc
,

69489 
sqlite3_value
 **
argv


69493 const unsigned char *
zA
, *
zB
;

69494 
u32
 
escape
;

69495 int 
nPat
;

69496 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

69497 struct 
compareInfo
 *
pInfo
 = 
	`sqlite3_user_data
(
context
);

69499 
zB
 = 
	`sqlite3_value_text
(
argv
[0]);

69500 
zA
 = 
	`sqlite3_value_text
(
argv
[1]);

69505 
nPat
 = 
	`sqlite3_value_bytes
(
argv
[0]);

69508 if( 
nPat
 > 
db
->
aLimit
[8] )

69511 
	`sqlite3_result_error
(
context
, "LIKE or GLOB pattern too complex", -1);

69516 if( 
argc
==3 )

69522 const unsigned char *
zEsc
 = 
	`sqlite3_value_text
(
argv
[2]);

69523 if( 
zEsc
==0 ) return;

69524 if( 
	`sqlite3Utf8CharLen
((char*)
zEsc
, -1)!=1 )

69527 
	`sqlite3_result_error
(
context
,

69531 
escape
 = 
	`sqlite3Utf8Read
(&
zEsc
);

69533 
escape
 = 
pInfo
->
matchSet
;

69535 if( 
zA
 && 
zB
 )

69541 
	`sqlite3_result_int
(
context
, 
	`patternCompare
(
zB
, 
zA
, 
pInfo
, 
escape
));

69543 
	}
}

69550 static void 
	$nullifFunc
(

69551 
sqlite3_context
 *
context
,

69552 int 
NotUsed
,

69553 
sqlite3_value
 **
argv


69557 
CollSeq
 *
pColl
 = 
	`sqlite3GetFuncCollSeq
(
context
);

69558 (void)(
NotUsed
);

69559 if( 
	`sqlite3MemCompare
(
argv
[0], argv[1], 
pColl
)!=0 )

69562 
	`sqlite3_result_value
(
context
, 
argv
[0]);

69564 
	}
}

69570 static void 
	$versionFunc
(

69571 
sqlite3_context
 *
context
,

69572 int 
NotUsed
,

69573 
sqlite3_value
 **
NotUsed2


69577 (void)(
NotUsed
),(void)(
NotUsed2
);

69580 
	`sqlite3_result_text
(
context
, 
	`sqlite3_libversion
(), -1, ((
sqlite3_destructor_type
)0));

69581 
	}
}

69588 static void 
	$sourceidFunc
(

69589 
sqlite3_context
 *
context
,

69590 int 
NotUsed
,

69591 
sqlite3_value
 **
NotUsed2


69595 (void)(
NotUsed
),(void)(
NotUsed2
);

69598 
	`sqlite3_result_text
(
context
, 
	`sqlite3_sourceid
(), -1, ((
sqlite3_destructor_type
)0));

69599 
	}
}

69606 static void 
	$errlogFunc
(

69607 
sqlite3_context
 *
context
,

69608 int 
argc
,

69609 
sqlite3_value
 **
argv


69613 (void)(
argc
);

69614 (void)(
context
);

69615 
	`sqlite3_log
(
	`sqlite3_value_int
(
argv
[0]), "%s", 
	`sqlite3_value_text
(argv[1]));

69616 
	}
}

69624 static void 
	$compileoptionusedFunc
(

69625 
sqlite3_context
 *
context
,

69626 int 
argc
,

69627 
sqlite3_value
 **
argv


69631 const char *
zOptName
;

69633 (void)(
argc
);

69638 if( (
zOptName
 = (const char*)
	`sqlite3_value_text
(
argv
[0]))!=0 )

69641 
	`sqlite3_result_int
(
context
, 
	`sqlite3_compileoption_used
(
zOptName
));

69643 
	}
}

69645 static void 
	$compileoptiongetFunc
(

69646 
sqlite3_context
 *
context
,

69647 int 
argc
,

69648 
sqlite3_value
 **
argv


69652 int 
n
;

69654 (void)(
argc
);

69658 
n
 = 
	`sqlite3_value_int
(
argv
[0]);

69659 
	`sqlite3_result_text
(
context
, 
	`sqlite3_compileoption_get
(
n
), -1, ((
sqlite3_destructor_type
)0));

69660 
	}
}

69665 static const char 
	ghexdigits
[] = {

69670 static void 
	$quoteFunc
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

69674 (void)(
argc
);

69675 switch( 
	`sqlite3_value_type
(
argv
[0]) )

69679 double 
r1
, 
r2
;

69680 char 
zBuf
[50];

69681 
r1
 = 
	`sqlite3_value_double
(
argv
[0]);

69682 
	`sqlite3_snprintf
(sizeof(
zBuf
), zBuf, "%!.15g", 
r1
);

69683 
	`sqlite3AtoF
(
zBuf
, &
r2
, 20, 1);

69684 if( 
r1
!=
r2
 )

69687 
	`sqlite3_snprintf
(sizeof(
zBuf
), zBuf, "%!.20e", 
r1
);

69689 
	`sqlite3_result_text
(
context
, 
zBuf
, -1, ((
sqlite3_destructor_type
)-1));

69693 
	`sqlite3_result_value
(
context
, 
argv
[0]);

69697 char *
zText
 = 0;

69698 char const *
zBlob
 = 
	`sqlite3_value_blob
(
argv
[0]);

69699 int 
nBlob
 = 
	`sqlite3_value_bytes
(
argv
[0]);

69701 
zText
 = (char *)
	`contextMalloc
(
context
, (2*(
i64
)
nBlob
)+4);

69702 if( 
zText
 )

69705 int 
i
;

69706 for(
i
=0; i<
nBlob
; i++)

69709 
zText
[(
i
*2)+2] = 
hexdigits
[(
zBlob
[i]>>4)&0x0F];

69710 
zText
[(
i
*2)+3] = 
hexdigits
[(
zBlob
[i])&0x0F];

69712 
zText
[(
nBlob
*2)+2] = '\'';

69713 
zText
[(
nBlob
*2)+3] = '\0';

69714 
zText
[0] = 'X';

69715 
zText
[1] = '\'';

69716 
	`sqlite3_result_text
(
context
, 
zText
, -1, ((
sqlite3_destructor_type
)-1));

69717 
	`sqlite3_free
(
zText
);

69722 int 
i
,
j
;

69723 
u64
 
n
;

69724 const unsigned char *
zArg
 = 
	`sqlite3_value_text
(
argv
[0]);

69725 char *
z
;

69727 if( 
zArg
==0 ) return;

69728 for(
i
=0, 
n
=0; 
zArg
[i]; i++)

69730 if( 
zArg
[
i
]=='\'' ) 
n
++; }

69731 
z
 = 
	`contextMalloc
(
context
, ((
i64
)
i
)+((i64)
n
)+3);

69732 if( 
z
 )

69735 
z
[0] = '\'';

69736 for(
i
=0, 
j
=1; 
zArg
[i]; i++)

69739 
z
[
j
++] = 
zArg
[
i
];

69740 if( 
zArg
[
i
]=='\'' )

69743 
z
[
j
++] = '\'';

69746 
z
[
j
++] = '\'';

69747 
z
[
j
] = 0;

69748 
	`sqlite3_result_text
(
context
, 
z
, 
j
, 
sqlite3_free
);

69754 
	`sqlite3_result_text
(
context
, "NULL", 4, ((
sqlite3_destructor_type
)0));

69758 
	}
}

69764 static void 
	$unicodeFunc
(

69765 
sqlite3_context
 *
context
,

69766 int 
argc
,

69767 
sqlite3_value
 **
argv


69771 const unsigned char *
z
 = 
	`sqlite3_value_text
(
argv
[0]);

69772 (void)
argc
;

69773 if( 
z
 && z[0] ) 
	`sqlite3_result_int
(
context
, 
	`sqlite3Utf8Read
(&z));

69774 
	}
}

69781 static void 
	$charFunc
(

69782 
sqlite3_context
 *
context
,

69783 int 
argc
,

69784 
sqlite3_value
 **
argv


69788 unsigned char *
z
, *
zOut
;

69789 int 
i
;

69790 
zOut
 = 
z
 = 
	`sqlite3_malloc64
( 
argc
*4+1 );

69791 if( 
z
==0 )

69794 
	`sqlite3_result_error_nomem
(
context
);

69797 for(
i
=0; i<
argc
; i++)

69800 
sqlite3_int64
 
x
;

69801 unsigned 
c
;

69802 
x
 = 
	`sqlite3_value_int64
(
argv
[
i
]);

69803 if( 
x
<0 || x>0x10ffff ) x = 0xfffd;

69804 
c
 = (unsigned)(
x
 & 0x1fffff);

69805 if( 
c
<0x00080 )

69808 *
zOut
++ = (
u8
)(
c
&0xFF);

69809 }else if( 
c
<0x00800 )

69812 *
zOut
++ = 0xC0 + (
u8
)((
c
>>6)&0x1F);

69813 *
zOut
++ = 0x80 + (
u8
)(
c
 & 0x3F);

69814 }else if( 
c
<0x10000 )

69817 *
zOut
++ = 0xE0 + (
u8
)((
c
>>12)&0x0F);

69818 *
zOut
++ = 0x80 + (
u8
)((
c
>>6) & 0x3F);

69819 *
zOut
++ = 0x80 + (
u8
)(
c
 & 0x3F);

69821 *
zOut
++ = 0xF0 + (
u8
)((
c
>>18) & 0x07);

69822 *
zOut
++ = 0x80 + (
u8
)((
c
>>12) & 0x3F);

69823 *
zOut
++ = 0x80 + (
u8
)((
c
>>6) & 0x3F);

69824 *
zOut
++ = 0x80 + (
u8
)(
c
 & 0x3F);

69827 
	`sqlite3_result_text64
(
context
, (char*)
z
, 
zOut
-z, 
sqlite3_free
, 1);

69828 
	}
}

69834 static void 
	$hexFunc
(

69835 
sqlite3_context
 *
context
,

69836 int 
argc
,

69837 
sqlite3_value
 **
argv


69841 int 
i
, 
n
;

69842 const unsigned char *
pBlob
;

69843 char *
zHex
, *
z
;

69845 (void)(
argc
);

69846 
pBlob
 = 
	`sqlite3_value_blob
(
argv
[0]);

69847 
n
 = 
	`sqlite3_value_bytes
(
argv
[0]);

69849 
z
 = 
zHex
 = 
	`contextMalloc
(
context
, ((
i64
)
n
)*2 + 1);

69850 if( 
zHex
 )

69853 for(
i
=0; i<
n
; i++, 
pBlob
++)

69856 unsigned char 
c
 = *
pBlob
;

69857 *(
z
++) = 
hexdigits
[(
c
>>4)&0xf];

69858 *(
z
++) = 
hexdigits
[
c
&0xf];

69860 *
z
 = 0;

69861 
	`sqlite3_result_text
(
context
, 
zHex
, 
n
*2, 
sqlite3_free
);

69863 
	}
}

69868 static void 
	$zeroblobFunc
(

69869 
sqlite3_context
 *
context
,

69870 int 
argc
,

69871 
sqlite3_value
 **
argv


69875 
i64
 
n
;

69876 int 
rc
;

69878 (void)(
argc
);

69879 
n
 = 
	`sqlite3_value_int64
(
argv
[0]);

69880 if( 
n
<0 ) n = 0;

69881 
rc
 = 
	`sqlite3_result_zeroblob64
(
context
, 
n
);

69882 if( 
rc
 )

69885 
	`sqlite3_result_error_code
(
context
, 
rc
);

69887 
	}
}

69895 static void 
	$replaceFunc
(

69896 
sqlite3_context
 *
context
,

69897 int 
argc
,

69898 
sqlite3_value
 **
argv


69902 const unsigned char *
zStr
;

69903 const unsigned char *
zPattern
;

69904 const unsigned char *
zRep
;

69905 unsigned char *
zOut
;

69906 int 
nStr
;

69907 int 
nPattern
;

69908 int 
nRep
;

69909 
i64
 
nOut
;

69910 int 
loopLimit
;

69911 int 
i
, 
j
;

69914 (void)(
argc
);

69915 
zStr
 = 
	`sqlite3_value_text
(
argv
[0]);

69916 if( 
zStr
==0 ) return;

69917 
nStr
 = 
	`sqlite3_value_bytes
(
argv
[0]);

69919 
zPattern
 = 
	`sqlite3_value_text
(
argv
[1]);

69920 if( 
zPattern
==0 )

69927 if( 
zPattern
[0]==0 )

69931 
	`sqlite3_result_value
(
context
, 
argv
[0]);

69934 
nPattern
 = 
	`sqlite3_value_bytes
(
argv
[1]);

69936 
zRep
 = 
	`sqlite3_value_text
(
argv
[2]);

69937 if( 
zRep
==0 ) return;

69938 
nRep
 = 
	`sqlite3_value_bytes
(
argv
[2]);

69940 
nOut
 = 
nStr
 + 1;

69942 
zOut
 = 
	`contextMalloc
(
context
, (
i64
)
nOut
);

69943 if( 
zOut
==0 )

69948 
loopLimit
 = 
nStr
 - 
nPattern
;

69949 for(
i
=
j
=0; i<=
loopLimit
; i++)

69952 if( 
zStr
[
i
]!=
zPattern
[0] || 
	`memcmp
(&zStr[i], zPattern, 
nPattern
) )

69955 
zOut
[
j
++] = 
zStr
[
i
];

69957 
u8
 *
zOld
;

69958 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

69959 
nOut
 += 
nRep
 - 
nPattern
;

69962 if( 
nOut
-1>
db
->
aLimit
[0] )

69965 
	`sqlite3_result_error_toobig
(
context
);

69966 
	`sqlite3_free
(
zOut
);

69969 
zOld
 = 
zOut
;

69970 
zOut
 = 
	`sqlite3_realloc64
(zOut, (int)
nOut
);

69971 if( 
zOut
==0 )

69974 
	`sqlite3_result_error_nomem
(
context
);

69975 
	`sqlite3_free
(
zOld
);

69978 
	`memcpy
(&
zOut
[
j
], 
zRep
, 
nRep
);

69979 
j
 += 
nRep
;

69980 
i
 += 
nPattern
-1;

69984 
	`memcpy
(&
zOut
[
j
], &
zStr
[
i
], 
nStr
-i);

69985 
j
 += 
nStr
 - 
i
;

69987 
zOut
[
j
] = 0;

69988 
	`sqlite3_result_text
(
context
, (char*)
zOut
, 
j
, 
sqlite3_free
);

69989 
	}
}

69995 static void 
	$trimFunc
(

69996 
sqlite3_context
 *
context
,

69997 int 
argc
,

69998 
sqlite3_value
 **
argv


70002 const unsigned char *
zIn
;

70003 const unsigned char *
zCharSet
;

70004 int 
nIn
;

70005 int 
flags
;

70006 int 
i
;

70007 unsigned char *
aLen
 = 0;

70008 unsigned char **
azChar
 = 0;

70009 int 
nChar
;

70011 if( 
	`sqlite3_value_type
(
argv
[0])==5 )

70016 
zIn
 = 
	`sqlite3_value_text
(
argv
[0]);

70017 if( 
zIn
==0 ) return;

70018 
nIn
 = 
	`sqlite3_value_bytes
(
argv
[0]);

70020 if( 
argc
==1 )

70023 static const unsigned char 
lenOne
[] = { 1 };

70024 static unsigned char * const 
azOne
[] = { (
u8
*)" " };

70025 
nChar
 = 1;

70026 
aLen
 = (
u8
*)
lenOne
;

70027 
azChar
 = (unsigned char **)
azOne
;

70028 
zCharSet
 = 0;

70029 }else if( (
zCharSet
 = 
	`sqlite3_value_text
(
argv
[1]))==0 )

70034 const unsigned char *
z
;

70035 for(
z
=
zCharSet
, 
nChar
=0; *z; nChar++)

70038 { if( (*(
z
++))>=0xc0 )

70040 while( (*
z
 & 0xc0)==0x80 )

70042 
z
++; } } };

70044 if( 
nChar
>0 )

70047 
azChar
 = 
	`contextMalloc
(
context
, ((
i64
)
nChar
)*(sizeof(char*)+1));

70048 if( 
azChar
==0 )

70053 
aLen
 = (unsigned char*)&
azChar
[
nChar
];

70054 for(
z
=
zCharSet
, 
nChar
=0; *z; nChar++)

70057 
azChar
[
nChar
] = (unsigned char *)
z
;

70058 { if( (*(
z
++))>=0xc0 )

70060 while( (*
z
 & 0xc0)==0x80 )

70062 
z
++; } } };

70063 
aLen
[
nChar
] = (
u8
)(
z
 - 
azChar
[nChar]);

70067 if( 
nChar
>0 )

70070 
flags
 = ((int)(long int)(
	`sqlite3_user_data
(
context
)));

70071 if( 
flags
 & 1 )

70074 while( 
nIn
>0 )

70077 int 
len
 = 0;

70078 for(
i
=0; i<
nChar
; i++)

70081 
len
 = 
aLen
[
i
];

70082 if( 
len
<=
nIn
 && 
	`memcmp
(
zIn
, 
azChar
[
i
], len)==0 ) break;

70084 if( 
i
>=
nChar
 ) break;

70085 
zIn
 += 
len
;

70086 
nIn
 -= 
len
;

70089 if( 
flags
 & 2 )

70092 while( 
nIn
>0 )

70095 int 
len
 = 0;

70096 for(
i
=0; i<
nChar
; i++)

70099 
len
 = 
aLen
[
i
];

70100 if( 
len
<=
nIn
 && 
	`memcmp
(&
zIn
[nIn-len],
azChar
[
i
],len)==0 ) break;

70102 if( 
i
>=
nChar
 ) break;

70103 
nIn
 -= 
len
;

70106 if( 
zCharSet
 )

70109 
	`sqlite3_free
(
azChar
);

70112 
	`sqlite3_result_text
(
context
, (char*)
zIn
, 
nIn
, ((
sqlite3_destructor_type
)-1));

70113 
	}
}

70115 static void 
	$loadExt
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

70118 const char *
zFile
 = (const char *)
	`sqlite3_value_text
(
argv
[0]);

70119 const char *
zProc
;

70120 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

70121 char *
zErrMsg
 = 0;

70123 if( 
argc
==2 )

70126 
zProc
 = (const char *)
	`sqlite3_value_text
(
argv
[1]);

70128 
zProc
 = 0;

70130 if( 
zFile
 && 
	`sqlite3_load_extension
(
db
, zFile, 
zProc
, &
zErrMsg
) )

70133 
	`sqlite3_result_error
(
context
, 
zErrMsg
, -1);

70134 
	`sqlite3_free
(
zErrMsg
);

70136 
	}
}

70144 typedef struct 
SumCtx
 
	tSumCtx
;

70145 struct 
	sSumCtx
 {

70146 double 
	mrSum
;

70147 
i64
 
	miSum
;

70148 
i64
 
	mcnt
;

70149 
u8
 
	moverflow
;

70150 
u8
 
	mapprox
;

70153 static void 
	$sumStep
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

70156 
SumCtx
 *
p
;

70157 int 
type
;

70159 (void)(
argc
);

70160 
p
 = 
	`sqlite3_aggregate_context
(
context
, sizeof(*p));

70161 
type
 = 
	`sqlite3_value_numeric_type
(
argv
[0]);

70162 if( 
p
 && 
type
!=5 )

70165 
p
->
cnt
++;

70166 if( 
type
==1 )

70169 
i64
 
v
 = 
	`sqlite3_value_int64
(
argv
[0]);

70170 
p
->
rSum
 += 
v
;

70171 if( (
p
->
approx
|p->
overflow
)==0 && 
	`sqlite3AddInt64
(&p->
iSum
, 
v
) )

70174 
p
->
overflow
 = 1;

70177 
p
->
rSum
 += 
	`sqlite3_value_double
(
argv
[0]);

70178 
p
->
approx
 = 1;

70181 
	}
}

70182 static void 
	$sumFinalize
(
sqlite3_context
 *
context
)

70185 
SumCtx
 *
p
;

70186 
p
 = 
	`sqlite3_aggregate_context
(
context
, 0);

70187 if( 
p
 && p->
cnt
>0 )

70190 if( 
p
->
overflow
 )

70193 
	`sqlite3_result_error
(
context
,"integer overflow",-1);

70194 }else if( 
p
->
approx
 )

70197 
	`sqlite3_result_double
(
context
, 
p
->
rSum
);

70199 
	`sqlite3_result_int64
(
context
, 
p
->
iSum
);

70202 
	}
}

70203 static void 
	$avgFinalize
(
sqlite3_context
 *
context
)

70206 
SumCtx
 *
p
;

70207 
p
 = 
	`sqlite3_aggregate_context
(
context
, 0);

70208 if( 
p
 && p->
cnt
>0 )

70211 
	`sqlite3_result_double
(
context
, 
p
->
rSum
/(double)p->
cnt
);

70213 
	}
}

70214 static void 
	$totalFinalize
(
sqlite3_context
 *
context
)

70217 
SumCtx
 *
p
;

70218 
p
 = 
	`sqlite3_aggregate_context
(
context
, 0);

70220 
	`sqlite3_result_double
(
context
, 
p
 ? p->
rSum
 : (double)0);

70221 
	}
}

70227 typedef struct 
CountCtx
 
	tCountCtx
;

70228 struct 
	sCountCtx
 {

70229 
i64
 
	mn
;

70235 static void 
	$countStep
(
sqlite3_context
 *
context
, int 
argc
, 
sqlite3_value
 **
argv
)

70238 
CountCtx
 *
p
;

70239 
p
 = 
	`sqlite3_aggregate_context
(
context
, sizeof(*p));

70240 if( (
argc
==0 || 5!=
	`sqlite3_value_type
(
argv
[0])) && 
p
 )

70243 
p
->
n
++;

70254 
	}
}

70255 static void 
	$countFinalize
(
sqlite3_context
 *
context
)

70258 
CountCtx
 *
p
;

70259 
p
 = 
	`sqlite3_aggregate_context
(
context
, 0);

70260 
	`sqlite3_result_int64
(
context
, 
p
 ? p->
n
 : 0);

70261 
	}
}

70266 static void 
	$minmaxStep
(

70267 
sqlite3_context
 *
context
,

70268 int 
NotUsed
,

70269 
sqlite3_value
 **
argv


70273 
Mem
 *
pArg
 = (Mem *)
argv
[0];

70274 
Mem
 *
pBest
;

70275 (void)(
NotUsed
);

70277 
pBest
 = (
Mem
 *)
	`sqlite3_aggregate_context
(
context
, sizeof(*pBest));

70278 if( !
pBest
 ) return;

70280 if( 
	`sqlite3_value_type
(
argv
[0])==5 )

70283 if( 
pBest
->
flags
 ) 
	`sqlite3SkipAccumulatorLoad
(
context
);

70284 }else if( 
pBest
->
flags
 )

70287 int 
max
;

70288 int 
cmp
;

70289 
CollSeq
 *
pColl
 = 
	`sqlite3GetFuncCollSeq
(
context
);

70291 
max
 = 
	`sqlite3_user_data
(
context
)!=0;

70292 
cmp
 = 
	`sqlite3MemCompare
(
pBest
, 
pArg
, 
pColl
);

70293 if( (
max
 && 
cmp
<0) || (!max && cmp>0) )

70296 
	`sqlite3VdbeMemCopy
(
pBest
, 
pArg
);

70298 
	`sqlite3SkipAccumulatorLoad
(
context
);

70301 
pBest
->
db
 = 
	`sqlite3_context_db_handle
(
context
);

70302 
	`sqlite3VdbeMemCopy
(
pBest
, 
pArg
);

70304 
	}
}

70305 static void 
	$minMaxFinalize
(
sqlite3_context
 *
context
)

70308 
sqlite3_value
 *
pRes
;

70309 
pRes
 = (
sqlite3_value
 *)
	`sqlite3_aggregate_context
(
context
, 0);

70310 if( 
pRes
 )

70313 if( 
pRes
->
flags
 )

70316 
	`sqlite3_result_value
(
context
, 
pRes
);

70318 
	`sqlite3VdbeMemRelease
(
pRes
);

70320 
	}
}

70325 static void 
	$groupConcatStep
(

70326 
sqlite3_context
 *
context
,

70327 int 
argc
,

70328 
sqlite3_value
 **
argv


70332 const char *
zVal
;

70333 
StrAccum
 *
pAccum
;

70334 const char *
zSep
;

70335 int 
nVal
, 
nSep
;

70337 if( 
	`sqlite3_value_type
(
argv
[0])==5 ) return;

70338 
pAccum
 = (
StrAccum
*)
	`sqlite3_aggregate_context
(
context
, sizeof(*pAccum));

70340 if( 
pAccum
 )

70343 
sqlite3
 *
db
 = 
	`sqlite3_context_db_handle
(
context
);

70344 int 
firstTerm
 = 
pAccum
->
mxAlloc
==0;

70345 
pAccum
->
mxAlloc
 = 
db
->
aLimit
[0];

70346 if( !
firstTerm
 )

70349 if( 
argc
==2 )

70352 
zSep
 = (char*)
	`sqlite3_value_text
(
argv
[1]);

70353 
nSep
 = 
	`sqlite3_value_bytes
(
argv
[1]);

70355 
zSep
 = ",";

70356 
nSep
 = 1;

70358 if( 
nSep
 ) 
	`sqlite3StrAccumAppend
(
pAccum
, 
zSep
, nSep);

70360 
zVal
 = (char*)
	`sqlite3_value_text
(
argv
[0]);

70361 
nVal
 = 
	`sqlite3_value_bytes
(
argv
[0]);

70362 if( 
zVal
 ) 
	`sqlite3StrAccumAppend
(
pAccum
, zVal, 
nVal
);

70364 
	}
}

70365 static void 
	$groupConcatFinalize
(
sqlite3_context
 *
context
)

70368 
StrAccum
 *
pAccum
;

70369 
pAccum
 = 
	`sqlite3_aggregate_context
(
context
, 0);

70370 if( 
pAccum
 )

70373 if( 
pAccum
->
accError
==2 )

70376 
	`sqlite3_result_error_toobig
(
context
);

70377 }else if( 
pAccum
->
accError
==1 )

70380 
	`sqlite3_result_error_nomem
(
context
);

70382 
	`sqlite3_result_text
(
context
, 
	`sqlite3StrAccumFinish
(
pAccum
), -1,

70383 
sqlite3_free
);

70386 
	}
}

70393 static void 
	$sqlite3RegisterPerConnectionBuiltinFunctions
(
sqlite3
 *
db
)

70396 int 
rc
 = 
	`sqlite3_overload_function
(
db
, "MATCH", 2);

70398 if( 
rc
==7 )

70401 
	`sqlite3OomFault
(
db
);

70403 
	}
}

70408 static void 
	$setLikeOptFlag
(
sqlite3
 *
db
, const char *
zName
, 
u8
 
flagVal
)

70411 
FuncDef
 *
pDef
;

70412 
pDef
 = 
	`sqlite3FindFunction
(
db
, 
zName
, 2, 1, 0);

70413 if( (
pDef
) )

70416 
pDef
->
funcFlags
 |= 
flagVal
;

70418 
	}
}

70425 static void 
	$sqlite3RegisterLikeFunctions
(
sqlite3
 *
db
, int 
caseSensitive
)

70428 struct 
compareInfo
 *
pInfo
;

70429 if( 
caseSensitive
 )

70432 
pInfo
 = (struct 
compareInfo
*)&
likeInfoAlt
;

70434 
pInfo
 = (struct 
compareInfo
*)&
likeInfoNorm
;

70436 
	`sqlite3CreateFunc
(
db
, "like", 2, 1, 
pInfo
, 
likeFunc
, 0, 0, 0);

70437 
	`sqlite3CreateFunc
(
db
, "like", 3, 1, 
pInfo
, 
likeFunc
, 0, 0, 0);

70438 
	`sqlite3CreateFunc
(
db
, "glob", 2, 1,

70439 (struct 
compareInfo
*)&
globInfo
, 
likeFunc
, 0, 0, 0);

70440 
	`setLikeOptFlag
(
db
, "glob", 0x0004 | 0x0008);

70441 
	`setLikeOptFlag
(
db
, "like",

70442 
caseSensitive
 ? (0x0004 | 0x0008) : 0x0004);

70443 
	}
}

70445 static int 
	$sqlite3IsLikeFunction
(
sqlite3
 *
db
, 
Expr
 *
pExpr
, int *
pIsNocase
, char *
aWc
)

70448 
FuncDef
 *
pDef
;

70449 if( 
pExpr
->
op
!=151

70450 || !
pExpr
->
x
.
pList


70451 || 
pExpr
->
x
.
pList
->
nExpr
!=2

70458 
pDef
 = 
	`sqlite3FindFunction
(
db
, 
pExpr
->
u
.
zToken
, 2, 1, 0);

70459 if( (
pDef
==0) || (pDef->
funcFlags
 & 0x0004)==0 )

70469 
	`memcpy
(
aWc
, 
pDef
->
pUserData
, 3);

70473 *
pIsNocase
 = (
pDef
->
funcFlags
 & 0x0008)==0;

70475 
	}
}

70477 static void 
	$sqlite3RegisterBuiltinFunctions
(void)

70481 static 
FuncDef
 
aBuiltinFunc
[] = {

70486 {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
loadExt
, 0, "load_extension", {0} },

70487 {2, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
loadExt
, 0, "load_extension", {0} },

70493 {1, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
compileoptionusedFunc
, 0, "sqlite_compileoption_used", {0} },

70494 {1, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
compileoptiongetFunc
, 0, "sqlite_compileoption_get", {0} },

70496 {1,0x0800|1|(0*0x0020)|0x0400, ((void*)(long int)(0)), 0, 
versionFunc
, 0, "unlikely", {0} },

70497 {2,0x0800|1|(0*0x0020)|0x0400, ((void*)(long int)(0)), 0, 
versionFunc
, 0, "likelihood", {0} },

70498 {1,0x0800|1|(0*0x0020)|0x0400, ((void*)(long int)(0)), 0, 
versionFunc
, 0, "likely", {0} },

70499 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(1)), 0, 
trimFunc
, 0, "ltrim", {0} },

70500 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(1)), 0, 
trimFunc
, 0, "ltrim", {0} },

70501 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(2)), 0, 
trimFunc
, 0, "rtrim", {0} },

70502 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(2)), 0, 
trimFunc
, 0, "rtrim", {0} },

70503 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(3)), 0, 
trimFunc
, 0, "trim", {0} },

70504 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(3)), 0, 
trimFunc
, 0, "trim", {0} },

70505 {-1, 0x0800|1|(1*0x0020), ((void*)(long int)(0)), 0, 
minmaxFunc
, 0, "min", {0} },

70507 {1, 1|(1*0x0020)|0x1000, ((void*)(long int)(0)), 0, 
minmaxStep
,
minMaxFinalize
,"min", {0}}

70509 {-1, 0x0800|1|(1*0x0020), ((void*)(long int)(1)), 0, 
minmaxFunc
, 0, "max", {0} },

70511 {1, 1|(1*0x0020)|0x1000, ((void*)(long int)(1)), 0, 
minmaxStep
,
minMaxFinalize
,"max", {0}}

70513 {1,0x0800|1|(0*0x0020)|0x0080, ((void*)(long int)(0)), 0, 
typeofFunc
, 0, "typeof", {0} },

70514 {1,0x0800|1|(0*0x0020)|0x0040, ((void*)(long int)(0)), 0, 
lengthFunc
, 0, "length", {0} },

70515 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
instrFunc
, 0, "instr", {0} },

70516 {-1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
printfFunc
, 0, "printf", {0} },

70517 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
unicodeFunc
, 0, "unicode", {0} },

70518 {-1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
charFunc
, 0, "char", {0} },

70519 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
absFunc
, 0, "abs", {0} },

70521 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
roundFunc
, 0, "round", {0} },

70522 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
roundFunc
, 0, "round", {0} },

70524 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
upperFunc
, 0, "upper", {0} },

70525 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
lowerFunc
, 0, "lower", {0} },

70526 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
hexFunc
, 0, "hex", {0} },

70527 {2,0x0800|1|(0*0x0020)|0x0200, ((void*)(long int)(0)), 0, 
versionFunc
, 0, "ifnull", {0} },

70528 {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
randomFunc
, 0, "random", {0} },

70529 {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
randomBlob
, 0, "randomblob", {0} },

70530 {2, 0x0800|1|(1*0x0020), ((void*)(long int)(0)), 0, 
nullifFunc
, 0, "nullif", {0} },

70531 {0, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
versionFunc
, 0, "sqlite_version", {0} },

70532 {0, 0x2000|1|(0*0x0020), ((void*)(long int)(0)), 0, 
sourceidFunc
, 0, "sqlite_source_id", {0} },

70533 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
errlogFunc
, 0, "sqlite_log", {0} },

70534 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
quoteFunc
, 0, "quote", {0} },

70535 {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
last_insert_rowid
, 0, "last_insert_rowid", {0} },

70536 {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
changes
, 0, "changes", {0} },

70537 {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
total_changes
, 0, "total_changes", {0} },

70538 {3, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
replaceFunc
, 0, "replace", {0} },

70539 {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
zeroblobFunc
, 0, "zeroblob", {0} },

70540 {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
substrFunc
, 0, "substr", {0} },

70541 {3, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 
substrFunc
, 0, "substr", {0} },

70542 {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
sumStep
,
sumFinalize
,"sum", {0}},

70543 {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
sumStep
,
totalFinalize
,"total", {0}},

70544 {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
sumStep
,
avgFinalize
,"avg", {0}},

70545 {0, 1|(0*0x0020)|0x0100, ((void*)(long int)(0)), 0, 
countStep
,
countFinalize
,"count", {0}}

70547 {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
countStep
,
countFinalize
,"count", {0}},

70548 {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
groupConcatStep
,
groupConcatFinalize
,"group_concat", {0}},

70549 {2, 1|(0*0x0020), ((void*)(long int)(0)), 0, 
groupConcatStep
,
groupConcatFinalize
,"group_concat", {0}},

70551 {2, 0x0800|1|0x0004|0x0008, (void *)&
globInfo
, 0, 
likeFunc
, 0, "glob", {0} },

70556 {2, 0x0800|1|0x0004, (void *)&
likeInfoNorm
, 0, 
likeFunc
, 0, "like", {0} },

70557 {3, 0x0800|1|0x0004, (void *)&
likeInfoNorm
, 0, 
likeFunc
, 0, "like", {0} },

70561 {-1,0x0800|1|(0*0x0020)|0x0200, ((void*)(long int)(0)), 0, 
versionFunc
, 0, "coalesce", {0} },

70564 
	`sqlite3AlterFunctions
();

70569 
	`sqlite3RegisterDateTimeFunctions
();

70570 
	`sqlite3InsertBuiltinFuncs
(
aBuiltinFunc
, ((int)(sizeof(aBuiltinFunc)/sizeof(aBuiltinFunc[0]))));

70572 
	}
}

70574 static int 
	$sqlite3FkLocateIndex
(

70575 
Parse
 *
pParse
,

70576 
Table
 *
pParent
,

70577 
FKey
 *
pFKey
,

70578 
Index
 **
ppIdx
,

70579 int **
paiCol


70583 
Index
 *
pIdx
 = 0;

70584 int *
aiCol
 = 0;

70585 int 
nCol
 = 
pFKey
->nCol;

70586 char *
zKey
 = 
pFKey
->
aCol
[0].
zCol
;

70593 if( 
nCol
==1 )

70603 if( 
pParent
->
iPKey
>=0 )

70606 if( !
zKey
 ) return 0;

70607 if( !
	`sqlite3StrICmp
(
pParent
->
aCol
[pParent->
iPKey
].
zName
, 
zKey
) ) return 0;

70609 }else if( 
paiCol
 )

70613 
aiCol
 = (int *)
	`sqlite3DbMallocRawNN
(
pParse
->
db
, 
nCol
*sizeof(int));

70614 if( !
aiCol
 ) return 1;

70615 *
paiCol
 = 
aiCol
;

70618 for(
pIdx
=
pParent
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

70621 if( 
pIdx
->
nKeyCol
==
nCol
 && ((pIdx)->
onError
!=0) )

70628 if( 
zKey
==0 )

70634 if( ((
pIdx
)->
idxType
==2) )

70637 if( 
aiCol
 )

70640 int 
i
;

70641 for(
i
=0; i<
nCol
; i++) 
aiCol
[i] = 
pFKey
->
aCol
[i].
iFrom
;

70650 int 
i
, 
j
;

70651 for(
i
=0; i<
nCol
; i++)

70654 
i16
 
iCol
 = 
pIdx
->
aiColumn
[
i
];

70655 const char *
zDfltColl
;

70656 char *
zIdxCol
;

70658 if( 
iCol
<0 ) break;

70663 
zDfltColl
 = 
pParent
->
aCol
[
iCol
].
zColl
;

70664 if( !
zDfltColl
 ) zDfltColl = 
sqlite3StrBINARY
;

70665 if( 
	`sqlite3StrICmp
(
pIdx
->
azColl
[
i
], 
zDfltColl
) ) break;

70667 
zIdxCol
 = 
pParent
->
aCol
[
iCol
].
zName
;

70668 for(
j
=0; j<
nCol
; j++)

70671 if( 
	`sqlite3StrICmp
(
pFKey
->
aCol
[
j
].
zCol
, 
zIdxCol
)==0 )

70674 if( 
aiCol
 ) aiCol[
i
] = 
pFKey
->
aCol
[
j
].
iFrom
;

70678 if( 
j
==
nCol
 ) break;

70680 if( 
i
==
nCol
 ) break;

70685 if( !
pIdx
 )

70688 if( !
pParse
->
disableTriggers
 )

70691 
	`sqlite3ErrorMsg
(
pParse
,

70693 
pFKey
->
pFrom
->
zName
, pFKey->
zTo
);

70695 
	`sqlite3DbFree
(
pParse
->
db
, 
aiCol
);

70699 *
ppIdx
 = 
pIdx
;

70701 
	}
}

70703 static void 
	$fkLookupParent
(

70704 
Parse
 *
pParse
,

70705 int 
iDb
,

70706 
Table
 *
pTab
,

70707 
Index
 *
pIdx
,

70708 
FKey
 *
pFKey
,

70709 int *
aiCol
,

70710 int 
regData
,

70711 int 
nIncr
,

70712 int 
isIgnore


70716 int 
i
;

70717 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

70718 int 
iCur
 = 
pParse
->
nTab
 - 1;

70719 int 
iOk
 = 
	`sqlite3VdbeMakeLabel
(
v
);

70721 if( 
nIncr
<0 )

70724 
	`sqlite3VdbeAddOp2
(
v
, 136, 
pFKey
->
isDeferred
, 
iOk
);

70727 for(
i
=0; i<
pFKey
->
nCol
; i++)

70730 int 
iReg
 = 
aiCol
[
i
] + 
regData
 + 1;

70731 
	`sqlite3VdbeAddOp2
(
v
, 76, 
iReg
, 
iOk
); ;

70734 if( 
isIgnore
==0 )

70737 if( 
pIdx
==0 )

70742 int 
iMustBeInt
;

70743 int 
regTemp
 = 
	`sqlite3GetTempReg
(
pParse
);

70750 
	`sqlite3VdbeAddOp2
(
v
, 31, 
aiCol
[0]+1+
regData
, 
regTemp
);

70751 
iMustBeInt
 = 
	`sqlite3VdbeAddOp2
(
v
, 38, 
regTemp
, 0);

70758 if( 
pTab
==
pFKey
->
pFrom
 && 
nIncr
==1 )

70761 
	`sqlite3VdbeAddOp3
(
v
, 79, 
regData
, 
iOk
, 
regTemp
); ;

70762 
	`sqlite3VdbeChangeP5
(
v
, 0x90);

70765 
	`sqlite3OpenTable
(
pParse
, 
iCur
, 
iDb
, 
pTab
, 54);

70766 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iCur
, 0, 
regTemp
); ;

70767 
	`sqlite3VdbeGoto
(
v
, 
iOk
);

70768 
	`sqlite3VdbeJumpHere
(
v
, 
	`sqlite3VdbeCurrentAddr
(v)-2);

70769 
	`sqlite3VdbeJumpHere
(
v
, 
iMustBeInt
);

70770 
	`sqlite3ReleaseTempReg
(
pParse
, 
regTemp
);

70772 int 
nCol
 = 
pFKey
->nCol;

70773 int 
regTemp
 = 
	`sqlite3GetTempRange
(
pParse
, 
nCol
);

70774 int 
regRec
 = 
	`sqlite3GetTempReg
(
pParse
);

70776 
	`sqlite3VdbeAddOp3
(
v
, 54, 
iCur
, 
pIdx
->
tnum
, 
iDb
);

70777 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pIdx
);

70778 for(
i
=0; i<
nCol
; i++)

70781 
	`sqlite3VdbeAddOp2
(
v
, 30, 
aiCol
[
i
]+1+
regData
, 
regTemp
+i);

70784 if( 
pTab
==
pFKey
->
pFrom
 && 
nIncr
==1 )

70787 int 
iJump
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 
nCol
 + 1;

70788 for(
i
=0; i<
nCol
; i++)

70791 int 
iChild
 = 
aiCol
[
i
]+1+
regData
;

70792 int 
iParent
 = 
pIdx
->
aiColumn
[
i
]+1+
regData
;

70795 if( 
pIdx
->
aiColumn
[
i
]==
pTab
->
iPKey
 )

70799 
iParent
 = 
regData
;

70801 
	`sqlite3VdbeAddOp3
(
v
, 78, 
iChild
, 
iJump
, 
iParent
); ;

70802 
	`sqlite3VdbeChangeP5
(
v
, 0x10);

70804 
	`sqlite3VdbeGoto
(
v
, 
iOk
);

70807 
	`sqlite3VdbeAddOp4
(
v
, 49, 
regTemp
, 
nCol
, 
regRec
,

70808 
	`sqlite3IndexAffinityStr
(
pParse
->
db
,
pIdx
), 
nCol
);

70809 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
iCur
, 
iOk
, 
regRec
, 0); ;

70811 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRec
);

70812 
	`sqlite3ReleaseTempRange
(
pParse
, 
regTemp
, 
nCol
);

70816 if( !
pFKey
->
isDeferred
 && !(
pParse
->
db
->
flags
 & 0x01000000)

70817 && !
pParse
->
pToplevel


70818 && !
pParse
->
isMultiWrite


70827 
	`sqlite3HaltConstraint
(
pParse
, (19 | (3<<8)),

70830 if( 
nIncr
>0 && 
pFKey
->
isDeferred
==0 )

70833 
	`sqlite3MayAbort
(
pParse
);

70835 
	`sqlite3VdbeAddOp2
(
v
, 135, 
pFKey
->
isDeferred
, 
nIncr
);

70838 
	`sqlite3VdbeResolveLabel
(
v
, 
iOk
);

70839 
	`sqlite3VdbeAddOp1
(
v
, 61, 
iCur
);

70840 
	}
}

70842 static 
Expr
 *
	$exprTableRegister
(

70843 
Parse
 *
pParse
,

70844 
Table
 *
pTab
,

70845 int 
regBase
,

70846 
i16
 
iCol


70850 
Expr
 *
pExpr
;

70851 
Column
 *
pCol
;

70852 const char *
zColl
;

70853 
sqlite3
 *
db
 = 
pParse
->db;

70855 
pExpr
 = 
	`sqlite3Expr
(
db
, 157, 0);

70856 if( 
pExpr
 )

70859 if( 
iCol
>=0 && iCol!=
pTab
->
iPKey
 )

70862 
pCol
 = &
pTab
->
aCol
[
iCol
];

70863 
pExpr
->
iTable
 = 
regBase
 + 
iCol
 + 1;

70864 
pExpr
->
affinity
 = 
pCol
->affinity;

70865 
zColl
 = 
pCol
->zColl;

70866 if( 
zColl
==0 ) zColl = 
db
->
pDfltColl
->
zName
;

70867 
pExpr
 = 
	`sqlite3ExprAddCollateString
(
pParse
, pExpr, 
zColl
);

70869 
pExpr
->
iTable
 = 
regBase
;

70870 
pExpr
->
affinity
 = 'D';

70873 return 
pExpr
;

70874 
	}
}

70880 static 
Expr
 *
	$exprTableColumn
(

70881 
sqlite3
 *
db
,

70882 
Table
 *
pTab
,

70883 int 
iCursor
,

70884 
i16
 
iCol


70888 
Expr
 *
pExpr
 = 
	`sqlite3Expr
(
db
, 152, 0);

70889 if( 
pExpr
 )

70892 
pExpr
->
pTab
 = pTab;

70893 
pExpr
->
iTable
 = 
iCursor
;

70894 
pExpr
->
iColumn
 = 
iCol
;

70896 return 
pExpr
;

70897 
	}
}

70899 static void 
	$fkScanChildren
(

70900 
Parse
 *
pParse
,

70901 
SrcList
 *
pSrc
,

70902 
Table
 *
pTab
,

70903 
Index
 *
pIdx
,

70904 
FKey
 *
pFKey
,

70905 int *
aiCol
,

70906 int 
regData
,

70907 int 
nIncr


70911 
sqlite3
 *
db
 = 
pParse
->db;

70912 int 
i
;

70913 
Expr
 *
pWhere
 = 0;

70914 
NameContext
 
sNameContext
;

70915 
WhereInfo
 *
pWInfo
;

70916 int 
iFkIfZero
 = 0;

70917 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

70924 if( 
nIncr
<0 )

70927 
iFkIfZero
 = 
	`sqlite3VdbeAddOp2
(
v
, 136, 
pFKey
->
isDeferred
, 0);

70931 for(
i
=0; i<
pFKey
->
nCol
; i++)

70934 
Expr
 *
pLeft
;

70935 
Expr
 *
pRight
;

70936 
Expr
 *
pEq
;

70937 
i16
 
iCol
;

70938 const char *
zCol
;

70940 
iCol
 = 
pIdx
 ? pIdx->
aiColumn
[
i
] : -1;

70941 
pLeft
 = 
	`exprTableRegister
(
pParse
, 
pTab
, 
regData
, 
iCol
);

70942 
iCol
 = 
aiCol
 ? aiCol[
i
] : 
pFKey
->
aCol
[0].
iFrom
;

70944 
zCol
 = 
pFKey
->
pFrom
->
aCol
[
iCol
].
zName
;

70945 
pRight
 = 
	`sqlite3Expr
(
db
, 27, 
zCol
);

70946 
pEq
 = 
	`sqlite3PExpr
(
pParse
, 79, 
pLeft
, 
pRight
, 0);

70947 
pWhere
 = 
	`sqlite3ExprAnd
(
db
, pWhere, 
pEq
);

70950 if( 
pTab
==
pFKey
->
pFrom
 && 
nIncr
>0 )

70953 
Expr
 *
pNe
;

70954 
Expr
 *
pLeft
;

70955 
Expr
 *
pRight
;

70956 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

70959 
pLeft
 = 
	`exprTableRegister
(
pParse
, 
pTab
, 
regData
, -1);

70960 
pRight
 = 
	`exprTableColumn
(
db
, 
pTab
, 
pSrc
->
a
[0].
iCursor
, -1);

70961 
pNe
 = 
	`sqlite3PExpr
(
pParse
, 78, 
pLeft
, 
pRight
, 0);

70963 
Expr
 *
pEq
, *
pAll
 = 0;

70964 
Index
 *
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

70966 for(
i
=0; i<
pPk
->
nKeyCol
; i++)

70969 
i16
 
iCol
 = 
pIdx
->
aiColumn
[
i
];

70971 
pLeft
 = 
	`exprTableRegister
(
pParse
, 
pTab
, 
regData
, 
iCol
);

70972 
pRight
 = 
	`exprTableColumn
(
db
, 
pTab
, 
pSrc
->
a
[0].
iCursor
, 
iCol
);

70973 
pEq
 = 
	`sqlite3PExpr
(
pParse
, 79, 
pLeft
, 
pRight
, 0);

70974 
pAll
 = 
	`sqlite3ExprAnd
(
db
, pAll, 
pEq
);

70976 
pNe
 = 
	`sqlite3PExpr
(
pParse
, 19, 
pAll
, 0, 0);

70978 
pWhere
 = 
	`sqlite3ExprAnd
(
db
, pWhere, 
pNe
);

70982 
	`memset
(&
sNameContext
, 0, sizeof(
NameContext
));

70983 
sNameContext
.
pSrcList
 = 
pSrc
;

70984 
sNameContext
.
pParse
 = pParse;

70985 
	`sqlite3ResolveExprNames
(&
sNameContext
, 
pWhere
);

70990 
pWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pSrc
, 
pWhere
, 0, 0, 0, 0);

70991 
	`sqlite3VdbeAddOp2
(
v
, 135, 
pFKey
->
isDeferred
, 
nIncr
);

70992 if( 
pWInfo
 )

70995 
	`sqlite3WhereEnd
(
pWInfo
);

70999 
	`sqlite3ExprDelete
(
db
, 
pWhere
);

71000 if( 
iFkIfZero
 )

71003 
	`sqlite3VdbeJumpHere
(
v
, 
iFkIfZero
);

71005 
	}
}

71007 static 
FKey
 *
	$sqlite3FkReferences
(
Table
 *
pTab
)

71010 return (
FKey
 *)
	`sqlite3HashFind
(&
pTab
->
pSchema
->
fkeyHash
, pTab->
zName
);

71011 
	}
}

71013 static void 
	$fkTriggerDelete
(
sqlite3
 *
dbMem
, 
Trigger
 *
p
)

71016 if( 
p
 )

71019 
TriggerStep
 *
pStep
 = 
p
->
step_list
;

71020 
	`sqlite3ExprDelete
(
dbMem
, 
pStep
->
pWhere
);

71021 
	`sqlite3ExprListDelete
(
dbMem
, 
pStep
->
pExprList
);

71022 
	`sqlite3SelectDelete
(
dbMem
, 
pStep
->
pSelect
);

71023 
	`sqlite3ExprDelete
(
dbMem
, 
p
->
pWhen
);

71024 
	`sqlite3DbFree
(
dbMem
, 
p
);

71026 
	}
}

71028 static void 
	$sqlite3FkDropTable
(
Parse
 *
pParse
, 
SrcList
 *
pName
, 
Table
 *
pTab
)

71031 
sqlite3
 *
db
 = 
pParse
->db;

71032 if( (
db
->
flags
&0x00080000) && !(((
pTab
)->
tabFlags
 & 0x10)!=0) && !pTab->
pSelect
 )

71035 int 
iSkip
 = 0;

71036 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

71039 if( 
	`sqlite3FkReferences
(
pTab
)==0 )

71047 
FKey
 *
p
;

71048 for(
p
=
pTab
->
pFKey
; p; p=p->
pNextFrom
)

71051 if( 
p
->
isDeferred
 || (
db
->
flags
 & 0x01000000) ) break;

71053 if( !
p
 ) return;

71054 
iSkip
 = 
	`sqlite3VdbeMakeLabel
(
v
);

71055 
	`sqlite3VdbeAddOp2
(
v
, 136, 1, 
iSkip
); ;

71058 
pParse
->
disableTriggers
 = 1;

71059 
	`sqlite3DeleteFrom
(
pParse
, 
	`sqlite3SrcListDup
(
db
, 
pName
, 0), 0);

71060 
pParse
->
disableTriggers
 = 0;

71062 if( (
db
->
flags
 & 0x01000000)==0 )

71065 
	`sqlite3VdbeAddOp2
(
v
, 136, 0, 
	`sqlite3VdbeCurrentAddr
(v)+2);

71067 
	`sqlite3HaltConstraint
(
pParse
, (19 | (3<<8)),

71071 if( 
iSkip
 )

71074 
	`sqlite3VdbeResolveLabel
(
v
, 
iSkip
);

71077 
	}
}

71079 static int 
	$fkChildIsModified
(

71080 
Table
 *
pTab
,

71081 
FKey
 *
p
,

71082 int *
aChange
,

71083 int 
bChngRowid


71087 int 
i
;

71088 for(
i
=0; i<
p
->
nCol
; i++)

71091 int 
iChildKey
 = 
p
->
aCol
[
i
].
iFrom
;

71092 if( 
aChange
[
iChildKey
]>=0 ) return 1;

71093 if( 
iChildKey
==
pTab
->
iPKey
 && 
bChngRowid
 ) return 1;

71096 
	}
}

71098 static int 
	$fkParentIsModified
(

71099 
Table
 *
pTab
,

71100 
FKey
 *
p
,

71101 int *
aChange
,

71102 int 
bChngRowid


71106 int 
i
;

71107 for(
i
=0; i<
p
->
nCol
; i++)

71110 char *
zKey
 = 
p
->
aCol
[
i
].
zCol
;

71111 int 
iKey
;

71112 for(
iKey
=0; iKey<
pTab
->
nCol
; iKey++)

71115 if( 
aChange
[
iKey
]>=0 || (iKey==
pTab
->
iPKey
 && 
bChngRowid
) )

71118 
Column
 *
pCol
 = &
pTab
->
aCol
[
iKey
];

71119 if( 
zKey
 )

71122 if( 0==
	`sqlite3StrICmp
(
pCol
->
zName
, 
zKey
) ) return 1;

71123 }else if( 
pCol
->
colFlags
 & 0x0001 )

71132 
	}
}

71139 static int 
	$isSetNullAction
(
Parse
 *
pParse
, 
FKey
 *
pFKey
)

71142 
Parse
 *
pTop
 = ((
pParse
)->
pToplevel
 ? (pParse)->pToplevel : (pParse));

71143 if( 
pTop
->
pTriggerPrg
 )

71146 
Trigger
 *
p
 = 
pTop
->
pTriggerPrg
->
pTrigger
;

71147 if( (
p
==
pFKey
->
apTrigger
[0] && pFKey->
aAction
[0]==7)

71148 || (
p
==
pFKey
->
apTrigger
[1] && pFKey->
aAction
[1]==7)

71156 
	}
}

71158 static void 
	$sqlite3FkCheck
(

71159 
Parse
 *
pParse
,

71160 
Table
 *
pTab
,

71161 int 
regOld
,

71162 int 
regNew
,

71163 int *
aChange
,

71164 int 
bChngRowid


71168 
sqlite3
 *
db
 = 
pParse
->db;

71169 
FKey
 *
pFKey
;

71170 int 
iDb
;

71171 const char *
zDb
;

71172 int 
isIgnoreErrors
 = 
pParse
->
disableTriggers
;

71178 if( (
db
->
flags
&0x00080000)==0 ) return;

71180 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

71181 
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

71185 for(
pFKey
=
pTab
->pFKey; pFKey; pFKey=pFKey->
pNextFrom
)

71188 
Table
 *
pTo
;

71189 
Index
 *
pIdx
 = 0;

71190 int *
aiFree
 = 0;

71191 int *
aiCol
;

71192 int 
iCol
;

71193 int 
i
;

71194 int 
bIgnore
 = 0;

71196 if( 
aChange


71197 && 
	`sqlite3_stricmp
(
pTab
->
zName
, 
pFKey
->
zTo
)!=0

71198 && 
	`fkChildIsModified
(
pTab
, 
pFKey
, 
aChange
, 
bChngRowid
)==0

71209 if( 
pParse
->
disableTriggers
 )

71212 
pTo
 = 
	`sqlite3FindTable
(
db
, 
pFKey
->
zTo
, 
zDb
);

71214 
pTo
 = 
	`sqlite3LocateTable
(
pParse
, 0, 
pFKey
->
zTo
, 
zDb
);

71216 if( !
pTo
 || 
	`sqlite3FkLocateIndex
(
pParse
, pTo, 
pFKey
, &
pIdx
, &
aiFree
) )

71220 if( !
isIgnoreErrors
 || 
db
->
mallocFailed
 ) return;

71221 if( 
pTo
==0 )

71231 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

71232 int 
iJump
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 
pFKey
->
nCol
 + 1;

71233 for(
i
=0; i<
pFKey
->
nCol
; i++)

71236 int 
iReg
 = 
pFKey
->
aCol
[
i
].
iFrom
 + 
regOld
 + 1;

71237 
	`sqlite3VdbeAddOp2
(
v
, 76, 
iReg
, 
iJump
); ;

71239 
	`sqlite3VdbeAddOp2
(
v
, 135, 
pFKey
->
isDeferred
, -1);

71245 if( 
aiFree
 )

71248 
aiCol
 = 
aiFree
;

71250 
iCol
 = 
pFKey
->
aCol
[0].
iFrom
;

71251 
aiCol
 = &
iCol
;

71253 for(
i
=0; i<
pFKey
->
nCol
; i++)

71256 if( 
aiCol
[
i
]==
pTab
->
iPKey
 )

71259 
aiCol
[
i
] = -1;

71266 if( 
db
->
xAuth
 )

71269 int 
rcauth
;

71270 char *
zCol
 = 
pTo
->
aCol
[
pIdx
 ? pIdx->
aiColumn
[
i
] : pTo->
iPKey
].
zName
;

71271 
rcauth
 = 
	`sqlite3AuthReadCol
(
pParse
, 
pTo
->
zName
, 
zCol
, 
iDb
);

71272 
bIgnore
 = (
rcauth
==2);

71280 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTo
->
tnum
, 0, pTo->
zName
);

71281 
pParse
->
nTab
++;

71283 if( 
regOld
!=0 )

71289 
	`fkLookupParent
(
pParse
, 
iDb
, 
pTo
, 
pIdx
, 
pFKey
, 
aiCol
, 
regOld
, -1, 
bIgnore
);

71291 if( 
regNew
!=0 && !
	`isSetNullAction
(
pParse
, 
pFKey
) )

71295 
	`fkLookupParent
(
pParse
, 
iDb
, 
pTo
, 
pIdx
, 
pFKey
, 
aiCol
, 
regNew
, +1, 
bIgnore
);

71298 
	`sqlite3DbFree
(
db
, 
aiFree
);

71303 for(
pFKey
 = 
	`sqlite3FkReferences
(
pTab
); pFKey; pFKey=pFKey->
pNextTo
)

71306 
Index
 *
pIdx
 = 0;

71307 
SrcList
 *
pSrc
;

71308 int *
aiCol
 = 0;

71310 if( 
aChange
 && 
	`fkParentIsModified
(
pTab
, 
pFKey
, aChange, 
bChngRowid
)==0 )

71316 if( !
pFKey
->
isDeferred
 && !(
db
->
flags
 & 0x01000000)

71317 && !
pParse
->
pToplevel
 && !pParse->
isMultiWrite


71327 if( 
	`sqlite3FkLocateIndex
(
pParse
, 
pTab
, 
pFKey
, &
pIdx
, &
aiCol
) )

71330 if( !
isIgnoreErrors
 || 
db
->
mallocFailed
 ) return;

71337 
pSrc
 = 
	`sqlite3SrcListAppend
(
db
, 0, 0, 0);

71338 if( 
pSrc
 )

71341 struct 
SrcList_item
 *
pItem
 = 
pSrc
->
a
;

71342 
pItem
->
pTab
 = 
pFKey
->
pFrom
;

71343 
pItem
->
zName
 = 
pFKey
->
pFrom
->zName;

71344 
pItem
->
pTab
->
nRef
++;

71345 
pItem
->
iCursor
 = 
pParse
->
nTab
++;

71347 if( 
regNew
!=0 )

71350 
	`fkScanChildren
(
pParse
, 
pSrc
, 
pTab
, 
pIdx
, 
pFKey
, 
aiCol
, 
regNew
, -1);

71352 if( 
regOld
!=0 )

71355 int 
eAction
 = 
pFKey
->
aAction
[
aChange
!=0];

71356 
	`fkScanChildren
(
pParse
, 
pSrc
, 
pTab
, 
pIdx
, 
pFKey
, 
aiCol
, 
regOld
, 1);

71358 if( !
pFKey
->
isDeferred
 && 
eAction
!=9 && eAction!=7 )

71361 
	`sqlite3MayAbort
(
pParse
);

71364 
pItem
->
zName
 = 0;

71365 
	`sqlite3SrcListDelete
(
db
, 
pSrc
);

71367 
	`sqlite3DbFree
(
db
, 
aiCol
);

71369 
	}
}

71377 static 
u32
 
	$sqlite3FkOldmask
(

71378 
Parse
 *
pParse
,

71379 
Table
 *
pTab


71383 
u32
 
mask
 = 0;

71384 if( 
pParse
->
db
->
flags
&0x00080000 )

71387 
FKey
 *
p
;

71388 int 
i
;

71389 for(
p
=
pTab
->
pFKey
; p; p=p->
pNextFrom
)

71392 for(
i
=0; i<
p
->
nCol
; i++) 
mask
 |= (((p->
aCol
[i].
iFrom
)>31) ? 0xffffffff : ((
u32
)1<<(p->aCol[i].iFrom)));

71394 for(
p
=
	`sqlite3FkReferences
(
pTab
); p; p=p->
pNextTo
)

71397 
Index
 *
pIdx
 = 0;

71398 
	`sqlite3FkLocateIndex
(
pParse
, 
pTab
, 
p
, &
pIdx
, 0);

71399 if( 
pIdx
 )

71402 for(
i
=0; i<
pIdx
->
nKeyCol
; i++)

71406 
mask
 |= (((
pIdx
->
aiColumn
[
i
])>31) ? 0xffffffff : ((
u32
)1<<(pIdx->aiColumn[i])));

71411 return 
mask
;

71412 
	}
}

71414 static int 
	$sqlite3FkRequired
(

71415 
Parse
 *
pParse
,

71416 
Table
 *
pTab
,

71417 int *
aChange
,

71418 int 
chngRowid


71422 if( 
pParse
->
db
->
flags
&0x00080000 )

71425 if( !
aChange
 )

71431 return (
	`sqlite3FkReferences
(
pTab
) || pTab->
pFKey
);

71435 
FKey
 *
p
;

71438 for(
p
=
pTab
->
pFKey
; p; p=p->
pNextFrom
)

71441 if( 
	`fkChildIsModified
(
pTab
, 
p
, 
aChange
, 
chngRowid
) ) return 1;

71445 for(
p
=
	`sqlite3FkReferences
(
pTab
); p; p=p->
pNextTo
)

71448 if( 
	`fkParentIsModified
(
pTab
, 
p
, 
aChange
, 
chngRowid
) ) return 1;

71453 
	}
}

71455 static 
Trigger
 *
	$fkActionTrigger
(

71456 
Parse
 *
pParse
,

71457 
Table
 *
pTab
,

71458 
FKey
 *
pFKey
,

71459 
ExprList
 *
pChanges


71463 
sqlite3
 *
db
 = 
pParse
->db;

71464 int 
action
;

71465 
Trigger
 *
pTrigger
;

71466 int 
iAction
 = (
pChanges
!=0);

71468 
action
 = 
pFKey
->
aAction
[
iAction
];

71469 if( 
action
==6 && (
db
->
flags
 & 0x01000000) )

71475 
pTrigger
 = 
pFKey
->
apTrigger
[
iAction
];

71477 if( 
action
!=0 && !
pTrigger
 )

71480 char const *
zFrom
;

71481 int 
nFrom
;

71482 
Index
 *
pIdx
 = 0;

71483 int *
aiCol
 = 0;

71484 
TriggerStep
 *
pStep
 = 0;

71485 
Expr
 *
pWhere
 = 0;

71486 
ExprList
 *
pList
 = 0;

71487 
Select
 *
pSelect
 = 0;

71488 int 
i
;

71489 
Expr
 *
pWhen
 = 0;

71491 if( 
	`sqlite3FkLocateIndex
(
pParse
, 
pTab
, 
pFKey
, &
pIdx
, &
aiCol
) ) return 0;

71494 for(
i
=0; i<
pFKey
->
nCol
; i++)

71497 
Token
 
tOld
 = { "old", 3 };

71498 
Token
 
tNew
 = { "new", 3 };

71499 
Token
 
tFromCol
;

71500 
Token
 
tToCol
;

71501 int 
iFromCol
;

71502 
Expr
 *
pEq
;

71504 
iFromCol
 = 
aiCol
 ? aiCol[
i
] : 
pFKey
->
aCol
[0].
iFrom
;

71508 
	`sqlite3TokenInit
(&
tToCol
,

71509 
pTab
->
aCol
[
pIdx
 ? pIdx->
aiColumn
[
i
] : pTab->
iPKey
].
zName
);

71510 
	`sqlite3TokenInit
(&
tFromCol
, 
pFKey
->
pFrom
->
aCol
[
iFromCol
].
zName
);

71516 
pEq
 = 
	`sqlite3PExpr
(
pParse
, 79,

71517 
	`sqlite3PExpr
(
pParse
, 122,

71518 
	`sqlite3ExprAlloc
(
db
, 27, &
tOld
, 0),

71519 
	`sqlite3ExprAlloc
(
db
, 27, &
tToCol
, 0)

71521 
	`sqlite3ExprAlloc
(
db
, 27, &
tFromCol
, 0)

71523 
pWhere
 = 
	`sqlite3ExprAnd
(
db
, pWhere, 
pEq
);

71530 if( 
pChanges
 )

71533 
pEq
 = 
	`sqlite3PExpr
(
pParse
, 73,

71534 
	`sqlite3PExpr
(
pParse
, 122,

71535 
	`sqlite3ExprAlloc
(
db
, 27, &
tOld
, 0),

71536 
	`sqlite3ExprAlloc
(
db
, 27, &
tToCol
, 0),

71538 
	`sqlite3PExpr
(
pParse
, 122,

71539 
	`sqlite3ExprAlloc
(
db
, 27, &
tNew
, 0),

71540 
	`sqlite3ExprAlloc
(
db
, 27, &
tToCol
, 0),

71543 
pWhen
 = 
	`sqlite3ExprAnd
(
db
, pWhen, 
pEq
);

71546 if( 
action
!=6 && (action!=9 || 
pChanges
) )

71549 
Expr
 *
pNew
;

71550 if( 
action
==9 )

71553 
pNew
 = 
	`sqlite3PExpr
(
pParse
, 122,

71554 
	`sqlite3ExprAlloc
(
db
, 27, &
tNew
, 0),

71555 
	`sqlite3ExprAlloc
(
db
, 27, &
tToCol
, 0)

71557 }else if( 
action
==8 )

71560 
Expr
 *
pDflt
 = 
pFKey
->
pFrom
->
aCol
[
iFromCol
].pDflt;

71561 if( 
pDflt
 )

71564 
pNew
 = 
	`sqlite3ExprDup
(
db
, 
pDflt
, 0);

71566 
pNew
 = 
	`sqlite3PExpr
(
pParse
, 101, 0, 0, 0);

71569 
pNew
 = 
	`sqlite3PExpr
(
pParse
, 101, 0, 0, 0);

71571 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
, pList, 
pNew
);

71572 
	`sqlite3ExprListSetName
(
pParse
, 
pList
, &
tFromCol
, 0);

71575 
	`sqlite3DbFree
(
db
, 
aiCol
);

71577 
zFrom
 = 
pFKey
->
pFrom
->
zName
;

71578 
nFrom
 = 
	`sqlite3Strlen30
(
zFrom
);

71580 if( 
action
==6 )

71583 
Token
 
tFrom
;

71584 
Expr
 *
pRaise
;

71586 
tFrom
.
z
 = 
zFrom
;

71587 
tFrom
.
n
 = 
nFrom
;

71588 
pRaise
 = 
	`sqlite3Expr
(
db
, 57, "FOREIGN KEY constraint failed");

71589 if( 
pRaise
 )

71592 
pRaise
->
affinity
 = 2;

71594 
pSelect
 = 
	`sqlite3SelectNew
(
pParse
,

71595 
	`sqlite3ExprListAppend
(
pParse
, 0, 
pRaise
),

71596 
	`sqlite3SrcListAppend
(
db
, 0, &
tFrom
, 0),

71597 
pWhere
,

71600 
pWhere
 = 0;

71604 
db
->
lookaside
.
bDisable
++;

71606 
pTrigger
 = (
Trigger
 *)
	`sqlite3DbMallocZero
(
db
,

71607 sizeof(
Trigger
) +

71608 sizeof(
TriggerStep
) +

71609 
nFrom
 + 1

71611 if( 
pTrigger
 )

71614 
pStep
 = 
pTrigger
->
step_list
 = (
TriggerStep
 *)&pTrigger[1];

71615 
pStep
->
zTarget
 = (char *)&pStep[1];

71616 
	`memcpy
((char *)
pStep
->
zTarget
, 
zFrom
, 
nFrom
);

71618 
pStep
->
pWhere
 = 
	`sqlite3ExprDup
(
db
, pWhere, 0x0001);

71619 
pStep
->
pExprList
 = 
	`sqlite3ExprListDup
(
db
, 
pList
, 0x0001);

71620 
pStep
->
pSelect
 = 
	`sqlite3SelectDup
(
db
, pSelect, 0x0001);

71621 if( 
pWhen
 )

71624 
pWhen
 = 
	`sqlite3PExpr
(
pParse
, 19, pWhen, 0, 0);

71625 
pTrigger
->
pWhen
 = 
	`sqlite3ExprDup
(
db
, pWhen, 0x0001);

71630 
db
->
lookaside
.
bDisable
--;

71632 
	`sqlite3ExprDelete
(
db
, 
pWhere
);

71633 
	`sqlite3ExprDelete
(
db
, 
pWhen
);

71634 
	`sqlite3ExprListDelete
(
db
, 
pList
);

71635 
	`sqlite3SelectDelete
(
db
, 
pSelect
);

71636 if( 
db
->
mallocFailed
==1 )

71639 
	`fkTriggerDelete
(
db
, 
pTrigger
);

71644 switch( 
action
 )

71648 
pStep
->
op
 = 119;

71651 if( !
pChanges
 )

71654 
pStep
->
op
 = 109;

71658 
pStep
->
op
 = 110;

71660 
pStep
->
pTrig
 = 
pTrigger
;

71661 
pTrigger
->
pSchema
 = 
pTab
->pSchema;

71662 
pTrigger
->
pTabSchema
 = 
pTab
->
pSchema
;

71663 
pFKey
->
apTrigger
[
iAction
] = 
pTrigger
;

71664 
pTrigger
->
op
 = (
pChanges
 ? 110 : 109);

71667 return 
pTrigger
;

71668 
	}
}

71674 static void 
	$sqlite3FkActions
(

71675 
Parse
 *
pParse
,

71676 
Table
 *
pTab
,

71677 
ExprList
 *
pChanges
,

71678 int 
regOld
,

71679 int *
aChange
,

71680 int 
bChngRowid


71688 if( 
pParse
->
db
->
flags
&0x00080000 )

71691 
FKey
 *
pFKey
;

71692 for(
pFKey
 = 
	`sqlite3FkReferences
(
pTab
); pFKey; pFKey=pFKey->
pNextTo
)

71695 if( 
aChange
==0 || 
	`fkParentIsModified
(
pTab
, 
pFKey
, aChange, 
bChngRowid
) )

71698 
Trigger
 *
pAct
 = 
	`fkActionTrigger
(
pParse
, 
pTab
, 
pFKey
, 
pChanges
);

71699 if( 
pAct
 )

71702 
	`sqlite3CodeRowTriggerDirect
(
pParse
, 
pAct
, 
pTab
, 
regOld
, 2, 0);

71707 
	}
}

71709 static void 
	$sqlite3FkDelete
(
sqlite3
 *
db
, 
Table
 *
pTab
)

71712 
FKey
 *
pFKey
;

71713 
FKey
 *
pNext
;

71716 for(
pFKey
=
pTab
->pFKey; pFKey; pFKey=
pNext
)

71721 if( !
db
 || db->
pnBytesFreed
==0 )

71724 if( 
pFKey
->
pPrevTo
 )

71727 
pFKey
->
pPrevTo
->
pNextTo
 = pFKey->pNextTo;

71729 void *
p
 = (void *)
pFKey
->
pNextTo
;

71730 const char *
z
 = (
p
 ? 
pFKey
->
pNextTo
->
zTo
 : pFKey->zTo);

71731 
	`sqlite3HashInsert
(&
pTab
->
pSchema
->
fkeyHash
, 
z
, 
p
);

71733 if( 
pFKey
->
pNextTo
 )

71736 
pFKey
->
pNextTo
->
pPrevTo
 = pFKey->pPrevTo;

71747 
	`fkTriggerDelete
(
db
, 
pFKey
->
apTrigger
[0]);

71748 
	`fkTriggerDelete
(
db
, 
pFKey
->
apTrigger
[1]);

71751 
pNext
 = 
pFKey
->
pNextFrom
;

71752 
	`sqlite3DbFree
(
db
, 
pFKey
);

71754 
	}
}

71756 static void 
	$sqlite3OpenTable
(

71757 
Parse
 *
pParse
,

71758 int 
iCur
,

71759 int 
iDb
,

71760 
Table
 *
pTab
,

71761 int 
opcode


71765 
Vdbe
 *
v
;

71767 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

71769 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
,

71770 (
opcode
==55)?1:0, 
pTab
->
zName
);

71771 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

71774 
	`sqlite3VdbeAddOp4Int
(
v
, 
opcode
, 
iCur
, 
pTab
->
tnum
, 
iDb
, pTab->
nCol
);

71777 
Index
 *
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

71780 
	`sqlite3VdbeAddOp3
(
v
, 
opcode
, 
iCur
, 
pPk
->
tnum
, 
iDb
);

71781 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pPk
);

71784 
	}
}

71786 static const char *
	$sqlite3IndexAffinityStr
(
sqlite3
 *
db
, 
Index
 *
pIdx
)

71789 if( !
pIdx
->
zColAff
 )

71793 int 
n
;

71794 
Table
 *
pTab
 = 
pIdx
->
pTable
;

71795 
pIdx
->
zColAff
 = (char *)
	`sqlite3DbMallocRaw
(0, pIdx->
nColumn
+1);

71796 if( !
pIdx
->
zColAff
 )

71799 
	`sqlite3OomFault
(
db
);

71802 for(
n
=0; n<
pIdx
->
nColumn
; n++)

71805 
i16
 
x
 = 
pIdx
->
aiColumn
[
n
];

71806 if( 
x
>=0 )

71809 
pIdx
->
zColAff
[
n
] = 
pTab
->
aCol
[
x
].
affinity
;

71810 }else if( 
x
==(-1) )

71813 
pIdx
->
zColAff
[
n
] = 'D';

71815 char 
aff
;

71818 
aff
 = 
	`sqlite3ExprAffinity
(
pIdx
->
aColExpr
->
a
[
n
].
pExpr
);

71819 if( 
aff
==0 ) aff = 'A';

71820 
pIdx
->
zColAff
[
n
] = 
aff
;

71823 
pIdx
->
zColAff
[
n
] = 0;

71826 return 
pIdx
->
zColAff
;

71827 
	}
}

71829 static void 
	$sqlite3TableAffinity
(
Vdbe
 *
v
, 
Table
 *
pTab
, int 
iReg
)

71832 int 
i
;

71833 char *
zColAff
 = 
pTab
->zColAff;

71834 if( 
zColAff
==0 )

71837 
sqlite3
 *
db
 = 
	`sqlite3VdbeDb
(
v
);

71838 
zColAff
 = (char *)
	`sqlite3DbMallocRaw
(0, 
pTab
->
nCol
+1);

71839 if( !
zColAff
 )

71842 
	`sqlite3OomFault
(
db
);

71846 for(
i
=0; i<
pTab
->
nCol
; i++)

71849 
zColAff
[
i
] = 
pTab
->
aCol
[i].
affinity
;

71852 
zColAff
[
i
--] = 0;

71853 }while( 
i
>=0 && 
zColAff
[i]=='A' );

71854 
pTab
->
zColAff
 = zColAff;

71856 
i
 = 
	`sqlite3Strlen30
(
zColAff
);

71857 if( 
i
 )

71860 if( 
iReg
 )

71863 
	`sqlite3VdbeAddOp4
(
v
, 48, 
iReg
, 
i
, 0, 
zColAff
, i);

71865 
	`sqlite3VdbeChangeP4
(
v
, -1, 
zColAff
, 
i
);

71868 
	}
}

71876 static int 
	$readsTable
(
Parse
 *
p
, int 
iDb
, 
Table
 *
pTab
)

71879 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
p
);

71880 int 
i
;

71881 int 
iEnd
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

71883 
VTable
 *
pVTab
 = (((
pTab
)->
tabFlags
 & 0x10)!=0) ? 
	`sqlite3GetVTable
(
p
->
db
, pTab) : 0;

71886 for(
i
=1; i<
iEnd
; i++)

71889 
VdbeOp
 *
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, 
i
);

71891 if( 
pOp
->
opcode
==54 && pOp->
p3
==
iDb
 )

71894 
Index
 *
pIndex
;

71895 int 
tnum
 = 
pOp
->
p2
;

71896 if( 
tnum
==
pTab
->tnum )

71901 for(
pIndex
=
pTab
->pIndex; pIndex; pIndex=pIndex->
pNext
)

71904 if( 
tnum
==
pIndex
->tnum )

71912 if( 
pOp
->
opcode
==152 && pOp->
p4
.
pVtab
==
pVTab
 )

71922 
	}
}

71924 static int 
	$autoIncBegin
(

71925 
Parse
 *
pParse
,

71926 int 
iDb
,

71927 
Table
 *
pTab


71931 int 
memId
 = 0;

71932 if( 
pTab
->
tabFlags
 & 0x08 )

71935 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

71936 
AutoincInfo
 *
pInfo
;

71938 
pInfo
 = 
pToplevel
->
pAinc
;

71939 while( 
pInfo
 && pInfo->
pTab
!=pTab )

71941 
pInfo
 = pInfo->
pNext
; }

71942 if( 
pInfo
==0 )

71945 
pInfo
 = 
	`sqlite3DbMallocRawNN
(
pParse
->
db
, sizeof(*pInfo));

71946 if( 
pInfo
==0 ) return 0;

71947 
pInfo
->
pNext
 = 
pToplevel
->
pAinc
;

71948 
pToplevel
->
pAinc
 = 
pInfo
;

71949 
pInfo
->
pTab
 = pTab;

71950 
pInfo
->
iDb
 = iDb;

71951 
pToplevel
->
nMem
++;

71952 
pInfo
->
regCtr
 = ++
pToplevel
->
nMem
;

71953 
pToplevel
->
nMem
++;

71955 
memId
 = 
pInfo
->
regCtr
;

71957 return 
memId
;

71958 
	}
}

71964 static void 
	$sqlite3AutoincrementBegin
(
Parse
 *
pParse
)

71967 
AutoincInfo
 *
p
;

71968 
sqlite3
 *
db
 = 
pParse
->db;

71969 
Db
 *
pDb
;

71970 int 
memId
;

71971 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

71979 for(
p
 = 
pParse
->
pAinc
; p; p = p->
pNext
)

71982 static const int 
iLn
 = 0;

71983 static const 
VdbeOpList
 
autoInc
[] = {

71995 
VdbeOp
 *
aOp
;

71996 
pDb
 = &
db
->
aDb
[
p
->
iDb
];

71997 
memId
 = 
p
->
regCtr
;

71999 
	`sqlite3OpenTable
(
pParse
, 0, 
p
->
iDb
, 
pDb
->
pSchema
->
pSeqTab
, 54);

72000 
	`sqlite3VdbeLoadString
(
v
, 
memId
-1, 
p
->
pTab
->
zName
);

72001 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
autoInc
)/sizeof(autoInc[0]))), autoInc, 
iLn
);

72002 if( 
aOp
==0 ) break;

72003 
aOp
[0].
p2
 = 
memId
;

72004 
aOp
[0].
p3
 = 
memId
+1;

72005 
aOp
[2].
p3
 = 
memId
;

72006 
aOp
[3].
p1
 = 
memId
-1;

72007 
aOp
[3].
p3
 = 
memId
;

72008 
aOp
[3].
p5
 = 0x10;

72009 
aOp
[4].
p2
 = 
memId
+1;

72010 
aOp
[5].
p3
 = 
memId
;

72011 
aOp
[8].
p2
 = 
memId
;

72013 
	}
}

72015 static void 
	$autoIncStep
(
Parse
 *
pParse
, int 
memId
, int 
regRowid
)

72018 if( 
memId
>0 )

72021 
	`sqlite3VdbeAddOp2
(
pParse
->
pVdbe
, 137, 
memId
, 
regRowid
);

72023 
	}
}

72025 static 
__attribute__
((
noinline
)) void 
	$autoIncrementEnd
(
Parse
 *
pParse
)

72028 
AutoincInfo
 *
p
;

72029 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

72030 
sqlite3
 *
db
 = 
pParse
->db;

72033 for(
p
 = 
pParse
->
pAinc
; p; p = p->
pNext
)

72036 static const int 
iLn
 = 0;

72037 static const 
VdbeOpList
 
autoIncEnd
[] = {

72044 
VdbeOp
 *
aOp
;

72045 
Db
 *
pDb
 = &
db
->
aDb
[
p
->
iDb
];

72046 int 
iRec
;

72047 int 
memId
 = 
p
->
regCtr
;

72049 
iRec
 = 
	`sqlite3GetTempReg
(
pParse
);

72051 
	`sqlite3OpenTable
(
pParse
, 0, 
p
->
iDb
, 
pDb
->
pSchema
->
pSeqTab
, 55);

72052 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
autoIncEnd
)/sizeof(autoIncEnd[0]))), autoIncEnd, 
iLn
);

72053 if( 
aOp
==0 ) break;

72054 
aOp
[0].
p1
 = 
memId
+1;

72055 
aOp
[1].
p2
 = 
memId
+1;

72056 
aOp
[2].
p1
 = 
memId
-1;

72057 
aOp
[2].
p3
 = 
iRec
;

72058 
aOp
[3].
p2
 = 
iRec
;

72059 
aOp
[3].
p3
 = 
memId
+1;

72060 
aOp
[3].
p5
 = 0x08;

72061 
	`sqlite3ReleaseTempReg
(
pParse
, 
iRec
);

72063 
	}
}

72064 static void 
	$sqlite3AutoincrementEnd
(
Parse
 *
pParse
)

72067 if( 
pParse
->
pAinc
 ) 
	`autoIncrementEnd
(pParse);

72068 
	}
}

72070 static int 
xferOptimization
(

72071 
Parse
 *
pParse
,

72072 
Table
 *
pDest
,

72073 
Select
 *
pSelect
,

72074 int 
onError
,

72075 int 
iDbDest


72078 static void 
	$sqlite3Insert
(

72079 
Parse
 *
pParse
,

72080 
SrcList
 *
pTabList
,

72081 
Select
 *
pSelect
,

72082 
IdList
 *
pColumn
,

72083 int 
onError


72087 
sqlite3
 *
db
;

72088 
Table
 *
pTab
;

72089 char *
zTab
;

72090 const char *
zDb
;

72091 int 
i
, 
j
, 
idx
;

72092 
Vdbe
 *
v
;

72093 
Index
 *
pIdx
;

72094 int 
nColumn
;

72095 int 
nHidden
 = 0;

72096 int 
iDataCur
 = 0;

72097 int 
iIdxCur
 = 0;

72098 int 
ipkColumn
 = -1;

72099 int 
endOfLoop
;

72100 int 
srcTab
 = 0;

72101 int 
addrInsTop
 = 0;

72102 int 
addrCont
 = 0;

72103 
SelectDest
 
dest
;

72104 int 
iDb
;

72105 
Db
 *
pDb
;

72106 
u8
 
useTempTable
 = 0;

72107 
u8
 
appendFlag
 = 0;

72108 
u8
 
withoutRowid
;

72109 
u8
 
bIdListInOrder
;

72110 
ExprList
 *
pList
 = 0;

72113 int 
regFromSelect
 = 0;

72114 int 
regAutoinc
 = 0;

72115 int 
regRowCount
 = 0;

72116 int 
regIns
;

72117 int 
regRowid
;

72118 int 
regData
;

72119 int *
aRegIdx
 = 0;

72122 int 
isView
;

72123 
Trigger
 *
pTrigger
;

72124 int 
tmask
;

72127 
db
 = 
pParse
->db;

72128 
	`memset
(&
dest
, 0, sizeof(dest));

72129 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 )

72132 goto 
insert_cleanup
;

72139 if( 
pSelect
 && (pSelect->
selFlags
 & 0x00100)!=0 && pSelect->
pPrior
==0 )

72142 
pList
 = 
pSelect
->
pEList
;

72143 
pSelect
->
pEList
 = 0;

72144 
	`sqlite3SelectDelete
(
db
, 
pSelect
);

72145 
pSelect
 = 0;

72151 
zTab
 = 
pTabList
->
a
[0].
zName
;

72152 if( (
zTab
==0) ) goto 
insert_cleanup
;

72153 
pTab
 = 
	`sqlite3SrcListLookup
(
pParse
, 
pTabList
);

72154 if( 
pTab
==0 )

72157 goto 
insert_cleanup
;

72159 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

72161 
pDb
 = &
db
->
aDb
[
iDb
];

72162 
zDb
 = 
pDb
->
zName
;

72163 if( 
	`sqlite3AuthCheck
(
pParse
, 18, 
pTab
->
zName
, 0, 
zDb
) )

72166 goto 
insert_cleanup
;

72168 
withoutRowid
 = !(((
pTab
)->
tabFlags
 & 0x20)==0);

72174 
pTrigger
 = 
	`sqlite3TriggersExist
(
pParse
, 
pTab
, 108, 0, &
tmask
);

72175 
isView
 = 
pTab
->
pSelect
!=0;

72182 if( 
	`sqlite3ViewGetColumnNames
(
pParse
, 
pTab
) )

72185 goto 
insert_cleanup
;

72190 if( 
	`sqlite3IsReadOnly
(
pParse
, 
pTab
, 
tmask
) )

72193 goto 
insert_cleanup
;

72198 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

72199 if( 
v
==0 ) goto 
insert_cleanup
;

72200 if( 
pParse
->
nested
==0 ) 
	`sqlite3VdbeCountChanges
(
v
);

72201 
	`sqlite3BeginWriteOperation
(
pParse
, 
pSelect
 || 
pTrigger
, 
iDb
);

72203 if( 
pColumn
==0 && 
	`xferOptimization
(
pParse
, 
pTab
, 
pSelect
, 
onError
, 
iDb
) )

72208 goto 
insert_end
;

72215 
regAutoinc
 = 
	`autoIncBegin
(
pParse
, 
iDb
, 
pTab
);

72220 
regRowid
 = 
regIns
 = 
pParse
->
nMem
+1;

72221 
pParse
->
nMem
 += 
pTab
->
nCol
 + 1;

72222 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

72225 
regRowid
++;

72226 
pParse
->
nMem
++;

72228 
regData
 = 
regRowid
+1;

72230 
bIdListInOrder
 = (
pTab
->
tabFlags
 & 0x80)==0;

72231 if( 
pColumn
 )

72234 for(
i
=0; i<
pColumn
->
nId
; i++)

72237 
pColumn
->
a
[
i
].
idx
 = -1;

72239 for(
i
=0; i<
pColumn
->
nId
; i++)

72242 for(
j
=0; j<
pTab
->
nCol
; j++)

72245 if( 
	`sqlite3StrICmp
(
pColumn
->
a
[
i
].
zName
, 
pTab
->
aCol
[
j
].zName)==0 )

72248 
pColumn
->
a
[
i
].
idx
 = 
j
;

72249 if( 
i
!=
j
 ) 
bIdListInOrder
 = 0;

72250 if( 
j
==
pTab
->
iPKey
 )

72253 
ipkColumn
 = 
i
; ((void) (0));

72258 if( 
j
>=
pTab
->
nCol
 )

72261 if( 
	`sqlite3IsRowid
(
pColumn
->
a
[
i
].
zName
) && !
withoutRowid
 )

72264 
ipkColumn
 = 
i
;

72265 
bIdListInOrder
 = 0;

72267 
	`sqlite3ErrorMsg
(
pParse
, "table %S has no column named %s",

72268 
pTabList
, 0, 
pColumn
->
a
[
i
].
zName
);

72269 
pParse
->
checkSchema
 = 1;

72270 goto 
insert_cleanup
;

72281 if( 
pSelect
 )

72286 int 
regYield
;

72287 int 
addrTop
;

72288 int 
rc
;

72290 
regYield
 = ++
pParse
->
nMem
;

72291 
addrTop
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 1;

72292 
	`sqlite3VdbeAddOp3
(
v
, 16, 
regYield
, 0, 
addrTop
);

72293 
	`sqlite3SelectDestInit
(&
dest
, 13, 
regYield
);

72294 
dest
.
iSdst
 = 
bIdListInOrder
 ? 
regData
 : 0;

72295 
dest
.
nSdst
 = 
pTab
->
nCol
;

72296 
rc
 = 
	`sqlite3Select
(
pParse
, 
pSelect
, &
dest
);

72297 
regFromSelect
 = 
dest
.
iSdst
;

72298 if( 
rc
 || 
db
->
mallocFailed
 || 
pParse
->
nErr
 ) goto 
insert_cleanup
;

72299 
	`sqlite3VdbeEndCoroutine
(
v
, 
regYield
);

72300 
	`sqlite3VdbeJumpHere
(
v
, 
addrTop
 - 1);

72302 
nColumn
 = 
pSelect
->
pEList
->
nExpr
;

72304 if( 
pTrigger
 || 
	`readsTable
(
pParse
, 
iDb
, 
pTab
) )

72307 
useTempTable
 = 1;

72310 if( 
useTempTable
 )

72314 int 
regRec
;

72315 int 
regTempRowid
;

72316 int 
addrL
;

72318 
srcTab
 = 
pParse
->
nTab
++;

72319 
regRec
 = 
	`sqlite3GetTempReg
(
pParse
);

72320 
regTempRowid
 = 
	`sqlite3GetTempReg
(
pParse
);

72321 
	`sqlite3VdbeAddOp2
(
v
, 57, 
srcTab
, 
nColumn
);

72322 
addrL
 = 
	`sqlite3VdbeAddOp1
(
v
, 18, 
dest
.
iSDParm
); ;

72323 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regFromSelect
, 
nColumn
, 
regRec
);

72324 
	`sqlite3VdbeAddOp2
(
v
, 74, 
srcTab
, 
regTempRowid
);

72325 
	`sqlite3VdbeAddOp3
(
v
, 75, 
srcTab
, 
regRec
, 
regTempRowid
);

72326 
	`sqlite3VdbeGoto
(
v
, 
addrL
);

72327 
	`sqlite3VdbeJumpHere
(
v
, 
addrL
);

72328 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRec
);

72329 
	`sqlite3ReleaseTempReg
(
pParse
, 
regTempRowid
);

72335 
NameContext
 
sNC
;

72336 
	`memset
(&
sNC
, 0, sizeof(sNC));

72337 
sNC
.
pParse
 = pParse;

72338 
srcTab
 = -1;

72340 if( 
pList
 )

72343 
nColumn
 = 
pList
->
nExpr
;

72344 if( 
	`sqlite3ResolveExprListNames
(&
sNC
, 
pList
) )

72347 goto 
insert_cleanup
;

72350 
nColumn
 = 0;

72358 if( 
pColumn
==0 && 
nColumn
>0 )

72361 
ipkColumn
 = 
pTab
->
iPKey
;

72367 for(
i
=0; i<
pTab
->
nCol
; i++)

72370 
nHidden
 += ((((&
pTab
->
aCol
[
i
])->
colFlags
 & 0x0002)!=0) ? 1 : 0);

72372 if( 
pColumn
==0 && 
nColumn
 && nColumn!=(
pTab
->
nCol
-
nHidden
) )

72375 
	`sqlite3ErrorMsg
(
pParse
,

72377 
pTabList
, 0, 
pTab
->
nCol
-
nHidden
, 
nColumn
);

72378 goto 
insert_cleanup
;

72380 if( 
pColumn
!=0 && 
nColumn
!=pColumn->
nId
 )

72383 
	`sqlite3ErrorMsg
(
pParse
, "%d values for %d columns", 
nColumn
, 
pColumn
->
nId
);

72384 goto 
insert_cleanup
;

72389 if( 
db
->
flags
 & 0x00000080 )

72392 
regRowCount
 = ++
pParse
->
nMem
;

72393 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
regRowCount
);

72397 if( !
isView
 )

72400 int 
nIdx
;

72401 
nIdx
 = 
	`sqlite3OpenTableAndIndices
(
pParse
, 
pTab
, 55, 0, -1, 0,

72402 &
iDataCur
, &
iIdxCur
);

72403 
aRegIdx
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(int)*(
nIdx
+1));

72404 if( 
aRegIdx
==0 )

72407 goto 
insert_cleanup
;

72409 for(
i
=0; i<
nIdx
; i++)

72412 
aRegIdx
[
i
] = ++
pParse
->
nMem
;

72417 if( 
useTempTable
 )

72421 
addrInsTop
 = 
	`sqlite3VdbeAddOp1
(
v
, 108, 
srcTab
); ;

72422 
addrCont
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

72423 }else if( 
pSelect
 )

72427 
addrInsTop
 = 
addrCont
 = 
	`sqlite3VdbeAddOp1
(
v
, 18, 
dest
.
iSDParm
);

72433 
endOfLoop
 = 
	`sqlite3VdbeMakeLabel
(
v
);

72434 if( 
tmask
 & 1 )

72437 int 
regCols
 = 
	`sqlite3GetTempRange
(
pParse
, 
pTab
->
nCol
+1);

72445 if( 
ipkColumn
<0 )

72448 
	`sqlite3VdbeAddOp2
(
v
, 22, -1, 
regCols
);

72450 int 
addr1
;

72452 if( 
useTempTable
 )

72455 
	`sqlite3VdbeAddOp3
(
v
, 47, 
srcTab
, 
ipkColumn
, 
regCols
);

72458 
	`sqlite3ExprCode
(
pParse
, 
pList
->
a
[
ipkColumn
].
pExpr
, 
regCols
);

72460 
addr1
 = 
	`sqlite3VdbeAddOp1
(
v
, 77, 
regCols
); ;

72461 
	`sqlite3VdbeAddOp2
(
v
, 22, -1, 
regCols
);

72462 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

72463 
	`sqlite3VdbeAddOp1
(
v
, 38, 
regCols
); ;

72473 for(
i
=
j
=0; i<
pTab
->
nCol
; i++)

72476 if( 
pColumn
 )

72479 for(
j
=0; j<
pColumn
->
nId
; j++)

72482 if( 
pColumn
->
a
[
j
].
idx
==
i
 ) break;

72485 if( (!
useTempTable
 && !
pList
) || (
pColumn
 && 
j
>=pColumn->
nId
)

72486 || (
pColumn
==0 && 0) )

72489 
	`sqlite3ExprCode
(
pParse
, 
pTab
->
aCol
[
i
].
pDflt
, 
regCols
+i+1);

72490 }else if( 
useTempTable
 )

72493 
	`sqlite3VdbeAddOp3
(
v
, 47, 
srcTab
, 
j
, 
regCols
+
i
+1);

72496 
	`sqlite3ExprCodeAndCache
(
pParse
, 
pList
->
a
[
j
].
pExpr
, 
regCols
+
i
+1);

72498 if( 
pColumn
==0 && !0 ) 
j
++;

72506 if( !
isView
 )

72509 
	`sqlite3TableAffinity
(
v
, 
pTab
, 
regCols
+1);

72513 
	`sqlite3CodeRowTrigger
(
pParse
, 
pTrigger
, 108, 0, 1,

72514 
pTab
, 
regCols
-pTab->
nCol
-1, 
onError
, 
endOfLoop
);

72516 
	`sqlite3ReleaseTempRange
(
pParse
, 
regCols
, 
pTab
->
nCol
+1);

72522 if( !
isView
 )

72525 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

72529 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regIns
);

72531 if( 
ipkColumn
>=0 )

72534 if( 
useTempTable
 )

72537 
	`sqlite3VdbeAddOp3
(
v
, 47, 
srcTab
, 
ipkColumn
, 
regRowid
);

72538 }else if( 
pSelect
 )

72541 
	`sqlite3VdbeAddOp2
(
v
, 30, 
regFromSelect
+
ipkColumn
, 
regRowid
);

72543 
VdbeOp
 *
pOp
;

72544 
	`sqlite3ExprCode
(
pParse
, 
pList
->
a
[
ipkColumn
].
pExpr
, 
regRowid
);

72545 
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, -1);

72546 if( (
pOp
) && pOp->
opcode
==25 && !(((
pTab
)->
tabFlags
 & 0x10)!=0) )

72549 
appendFlag
 = 1;

72550 
pOp
->
opcode
 = 74;

72551 
pOp
->
p1
 = 
iDataCur
;

72552 
pOp
->
p2
 = 
regRowid
;

72553 
pOp
->
p3
 = 
regAutoinc
;

72559 if( !
appendFlag
 )

72562 int 
addr1
;

72563 if( !(((
pTab
)->
tabFlags
 & 0x10)!=0) )

72566 
addr1
 = 
	`sqlite3VdbeAddOp1
(
v
, 77, 
regRowid
); ;

72567 
	`sqlite3VdbeAddOp3
(
v
, 74, 
iDataCur
, 
regRowid
, 
regAutoinc
);

72568 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

72570 
addr1
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

72571 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regRowid
, 
addr1
+2); ;

72573 
	`sqlite3VdbeAddOp1
(
v
, 38, 
regRowid
); ;

72575 }else if( (((
pTab
)->
tabFlags
 & 0x10)!=0) || 
withoutRowid
 )

72578 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regRowid
);

72580 
	`sqlite3VdbeAddOp3
(
v
, 74, 
iDataCur
, 
regRowid
, 
regAutoinc
);

72581 
appendFlag
 = 1;

72583 
	`autoIncStep
(
pParse
, 
regAutoinc
, 
regRowid
);

72588 
nHidden
 = 0;

72589 for(
i
=0; i<
pTab
->
nCol
; i++)

72592 int 
iRegStore
 = 
regRowid
+1+
i
;

72593 if( 
i
==
pTab
->
iPKey
 )

72601 
	`sqlite3VdbeAddOp1
(
v
, 26, 
iRegStore
);

72604 if( 
pColumn
==0 )

72607 if( (((&
pTab
->
aCol
[
i
])->
colFlags
 & 0x0002)!=0) )

72610 
j
 = -1;

72611 
nHidden
++;

72613 
j
 = 
i
 - 
nHidden
;

72616 for(
j
=0; j<
pColumn
->
nId
; j++)

72619 if( 
pColumn
->
a
[
j
].
idx
==
i
 ) break;

72622 if( 
j
<0 || 
nColumn
==0 || (
pColumn
 && j>=pColumn->
nId
) )

72625 
	`sqlite3ExprCodeFactorable
(
pParse
, 
pTab
->
aCol
[
i
].
pDflt
, 
iRegStore
);

72626 }else if( 
useTempTable
 )

72629 
	`sqlite3VdbeAddOp3
(
v
, 47, 
srcTab
, 
j
, 
iRegStore
);

72630 }else if( 
pSelect
 )

72633 if( 
regFromSelect
!=
regData
 )

72636 
	`sqlite3VdbeAddOp2
(
v
, 31, 
regFromSelect
+
j
, 
iRegStore
);

72639 
	`sqlite3ExprCode
(
pParse
, 
pList
->
a
[
j
].
pExpr
, 
iRegStore
);

72647 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

72650 const char *
pVTab
 = (const char *)
	`sqlite3GetVTable
(
db
, 
pTab
);

72651 
	`sqlite3VtabMakeWritable
(
pParse
, 
pTab
);

72652 
	`sqlite3VdbeAddOp4
(
v
, 12, 1, 
pTab
->
nCol
+2, 
regIns
, 
pVTab
, (-10));

72653 
	`sqlite3VdbeChangeP5
(
v
, 
onError
==10 ? 2 : onError);

72654 
	`sqlite3MayAbort
(
pParse
);

72658 int 
isReplace
;

72659 
	`sqlite3GenerateConstraintChecks
(
pParse
, 
pTab
, 
aRegIdx
, 
iDataCur
, 
iIdxCur
,

72660 
regIns
, 0, 
ipkColumn
>=0, 
onError
, 
endOfLoop
, &
isReplace
, 0

72662 
	`sqlite3FkCheck
(
pParse
, 
pTab
, 0, 
regIns
, 0, 0);

72663 
	`sqlite3CompleteInsertion
(
pParse
, 
pTab
, 
iDataCur
, 
iIdxCur
,

72664 
regIns
, 
aRegIdx
, 0, 
appendFlag
, 
isReplace
==0);

72670 if( (
db
->
flags
 & 0x00000080)!=0 )

72673 
	`sqlite3VdbeAddOp2
(
v
, 37, 
regRowCount
, 1);

72676 if( 
pTrigger
 )

72680 
	`sqlite3CodeRowTrigger
(
pParse
, 
pTrigger
, 108, 0, 2,

72681 
pTab
, 
regData
-2-pTab->
nCol
, 
onError
, 
endOfLoop
);

72687 
	`sqlite3VdbeResolveLabel
(
v
, 
endOfLoop
);

72688 if( 
useTempTable
 )

72691 
	`sqlite3VdbeAddOp2
(
v
, 7, 
srcTab
, 
addrCont
); ;

72692 
	`sqlite3VdbeJumpHere
(
v
, 
addrInsTop
);

72693 
	`sqlite3VdbeAddOp1
(
v
, 61, 
srcTab
);

72694 }else if( 
pSelect
 )

72697 
	`sqlite3VdbeGoto
(
v
, 
addrCont
);

72698 
	`sqlite3VdbeJumpHere
(
v
, 
addrInsTop
);

72701 if( !(((
pTab
)->
tabFlags
 & 0x10)!=0) && !
isView
 )

72705 if( 
iDataCur
<
iIdxCur
 ) 
	`sqlite3VdbeAddOp1
(
v
, 61, iDataCur);

72706 for(
idx
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, idx++)

72709 
	`sqlite3VdbeAddOp1
(
v
, 61, 
idx
+
iIdxCur
);

72713 
insert_end
:

72718 if( 
pParse
->
nested
==0 && pParse->
pTriggerTab
==0 )

72721 
	`sqlite3AutoincrementEnd
(
pParse
);

72729 if( (
db
->
flags
&0x00000080) && !
pParse
->
nested
 && !pParse->
pTriggerTab
 )

72732 
	`sqlite3VdbeAddOp2
(
v
, 33, 
regRowCount
, 1);

72733 
	`sqlite3VdbeSetNumCols
(
v
, 1);

72734 
	`sqlite3VdbeSetColName
(
v
, 0, 0, "rows inserted", ((
sqlite3_destructor_type
)0));

72737 
insert_cleanup
:

72738 
	`sqlite3SrcListDelete
(
db
, 
pTabList
);

72739 
	`sqlite3ExprListDelete
(
db
, 
pList
);

72740 
	`sqlite3SelectDelete
(
db
, 
pSelect
);

72741 
	`sqlite3IdListDelete
(
db
, 
pColumn
);

72742 
	`sqlite3DbFree
(
db
, 
aRegIdx
);

72743 
	}
}

72745 static int 
	$checkConstraintExprNode
(
Walker
 *
pWalker
, 
Expr
 *
pExpr
)

72748 if( 
pExpr
->
op
==152 )

72752 if( 
pExpr
->
iColumn
>=0 )

72755 if( 
pWalker
->
u
.
aiCol
[
pExpr
->
iColumn
]>=0 )

72758 
pWalker
->
eCode
 |= 0x01;

72761 
pWalker
->
eCode
 |= 0x02;

72765 
	}
}

72767 static int 
	$checkConstraintUnchanged
(
Expr
 *
pExpr
, int *
aiChng
, int 
chngRowid
)

72770 
Walker
 
w
;

72771 
	`memset
(&
w
, 0, sizeof(w));

72772 
w
.
eCode
 = 0;

72773 
w
.
xExprCallback
 = 
checkConstraintExprNode
;

72774 
w
.
u
.
aiCol
 = 
aiChng
;

72775 
	`sqlite3WalkExpr
(&
w
, 
pExpr
);

72776 if( !
chngRowid
 )

72780 
w
.
eCode
 &= ~0x02;

72786 return !
w
.
eCode
;

72787 
	}
}

72789 static void 
	$sqlite3GenerateConstraintChecks
(

72790 
Parse
 *
pParse
,

72791 
Table
 *
pTab
,

72792 int *
aRegIdx
,

72793 int 
iDataCur
,

72794 int 
iIdxCur
,

72795 int 
regNewData
,

72796 int 
regOldData
,

72797 
u8
 
pkChng
,

72798 
u8
 
overrideError
,

72799 int 
ignoreDest
,

72800 int *
pbMayReplace
,

72801 int *
aiChng


72805 
Vdbe
 *
v
;

72806 
Index
 *
pIdx
;

72807 
Index
 *
pPk
 = 0;

72808 
sqlite3
 *
db
;

72809 int 
i
;

72810 int 
ix
;

72811 int 
nCol
;

72812 int 
onError
;

72813 int 
addr1
;

72814 int 
seenReplace
 = 0;

72815 int 
nPkField
;

72816 int 
ipkTop
 = 0;

72817 int 
ipkBottom
 = 0;

72818 
u8
 
isUpdate
;

72819 
u8
 
bAffinityDone
 = 0;

72820 int 
regRowid
 = -1;

72822 
isUpdate
 = 
regOldData
!=0;

72823 
db
 = 
pParse
->db;

72824 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

72827 
nCol
 = 
pTab
->nCol;

72833 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

72836 
pPk
 = 0;

72837 
nPkField
 = 1;

72839 
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

72840 
nPkField
 = 
pPk
->
nKeyCol
;

72849 for(
i
=0; i<
nCol
; i++)

72852 if( 
i
==
pTab
->
iPKey
 )

72857 if( 
aiChng
 && aiChng[
i
]<0 )

72863 
onError
 = 
pTab
->
aCol
[
i
].
notNull
;

72864 if( 
onError
==0 ) continue;

72865 if( 
overrideError
!=10 )

72868 
onError
 = 
overrideError
;

72869 }else if( 
onError
==10 )

72872 
onError
 = 2;

72874 if( 
onError
==5 && 
pTab
->
aCol
[
i
].
pDflt
==0 )

72877 
onError
 = 2;

72881 switch( 
onError
 )

72885 
	`sqlite3MayAbort
(
pParse
);

72889 char *
zMsg
 = 
	`sqlite3MPrintf
(
db
, "%s.%s", 
pTab
->
zName
,

72890 
pTab
->
aCol
[
i
].
zName
);

72891 
	`sqlite3VdbeAddOp4
(
v
, 20, (19 | (5<<8)), 
onError
,

72892 
regNewData
+1+
i
, 
zMsg
, (-1));

72893 
	`sqlite3VdbeChangeP5
(
v
, 1);

72898 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regNewData
+1+
i
, 
ignoreDest
);

72904 
addr1
 = 
	`sqlite3VdbeAddOp1
(
v
, 77, 
regNewData
+1+
i
);

72906 
	`sqlite3ExprCode
(
pParse
, 
pTab
->
aCol
[
i
].
pDflt
, 
regNewData
+1+i);

72907 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

72916 if( 
pTab
->
pCheck
 && (
db
->
flags
 & 0x00002000)==0 )

72919 
ExprList
 *
pCheck
 = 
pTab
->pCheck;

72920 
pParse
->
ckBase
 = 
regNewData
+1;

72921 
onError
 = 
overrideError
!=10 ? overrideError : 2;

72922 for(
i
=0; i<
pCheck
->
nExpr
; i++)

72925 int 
allOk
;

72926 
Expr
 *
pExpr
 = 
pCheck
->
a
[
i
].pExpr;

72927 if( 
aiChng
 && 
	`checkConstraintUnchanged
(
pExpr
, aiChng, 
pkChng
) ) continue;

72928 
allOk
 = 
	`sqlite3VdbeMakeLabel
(
v
);

72929 
	`sqlite3ExprIfTrue
(
pParse
, 
pExpr
, 
allOk
, 0x10);

72930 if( 
onError
==4 )

72933 
	`sqlite3VdbeGoto
(
v
, 
ignoreDest
);

72935 char *
zName
 = 
pCheck
->
a
[
i
].zName;

72936 if( 
zName
==0 ) zName = 
pTab
->zName;

72937 if( 
onError
==5 ) onError = 2;

72938 
	`sqlite3HaltConstraint
(
pParse
, (19 | (1<<8)),

72939 
onError
, 
zName
, 0,

72942 
	`sqlite3VdbeResolveLabel
(
v
, 
allOk
);

72950 if( 
pkChng
 && 
pPk
==0 )

72953 int 
addrRowidOk
 = 
	`sqlite3VdbeMakeLabel
(
v
);

72956 
onError
 = 
pTab
->
keyConf
;

72957 if( 
overrideError
!=10 )

72960 
onError
 = 
overrideError
;

72961 }else if( 
onError
==10 )

72964 
onError
 = 2;

72967 if( 
isUpdate
 )

72973 
	`sqlite3VdbeAddOp3
(
v
, 79, 
regNewData
, 
addrRowidOk
, 
regOldData
);

72974 
	`sqlite3VdbeChangeP5
(
v
, 0x90);

72983 if( 
onError
==5 && 
overrideError
!=5 )

72986 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

72989 if( 
pIdx
->
onError
==4 || pIdx->onError==3 )

72992 
ipkTop
 = 
	`sqlite3VdbeAddOp0
(
v
, 13);

73000 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iDataCur
, 
addrRowidOk
, 
regNewData
);

73004 switch( 
onError
 )

73008 
onError
 = 2;

73014 
	`sqlite3RowidConstraint
(
pParse
, 
onError
, 
pTab
);

73019 
Trigger
 *
pTrigger
 = 0;

73020 if( 
db
->
flags
&0x00040000 )

73023 
pTrigger
 = 
	`sqlite3TriggersExist
(
pParse
, 
pTab
, 109, 0, 0);

73025 if( 
pTrigger
 || 
	`sqlite3FkRequired
(
pParse
, 
pTab
, 0, 0) )

73028 
	`sqlite3MultiWrite
(
pParse
);

73029 
	`sqlite3GenerateRowDelete
(
pParse
, 
pTab
, 
pTrigger
, 
iDataCur
, 
iIdxCur
,

73030 
regNewData
, 1, 0, 5,

73033 if( 
pTab
->
pIndex
 )

73036 
	`sqlite3MultiWrite
(
pParse
);

73037 
	`sqlite3GenerateRowIndexDelete
(
pParse
, 
pTab
, 
iDataCur
, 
iIdxCur
,0,-1);

73040 
seenReplace
 = 1;

73045 
	`sqlite3VdbeGoto
(
v
, 
ignoreDest
);

73049 
	`sqlite3VdbeResolveLabel
(
v
, 
addrRowidOk
);

73050 if( 
ipkTop
 )

73053 
ipkBottom
 = 
	`sqlite3VdbeAddOp0
(
v
, 13);

73054 
	`sqlite3VdbeJumpHere
(
v
, 
ipkTop
);

73058 for(
ix
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, ix++)

73061 int 
regIdx
;

73062 int 
regR
;

73063 int 
iThisCur
;

73064 int 
addrUniqueOk
;

73066 if( 
aRegIdx
[
ix
]==0 ) continue;

73067 if( 
bAffinityDone
==0 )

73070 
	`sqlite3TableAffinity
(
v
, 
pTab
, 
regNewData
+1);

73071 
bAffinityDone
 = 1;

73073 
iThisCur
 = 
iIdxCur
+
ix
;

73074 
addrUniqueOk
 = 
	`sqlite3VdbeMakeLabel
(
v
);

73077 if( 
pIdx
->
pPartIdxWhere
 )

73080 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
aRegIdx
[
ix
]);

73081 
pParse
->
ckBase
 = 
regNewData
+1;

73082 
	`sqlite3ExprIfFalseDup
(
pParse
, 
pIdx
->
pPartIdxWhere
, 
addrUniqueOk
,

73084 
pParse
->
ckBase
 = 0;

73090 
regIdx
 = 
	`sqlite3GetTempRange
(
pParse
, 
pIdx
->
nColumn
);

73091 for(
i
=0; i<
pIdx
->
nColumn
; i++)

73094 int 
iField
 = 
pIdx
->
aiColumn
[
i
];

73095 int 
x
;

73096 if( 
iField
==(-2) )

73099 
pParse
->
ckBase
 = 
regNewData
+1;

73100 
	`sqlite3ExprCodeCopy
(
pParse
, 
pIdx
->
aColExpr
->
a
[
i
].
pExpr
, 
regIdx
+i);

73101 
pParse
->
ckBase
 = 0;

73104 if( 
iField
==(-1) || iField==
pTab
->
iPKey
 )

73107 if( 
regRowid
==
regIdx
+
i
 ) continue;

73108 
x
 = 
regNewData
;

73109 
regRowid
 = 
pIdx
->
pPartIdxWhere
 ? -1 : 
regIdx
+
i
;

73111 
x
 = 
iField
 + 
regNewData
 + 1;

73113 
	`sqlite3VdbeAddOp2
(
v
, 
iField
<0 ? 32 : 31, 
x
, 
regIdx
+
i
);

73117 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regIdx
, 
pIdx
->
nColumn
, 
aRegIdx
[
ix
]);

73119 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
regIdx
, 
pIdx
->
nColumn
);

73125 if( 
isUpdate
 && 
pPk
==
pIdx
 && 
pkChng
==0 )

73128 
	`sqlite3VdbeResolveLabel
(
v
, 
addrUniqueOk
);

73133 
onError
 = 
pIdx
->onError;

73134 if( 
onError
==0 )

73137 
	`sqlite3ReleaseTempRange
(
pParse
, 
regIdx
, 
pIdx
->
nColumn
);

73138 
	`sqlite3VdbeResolveLabel
(
v
, 
addrUniqueOk
);

73141 if( 
overrideError
!=10 )

73144 
onError
 = 
overrideError
;

73145 }else if( 
onError
==10 )

73148 
onError
 = 2;

73152 
	`sqlite3VdbeAddOp4Int
(
v
, 67, 
iThisCur
, 
addrUniqueOk
,

73153 
regIdx
, 
pIdx
->
nKeyCol
); ;

73156 
regR
 = (
pIdx
==
pPk
) ? 
regIdx
 : 
	`sqlite3GetTempRange
(
pParse
, 
nPkField
);

73157 if( 
isUpdate
 || 
onError
==5 )

73160 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

73163 
	`sqlite3VdbeAddOp2
(
v
, 113, 
iThisCur
, 
regR
);

73166 if( 
isUpdate
 )

73169 
	`sqlite3VdbeAddOp3
(
v
, 79, 
regR
, 
addrUniqueOk
, 
regOldData
);

73170 
	`sqlite3VdbeChangeP5
(
v
, 0x90);

73174 int 
x
;

73177 if( 
pIdx
!=
pPk
 )

73180 for(
i
=0; i<
pPk
->
nKeyCol
; i++)

73184 
x
 = 
	`sqlite3ColumnOfIndex
(
pIdx
, 
pPk
->
aiColumn
[
i
]);

73185 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iThisCur
, 
x
, 
regR
+
i
);

73190 if( 
isUpdate
 )

73200 int 
addrJump
 = 
	`sqlite3VdbeCurrentAddr
(
v
)+
pPk
->
nKeyCol
;

73201 int 
op
 = 78;

73202 int 
regCmp
 = (((
pIdx
)->
idxType
==2) ? 
regIdx
 : 
regR
);

73204 for(
i
=0; i<
pPk
->
nKeyCol
; i++)

73207 char *
p4
 = (char*)
	`sqlite3LocateCollSeq
(
pParse
, 
pPk
->
azColl
[
i
]);

73208 
x
 = 
pPk
->
aiColumn
[
i
];

73210 if( 
i
==(
pPk
->
nKeyCol
-1) )

73213 
addrJump
 = 
addrUniqueOk
;

73214 
op
 = 79;

73216 
	`sqlite3VdbeAddOp4
(
v
, 
op
,

73217 
regOldData
+1+
x
, 
addrJump
, 
regCmp
+
i
, 
p4
, (-4)

73219 
	`sqlite3VdbeChangeP5
(
v
, 0x90);

73230 switch( 
onError
 )

73236 
	`sqlite3UniqueConstraint
(
pParse
, 
onError
, 
pIdx
);

73240 
	`sqlite3VdbeGoto
(
v
, 
ignoreDest
);

73244 
Trigger
 *
pTrigger
 = 0;

73246 
	`sqlite3MultiWrite
(
pParse
);

73247 if( 
db
->
flags
&0x00040000 )

73250 
pTrigger
 = 
	`sqlite3TriggersExist
(
pParse
, 
pTab
, 109, 0, 0);

73252 
	`sqlite3GenerateRowDelete
(
pParse
, 
pTab
, 
pTrigger
, 
iDataCur
, 
iIdxCur
,

73253 
regR
, 
nPkField
, 0, 5,

73254 (
pIdx
==
pPk
 ? 1 : 0), -1);

73255 
seenReplace
 = 1;

73259 
	`sqlite3VdbeResolveLabel
(
v
, 
addrUniqueOk
);

73260 
	`sqlite3ReleaseTempRange
(
pParse
, 
regIdx
, 
pIdx
->
nColumn
);

73261 if( 
regR
!=
regIdx
 ) 
	`sqlite3ReleaseTempRange
(
pParse
, regR, 
nPkField
);

73263 if( 
ipkTop
 )

73266 
	`sqlite3VdbeGoto
(
v
, 
ipkTop
+1);

73267 
	`sqlite3VdbeJumpHere
(
v
, 
ipkBottom
);

73270 *
pbMayReplace
 = 
seenReplace
;

73272 
	}
}

73274 static void 
	$sqlite3CompleteInsertion
(

73275 
Parse
 *
pParse
,

73276 
Table
 *
pTab
,

73277 int 
iDataCur
,

73278 int 
iIdxCur
,

73279 int 
regNewData
,

73280 int *
aRegIdx
,

73281 int 
isUpdate
,

73282 int 
appendBias
,

73283 int 
useSeekResult


73287 
Vdbe
 *
v
;

73288 
Index
 *
pIdx
;

73289 
u8
 
pik_flags
;

73290 int 
regData
;

73291 int 
regRec
;

73292 int 
i
;

73293 
u8
 
bAffinityDone
 = 0;

73295 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

73298 for(
i
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, i++)

73301 if( 
aRegIdx
[
i
]==0 ) continue;

73302 
bAffinityDone
 = 1;

73303 if( 
pIdx
->
pPartIdxWhere
 )

73306 
	`sqlite3VdbeAddOp2
(
v
, 76, 
aRegIdx
[
i
], 
	`sqlite3VdbeCurrentAddr
(v)+2);

73309 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iIdxCur
+
i
, 
aRegIdx
[i]);

73310 
pik_flags
 = 0;

73311 if( 
useSeekResult
 ) 
pik_flags
 = 0x10;

73312 if( ((
pIdx
)->
idxType
==2) && !(((
pTab
)->
tabFlags
 & 0x20)==0) )

73316 
pik_flags
 |= 0x01;

73318 
	`sqlite3VdbeChangeP5
(
v
, 
pik_flags
);

73320 if( !(((
pTab
)->
tabFlags
 & 0x20)==0) ) return;

73321 
regData
 = 
regNewData
 + 1;

73322 
regRec
 = 
	`sqlite3GetTempReg
(
pParse
);

73323 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regData
, 
pTab
->
nCol
, 
regRec
);

73324 if( !
bAffinityDone
 ) 
	`sqlite3TableAffinity
(
v
, 
pTab
, 0);

73325 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
regData
, 
pTab
->
nCol
);

73326 if( 
pParse
->
nested
 )

73329 
pik_flags
 = 0;

73331 
pik_flags
 = 0x01;

73332 
pik_flags
 |= (
isUpdate
?0x04:0x02);

73334 if( 
appendBias
 )

73337 
pik_flags
 |= 0x08;

73339 if( 
useSeekResult
 )

73342 
pik_flags
 |= 0x10;

73344 
	`sqlite3VdbeAddOp3
(
v
, 75, 
iDataCur
, 
regRec
, 
regNewData
);

73345 if( !
pParse
->
nested
 )

73348 
	`sqlite3VdbeChangeP4
(
v
, -1, 
pTab
->
zName
, 0);

73350 
	`sqlite3VdbeChangeP5
(
v
, 
pik_flags
);

73351 
	}
}

73353 static int 
	$sqlite3OpenTableAndIndices
(

73354 
Parse
 *
pParse
,

73355 
Table
 *
pTab
,

73356 int 
op
,

73357 
u8
 
p5
,

73358 int 
iBase
,

73359 
u8
 *
aToOpen
,

73360 int *
piDataCur
,

73361 int *
piIdxCur


73365 int 
i
;

73366 int 
iDb
;

73367 int 
iDataCur
;

73368 
Index
 *
pIdx
;

73369 
Vdbe
 *
v
;

73373 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

73381 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

73382 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

73384 if( 
iBase
<0 ) iBase = 
pParse
->
nTab
;

73385 
iDataCur
 = 
iBase
++;

73386 if( 
piDataCur
 ) *piDataCur = 
iDataCur
;

73387 if( (((
pTab
)->
tabFlags
 & 0x20)==0) && (
aToOpen
==0 || aToOpen[0]) )

73390 
	`sqlite3OpenTable
(
pParse
, 
iDataCur
, 
iDb
, 
pTab
, 
op
);

73392 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 
op
==55, pTab->
zName
);

73394 if( 
piIdxCur
 ) *piIdxCur = 
iBase
;

73395 for(
i
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, i++)

73398 int 
iIdxCur
 = 
iBase
++;

73400 if( 
aToOpen
==0 || aToOpen[
i
+1] )

73403 
	`sqlite3VdbeAddOp3
(
v
, 
op
, 
iIdxCur
, 
pIdx
->
tnum
, 
iDb
);

73404 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pIdx
);

73407 if( ((
pIdx
)->
idxType
==2) && !(((
pTab
)->
tabFlags
 & 0x20)==0) )

73410 if( 
piDataCur
 ) *piDataCur = 
iIdxCur
;

73412 
	`sqlite3VdbeChangeP5
(
v
, 
p5
);

73415 if( 
iBase
>
pParse
->
nTab
 ) pParse->nTab = iBase;

73416 return 
i
;

73417 
	}
}

73419 static int 
	$xferCompatibleIndex
(
Index
 *
pDest
, Index *
pSrc
)

73422 int 
i
;

73425 if( 
pDest
->
nKeyCol
!=
pSrc
->nKeyCol )

73430 if( 
pDest
->
onError
!=
pSrc
->onError )

73435 for(
i
=0; i<
pSrc
->
nKeyCol
; i++)

73438 if( 
pSrc
->
aiColumn
[
i
]!=
pDest
->aiColumn[i] )

73443 if( 
pSrc
->
aiColumn
[
i
]==(-2) )

73447 if( 
	`sqlite3ExprCompare
(
pSrc
->
aColExpr
->
a
[
i
].
pExpr
,

73448 
pDest
->
aColExpr
->
a
[
i
].
pExpr
, -1)!=0 )

73454 if( 
pSrc
->
aSortOrder
[
i
]!=
pDest
->aSortOrder[i] )

73459 if( 
	`sqlite3_stricmp
(
pSrc
->
azColl
[
i
],
pDest
->azColl[i])!=0 )

73465 if( 
	`sqlite3ExprCompare
(
pSrc
->
pPartIdxWhere
, 
pDest
->pPartIdxWhere, -1) )

73473 
	}
}

73475 static int 
	$xferOptimization
(

73476 
Parse
 *
pParse
,

73477 
Table
 *
pDest
,

73478 
Select
 *
pSelect
,

73479 int 
onError
,

73480 int 
iDbDest


73484 
sqlite3
 *
db
 = 
pParse
->db;

73485 
ExprList
 *
pEList
;

73486 
Table
 *
pSrc
;

73487 
Index
 *
pSrcIdx
, *
pDestIdx
;

73488 struct 
SrcList_item
 *
pItem
;

73489 int 
i
;

73490 int 
iDbSrc
;

73491 int 
iSrc
, 
iDest
;

73492 int 
addr1
, 
addr2
;

73493 int 
emptyDestTest
 = 0;

73494 int 
emptySrcTest
 = 0;

73495 
Vdbe
 *
v
;

73496 int 
regAutoinc
;

73497 int 
destHasUniqueIdx
 = 0;

73498 int 
regData
, 
regRowid
;

73500 if( 
pSelect
==0 )

73505 if( 
pParse
->
pWith
 || 
pSelect
->pWith )

73513 if( 
	`sqlite3TriggerList
(
pParse
, 
pDest
) )

73519 if( 
pDest
->
tabFlags
 & 0x10 )

73525 if( 
onError
==10 )

73528 if( 
pDest
->
iPKey
>=0 ) 
onError
 = pDest->
keyConf
;

73529 if( 
onError
==10 ) onError = 2;

73532 if( 
pSelect
->
pSrc
->
nSrc
!=1 )

73537 if( 
pSelect
->
pSrc
->
a
[0].pSelect )

73542 if( 
pSelect
->
pWhere
 )

73547 if( 
pSelect
->
pOrderBy
 )

73554 if( 
pSelect
->
pGroupBy
 )

73559 if( 
pSelect
->
pLimit
 )

73565 if( 
pSelect
->
pPrior
 )

73570 if( 
pSelect
->
selFlags
 & 0x00001 )

73575 
pEList
 = 
pSelect
->pEList;

73577 if( 
pEList
->
nExpr
!=1 )

73583 if( 
pEList
->
a
[0].
pExpr
->
op
!=158 )

73593 
pItem
 = 
pSelect
->
pSrc
->
a
;

73594 
pSrc
 = 
	`sqlite3LocateTableItem
(
pParse
, 0, 
pItem
);

73595 if( 
pSrc
==0 )

73600 if( 
pSrc
==
pDest
 )

73605 if( (((
pDest
)->
tabFlags
 & 0x20)==0)!=(((
pSrc
)->tabFlags & 0x20)==0) )

73611 if( 
pSrc
->
tabFlags
 & 0x10 )

73617 if( 
pSrc
->
pSelect
 )

73622 if( 
pDest
->
nCol
!=
pSrc
->nCol )

73627 if( 
pDest
->
iPKey
!=
pSrc
->iPKey )

73632 for(
i
=0; i<
pDest
->
nCol
; i++)

73635 
Column
 *
pDestCol
 = &
pDest
->
aCol
[
i
];

73636 
Column
 *
pSrcCol
 = &
pSrc
->
aCol
[
i
];

73644 if( 
pDestCol
->
affinity
!=
pSrcCol
->affinity )

73649 if( 
	`sqlite3_stricmp
(
pDestCol
->
zColl
, 
pSrcCol
->zColl)!=0 )

73654 if( 
pDestCol
->
notNull
 && !
pSrcCol
->notNull )

73660 if( 
i
>0 )

73665 if( (
pDestCol
->
pDflt
==0)!=(
pSrcCol
->pDflt==0)

73666 || (
pDestCol
->
pDflt
 && 
	`strcmp
(pDestCol->pDflt->
u
.
zToken
,

73667 
pSrcCol
->
pDflt
->
u
.
zToken
)!=0)

73675 for(
pDestIdx
=
pDest
->
pIndex
; pDestIdx; pDestIdx=pDestIdx->
pNext
)

73678 if( ((
pDestIdx
)->
onError
!=0) )

73681 
destHasUniqueIdx
 = 1;

73683 for(
pSrcIdx
=
pSrc
->
pIndex
; pSrcIdx; pSrcIdx=pSrcIdx->
pNext
)

73686 if( 
	`xferCompatibleIndex
(
pDestIdx
, 
pSrcIdx
) ) break;

73688 if( 
pSrcIdx
==0 )

73695 if( 
pDest
->
pCheck
 && 
	`sqlite3ExprListCompare
(
pSrc
->pCheck,pDest->pCheck,-1) )

73701 if( (
db
->
flags
 & 0x00080000)!=0 && 
pDest
->
pFKey
!=0 )

73707 if( (
db
->
flags
 & 0x00000080)!=0 )

73713 
iDbSrc
 = 
	`sqlite3SchemaToIndex
(
db
, 
pSrc
->
pSchema
);

73714 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

73715 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDbSrc
);

73716 
iSrc
 = 
pParse
->
nTab
++;

73717 
iDest
 = 
pParse
->
nTab
++;

73718 
regAutoinc
 = 
	`autoIncBegin
(
pParse
, 
iDbDest
, 
pDest
);

73719 
regData
 = 
	`sqlite3GetTempReg
(
pParse
);

73720 
regRowid
 = 
	`sqlite3GetTempReg
(
pParse
);

73721 
	`sqlite3OpenTable
(
pParse
, 
iDest
, 
iDbDest
, 
pDest
, 55);

73723 if( (
db
->
flags
 & 0x08000000)==0 && (

73724 (
pDest
->
iPKey
<0 && pDest->
pIndex
!=0)

73725 || 
destHasUniqueIdx


73726 || (
onError
!=2 && onError!=1)

73731 
addr1
 = 
	`sqlite3VdbeAddOp2
(
v
, 108, 
iDest
, 0); ;

73732 
emptyDestTest
 = 
	`sqlite3VdbeAddOp0
(
v
, 13);

73733 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

73735 if( (((
pSrc
)->
tabFlags
 & 0x20)==0) )

73738 
	`sqlite3OpenTable
(
pParse
, 
iSrc
, 
iDbSrc
, 
pSrc
, 54);

73739 
emptySrcTest
 = 
	`sqlite3VdbeAddOp2
(
v
, 108, 
iSrc
, 0); ;

73740 if( 
pDest
->
iPKey
>=0 )

73743 
addr1
 = 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iSrc
, 
regRowid
);

73744 
addr2
 = 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iDest
, 0, 
regRowid
);

73746 
	`sqlite3RowidConstraint
(
pParse
, 
onError
, 
pDest
);

73747 
	`sqlite3VdbeJumpHere
(
v
, 
addr2
);

73748 
	`autoIncStep
(
pParse
, 
regAutoinc
, 
regRowid
);

73749 }else if( 
pDest
->
pIndex
==0 )

73752 
addr1
 = 
	`sqlite3VdbeAddOp2
(
v
, 74, 
iDest
, 
regRowid
);

73754 
addr1
 = 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iSrc
, 
regRowid
);

73757 
	`sqlite3VdbeAddOp2
(
v
, 102, 
iSrc
, 
regData
);

73758 
	`sqlite3VdbeAddOp4
(
v
, 75, 
iDest
, 
regData
, 
regRowid
,

73759 
pDest
->
zName
, 0);

73760 
	`sqlite3VdbeChangeP5
(
v
, 0x01|0x02|0x08);

73761 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iSrc
, 
addr1
); ;

73762 
	`sqlite3VdbeAddOp2
(
v
, 61, 
iSrc
, 0);

73763 
	`sqlite3VdbeAddOp2
(
v
, 61, 
iDest
, 0);

73765 
	`sqlite3TableLock
(
pParse
, 
iDbDest
, 
pDest
->
tnum
, 1, pDest->
zName
);

73766 
	`sqlite3TableLock
(
pParse
, 
iDbSrc
, 
pSrc
->
tnum
, 0, pSrc->
zName
);

73768 for(
pDestIdx
=
pDest
->
pIndex
; pDestIdx; pDestIdx=pDestIdx->
pNext
)

73771 
u8
 
idxInsFlags
 = 0;

73772 for(
pSrcIdx
=
pSrc
->
pIndex
; (pSrcIdx); pSrcIdx=pSrcIdx->
pNext
)

73775 if( 
	`xferCompatibleIndex
(
pDestIdx
, 
pSrcIdx
) ) break;

73778 
	`sqlite3VdbeAddOp3
(
v
, 54, 
iSrc
, 
pSrcIdx
->
tnum
, 
iDbSrc
);

73779 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pSrcIdx
);

73781 
	`sqlite3VdbeAddOp3
(
v
, 55, 
iDest
, 
pDestIdx
->
tnum
, 
iDbDest
);

73782 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pDestIdx
);

73783 
	`sqlite3VdbeChangeP5
(
v
, 0x01);

73785 
addr1
 = 
	`sqlite3VdbeAddOp2
(
v
, 108, 
iSrc
, 0); ;

73786 
	`sqlite3VdbeAddOp2
(
v
, 101, 
iSrc
, 
regData
);

73787 if( 
db
->
flags
 & 0x08000000 )

73791 for(
i
=0; i<
pSrcIdx
->
nColumn
; i++)

73794 const char *
zColl
 = 
pSrcIdx
->
azColl
[
i
];

73797 if( 
	`sqlite3_stricmp
(
sqlite3StrBINARY
, 
zColl
) ) break;

73799 if( 
i
==
pSrcIdx
->
nColumn
 )

73802 
idxInsFlags
 = 0x10;

73803 
	`sqlite3VdbeAddOp3
(
v
, 105, 
iDest
, 0, -1);

73806 if( !(((
pSrc
)->
tabFlags
 & 0x20)==0) && 
pDestIdx
->
idxType
==2 )

73809 
idxInsFlags
 |= 0x01;

73811 
	`sqlite3VdbeAddOp3
(
v
, 110, 
iDest
, 
regData
, 1);

73812 
	`sqlite3VdbeChangeP5
(
v
, 
idxInsFlags
);

73813 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iSrc
, 
addr1
+1); ;

73814 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

73815 
	`sqlite3VdbeAddOp2
(
v
, 61, 
iSrc
, 0);

73816 
	`sqlite3VdbeAddOp2
(
v
, 61, 
iDest
, 0);

73818 if( 
emptySrcTest
 ) 
	`sqlite3VdbeJumpHere
(
v
, emptySrcTest);

73819 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRowid
);

73820 
	`sqlite3ReleaseTempReg
(
pParse
, 
regData
);

73821 if( 
emptyDestTest
 )

73824 
	`sqlite3VdbeAddOp2
(
v
, 21, 0, 0);

73825 
	`sqlite3VdbeJumpHere
(
v
, 
emptyDestTest
);

73826 
	`sqlite3VdbeAddOp2
(
v
, 61, 
iDest
, 0);

73831 
	}
}

73833 int 
	$sqlite3_exec
(

73834 
sqlite3
 *
db
,

73835 const char *
zSql
,

73836 
sqlite3_callback
 
xCallback
,

73837 void *
pArg
,

73838 char **
pzErrMsg


73842 int 
rc
 = 0;

73843 const char *
zLeftover
;

73844 
sqlite3_stmt
 *
pStmt
 = 0;

73845 char **
azCols
 = 0;

73846 int 
callbackIsInit
;

73848 if( !
	`sqlite3SafetyCheckOk
(
db
) ) return 
	`sqlite3MisuseError
(105726);

73849 if( 
zSql
==0 ) zSql = "";

73851 
	`sqlite3_mutex_enter
(
db
->
mutex
);

73852 
	`sqlite3Error
(
db
, 0);

73853 while( 
rc
==0 && 
zSql
[0] )

73856 int 
nCol
;

73857 char **
azVals
 = 0;

73859 
pStmt
 = 0;

73860 
rc
 = 
	`sqlite3_prepare_v2
(
db
, 
zSql
, -1, &
pStmt
, &
zLeftover
);

73862 if( 
rc
!=0 )

73867 if( !
pStmt
 )

73871 
zSql
 = 
zLeftover
;

73875 
callbackIsInit
 = 0;

73876 
nCol
 = 
	`sqlite3_column_count
(
pStmt
);

73881 int 
i
;

73882 
rc
 = 
	`sqlite3_step
(
pStmt
);

73885 if( 
xCallback
 && (100==
rc
 ||

73886 (101==
rc
 && !
callbackIsInit


73887 && 
db
->
flags
&0x00000100)) )

73890 if( !
callbackIsInit
 )

73893 
azCols
 = 
	`sqlite3DbMallocZero
(
db
, 2*
nCol
*sizeof(const char*) + 1);

73894 if( 
azCols
==0 )

73897 goto 
exec_out
;

73899 for(
i
=0; i<
nCol
; i++)

73902 
azCols
[
i
] = (char *)
	`sqlite3_column_name
(
pStmt
, i);

73907 
callbackIsInit
 = 1;

73909 if( 
rc
==100 )

73912 
azVals
 = &
azCols
[
nCol
];

73913 for(
i
=0; i<
nCol
; i++)

73916 
azVals
[
i
] = (char *)
	`sqlite3_column_text
(
pStmt
, i);

73917 if( !
azVals
[
i
] && 
	`sqlite3_column_type
(
pStmt
, i)!=5 )

73920 
	`sqlite3OomFault
(
db
);

73921 goto 
exec_out
;

73925 if( 
	`xCallback
(
pArg
, 
nCol
, 
azVals
, 
azCols
) )

73931 
rc
 = 4;

73932 
	`sqlite3VdbeFinalize
((
Vdbe
 *)
pStmt
);

73933 
pStmt
 = 0;

73934 
	`sqlite3Error
(
db
, 4);

73935 goto 
exec_out
;

73939 if( 
rc
!=100 )

73942 
rc
 = 
	`sqlite3VdbeFinalize
((
Vdbe
 *)
pStmt
);

73943 
pStmt
 = 0;

73944 
zSql
 = 
zLeftover
;

73945 while( (
sqlite3CtypeMap
[(unsigned char)(
zSql
[0])]&0x01) ) zSql++;

73950 
	`sqlite3DbFree
(
db
, 
azCols
);

73951 
azCols
 = 0;

73954 
exec_out
:

73955 if( 
pStmt
 ) 
	`sqlite3VdbeFinalize
((
Vdbe
 *)pStmt);

73956 
	`sqlite3DbFree
(
db
, 
azCols
);

73958 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

73959 if( 
rc
!=0 && 
pzErrMsg
 )

73962 int 
nErrMsg
 = 1 + 
	`sqlite3Strlen30
(
	`sqlite3_errmsg
(
db
));

73963 *
pzErrMsg
 = 
	`sqlite3Malloc
(
nErrMsg
);

73964 if( *
pzErrMsg
 )

73967 
	`memcpy
(*
pzErrMsg
, 
	`sqlite3_errmsg
(
db
), 
nErrMsg
);

73969 
rc
 = 7;

73970 
	`sqlite3Error
(
db
, 7);

73972 }else if( 
pzErrMsg
 )

73975 *
pzErrMsg
 = 0;

73979 
	`sqlite3_mutex_leave
(
db
->
mutex
);

73980 return 
rc
;

73981 
	}
}

73983 typedef struct 
sqlite3_api_routines
 
	tsqlite3_api_routines
;

73985 struct 
	ssqlite3_api_routines
 {

73986 void * (*
	maggregate_context
)(
	msqlite3_context
*,int 
	mnBytes
);

73987 int (*
	maggregate_count
)(
	msqlite3_context
*);

73988 int (*
	mbind_blob
)(
	msqlite3_stmt
*,int,const void*,int 
	mn
,void(*)(void*));

73989 int (*
	mbind_double
)(
	msqlite3_stmt
*,int,double);

73990 int (*
	mbind_int
)(
	msqlite3_stmt
*,int,int);

73991 int (*
	mbind_int64
)(
	msqlite3_stmt
*,int,
	msqlite_int64
);

73992 int (*
	mbind_null
)(
	msqlite3_stmt
*,int);

73993 int (*
	mbind_parameter_count
)(
	msqlite3_stmt
*);

73994 int (*
	mbind_parameter_index
)(
	msqlite3_stmt
*,const char*
	mzName
);

73995 const char * (*
	mbind_parameter_name
)(
	msqlite3_stmt
*,int);

73996 int (*
	mbind_text
)(
	msqlite3_stmt
*,int,const char*,int 
	mn
,void(*)(void*));

73997 int (*
	mbind_text16
)(
	msqlite3_stmt
*,int,const void*,int,void(*)(void*));

73998 int (*
	mbind_value
)(
	msqlite3_stmt
*,int,const 
	msqlite3_value
*);

73999 int (*
	mbusy_handler
)(
	msqlite3
*,int(*)(void*,int),void*);

74000 int (*
	mbusy_timeout
)(
	msqlite3
*,int 
	mms
);

74001 int (*
	mchanges
)(
	msqlite3
*);

74002 int (*
	mclose
)(
	msqlite3
*);

74003 int (*
	mcollation_needed
)(
	msqlite3
*,void*,void(*)(void*,sqlite3*,

74004 int 
	meTextRep
,const char*));

74005 int (*
	mcollation_needed16
)(
	msqlite3
*,void*,void(*)(void*,sqlite3*,

74006 int 
	meTextRep
,const void*));

74007 const void * (*
	mcolumn_blob
)(
	msqlite3_stmt
*,int 
	miCol
);

74008 int (*
	mcolumn_bytes
)(
	msqlite3_stmt
*,int 
	miCol
);

74009 int (*
	mcolumn_bytes16
)(
	msqlite3_stmt
*,int 
	miCol
);

74010 int (*
	mcolumn_count
)(
sqlite3_stmt
*
	mpStmt
);

74011 const char * (*
	mcolumn_database_name
)(
	msqlite3_stmt
*,int);

74012 const void * (*
	mcolumn_database_name16
)(
	msqlite3_stmt
*,int);

74013 const char * (*
	mcolumn_decltype
)(
	msqlite3_stmt
*,int 
	mi
);

74014 const void * (*
	mcolumn_decltype16
)(
	msqlite3_stmt
*,int);

74015 double (*
	mcolumn_double
)(
	msqlite3_stmt
*,int 
	miCol
);

74016 int (*
	mcolumn_int
)(
	msqlite3_stmt
*,int 
	miCol
);

74017 
sqlite_int64
 (*
column_int64
)(
	msqlite3_stmt
*,int 
	miCol
);

74018 const char * (*
	mcolumn_name
)(
	msqlite3_stmt
*,int);

74019 const void * (*
	mcolumn_name16
)(
	msqlite3_stmt
*,int);

74020 const char * (*
	mcolumn_origin_name
)(
	msqlite3_stmt
*,int);

74021 const void * (*
	mcolumn_origin_name16
)(
	msqlite3_stmt
*,int);

74022 const char * (*
	mcolumn_table_name
)(
	msqlite3_stmt
*,int);

74023 const void * (*
	mcolumn_table_name16
)(
	msqlite3_stmt
*,int);

74024 const unsigned char * (*
	mcolumn_text
)(
	msqlite3_stmt
*,int 
	miCol
);

74025 const void * (*
	mcolumn_text16
)(
	msqlite3_stmt
*,int 
	miCol
);

74026 int (*
	mcolumn_type
)(
	msqlite3_stmt
*,int 
	miCol
);

74027 
	msqlite3_value
* (*
	mcolumn_value
)(
	msqlite3_stmt
*,int 
	miCol
);

74028 void * (*
	mcommit_hook
)(
	msqlite3
*,int(*)(void*),void*);

74029 int (*
	mcomplete
)(const char*
	msql
);

74030 int (*
	mcomplete16
)(const void*
	msql
);

74031 int (*
	mcreate_collation
)(
	msqlite3
*,const char*,int,void*,

74033 int (*
	mcreate_collation16
)(
	msqlite3
*,const void*,int,void*,

74035 int (*
	mcreate_function
)(
	msqlite3
*,const char*,int,int,void*,

74036 void (*
	mxFunc
)(
	msqlite3_context
*,int,
	msqlite3_value
**),

74037 void (*
	mxStep
)(
	msqlite3_context
*,int,
	msqlite3_value
**),

74038 void (*
	mxFinal
)(
	msqlite3_context
*));

74039 int (*
	mcreate_function16
)(
	msqlite3
*,const void*,int,int,void*,

74040 void (*
	mxFunc
)(
	msqlite3_context
*,int,
	msqlite3_value
**),

74041 void (*
	mxStep
)(
	msqlite3_context
*,int,
	msqlite3_value
**),

74042 void (*
	mxFinal
)(
	msqlite3_context
*));

74043 int (*
	mcreate_module
)(
	msqlite3
*,const char*,const 
	msqlite3_module
*,void*);

74044 int (*
	mdata_count
)(
sqlite3_stmt
*
	mpStmt
);

74045 
	msqlite3
 * (*
	mdb_handle
)(
	msqlite3_stmt
*);

74046 int (*
	mdeclare_vtab
)(
	msqlite3
*,const char*);

74047 int (*
	menable_shared_cache
)(int);

74048 int (*
	merrcode
)(
sqlite3
*
	mdb
);

74049 const char * (*
	merrmsg
)(
	msqlite3
*);

74050 const void * (*
	merrmsg16
)(
	msqlite3
*);

74051 int (*
	mexec
)(
	msqlite3
*,const char*,
	msqlite3_callback
,void*,char**);

74052 int (*
	mexpired
)(
	msqlite3_stmt
*);

74053 int (*
	mfinalize
)(
sqlite3_stmt
*
	mpStmt
);

74054 void (*
	mfree
)(void*);

74055 void (*
	mfree_table
)(char**
	mresult
);

74056 int (*
	mget_autocommit
)(
	msqlite3
*);

74057 void * (*
	mget_auxdata
)(
	msqlite3_context
*,int);

74058 int (*
	mget_table
)(
	msqlite3
*,const char*,char***,int*,int*,char**);

74059 int (*
	mglobal_recover
)(void);

74060 void (*
	minterruptx
)(
	msqlite3
*);

74061 
sqlite_int64
 (*
last_insert_rowid
)(
	msqlite3
*);

74062 const char * (*
	mlibversion
)(void);

74063 int (*
	mlibversion_number
)(void);

74064 void *(*
	mmalloc
)(int);

74065 char * (*
	mmprintf
)(const char*,...);

74066 int (*
	mopen
)(const char*,
	msqlite3
**);

74067 int (*
	mopen16
)(const void*,
	msqlite3
**);

74068 int (*
	mprepare
)(
	msqlite3
*,const char*,int,
	msqlite3_stmt
**,const char**);

74069 int (*
	mprepare16
)(
	msqlite3
*,const void*,int,
	msqlite3_stmt
**,const void**);

74070 void * (*
	mprofile
)(
	msqlite3
*,void(*)(void*,const char*,
	msqlite_uint64
),void*);

74071 void (*
	mprogress_handler
)(
	msqlite3
*,int,int(*)(void*),void*);

74072 void *(*
	mrealloc
)(void*,int);

74073 int (*
	mreset
)(
sqlite3_stmt
*
	mpStmt
);

74074 void (*
	mresult_blob
)(
	msqlite3_context
*,const void*,int,void(*)(void*));

74075 void (*
	mresult_double
)(
	msqlite3_context
*,double);

74076 void (*
	mresult_error
)(
	msqlite3_context
*,const char*,int);

74077 void (*
	mresult_error16
)(
	msqlite3_context
*,const void*,int);

74078 void (*
	mresult_int
)(
	msqlite3_context
*,int);

74079 void (*
	mresult_int64
)(
	msqlite3_context
*,
	msqlite_int64
);

74080 void (*
	mresult_null
)(
	msqlite3_context
*);

74081 void (*
	mresult_text
)(
	msqlite3_context
*,const char*,int,void(*)(void*));

74082 void (*
	mresult_text16
)(
	msqlite3_context
*,const void*,int,void(*)(void*));

74083 void (*
	mresult_text16be
)(
	msqlite3_context
*,const void*,int,void(*)(void*));

74084 void (*
	mresult_text16le
)(
	msqlite3_context
*,const void*,int,void(*)(void*));

74085 void (*
	mresult_value
)(
	msqlite3_context
*,
	msqlite3_value
*);

74086 void * (*
	mrollback_hook
)(
	msqlite3
*,void(*)(void*),void*);

74087 int (*
	mset_authorizer
)(
	msqlite3
*,int(*)(void*,int,const char*,const char*,

74089 void (*
	mset_auxdata
)(
	msqlite3_context
*,int,void*,void (*)(void*));

74090 char * (*
	msnprintf
)(int,char*,const char*,...);

74091 int (*
	mstep
)(
	msqlite3_stmt
*);

74092 int (*
	mtable_column_metadata
)(
	msqlite3
*,const char*,const char*,const char*,

74094 void (*
	mthread_cleanup
)(void);

74095 int (*
	mtotal_changes
)(
	msqlite3
*);

74096 void * (*
	mtrace
)(
	msqlite3
*,void(*
	mxTrace
)(void*,const char*),void*);

74097 int (*
	mtransfer_bindings
)(
	msqlite3_stmt
*,sqlite3_stmt*);

74098 void * (*
	mupdate_hook
)(
	msqlite3
*,void(*)(void*,int ,char const*,char const*,

74099 
	msqlite_int64
),void*);

74100 void * (*
	muser_data
)(
	msqlite3_context
*);

74101 const void * (*
	mvalue_blob
)(
	msqlite3_value
*);

74102 int (*
	mvalue_bytes
)(
	msqlite3_value
*);

74103 int (*
	mvalue_bytes16
)(
	msqlite3_value
*);

74104 double (*
	mvalue_double
)(
	msqlite3_value
*);

74105 int (*
	mvalue_int
)(
	msqlite3_value
*);

74106 
sqlite_int64
 (*
value_int64
)(
	msqlite3_value
*);

74107 int (*
	mvalue_numeric_type
)(
	msqlite3_value
*);

74108 const unsigned char * (*
	mvalue_text
)(
	msqlite3_value
*);

74109 const void * (*
	mvalue_text16
)(
	msqlite3_value
*);

74110 const void * (*
	mvalue_text16be
)(
	msqlite3_value
*);

74111 const void * (*
	mvalue_text16le
)(
	msqlite3_value
*);

74112 int (*
	mvalue_type
)(
	msqlite3_value
*);

74113 char *(*
	mvmprintf
)(const char*,
	mva_list
);

74115 int (*
	moverload_function
)(
	msqlite3
*, const char *
	mzFuncName
, int 
	mnArg
);

74117 int (*
	mprepare_v2
)(
	msqlite3
*,const char*,int,
	msqlite3_stmt
**,const char**);

74118 int (*
	mprepare16_v2
)(
	msqlite3
*,const void*,int,
	msqlite3_stmt
**,const void**);

74119 int (*
	mclear_bindings
)(
	msqlite3_stmt
*);

74121 int (*
	mcreate_module_v2
)(
	msqlite3
*,const char*,const 
	msqlite3_module
*,void*,

74122 void (*
	mxDestroy
)(void *));

74124 int (*
	mbind_zeroblob
)(
	msqlite3_stmt
*,int,int);

74125 int (*
	mblob_bytes
)(
	msqlite3_blob
*);

74126 int (*
	mblob_close
)(
	msqlite3_blob
*);

74127 int (*
	mblob_open
)(
	msqlite3
*,const char*,const char*,const char*,
	msqlite3_int64
,

74128 int,
	msqlite3_blob
**);

74129 int (*
	mblob_read
)(
	msqlite3_blob
*,void*,int,int);

74130 int (*
	mblob_write
)(
	msqlite3_blob
*,const void*,int,int);

74131 int (*
	mcreate_collation_v2
)(
	msqlite3
*,const char*,int,void*,

74134 int (*
	mfile_control
)(
	msqlite3
*,const char*,int,void*);

74135 
sqlite3_int64
 (*
memory_highwater
)(int);

74136 
sqlite3_int64
 (*
memory_used
)(void);

74137 
	msqlite3_mutex
 *(*
	mmutex_alloc
)(int);

74138 void (*
	mmutex_enter
)(
	msqlite3_mutex
*);

74139 void (*
	mmutex_free
)(
	msqlite3_mutex
*);

74140 void (*
	mmutex_leave
)(
	msqlite3_mutex
*);

74141 int (*
	mmutex_try
)(
	msqlite3_mutex
*);

74142 int (*
	mopen_v2
)(const char*,
	msqlite3
**,int,const char*);

74143 int (*
	mrelease_memory
)(int);

74144 void (*
	mresult_error_nomem
)(
	msqlite3_context
*);

74145 void (*
	mresult_error_toobig
)(
	msqlite3_context
*);

74146 int (*
	msleep
)(int);

74147 void (*
	msoft_heap_limit
)(int);

74148 
	msqlite3_vfs
 *(*
	mvfs_find
)(const char*);

74149 int (*
	mvfs_register
)(
	msqlite3_vfs
*,int);

74150 int (*
	mvfs_unregister
)(
	msqlite3_vfs
*);

74151 int (*
	mxthreadsafe
)(void);

74152 void (*
	mresult_zeroblob
)(
	msqlite3_context
*,int);

74153 void (*
	mresult_error_code
)(
	msqlite3_context
*,int);

74154 int (*
	mtest_control
)(int, ...);

74155 void (*
	mrandomness
)(int,void*);

74156 
	msqlite3
 *(*
	mcontext_db_handle
)(
	msqlite3_context
*);

74157 int (*
	mextended_result_codes
)(
	msqlite3
*,int);

74158 int (*
	mlimit
)(
	msqlite3
*,int,int);

74159 
	msqlite3_stmt
 *(*
	mnext_stmt
)(
	msqlite3
*,sqlite3_stmt*);

74160 const char *(*
	msql
)(
	msqlite3_stmt
*);

74161 int (*
	mstatus
)(int,int*,int*,int);

74162 int (*
	mbackup_finish
)(
	msqlite3_backup
*);

74163 
	msqlite3_backup
 *(*
	mbackup_init
)(
	msqlite3
*,const char*,sqlite3*,const char*);

74164 int (*
	mbackup_pagecount
)(
	msqlite3_backup
*);

74165 int (*
	mbackup_remaining
)(
	msqlite3_backup
*);

74166 int (*
	mbackup_step
)(
	msqlite3_backup
*,int);

74167 const char *(*
	mcompileoption_get
)(int);

74168 int (*
	mcompileoption_used
)(const char*);

74169 int (*
	mcreate_function_v2
)(
	msqlite3
*,const char*,int,int,void*,

74170 void (*
	mxFunc
)(
	msqlite3_context
*,int,
	msqlite3_value
**),

74171 void (*
	mxStep
)(
	msqlite3_context
*,int,
	msqlite3_value
**),

74172 void (*
	mxFinal
)(
	msqlite3_context
*),

74173 void(*
	mxDestroy
)(void*));

74174 int (*
	mdb_config
)(
	msqlite3
*,int,...);

74175 
	msqlite3_mutex
 *(*
	mdb_mutex
)(
	msqlite3
*);

74176 int (*
	mdb_status
)(
	msqlite3
*,int,int*,int*,int);

74177 int (*
	mextended_errcode
)(
	msqlite3
*);

74178 void (*
	mlog
)(int,const char*,...);

74179 
sqlite3_int64
 (*
soft_heap_limit64
)(
	msqlite3_int64
);

74180 const char *(*
	msourceid
)(void);

74181 int (*
	mstmt_status
)(
	msqlite3_stmt
*,int,int);

74182 int (*
	mstrnicmp
)(const char*,const char*,int);

74183 int (*
	munlock_notify
)(
	msqlite3
*,void(*)(void**,int),void*);

74184 int (*
	mwal_autocheckpoint
)(
	msqlite3
*,int);

74185 int (*
	mwal_checkpoint
)(
	msqlite3
*,const char*);

74186 void *(*
	mwal_hook
)(
	msqlite3
*,int(*)(void*,sqlite3*,const char*,int),void*);

74187 int (*
	mblob_reopen
)(
	msqlite3_blob
*,
	msqlite3_int64
);

74188 int (*
	mvtab_config
)(
	msqlite3
*,int 
	mop
,...);

74189 int (*
	mvtab_on_conflict
)(
	msqlite3
*);

74191 int (*
	mclose_v2
)(
	msqlite3
*);

74192 const char *(*
	mdb_filename
)(
	msqlite3
*,const char*);

74193 int (*
	mdb_readonly
)(
	msqlite3
*,const char*);

74194 int (*
	mdb_release_memory
)(
	msqlite3
*);

74195 const char *(*
	merrstr
)(int);

74196 int (*
	mstmt_busy
)(
	msqlite3_stmt
*);

74197 int (*
	mstmt_readonly
)(
	msqlite3_stmt
*);

74198 int (*
	mstricmp
)(const char*,const char*);

74199 int (*
	muri_boolean
)(const char*,const char*,int);

74200 
sqlite3_int64
 (*
uri_int64
)(const char*,const char*,
	msqlite3_int64
);

74201 const char *(*
	muri_parameter
)(const char*,const char*);

74202 char *(*
	mvsnprintf
)(int,char*,const char*,
	mva_list
);

74203 int (*
	mwal_checkpoint_v2
)(
	msqlite3
*,const char*,int,int*,int*);

74205 int (*
	mauto_extension
)(void(*)(void));

74206 int (*
	mbind_blob64
)(
	msqlite3_stmt
*,int,const void*,
	msqlite3_uint64
,

74208 int (*
	mbind_text64
)(
	msqlite3_stmt
*,int,const char*,
	msqlite3_uint64
,

74210 int (*
	mcancel_auto_extension
)(void(*)(void));

74211 int (*
	mload_extension
)(
	msqlite3
*,const char*,const char*,char**);

74212 void *(*
	mmalloc64
)(
	msqlite3_uint64
);

74213 
sqlite3_uint64
 (*
msize
)(void*);

74214 void *(*
	mrealloc64
)(void*,
	msqlite3_uint64
);

74215 void (*
	mreset_auto_extension
)(void);

74216 void (*
	mresult_blob64
)(
	msqlite3_context
*,const void*,
	msqlite3_uint64
,

74218 void (*
	mresult_text64
)(
	msqlite3_context
*,const char*,
	msqlite3_uint64
,

74220 int (*
	mstrglob
)(const char*,const char*);

74222 
	msqlite3_value
 *(*
	mvalue_dup
)(const sqlite3_value*);

74223 void (*
	mvalue_free
)(
	msqlite3_value
*);

74224 int (*
	mresult_zeroblob64
)(
	msqlite3_context
*,
	msqlite3_uint64
);

74225 int (*
	mbind_zeroblob64
)(
	msqlite3_stmt
*, int, 
	msqlite3_uint64
);

74227 unsigned int (*
	mvalue_subtype
)(
	msqlite3_value
*);

74228 void (*
	mresult_subtype
)(
	msqlite3_context
*,unsigned int);

74230 int (*
	mstatus64
)(int,
	msqlite3_int64
*,sqlite3_int64*,int);

74231 int (*
	mstrlike
)(const char*,const char*,unsigned int);

74232 int (*
	mdb_cacheflush
)(
	msqlite3
*);

74234 int (*
	msystem_errno
)(
	msqlite3
*);

74237 static const 
sqlite3_api_routines
 
	gsqlite3Apis
 = {

74238 
sqlite3_aggregate_context
,

74240 
sqlite3_aggregate_count
,

74244 
sqlite3_bind_blob
,

74245 
sqlite3_bind_double
,

74246 
sqlite3_bind_int
,

74247 
sqlite3_bind_int64
,

74248 
sqlite3_bind_null
,

74249 
sqlite3_bind_parameter_count
,

74250 
sqlite3_bind_parameter_index
,

74251 
sqlite3_bind_parameter_name
,

74252 
sqlite3_bind_text
,

74253 
sqlite3_bind_text16
,

74254 
sqlite3_bind_value
,

74255 
sqlite3_busy_handler
,

74256 
sqlite3_busy_timeout
,

74257 
sqlite3_changes
,

74258 
sqlite3_close
,

74259 
sqlite3_collation_needed
,

74260 
sqlite3_collation_needed16
,

74261 
sqlite3_column_blob
,

74262 
sqlite3_column_bytes
,

74263 
sqlite3_column_bytes16
,

74264 
sqlite3_column_count
,

74267 
sqlite3_column_decltype
,

74268 
sqlite3_column_decltype16
,

74269 
sqlite3_column_double
,

74270 
sqlite3_column_int
,

74271 
sqlite3_column_int64
,

74272 
sqlite3_column_name
,

74273 
sqlite3_column_name16
,

74278 
sqlite3_column_text
,

74279 
sqlite3_column_text16
,

74280 
sqlite3_column_type
,

74281 
sqlite3_column_value
,

74282 
sqlite3_commit_hook
,

74283 
sqlite3_complete
,

74284 
sqlite3_complete16
,

74285 
sqlite3_create_collation
,

74286 
sqlite3_create_collation16
,

74287 
sqlite3_create_function
,

74288 
sqlite3_create_function16
,

74289 
sqlite3_create_module
,

74290 
sqlite3_data_count
,

74291 
sqlite3_db_handle
,

74292 
sqlite3_declare_vtab
,

74293 
sqlite3_enable_shared_cache
,

74294 
sqlite3_errcode
,

74295 
sqlite3_errmsg
,

74296 
sqlite3_errmsg16
,

74297 
sqlite3_exec
,

74299 
sqlite3_expired
,

74303 
sqlite3_finalize
,

74304 
sqlite3_free
,

74305 
sqlite3_free_table
,

74306 
sqlite3_get_autocommit
,

74307 
sqlite3_get_auxdata
,

74308 
sqlite3_get_table
,

74310 
sqlite3_interrupt
,

74311 
sqlite3_last_insert_rowid
,

74312 
sqlite3_libversion
,

74313 
sqlite3_libversion_number
,

74314 
sqlite3_malloc
,

74315 
sqlite3_mprintf
,

74316 
sqlite3_open
,

74317 
sqlite3_open16
,

74318 
sqlite3_prepare
,

74319 
sqlite3_prepare16
,

74320 
sqlite3_profile
,

74321 
sqlite3_progress_handler
,

74322 
sqlite3_realloc
,

74323 
sqlite3_reset
,

74324 
sqlite3_result_blob
,

74325 
sqlite3_result_double
,

74326 
sqlite3_result_error
,

74327 
sqlite3_result_error16
,

74328 
sqlite3_result_int
,

74329 
sqlite3_result_int64
,

74330 
sqlite3_result_null
,

74331 
sqlite3_result_text
,

74332 
sqlite3_result_text16
,

74333 
sqlite3_result_text16be
,

74334 
sqlite3_result_text16le
,

74335 
sqlite3_result_value
,

74336 
sqlite3_rollback_hook
,

74337 
sqlite3_set_authorizer
,

74338 
sqlite3_set_auxdata
,

74339 
sqlite3_snprintf
,

74340 
sqlite3_step
,

74341 
sqlite3_table_column_metadata
,

74343 
sqlite3_thread_cleanup
,

74347 
sqlite3_total_changes
,

74348 
sqlite3_trace
,

74350 
sqlite3_transfer_bindings
,

74354 
sqlite3_update_hook
,

74355 
sqlite3_user_data
,

74356 
sqlite3_value_blob
,

74357 
sqlite3_value_bytes
,

74358 
sqlite3_value_bytes16
,

74359 
sqlite3_value_double
,

74360 
sqlite3_value_int
,

74361 
sqlite3_value_int64
,

74362 
sqlite3_value_numeric_type
,

74363 
sqlite3_value_text
,

74364 
sqlite3_value_text16
,

74365 
sqlite3_value_text16be
,

74366 
sqlite3_value_text16le
,

74367 
sqlite3_value_type
,

74368 
sqlite3_vmprintf
,

74370 
sqlite3_overload_function
,

74375 
sqlite3_prepare_v2
,

74376 
sqlite3_prepare16_v2
,

74377 
sqlite3_clear_bindings
,

74382 
sqlite3_create_module_v2
,

74387 
sqlite3_bind_zeroblob
,

74388 
sqlite3_blob_bytes
,

74389 
sqlite3_blob_close
,

74390 
sqlite3_blob_open
,

74391 
sqlite3_blob_read
,

74392 
sqlite3_blob_write
,

74393 
sqlite3_create_collation_v2
,

74394 
sqlite3_file_control
,

74395 
sqlite3_memory_highwater
,

74396 
sqlite3_memory_used
,

74404 
sqlite3_mutex_alloc
,

74405 
sqlite3_mutex_enter
,

74406 
sqlite3_mutex_free
,

74407 
sqlite3_mutex_leave
,

74408 
sqlite3_mutex_try
,

74410 
sqlite3_open_v2
,

74411 
sqlite3_release_memory
,

74412 
sqlite3_result_error_nomem
,

74413 
sqlite3_result_error_toobig
,

74414 
sqlite3_sleep
,

74415 
sqlite3_soft_heap_limit
,

74416 
sqlite3_vfs_find
,

74417 
sqlite3_vfs_register
,

74418 
sqlite3_vfs_unregister
,

74423 
sqlite3_threadsafe
,

74424 
sqlite3_result_zeroblob
,

74425 
sqlite3_result_error_code
,

74426 
sqlite3_test_control
,

74427 
sqlite3_randomness
,

74428 
sqlite3_context_db_handle
,

74433 
sqlite3_extended_result_codes
,

74434 
sqlite3_limit
,

74435 
sqlite3_next_stmt
,

74436 
sqlite3_sql
,

74437 
sqlite3_status
,

74442 
sqlite3_backup_finish
,

74443 
sqlite3_backup_init
,

74444 
sqlite3_backup_pagecount
,

74445 
sqlite3_backup_remaining
,

74446 
sqlite3_backup_step
,

74448 
sqlite3_compileoption_get
,

74449 
sqlite3_compileoption_used
,

74454 
sqlite3_create_function_v2
,

74455 
sqlite3_db_config
,

74456 
sqlite3_db_mutex
,

74457 
sqlite3_db_status
,

74458 
sqlite3_extended_errcode
,

74459 
sqlite3_log
,

74460 
sqlite3_soft_heap_limit64
,

74461 
sqlite3_sourceid
,

74462 
sqlite3_stmt_status
,

74463 
sqlite3_strnicmp
,

74470 
sqlite3_wal_autocheckpoint
,

74471 
sqlite3_wal_checkpoint
,

74472 
sqlite3_wal_hook
,

74478 
sqlite3_blob_reopen
,

74479 
sqlite3_vtab_config
,

74480 
sqlite3_vtab_on_conflict
,

74481 
sqlite3_close_v2
,

74482 
sqlite3_db_filename
,

74483 
sqlite3_db_readonly
,

74484 
sqlite3_db_release_memory
,

74485 
sqlite3_errstr
,

74486 
sqlite3_stmt_busy
,

74487 
sqlite3_stmt_readonly
,

74488 
sqlite3_stricmp
,

74489 
sqlite3_uri_boolean
,

74490 
sqlite3_uri_int64
,

74491 
sqlite3_uri_parameter
,

74492 
sqlite3_vsnprintf
,

74493 
sqlite3_wal_checkpoint_v2
,

74495 
sqlite3_auto_extension
,

74496 
sqlite3_bind_blob64
,

74497 
sqlite3_bind_text64
,

74498 
sqlite3_cancel_auto_extension
,

74499 
sqlite3_load_extension
,

74500 
sqlite3_malloc64
,

74501 
sqlite3_msize
,

74502 
sqlite3_realloc64
,

74503 
sqlite3_reset_auto_extension
,

74504 
sqlite3_result_blob64
,

74505 
sqlite3_result_text64
,

74506 
sqlite3_strglob
,

74508 (
sqlite3_value
*(*)(const sqlite3_value*))
sqlite3_value_dup
,

74509 
sqlite3_value_free
,

74510 
sqlite3_result_zeroblob64
,

74511 
sqlite3_bind_zeroblob64
,

74513 
sqlite3_value_subtype
,

74514 
sqlite3_result_subtype
,

74516 
sqlite3_status64
,

74517 
sqlite3_strlike
,

74518 
sqlite3_db_cacheflush
,

74520 
sqlite3_system_errno


74523 static int 
	$sqlite3LoadExtension
(

74524 
sqlite3
 *
db
,

74525 const char *
zFile
,

74526 const char *
zProc
,

74527 char **
pzErrMsg


74531 
sqlite3_vfs
 *
pVfs
 = 
db
->pVfs;

74532 void *
handle
;

74533 int (*
xInit
)(
sqlite3
*,char**,const 
sqlite3_api_routines
*);

74534 char *
zErrmsg
 = 0;

74535 const char *
zEntry
;

74536 char *
zAltEntry
 = 0;

74537 void **
aHandle
;

74538 
u64
 
nMsg
 = 300 + 
	`sqlite3Strlen30
(
zFile
);

74539 int 
ii
;

74542 static const char *
azEndings
[] = {

74553 if( 
pzErrMsg
 ) *pzErrMsg = 0;

74561 if( (
db
->
flags
 & 0x00400000)==0 )

74564 if( 
pzErrMsg
 )

74567 *
pzErrMsg
 = 
	`sqlite3_mprintf
("not authorized");

74572 
zEntry
 = 
zProc
 ? zProc : "sqlite3_extension_init";

74574 
handle
 = 
	`sqlite3OsDlOpen
(
pVfs
, 
zFile
);

74576 for(
ii
=0; ii<((int)(sizeof(
azEndings
)/sizeof(azEndings[0]))) && 
handle
==0; ii++)

74579 char *
zAltFile
 = 
	`sqlite3_mprintf
("%s.%s", 
zFile
, 
azEndings
[
ii
]);

74580 if( 
zAltFile
==0 ) return 7;

74581 
handle
 = 
	`sqlite3OsDlOpen
(
pVfs
, 
zAltFile
);

74582 
	`sqlite3_free
(
zAltFile
);

74585 if( 
handle
==0 )

74588 if( 
pzErrMsg
 )

74591 *
pzErrMsg
 = 
zErrmsg
 = 
	`sqlite3_malloc64
(
nMsg
);

74592 if( 
zErrmsg
 )

74595 
	`sqlite3_snprintf
(
nMsg
, 
zErrmsg
,

74596 "unable to open shared library [%s]", 
zFile
);

74597 
	`sqlite3OsDlError
(
pVfs
, 
nMsg
-1, 
zErrmsg
);

74602 
xInit
 = (int(*)(
sqlite3
*,char**,const 
sqlite3_api_routines
*))

74603 
	`sqlite3OsDlSym
(
pVfs
, 
handle
, 
zEntry
);

74605 if( 
xInit
==0 && 
zProc
==0 )

74608 int 
iFile
, 
iEntry
, 
c
;

74609 int 
ncFile
 = 
	`sqlite3Strlen30
(
zFile
);

74610 
zAltEntry
 = 
	`sqlite3_malloc64
(
ncFile
+30);

74611 if( 
zAltEntry
==0 )

74614 
	`sqlite3OsDlClose
(
pVfs
, 
handle
);

74617 
	`memcpy
(
zAltEntry
, "sqlite3_", 8);

74618 for(
iFile
=
ncFile
-1; iFile>=0 && 
zFile
[iFile]!='/'; iFile--)

74621 
iFile
++;

74622 if( 
	`sqlite3_strnicmp
(
zFile
+
iFile
, "lib", 3)==0 ) iFile += 3;

74623 for(
iEntry
=8; (
c
 = 
zFile
[
iFile
])!=0 && c!='.'; iFile++)

74626 if( (
sqlite3CtypeMap
[(unsigned char)(
c
)]&0x02) )

74629 
zAltEntry
[
iEntry
++] = (char)
sqlite3UpperToLower
[(unsigned)
c
];

74632 
	`memcpy
(
zAltEntry
+
iEntry
, "_init", 6);

74633 
zEntry
 = 
zAltEntry
;

74634 
xInit
 = (int(*)(
sqlite3
*,char**,const 
sqlite3_api_routines
*))

74635 
	`sqlite3OsDlSym
(
pVfs
, 
handle
, 
zEntry
);

74637 if( 
xInit
==0 )

74640 if( 
pzErrMsg
 )

74643 
nMsg
 += 
	`sqlite3Strlen30
(
zEntry
);

74644 *
pzErrMsg
 = 
zErrmsg
 = 
	`sqlite3_malloc64
(
nMsg
);

74645 if( 
zErrmsg
 )

74648 
	`sqlite3_snprintf
(
nMsg
, 
zErrmsg
,

74649 "no entry point [%s] in shared library [%s]", 
zEntry
, 
zFile
);

74650 
	`sqlite3OsDlError
(
pVfs
, 
nMsg
-1, 
zErrmsg
);

74653 
	`sqlite3OsDlClose
(
pVfs
, 
handle
);

74654 
	`sqlite3_free
(
zAltEntry
);

74657 
	`sqlite3_free
(
zAltEntry
);

74658 if( 
	`xInit
(
db
, &
zErrmsg
, &
sqlite3Apis
) )

74661 if( 
pzErrMsg
 )

74664 *
pzErrMsg
 = 
	`sqlite3_mprintf
("error during initialization: %s", 
zErrmsg
);

74666 
	`sqlite3_free
(
zErrmsg
);

74667 
	`sqlite3OsDlClose
(
pVfs
, 
handle
);

74672 
aHandle
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
handle
)*(db->
nExtension
+1));

74673 if( 
aHandle
==0 )

74678 if( 
db
->
nExtension
>0 )

74681 
	`memcpy
(
aHandle
, 
db
->
aExtension
, sizeof(
handle
)*db->
nExtension
);

74683 
	`sqlite3DbFree
(
db
, db->
aExtension
);

74684 
db
->
aExtension
 = 
aHandle
;

74686 
db
->
aExtension
[db->
nExtension
++] = 
handle
;

74688 
	}
}

74689 int 
	$sqlite3_load_extension
(

74690 
sqlite3
 *
db
,

74691 const char *
zFile
,

74692 const char *
zProc
,

74693 char **
pzErrMsg


74697 int 
rc
;

74698 
	`sqlite3_mutex_enter
(
db
->
mutex
);

74699 
rc
 = 
	`sqlite3LoadExtension
(
db
, 
zFile
, 
zProc
, 
pzErrMsg
);

74700 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

74701 
	`sqlite3_mutex_leave
(
db
->
mutex
);

74702 return 
rc
;

74703 
	}
}

74709 static void 
	$sqlite3CloseExtensions
(
sqlite3
 *
db
)

74712 int 
i
;

74714 for(
i
=0; i<
db
->
nExtension
; i++)

74717 
	`sqlite3OsDlClose
(
db
->
pVfs
, db->
aExtension
[
i
]);

74719 
	`sqlite3DbFree
(
db
, db->
aExtension
);

74720 
	}
}

74726 int 
	$sqlite3_enable_load_extension
(
sqlite3
 *
db
, int 
onoff
)

74729 
	`sqlite3_mutex_enter
(
db
->
mutex
);

74730 if( 
onoff
 )

74733 
db
->
flags
 |= 0x00400000;

74735 
db
->
flags
 &= ~0x00400000;

74737 
	`sqlite3_mutex_leave
(
db
->
mutex
);

74739 
	}
}

74741 typedef struct 
sqlite3AutoExtList
 
	tsqlite3AutoExtList
;

74742 static struct 
	ssqlite3AutoExtList
 {

74743 
u32
 
	mnExt
;

74744 void (**
	maExt
)(void);

74745 } 
	gsqlite3Autoext
 = { 0, 0 };

74747 int 
sqlite3_auto_extension
(void (*
xInit
)(void))

74750 int 
rc
 = 0;

74752 
rc
 = 
	`sqlite3_initialize
();

74753 if( 
rc
 )

74756 return 
rc
;

74760 
u32
 
i
;

74762 
sqlite3_mutex
 *
mutex
 = 
	`sqlite3MutexAlloc
(2);

74765 
	`sqlite3_mutex_enter
(
mutex
);

74766 for(
i
=0; i<
sqlite3Autoext
.
nExt
; i++)

74769 if( 
sqlite3Autoext
.
aExt
[
i
]==
xInit
 ) break;

74771 if( 
i
==
sqlite3Autoext
.
nExt
 )

74774 
u64
 
nByte
 = (
sqlite3Autoext
.
nExt
+1)*sizeof(sqlite3Autoext.
aExt
[0]);

74775 void (**
aNew
)(void);

74776 
aNew
 = 
	`sqlite3_realloc64
(
sqlite3Autoext
.
aExt
, 
nByte
);

74777 if( 
aNew
==0 )

74780 
rc
 = 7;

74782 
sqlite3Autoext
.
aExt
 = 
aNew
;

74783 
sqlite3Autoext
.
aExt
[sqlite3Autoext.
nExt
] = 
xInit
;

74784 
sqlite3Autoext
.
nExt
++;

74787 
	`sqlite3_mutex_leave
(
mutex
);

74789 return 
rc
;

74791 
	}
}

74793 int 
sqlite3_cancel_auto_extension
(void (*
xInit
)(void))

74797 
sqlite3_mutex
 *
mutex
 = 
	`sqlite3MutexAlloc
(2);

74799 int 
i
;

74800 int 
n
 = 0;

74802 
	`sqlite3_mutex_enter
(
mutex
);

74803 for(
i
=(int)
sqlite3Autoext
.
nExt
-1; i>=0; i--)

74806 if( 
sqlite3Autoext
.
aExt
[
i
]==
xInit
 )

74809 
sqlite3Autoext
.
nExt
--;

74810 
sqlite3Autoext
.
aExt
[
i
] = sqlite3Autoext.aExt[sqlite3Autoext.
nExt
];

74811 
n
++;

74815 
	`sqlite3_mutex_leave
(
mutex
);

74816 return 
n
;

74817 
	}
}

74822 void 
	$sqlite3_reset_auto_extension
(void)

74826 if( 
	`sqlite3_initialize
()==0 )

74830 
sqlite3_mutex
 *
mutex
 = 
	`sqlite3MutexAlloc
(2);

74833 
	`sqlite3_mutex_enter
(
mutex
);

74834 
	`sqlite3_free
(
sqlite3Autoext
.
aExt
);

74835 
sqlite3Autoext
.
aExt
 = 0;

74836 
sqlite3Autoext
.
nExt
 = 0;

74837 
	`sqlite3_mutex_leave
(
mutex
);

74839 
	}
}

74846 static void 
	$sqlite3AutoLoadExtensions
(
sqlite3
 *
db
)

74849 
u32
 
i
;

74850 int 
go
 = 1;

74851 int 
rc
;

74852 int (*
xInit
)(
sqlite3
*,char**,const 
sqlite3_api_routines
*);

74855 if( 
sqlite3Autoext
.
nExt
==0 )

74861 for(
i
=0; 
go
; i++)

74864 char *
zErrmsg
;

74866 
sqlite3_mutex
 *
mutex
 = 
	`sqlite3MutexAlloc
(2);

74868 
	`sqlite3_mutex_enter
(
mutex
);

74869 if( 
i
>=
sqlite3Autoext
.
nExt
 )

74872 
xInit
 = 0;

74873 
go
 = 0;

74875 
xInit
 = (int(*)(
sqlite3
*,char**,const 
sqlite3_api_routines
*))

74876 
sqlite3Autoext
.
aExt
[
i
];

74878 
	`sqlite3_mutex_leave
(
mutex
);

74879 
zErrmsg
 = 0;

74880 if( 
xInit
 && (
rc
 = 
	`xInit
(
db
, &
zErrmsg
, &
sqlite3Apis
))!=0 )

74883 
	`sqlite3ErrorWithMsg
(
db
, 
rc
,

74884 "automatic extension loading failed: %s", 
zErrmsg
);

74885 
go
 = 0;

74887 
	`sqlite3_free
(
zErrmsg
);

74889 
	}
}

74891 static const struct 
	ssPragmaNames
 {

74892 const char *const 
	mzName
;

74893 
u8
 
	mePragTyp
;

74894 
u8
 
	mmPragFlag
;

74895 
u32
 
	miArg
;

74896 } 
	gaPragmaNames
[] = {

75219 static 
u8
 
	$getSafetyLevel
(const char *
z
, int 
omitFull
, 
u8
 
dflt
)

75223 static const char 
zText
[] = "onoffalseyestruextrafull";

75224 static const 
u8
 
iOffset
[] = {0, 1, 2, 4, 9, 12, 15, 20};

75225 static const 
u8
 
iLength
[] = {2, 2, 3, 5, 3, 4, 5, 4};

75226 static const 
u8
 
iValue
[] = {1, 0, 0, 0, 1, 1, 3, 2};

75228 int 
i
, 
n
;

75229 if( (
sqlite3CtypeMap
[(unsigned char)(*
z
)]&0x04) )

75232 return (
u8
)
	`sqlite3Atoi
(
z
);

75234 
n
 = 
	`sqlite3Strlen30
(
z
);

75235 for(
i
=0; i<((int)(sizeof(
iLength
)/sizeof(iLength[0]))); i++)

75238 if( 
iLength
[
i
]==
n
 && 
	`sqlite3_strnicmp
(&
zText
[
iOffset
[i]],
z
,n)==0

75239 && (!
omitFull
 || 
iValue
[
i
]<=1)

75243 return 
iValue
[
i
];

75246 return 
dflt
;

75247 
	}
}

75252 static 
u8
 
	$sqlite3GetBoolean
(const char *
z
, 
u8
 
dflt
)

75255 return 
	`getSafetyLevel
(
z
,1,
dflt
)!=0;

75256 
	}
}

75258 static int 
	$getLockingMode
(const char *
z
)

75261 if( 
z
 )

75264 if( 0==
	`sqlite3StrICmp
(
z
, "exclusive") ) return 1;

75265 if( 0==
	`sqlite3StrICmp
(
z
, "normal") ) return 0;

75268 
	}
}

75270 static int 
	$getAutoVacuum
(const char *
z
)

75273 int 
i
;

75274 if( 0==
	`sqlite3StrICmp
(
z
, "none") ) return 0;

75275 if( 0==
	`sqlite3StrICmp
(
z
, "full") ) return 1;

75276 if( 0==
	`sqlite3StrICmp
(
z
, "incremental") ) return 2;

75277 
i
 = 
	`sqlite3Atoi
(
z
);

75278 return (
u8
)((
i
>=0&&i<=2)?i:0);

75279 
	}
}

75281 static int 
	$getTempStore
(const char *
z
)

75284 if( 
z
[0]>='0' && z[0]<='2' )

75287 return 
z
[0] - '0';

75288 }else if( 
	`sqlite3StrICmp
(
z
, "file")==0 )

75292 }else if( 
	`sqlite3StrICmp
(
z
, "memory")==0 )

75299 
	}
}

75307 static int 
	$invalidateTempStorage
(
Parse
 *
pParse
)

75310 
sqlite3
 *
db
 = 
pParse
->db;

75311 if( 
db
->
aDb
[1].
pBt
!=0 )

75314 if( !
db
->
autoCommit
 || 
	`sqlite3BtreeIsInReadTrans
(db->
aDb
[1].
pBt
) )

75317 
	`sqlite3ErrorMsg
(
pParse
, "temporary storage cannot be changed "

75321 
	`sqlite3BtreeClose
(
db
->
aDb
[1].
pBt
);

75322 
db
->
aDb
[1].
pBt
 = 0;

75323 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

75326 
	}
}

75328 static int 
	$changeTempStorage
(
Parse
 *
pParse
, const char *
zStorageType
)

75331 int 
ts
 = 
	`getTempStore
(
zStorageType
);

75332 
sqlite3
 *
db
 = 
pParse
->db;

75333 if( 
db
->
temp_store
==
ts
 ) return 0;

75334 if( 
	`invalidateTempStorage
( 
pParse
 ) != 0 )

75339 
db
->
temp_store
 = (
u8
)
ts
;

75341 
	}
}

75347 static void 
	$setAllColumnNames
(

75348 
Vdbe
 *
v
,

75349 int 
N
,

75350 const char **
azCol


75354 int 
i
;

75355 
	`sqlite3VdbeSetNumCols
(
v
, 
N
);

75356 for(
i
=0; i<
N
; i++)

75359 
	`sqlite3VdbeSetColName
(
v
, 
i
, 0, 
azCol
[i], ((
sqlite3_destructor_type
)0));

75361 
	}
}

75362 static void 
	$setOneColumnName
(
Vdbe
 *
v
, const char *
z
)

75365 
	`setAllColumnNames
(
v
, 1, &
z
);

75366 
	}
}

75371 static void 
	$returnSingleInt
(
Vdbe
 *
v
, const char *
zLabel
, 
i64
 
value
)

75374 
	`sqlite3VdbeAddOp4Dup8
(
v
, 23, 0, 1, 0, (const 
u8
*)&
value
, (-13));

75375 
	`setOneColumnName
(
v
, 
zLabel
);

75376 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 1);

75377 
	}
}

75382 static void 
	$returnSingleText
(

75383 
Vdbe
 *
v
,

75384 const char *
zLabel
,

75385 const char *
zValue


75389 if( 
zValue
 )

75392 
	`sqlite3VdbeLoadString
(
v
, 1, (const char*)
zValue
);

75393 
	`setOneColumnName
(
v
, 
zLabel
);

75394 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 1);

75396 
	}
}

75404 static void 
	$setAllPagerFlags
(
sqlite3
 *
db
)

75407 if( 
db
->
autoCommit
 )

75410 
Db
 *
pDb
 = 
db
->
aDb
;

75411 int 
n
 = 
db
->
nDb
;

75418 while( (
n
--) > 0 )

75421 if( 
pDb
->
pBt
 )

75424 
	`sqlite3BtreeSetPagerFlags
(
pDb
->
pBt
,

75425 
pDb
->
safety_level
 | (
db
->
flags
 & 0x38) );

75427 
pDb
++;

75430 
	}
}

75432 static const char *
	$actionName
(
u8
 
action
)

75435 const char *
zName
;

75436 switch( 
action
 )

75439 case 7: 
zName
 = "SET NULL"; break;

75440 case 8: 
zName
 = "SET DEFAULT"; break;

75441 case 9: 
zName
 = "CASCADE"; break;

75442 case 6: 
zName
 = "RESTRICT"; break;

75443 default: 
zName
 = "NO ACTION";

75446 return 
zName
;

75447 
	}
}

75449 static const char *
	$sqlite3JournalModename
(int 
eMode
)

75452 static char * const 
azModeName
[] = {

75466 if( 
eMode
==((int)(sizeof(
azModeName
)/sizeof(azModeName[0]))) ) return 0;

75467 return 
azModeName
[
eMode
];

75468 
	}
}

75470 static void 
	$sqlite3Pragma
(

75471 
Parse
 *
pParse
,

75472 
Token
 *
pId1
,

75473 
Token
 *
pId2
,

75474 
Token
 *
pValue
,

75475 int 
minusFlag


75479 char *
zLeft
 = 0;

75480 char *
zRight
 = 0;

75481 const char *
zDb
 = 0;

75482 
Token
 *
pId
;

75483 char *
aFcntl
[4];

75484 int 
iDb
;

75485 int 
lwr
, 
upr
, 
mid
 = 0;

75486 int 
rc
;

75487 
sqlite3
 *
db
 = 
pParse
->db;

75488 
Db
 *
pDb
;

75489 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

75490 const struct 
sPragmaNames
 *
pPragma
;

75492 if( 
v
==0 ) return;

75493 
	`sqlite3VdbeRunOnlyOnce
(
v
);

75494 
pParse
->
nMem
 = 2;

75498 
iDb
 = 
	`sqlite3TwoPartName
(
pParse
, 
pId1
, 
pId2
, &
pId
);

75499 if( 
iDb
<0 ) return;

75500 
pDb
 = &
db
->
aDb
[
iDb
];

75505 if( 
iDb
==1 && 
	`sqlite3OpenTempDatabase
(
pParse
) )

75511 
zLeft
 = 
	`sqlite3NameFromToken
(
db
, 
pId
);

75512 if( !
zLeft
 ) return;

75513 if( 
minusFlag
 )

75516 
zRight
 = 
	`sqlite3MPrintf
(
db
, "-%T", 
pValue
);

75518 
zRight
 = 
	`sqlite3NameFromToken
(
db
, 
pValue
);

75522 
zDb
 = 
pId2
->
n
>0 ? 
pDb
->
zName
 : 0;

75523 if( 
	`sqlite3AuthCheck
(
pParse
, 19, 
zLeft
, 
zRight
, 
zDb
) )

75526 goto 
pragma_out
;

75529 
aFcntl
[0] = 0;

75530 
aFcntl
[1] = 
zLeft
;

75531 
aFcntl
[2] = 
zRight
;

75532 
aFcntl
[3] = 0;

75533 
db
->
busyHandler
.
nBusy
 = 0;

75534 
rc
 = 
	`sqlite3_file_control
(
db
, 
zDb
, 14, (void*)
aFcntl
);

75535 if( 
rc
==0 )

75538 
	`returnSingleText
(
v
, "result", 
aFcntl
[0]);

75539 
	`sqlite3_free
(
aFcntl
[0]);

75540 goto 
pragma_out
;

75542 if( 
rc
!=12 )

75545 if( 
aFcntl
[0] )

75548 
	`sqlite3ErrorMsg
(
pParse
, "%s", 
aFcntl
[0]);

75549 
	`sqlite3_free
(
aFcntl
[0]);

75551 
pParse
->
nErr
++;

75552 
pParse
->
rc
 = rc;

75553 goto 
pragma_out
;

75557 
lwr
 = 0;

75558 
upr
 = ((int)(sizeof(
aPragmaNames
)/sizeof(aPragmaNames[0])))-1;

75559 while( 
lwr
<=
upr
 )

75562 
mid
 = (
lwr
+
upr
)/2;

75563 
rc
 = 
	`sqlite3_stricmp
(
zLeft
, 
aPragmaNames
[
mid
].
zName
);

75564 if( 
rc
==0 ) break;

75565 if( 
rc
<0 )

75568 
upr
 = 
mid
 - 1;

75570 
lwr
 = 
mid
 + 1;

75573 if( 
lwr
>
upr
 ) goto 
pragma_out
;

75574 
pPragma
 = &
aPragmaNames
[
mid
];

75577 if( (
pPragma
->
mPragFlag
 & 0x01)!=0 )

75580 if( 
	`sqlite3ReadSchema
(
pParse
) ) goto 
pragma_out
;

75584 switch( 
pPragma
->
ePragTyp
 )

75589 static const int 
iLn
 = 0;

75590 static const 
VdbeOpList
 
getCacheSize
[] = {

75601 
VdbeOp
 *
aOp
;

75602 
	`sqlite3VdbeUsesBtree
(
v
, 
iDb
);

75603 if( !
zRight
 )

75606 
	`setOneColumnName
(
v
, "cache_size");

75607 
pParse
->
nMem
 += 2;

75609 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
getCacheSize
)/sizeof(getCacheSize[0]))), getCacheSize, 
iLn
);

75611 
aOp
[0].
p1
 = 
iDb
;

75612 
aOp
[1].
p1
 = 
iDb
;

75613 
aOp
[6].
p1
 = -2000;

75615 int 
size
 = 
	`sqlite3AbsInt32
(
	`sqlite3Atoi
(
zRight
));

75616 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

75617 
	`sqlite3VdbeAddOp3
(
v
, 52, 
iDb
, 3, 
size
);

75619 
pDb
->
pSchema
->
cache_size
 = 
size
;

75620 
	`sqlite3BtreeSetCacheSize
(
pDb
->
pBt
, pDb->
pSchema
->
cache_size
);

75626 
Btree
 *
pBt
 = 
pDb
->pBt;

75628 if( !
zRight
 )

75631 int 
size
 = (
pBt
) ? 
	`sqlite3BtreeGetPageSize
(pBt) : 0;

75632 
	`returnSingleInt
(
v
, "page_size", 
size
);

75637 
db
->
nextPagesize
 = 
	`sqlite3Atoi
(
zRight
);

75638 if( 7==
	`sqlite3BtreeSetPageSize
(
pBt
, 
db
->
nextPagesize
,-1,0) )

75641 
	`sqlite3OomFault
(
db
);

75648 
Btree
 *
pBt
 = 
pDb
->pBt;

75649 int 
b
 = -1;

75651 if( 
zRight
 )

75654 
b
 = 
	`sqlite3GetBoolean
(
zRight
, 0);

75656 if( 
pId2
->
n
==0 && 
b
>=0 )

75659 int 
ii
;

75660 for(
ii
=0; ii<
db
->
nDb
; ii++)

75663 
	`sqlite3BtreeSecureDelete
(
db
->
aDb
[
ii
].
pBt
, 
b
);

75666 
b
 = 
	`sqlite3BtreeSecureDelete
(
pBt
, b);

75667 
	`returnSingleInt
(
v
, "secure_delete", 
b
);

75672 int 
iReg
;

75673 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

75674 
iReg
 = ++
pParse
->
nMem
;

75675 if( (
sqlite3UpperToLower
[(unsigned char)(
zLeft
[0])])=='p' )

75678 
	`sqlite3VdbeAddOp2
(
v
, 156, 
iDb
, 
iReg
);

75680 
	`sqlite3VdbeAddOp3
(
v
, 157, 
iDb
, 
iReg
,

75681 
	`sqlite3AbsInt32
(
	`sqlite3Atoi
(
zRight
)));

75683 
	`sqlite3VdbeAddOp2
(
v
, 33, 
iReg
, 1);

75684 
	`sqlite3VdbeSetNumCols
(
v
, 1);

75685 
	`sqlite3VdbeSetColName
(
v
, 0, 0, 
zLeft
, ((
sqlite3_destructor_type
)-1));

75694 const char *
zRet
 = "normal";

75695 int 
eMode
 = 
	`getLockingMode
(
zRight
);

75697 if( 
pId2
->
n
==0 && 
eMode
==-1 )

75704 
eMode
 = 
db
->
dfltLockMode
;

75706 
Pager
 *
pPager
;

75707 if( 
pId2
->
n
==0 )

75711 int 
ii
;

75713 for(
ii
=2; ii<
db
->
nDb
; ii++)

75716 
pPager
 = 
	`sqlite3BtreePager
(
db
->
aDb
[
ii
].
pBt
);

75717 
	`sqlite3PagerLockingMode
(
pPager
, 
eMode
);

75719 
db
->
dfltLockMode
 = (
u8
)
eMode
;

75721 
pPager
 = 
	`sqlite3BtreePager
(
pDb
->
pBt
);

75722 
eMode
 = 
	`sqlite3PagerLockingMode
(
pPager
, eMode);

75727 if( 
eMode
==1 )

75730 
zRet
 = "exclusive";

75732 
	`returnSingleText
(
v
, "locking_mode", 
zRet
);

75742 int 
eMode
;

75743 int 
ii
;

75745 
	`setOneColumnName
(
v
, "journal_mode");

75746 if( 
zRight
==0 )

75751 
eMode
 = (-1);

75753 const char *
zMode
;

75754 int 
n
 = 
	`sqlite3Strlen30
(
zRight
);

75755 for(
eMode
=0; (
zMode
 = 
	`sqlite3JournalModename
(eMode))!=0; eMode++)

75758 if( 
	`sqlite3_strnicmp
(
zRight
, 
zMode
, 
n
)==0 ) break;

75760 if( !
zMode
 )

75765 
eMode
 = (-1);

75768 if( 
eMode
==(-1) && 
pId2
->
n
==0 )

75772 
iDb
 = 0;

75773 
pId2
->
n
 = 1;

75775 for(
ii
=
db
->
nDb
-1; ii>=0; ii--)

75778 if( 
db
->
aDb
[
ii
].
pBt
 && (ii==
iDb
 || 
pId2
->
n
==0) )

75781 
	`sqlite3VdbeUsesBtree
(
v
, 
ii
);

75782 
	`sqlite3VdbeAddOp3
(
v
, 9, 
ii
, 1, 
eMode
);

75785 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 1);

75796 
Pager
 *
pPager
 = 
	`sqlite3BtreePager
(
pDb
->
pBt
);

75797 
i64
 
iLimit
 = -2;

75798 if( 
zRight
 )

75801 
	`sqlite3DecOrHexToI64
(
zRight
, &
iLimit
);

75802 if( 
iLimit
<-1 ) iLimit = -1;

75804 
iLimit
 = 
	`sqlite3PagerJournalSizeLimit
(
pPager
, iLimit);

75805 
	`returnSingleInt
(
v
, "journal_size_limit", 
iLimit
);

75810 
Btree
 *
pBt
 = 
pDb
->pBt;

75812 if( !
zRight
 )

75815 
	`returnSingleInt
(
v
, "auto_vacuum", 
	`sqlite3BtreeGetAutoVacuum
(
pBt
));

75817 int 
eAuto
 = 
	`getAutoVacuum
(
zRight
);

75819 
db
->
nextAutovac
 = (
u8
)
eAuto
;

75825 
rc
 = 
	`sqlite3BtreeSetAutoVacuum
(
pBt
, 
eAuto
);

75826 if( 
rc
==0 && (
eAuto
==1 || eAuto==2) )

75834 static const int 
iLn
 = 0;

75835 static const 
VdbeOpList
 
setMeta6
[] = {

75842 
VdbeOp
 *
aOp
;

75843 int 
iAddr
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

75845 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
setMeta6
)/sizeof(setMeta6[0]))), setMeta6, 
iLn
);

75847 
aOp
[0].
p1
 = 
iDb
;

75848 
aOp
[1].
p1
 = 
iDb
;

75849 
aOp
[2].
p2
 = 
iAddr
+4;

75850 
aOp
[4].
p1
 = 
iDb
;

75851 
aOp
[4].
p3
 = 
eAuto
 - 1;

75852 
	`sqlite3VdbeUsesBtree
(
v
, 
iDb
);

75859 int 
iLimit
, 
addr
;

75860 if( 
zRight
==0 || !
	`sqlite3GetInt32
(zRight, &
iLimit
) || iLimit<=0 )

75863 
iLimit
 = 0x7fffffff;

75865 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

75866 
	`sqlite3VdbeAddOp2
(
v
, 22, 
iLimit
, 1);

75867 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 146, 
iDb
); ;

75868 
	`sqlite3VdbeAddOp1
(
v
, 33, 1);

75869 
	`sqlite3VdbeAddOp2
(
v
, 37, 1, -1);

75870 
	`sqlite3VdbeAddOp2
(
v
, 138, 1, 
addr
); ;

75871 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

75877 if( !
zRight
 )

75880 
	`returnSingleInt
(
v
, "cache_size", 
pDb
->
pSchema
->
cache_size
);

75882 int 
size
 = 
	`sqlite3Atoi
(
zRight
);

75883 
pDb
->
pSchema
->
cache_size
 = 
size
;

75884 
	`sqlite3BtreeSetCacheSize
(
pDb
->
pBt
, pDb->
pSchema
->
cache_size
);

75891 if( !
zRight
 )

75894 
	`returnSingleInt
(
v
, "cache_spill",

75895 (
db
->
flags
 & 0x00000020)==0 ? 0 :

75896 
	`sqlite3BtreeSetSpillSize
(
pDb
->
pBt
,0));

75898 int 
size
 = 1;

75899 if( 
	`sqlite3GetInt32
(
zRight
, &
size
) )

75902 
	`sqlite3BtreeSetSpillSize
(
pDb
->
pBt
, 
size
);

75904 if( 
	`sqlite3GetBoolean
(
zRight
, 
size
!=0) )

75907 
db
->
flags
 |= 0x00000020;

75909 
db
->
flags
 &= ~0x00000020;

75911 
	`setAllPagerFlags
(
db
);

75917 
sqlite3_int64
 
sz
;

75920 if( 
zRight
 )

75923 int 
ii
;

75924 
	`sqlite3DecOrHexToI64
(
zRight
, &
sz
);

75925 if( 
sz
<0 ) sz = 
sqlite3Config
.
szMmap
;

75926 if( 
pId2
->
n
==0 ) 
db
->
szMmap
 = 
sz
;

75927 for(
ii
=
db
->
nDb
-1; ii>=0; ii--)

75930 if( 
db
->
aDb
[
ii
].
pBt
 && (ii==
iDb
 || 
pId2
->
n
==0) )

75933 
	`sqlite3BtreeSetMmapLimit
(
db
->
aDb
[
ii
].
pBt
, 
sz
);

75937 
sz
 = -1;

75938 
rc
 = 
	`sqlite3_file_control
(
db
, 
zDb
, 18, &
sz
);

75943 if( 
rc
==0 )

75946 
	`returnSingleInt
(
v
, "mmap_size", 
sz
);

75947 }else if( 
rc
!=12 )

75950 
pParse
->
nErr
++;

75951 
pParse
->
rc
 = rc;

75957 if( !
zRight
 )

75960 
	`returnSingleInt
(
v
, "temp_store", 
db
->
temp_store
);

75962 
	`changeTempStorage
(
pParse
, 
zRight
);

75968 if( !
zRight
 )

75971 
	`returnSingleText
(
v
, "temp_store_directory", 
sqlite3_temp_directory
);

75974 if( 
zRight
[0] )

75977 int 
res
;

75978 
rc
 = 
	`sqlite3OsAccess
(
db
->
pVfs
, 
zRight
, 1, &
res
);

75979 if( 
rc
!=0 || 
res
==0 )

75982 
	`sqlite3ErrorMsg
(
pParse
, "not a writable directory");

75983 goto 
pragma_out
;

75987 || (1==1 && 
db
->
temp_store
<=1)

75988 || (1==2 && 
db
->
temp_store
==1)

75992 
	`invalidateTempStorage
(
pParse
);

75994 
	`sqlite3_free
(
sqlite3_temp_directory
);

75995 if( 
zRight
[0] )

75998 
sqlite3_temp_directory
 = 
	`sqlite3_mprintf
("%s", 
zRight
);

76000 
sqlite3_temp_directory
 = 0;

76008 if( !
zRight
 )

76011 
	`returnSingleInt
(
v
, "synchronous", 
pDb
->
safety_level
-1);

76013 if( !
db
->
autoCommit
 )

76016 
	`sqlite3ErrorMsg
(
pParse
,

76019 int 
iLevel
 = (
	`getSafetyLevel
(
zRight
,0,1)+1) & 0x07;

76020 if( 
iLevel
==0 ) iLevel = 1;

76021 
pDb
->
safety_level
 = 
iLevel
;

76022 
pDb
->
bSyncSet
 = 1;

76023 
	`setAllPagerFlags
(
db
);

76032 if( 
zRight
==0 )

76035 
	`returnSingleInt
(
v
, 
pPragma
->
zName
, (
db
->
flags
 & pPragma->
iArg
)!=0 );

76037 int 
mask
 = 
pPragma
->
iArg
;

76038 if( 
db
->
autoCommit
==0 )

76043 
mask
 &= ~(0x00080000);

76052 if( 
	`sqlite3GetBoolean
(
zRight
, 0) )

76055 
db
->
flags
 |= 
mask
;

76057 
db
->
flags
 &= ~
mask
;

76058 if( 
mask
==0x01000000 ) 
db
->
nDeferredImmCons
 = 0;

76065 
	`sqlite3VdbeAddOp2
(
v
, 147, 0, 0);

76066 
	`setAllPagerFlags
(
db
);

76071 case 31: if( 
zRight
 )

76074 
Table
 *
pTab
;

76075 
pTab
 = 
	`sqlite3FindTable
(
db
, 
zRight
, 
zDb
);

76076 if( 
pTab
 )

76079 static const char *
azCol
[] = {

76082 int 
i
, 
k
;

76083 int 
nHidden
 = 0;

76084 
Column
 *
pCol
;

76085 
Index
 *
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

76086 
pParse
->
nMem
 = 6;

76087 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

76088 
	`setAllColumnNames
(
v
, 6, 
azCol
); ((void) (0));

76089 
	`sqlite3ViewGetColumnNames
(
pParse
, 
pTab
);

76090 for(
i
=0, 
pCol
=
pTab
->
aCol
; i<pTab->
nCol
; i++, pCol++)

76093 if( (((
pCol
)->
colFlags
 & 0x0002)!=0) )

76096 
nHidden
++;

76099 if( (
pCol
->
colFlags
 & 0x0001)==0 )

76102 
k
 = 0;

76103 }else if( 
pPk
==0 )

76106 
k
 = 1;

76108 for(
k
=1; k<=
pTab
->
nCol
 && 
pPk
->
aiColumn
[k-1]!=
i
; k++)

76113 
	`sqlite3VdbeMultiLoad
(
v
, 1, "issisi",

76114 
i
-
nHidden
,

76115 
pCol
->
zName
,

76116 
	`sqlite3ColumnType
(
pCol
,""),

76117 
pCol
->
notNull
 ? 1 : 0,

76118 
pCol
->
pDflt
 ? pCol->pDflt->
u
.
zToken
 : 0,

76119 
k
);

76120 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 6);

76127 static const char *
azCol
[] = { "table", "index", "width", "height" };

76128 
Index
 *
pIdx
;

76129 
HashElem
 *
i
;

76130 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

76131 
pParse
->
nMem
 = 4;

76132 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

76133 
	`setAllColumnNames
(
v
, 4, 
azCol
); ((void) (0));

76134 for(
i
=((&
pDb
->
pSchema
->
tblHash
)->
first
); i; i=((i)->
next
))

76137 
Table
 *
pTab
 = ((
i
)->
data
);

76138 
	`sqlite3VdbeMultiLoad
(
v
, 1, "ssii",

76139 
pTab
->
zName
,

76141 
pTab
->
szTabRow
,

76142 
pTab
->
nRowLogEst
);

76143 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 4);

76144 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

76147 
	`sqlite3VdbeMultiLoad
(
v
, 2, "sii",

76148 
pIdx
->
zName
,

76149 
pIdx
->
szIdxRow
,

76150 
pIdx
->
aiRowLogEst
[0]);

76151 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 4);

76157 case 16: if( 
zRight
 )

76160 
Index
 *
pIdx
;

76161 
Table
 *
pTab
;

76162 
pIdx
 = 
	`sqlite3FindIndex
(
db
, 
zRight
, 
zDb
);

76163 if( 
pIdx
 )

76166 static const char *
azCol
[] = {

76169 int 
i
;

76170 int 
mx
;

76171 if( 
pPragma
->
iArg
 )

76175 
mx
 = 
pIdx
->
nColumn
;

76176 
pParse
->
nMem
 = 6;

76179 
mx
 = 
pIdx
->
nKeyCol
;

76180 
pParse
->
nMem
 = 3;

76182 
pTab
 = 
pIdx
->
pTable
;

76183 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

76185 
	`setAllColumnNames
(
v
, 
pParse
->
nMem
, 
azCol
);

76186 for(
i
=0; i<
mx
; i++)

76189 
i16
 
cnum
 = 
pIdx
->
aiColumn
[
i
];

76190 
	`sqlite3VdbeMultiLoad
(
v
, 1, "iis", 
i
, 
cnum
,

76191 
cnum
<0 ? 0 : 
pTab
->
aCol
[cnum].
zName
);

76192 if( 
pPragma
->
iArg
 )

76195 
	`sqlite3VdbeMultiLoad
(
v
, 4, "isi",

76196 
pIdx
->
aSortOrder
[
i
],

76197 
pIdx
->
azColl
[
i
],

76198 
i
<
pIdx
->
nKeyCol
);

76200 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 
pParse
->
nMem
);

76206 case 17: if( 
zRight
 )

76209 
Index
 *
pIdx
;

76210 
Table
 *
pTab
;

76211 int 
i
;

76212 
pTab
 = 
	`sqlite3FindTable
(
db
, 
zRight
, 
zDb
);

76213 if( 
pTab
 )

76216 static const char *
azCol
[] = {

76219 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

76220 
pParse
->
nMem
 = 5;

76221 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

76222 
	`setAllColumnNames
(
v
, 5, 
azCol
); ((void) (0));

76223 for(
pIdx
=
pTab
->
pIndex
, 
i
=0; pIdx; pIdx=pIdx->
pNext
, i++)

76226 const char *
azOrigin
[] = { "c", "u", "pk" };

76227 
	`sqlite3VdbeMultiLoad
(
v
, 1, "isisi",

76228 
i
,

76229 
pIdx
->
zName
,

76230 ((
pIdx
)->
onError
!=0),

76231 
azOrigin
[
pIdx
->
idxType
],

76232 
pIdx
->
pPartIdxWhere
!=0);

76233 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 5);

76240 static const char *
azCol
[] = { "seq", "name", "file" };

76241 int 
i
;

76242 
pParse
->
nMem
 = 3;

76243 
	`setAllColumnNames
(
v
, 3, 
azCol
); ((void) (0));

76244 for(
i
=0; i<
db
->
nDb
; i++)

76247 if( 
db
->
aDb
[
i
].
pBt
==0 ) continue;

76249 
	`sqlite3VdbeMultiLoad
(
v
, 1, "iss",

76250 
i
,

76251 
db
->
aDb
[
i
].
zName
,

76252 
	`sqlite3BtreeGetFilename
(
db
->
aDb
[
i
].
pBt
));

76253 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 3);

76259 static const char *
azCol
[] = { "seq", "name" };

76260 int 
i
 = 0;

76261 
HashElem
 *
p
;

76262 
pParse
->
nMem
 = 2;

76263 
	`setAllColumnNames
(
v
, 2, 
azCol
); ((void) (0));

76264 for(
p
=((&
db
->
aCollSeq
)->
first
); p; p=((p)->
next
))

76267 
CollSeq
 *
pColl
 = (CollSeq *)((
p
)->
data
);

76268 
	`sqlite3VdbeMultiLoad
(
v
, 1, "is", 
i
++, 
pColl
->
zName
);

76269 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 2);

76276 case 14: if( 
zRight
 )

76279 
FKey
 *
pFK
;

76280 
Table
 *
pTab
;

76281 
pTab
 = 
	`sqlite3FindTable
(
db
, 
zRight
, 
zDb
);

76282 if( 
pTab
 )

76285 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

76286 
pFK
 = 
pTab
->
pFKey
;

76287 if( 
pFK
 )

76290 static const char *
azCol
[] = {

76294 int 
i
 = 0;

76295 
pParse
->
nMem
 = 8;

76296 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

76297 
	`setAllColumnNames
(
v
, 8, 
azCol
); ((void) (0));

76298 while(
pFK
)

76301 int 
j
;

76302 for(
j
=0; j<
pFK
->
nCol
; j++)

76305 
	`sqlite3VdbeMultiLoad
(
v
, 1, "iissssss",

76306 
i
,

76307 
j
,

76308 
pFK
->
zTo
,

76309 
pTab
->
aCol
[
pFK
->aCol[
j
].
iFrom
].
zName
,

76310 
pFK
->
aCol
[
j
].
zCol
,

76311 
	`actionName
(
pFK
->
aAction
[1]),

76312 
	`actionName
(
pFK
->
aAction
[0]),

76314 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 8);

76316 ++
i
;

76317 
pFK
 = pFK->
pNextFrom
;

76328 
FKey
 *
pFK
;

76329 
Table
 *
pTab
;

76330 
Table
 *
pParent
;

76331 
Index
 *
pIdx
;

76332 int 
i
;

76333 int 
j
;

76334 
HashElem
 *
k
;

76335 int 
x
;

76336 int 
regResult
;

76337 int 
regKey
;

76338 int 
regRow
;

76339 int 
addrTop
;

76340 int 
addrOk
;

76341 int *
aiCols
;

76342 static const char *
azCol
[] = { "table", "rowid", "parent", "fkid" };

76344 
regResult
 = 
pParse
->
nMem
+1;

76345 
pParse
->
nMem
 += 4;

76346 
regKey
 = ++
pParse
->
nMem
;

76347 
regRow
 = ++
pParse
->
nMem
;

76348 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

76349 
	`setAllColumnNames
(
v
, 4, 
azCol
); ((void) (0));

76350 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

76351 
k
 = ((&
db
->
aDb
[
iDb
].
pSchema
->
tblHash
)->
first
);

76352 while( 
k
 )

76355 if( 
zRight
 )

76358 
pTab
 = 
	`sqlite3LocateTable
(
pParse
, 0, 
zRight
, 
zDb
);

76359 
k
 = 0;

76361 
pTab
 = (
Table
*)((
k
)->
data
);

76362 
k
 = ((k)->
next
);

76364 if( 
pTab
==0 || pTab->
pFKey
==0 ) continue;

76365 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 0, pTab->
zName
);

76366 if( 
pTab
->
nCol
+
regRow
>
pParse
->
nMem
 ) pParse->nMem = pTab->nCol + regRow;

76367 
	`sqlite3OpenTable
(
pParse
, 0, 
iDb
, 
pTab
, 54);

76368 
	`sqlite3VdbeLoadString
(
v
, 
regResult
, 
pTab
->
zName
);

76369 for(
i
=1, 
pFK
=
pTab
->
pFKey
; pFK; i++, pFK=pFK->
pNextFrom
)

76372 
pParent
 = 
	`sqlite3FindTable
(
db
, 
pFK
->
zTo
, 
zDb
);

76373 if( 
pParent
==0 ) continue;

76374 
pIdx
 = 0;

76375 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pParent
->
tnum
, 0, pParent->
zName
);

76376 
x
 = 
	`sqlite3FkLocateIndex
(
pParse
, 
pParent
, 
pFK
, &
pIdx
, 0);

76377 if( 
x
==0 )

76380 if( 
pIdx
==0 )

76383 
	`sqlite3OpenTable
(
pParse
, 
i
, 
iDb
, 
pParent
, 54);

76385 
	`sqlite3VdbeAddOp3
(
v
, 54, 
i
, 
pIdx
->
tnum
, 
iDb
);

76386 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pIdx
);

76389 
k
 = 0;

76394 if( 
pFK
 ) break;

76395 if( 
pParse
->
nTab
<
i
 ) pParse->nTab = i;

76396 
addrTop
 = 
	`sqlite3VdbeAddOp1
(
v
, 108, 0); ;

76397 for(
i
=1, 
pFK
=
pTab
->
pFKey
; pFK; i++, pFK=pFK->
pNextFrom
)

76400 
pParent
 = 
	`sqlite3FindTable
(
db
, 
pFK
->
zTo
, 
zDb
);

76401 
pIdx
 = 0;

76402 
aiCols
 = 0;

76403 if( 
pParent
 )

76406 
x
 = 
	`sqlite3FkLocateIndex
(
pParse
, 
pParent
, 
pFK
, &
pIdx
, &
aiCols
);

76409 
addrOk
 = 
	`sqlite3VdbeMakeLabel
(
v
);

76410 if( 
pParent
 && 
pIdx
==0 )

76413 int 
iKey
 = 
pFK
->
aCol
[0].
iFrom
;

76415 if( 
iKey
!=
pTab
->
iPKey
 )

76418 
	`sqlite3VdbeAddOp3
(
v
, 47, 0, 
iKey
, 
regRow
);

76419 
	`sqlite3ColumnDefault
(
v
, 
pTab
, 
iKey
, 
regRow
);

76420 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regRow
, 
addrOk
); ;

76421 
	`sqlite3VdbeAddOp2
(
v
, 38, 
regRow
,

76422 
	`sqlite3VdbeCurrentAddr
(
v
)+3); ;

76424 
	`sqlite3VdbeAddOp2
(
v
, 103, 0, 
regRow
);

76426 
	`sqlite3VdbeAddOp3
(
v
, 70, 
i
, 0, 
regRow
); ;

76427 
	`sqlite3VdbeGoto
(
v
, 
addrOk
);

76428 
	`sqlite3VdbeJumpHere
(
v
, 
	`sqlite3VdbeCurrentAddr
(v)-2);

76430 for(
j
=0; j<
pFK
->
nCol
; j++)

76433 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 0,

76434 
aiCols
 ? aiCols[
j
] : 
pFK
->
aCol
[j].
iFrom
, 
regRow
+j);

76435 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regRow
+
j
, 
addrOk
); ;

76437 if( 
pParent
 )

76440 
	`sqlite3VdbeAddOp4
(
v
, 49, 
regRow
, 
pFK
->
nCol
, 
regKey
,

76441 
	`sqlite3IndexAffinityStr
(
db
,
pIdx
), 
pFK
->
nCol
);

76442 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
i
, 
addrOk
, 
regKey
, 0);

76446 
	`sqlite3VdbeAddOp2
(
v
, 103, 0, 
regResult
+1);

76447 
	`sqlite3VdbeMultiLoad
(
v
, 
regResult
+2, "si", 
pFK
->
zTo
, 
i
-1);

76448 
	`sqlite3VdbeAddOp2
(
v
, 33, 
regResult
, 4);

76449 
	`sqlite3VdbeResolveLabel
(
v
, 
addrOk
);

76450 
	`sqlite3DbFree
(
db
, 
aiCols
);

76452 
	`sqlite3VdbeAddOp2
(
v
, 7, 0, 
addrTop
+1); ;

76453 
	`sqlite3VdbeJumpHere
(
v
, 
addrTop
);

76459 if( 
zRight
 )

76462 
	`sqlite3RegisterLikeFunctions
(
db
, 
	`sqlite3GetBoolean
(
zRight
, 0));

76468 int 
i
, 
j
, 
addr
, 
mxErr
;

76470 int 
isQuick
 = ((
sqlite3UpperToLower
[(unsigned char)(
zLeft
[0])])=='q');

76474 if( 
pId2
->
z
==0 ) 
iDb
 = -1;

76477 
pParse
->
nMem
 = 6;

76478 
	`setOneColumnName
(
v
, "integrity_check");

76481 
mxErr
 = 100;

76482 if( 
zRight
 )

76485 
	`sqlite3GetInt32
(
zRight
, &
mxErr
);

76486 if( 
mxErr
<=0 )

76489 
mxErr
 = 100;

76492 
	`sqlite3VdbeAddOp2
(
v
, 22, 
mxErr
, 1);

76495 for(
i
=0; i<
db
->
nDb
; i++)

76498 
HashElem
 *
x
;

76499 
Hash
 *
pTbls
;

76500 int *
aRoot
;

76501 int 
cnt
 = 0;

76502 int 
mxIdx
 = 0;

76503 int 
nIdx
;

76505 if( 0 && 
i
==1 ) continue;

76506 if( 
iDb
>=0 && 
i
!=iDb ) continue;

76508 
	`sqlite3CodeVerifySchema
(
pParse
, 
i
);

76509 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 138, 1);

76511 
	`sqlite3VdbeAddOp2
(
v
, 21, 0, 0);

76512 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

76520 
pTbls
 = &
db
->
aDb
[
i
].
pSchema
->
tblHash
;

76521 for(
cnt
=0, 
x
=((
pTbls
)->
first
); x; x=((x)->
next
))

76524 
Table
 *
pTab
 = ((
x
)->
data
);

76525 
Index
 *
pIdx
;

76526 if( (((
pTab
)->
tabFlags
 & 0x20)==0) ) 
cnt
++;

76527 for(
nIdx
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, nIdx++)

76529 
cnt
++; }

76530 if( 
nIdx
>
mxIdx
 ) mxIdx = nIdx;

76532 
aRoot
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(int)*(
cnt
+1));

76533 if( 
aRoot
==0 ) break;

76534 for(
cnt
=0, 
x
=((
pTbls
)->
first
); x; x=((x)->
next
))

76537 
Table
 *
pTab
 = ((
x
)->
data
);

76538 
Index
 *
pIdx
;

76539 if( (((
pTab
)->
tabFlags
 & 0x20)==0) ) 
aRoot
[
cnt
++] = pTab->
tnum
;

76540 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

76543 
aRoot
[
cnt
++] = 
pIdx
->
tnum
;

76546 
aRoot
[
cnt
] = 0;

76549 
pParse
->
nMem
 = ((pParse->nMem)>(8+
mxIdx
)?(pParse->nMem):(8+mxIdx));

76552 
	`sqlite3VdbeAddOp4
(
v
, 128, 2, 
cnt
, 1, (char*)
aRoot
,(-15));

76553 
	`sqlite3VdbeChangeP5
(
v
, (
u8
)
i
);

76554 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 76, 2); ;

76555 
	`sqlite3VdbeAddOp4
(
v
, 97, 0, 3, 0,

76556 
	`sqlite3MPrintf
(
db
, "*** in database %s ***\n", db->
aDb
[
i
].
zName
),

76558 
	`sqlite3VdbeAddOp3
(
v
, 29, 2, 4, 1);

76559 
	`sqlite3VdbeAddOp3
(
v
, 94, 4, 3, 2);

76560 
	`sqlite3VdbeAddOp2
(
v
, 33, 2, 1);

76561 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

76565 for(
x
=((
pTbls
)->
first
); x && !
isQuick
; x=((x)->
next
))

76568 
Table
 *
pTab
 = ((
x
)->
data
);

76569 
Index
 *
pIdx
, *
pPk
;

76570 
Index
 *
pPrior
 = 0;

76571 int 
loopTop
;

76572 int 
iDataCur
, 
iIdxCur
;

76573 int 
r1
 = -1;

76575 if( 
pTab
->
pIndex
==0 ) continue;

76576 
pPk
 = (((
pTab
)->
tabFlags
 & 0x20)==0) ? 0 : 
	`sqlite3PrimaryKeyIndex
(pTab);

76577 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 138, 1);

76579 
	`sqlite3VdbeAddOp2
(
v
, 21, 0, 0);

76580 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

76581 
	`sqlite3ExprCacheClear
(
pParse
);

76582 
	`sqlite3OpenTableAndIndices
(
pParse
, 
pTab
, 54, 0,

76583 1, 0, &
iDataCur
, &
iIdxCur
);

76584 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 7);

76585 for(
j
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, j++)

76588 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 8+
j
);

76592 
	`sqlite3VdbeAddOp2
(
v
, 108, 
iDataCur
, 0); ;

76593 
loopTop
 = 
	`sqlite3VdbeAddOp2
(
v
, 37, 7, 1);

76595 for(
j
=0; j<
pTab
->
nCol
; j++)

76598 char *
zErr
;

76599 int 
jmp2
, 
jmp3
;

76600 if( 
j
==
pTab
->
iPKey
 ) continue;

76601 if( 
pTab
->
aCol
[
j
].
notNull
==0 ) continue;

76602 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 
iDataCur
, 
j
, 3);

76603 
	`sqlite3VdbeChangeP5
(
v
, 0x80);

76604 
jmp2
 = 
	`sqlite3VdbeAddOp1
(
v
, 77, 3); ;

76605 
	`sqlite3VdbeAddOp2
(
v
, 37, 1, -1);

76606 
zErr
 = 
	`sqlite3MPrintf
(
db
, "NULL value in %s.%s", 
pTab
->
zName
,

76607 
pTab
->
aCol
[
j
].
zName
);

76608 
	`sqlite3VdbeAddOp4
(
v
, 97, 0, 3, 0, 
zErr
, (-1));

76609 
	`sqlite3VdbeAddOp2
(
v
, 33, 3, 1);

76610 
jmp3
 = 
	`sqlite3VdbeAddOp1
(
v
, 138, 1); ;

76611 
	`sqlite3VdbeAddOp0
(
v
, 21);

76612 
	`sqlite3VdbeJumpHere
(
v
, 
jmp2
);

76613 
	`sqlite3VdbeJumpHere
(
v
, 
jmp3
);

76616 for(
j
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, j++)

76619 int 
jmp2
, 
jmp3
, 
jmp4
, 
jmp5
;

76620 int 
ckUniq
 = 
	`sqlite3VdbeMakeLabel
(
v
);

76621 if( 
pPk
==
pIdx
 ) continue;

76622 
r1
 = 
	`sqlite3GenerateIndexKey
(
pParse
, 
pIdx
, 
iDataCur
, 0, 0, &
jmp3
,

76623 
pPrior
, 
r1
);

76624 
pPrior
 = 
pIdx
;

76625 
	`sqlite3VdbeAddOp2
(
v
, 37, 8+
j
, 1);

76627 
jmp2
 = 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
iIdxCur
+
j
, 
ckUniq
, 
r1
,

76628 
pIdx
->
nColumn
); ;

76629 
	`sqlite3VdbeAddOp2
(
v
, 37, 1, -1);

76630 
	`sqlite3VdbeLoadString
(
v
, 3, "row ");

76631 
	`sqlite3VdbeAddOp3
(
v
, 94, 7, 3, 3);

76632 
	`sqlite3VdbeLoadString
(
v
, 4, " missing from index ");

76633 
	`sqlite3VdbeAddOp3
(
v
, 94, 4, 3, 3);

76634 
jmp5
 = 
	`sqlite3VdbeLoadString
(
v
, 4, 
pIdx
->
zName
);

76635 
	`sqlite3VdbeAddOp3
(
v
, 94, 4, 3, 3);

76636 
	`sqlite3VdbeAddOp2
(
v
, 33, 3, 1);

76637 
jmp4
 = 
	`sqlite3VdbeAddOp1
(
v
, 138, 1); ;

76638 
	`sqlite3VdbeAddOp0
(
v
, 21);

76639 
	`sqlite3VdbeJumpHere
(
v
, 
jmp2
);

76643 if( ((
pIdx
)->
onError
!=0) )

76646 int 
uniqOk
 = 
	`sqlite3VdbeMakeLabel
(
v
);

76647 int 
jmp6
;

76648 int 
kk
;

76649 for(
kk
=0; kk<
pIdx
->
nKeyCol
; kk++)

76652 int 
iCol
 = 
pIdx
->
aiColumn
[
kk
];

76654 if( 
iCol
>=0 && 
pTab
->
aCol
[iCol].
notNull
 ) continue;

76655 
	`sqlite3VdbeAddOp2
(
v
, 76, 
r1
+
kk
, 
uniqOk
);

76658 
jmp6
 = 
	`sqlite3VdbeAddOp1
(
v
, 7, 
iIdxCur
+
j
); ;

76659 
	`sqlite3VdbeGoto
(
v
, 
uniqOk
);

76660 
	`sqlite3VdbeJumpHere
(
v
, 
jmp6
);

76661 
	`sqlite3VdbeAddOp4Int
(
v
, 115, 
iIdxCur
+
j
, 
uniqOk
, 
r1
,

76662 
pIdx
->
nKeyCol
); ;

76663 
	`sqlite3VdbeAddOp2
(
v
, 37, 1, -1);

76664 
	`sqlite3VdbeLoadString
(
v
, 3, "non-unique entry in index ");

76665 
	`sqlite3VdbeGoto
(
v
, 
jmp5
);

76666 
	`sqlite3VdbeResolveLabel
(
v
, 
uniqOk
);

76668 
	`sqlite3VdbeJumpHere
(
v
, 
jmp4
);

76669 
	`sqlite3ResolvePartIdxLabel
(
pParse
, 
jmp3
);

76671 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iDataCur
, 
loopTop
); ;

76672 
	`sqlite3VdbeJumpHere
(
v
, 
loopTop
-1);

76674 
	`sqlite3VdbeLoadString
(
v
, 2, "wrong # of entries in index ");

76675 for(
j
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, j++)

76678 if( 
pPk
==
pIdx
 ) continue;

76679 
addr
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

76680 
	`sqlite3VdbeAddOp2
(
v
, 138, 1, 
addr
+2); ;

76681 
	`sqlite3VdbeAddOp2
(
v
, 21, 0, 0);

76682 
	`sqlite3VdbeAddOp2
(
v
, 50, 
iIdxCur
+
j
, 3);

76683 
	`sqlite3VdbeAddOp3
(
v
, 79, 8+
j
, 
addr
+8, 3); ;

76684 
	`sqlite3VdbeChangeP5
(
v
, 0x90);

76685 
	`sqlite3VdbeAddOp2
(
v
, 37, 1, -1);

76686 
	`sqlite3VdbeLoadString
(
v
, 3, 
pIdx
->
zName
);

76687 
	`sqlite3VdbeAddOp3
(
v
, 94, 3, 2, 7);

76688 
	`sqlite3VdbeAddOp2
(
v
, 33, 7, 1);

76694 static const int 
iLn
 = 0;

76695 static const 
VdbeOpList
 
endCode
[] = {

76701 
VdbeOp
 *
aOp
;

76703 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
endCode
)/sizeof(endCode[0]))), endCode, 
iLn
);

76704 if( 
aOp
 )

76707 
aOp
[0].
p2
 = -
mxErr
;

76708 
aOp
[2].
p4type
 = (-2);

76709 
aOp
[2].
p4
.
z
 = "ok";

76716 static const struct 
	sEncName
 {

76717 char *
zName
;

76718 
u8
 
enc
;

76719 } 
encnames
[] = {

76730 const struct 
EncName
 *
pEnc
;

76731 if( !
zRight
 )

76734 if( 
	`sqlite3ReadSchema
(
pParse
) ) goto 
pragma_out
;

76738 
	`returnSingleText
(
v
, "encoding", 
encnames
[((
pParse
->
db
)->
enc
)].
zName
);

76746 !((((
db
)->
aDb
[0].
pSchema
->
schemaFlags
&(0x0001))==(0x0001))) ||

76747 (((
db
)->
aDb
[0].
pSchema
->
schemaFlags
&(0x0004))==(0x0004))

76751 for(
pEnc
=&
encnames
[0]; pEnc->
zName
; pEnc++)

76754 if( 0==
	`sqlite3StrICmp
(
zRight
, 
pEnc
->
zName
) )

76757 ((
db
)->
aDb
[0].
pSchema
->
enc
) = ((db)->enc) =

76758 
pEnc
->
enc
 ? pEnc->enc : 2;

76762 if( !
pEnc
->
zName
 )

76765 
	`sqlite3ErrorMsg
(
pParse
, "unsupported encoding: %s", 
zRight
);

76773 int 
iCookie
 = 
pPragma
->
iArg
;

76774 
	`sqlite3VdbeUsesBtree
(
v
, 
iDb
);

76775 if( 
zRight
 && (
pPragma
->
mPragFlag
 & 0x02)==0 )

76779 static const 
VdbeOpList
 
setCookie
[] = {

76783 
VdbeOp
 *
aOp
;

76785 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
setCookie
)/sizeof(setCookie[0]))), setCookie, 0);

76787 
aOp
[0].
p1
 = 
iDb
;

76788 
aOp
[1].
p1
 = 
iDb
;

76789 
aOp
[1].
p2
 = 
iCookie
;

76790 
aOp
[1].
p3
 = 
	`sqlite3Atoi
(
zRight
);

76793 static const 
VdbeOpList
 
readCookie
[] = {

76798 
VdbeOp
 *
aOp
;

76800 
aOp
 = 
	`sqlite3VdbeAddOpList
(
v
, ((int)(sizeof(
readCookie
)/sizeof(readCookie[0]))),readCookie,0);

76802 
aOp
[0].
p1
 = 
iDb
;

76803 
aOp
[1].
p1
 = 
iDb
;

76804 
aOp
[1].
p3
 = 
iCookie
;

76805 
	`sqlite3VdbeSetNumCols
(
v
, 1);

76806 
	`sqlite3VdbeSetColName
(
v
, 0, 0, 
zLeft
, ((
sqlite3_destructor_type
)-1));

76807 
	`sqlite3VdbeReusable
(
v
);

76813 int 
i
 = 0;

76814 const char *
zOpt
;

76815 
pParse
->
nMem
 = 1;

76816 
	`setOneColumnName
(
v
, "compile_option");

76817 while( (
zOpt
 = 
	`sqlite3_compileoption_get
(
i
++))!=0 )

76820 
	`sqlite3VdbeLoadString
(
v
, 1, 
zOpt
);

76821 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 1);

76823 
	`sqlite3VdbeReusable
(
v
);

76828 static const char *
azCol
[] = { "busy", "log", "checkpointed" };

76829 int 
iBt
 = (
pId2
->
z
?
iDb
:10);

76830 int 
eMode
 = 0;

76831 if( 
zRight
 )

76834 if( 
	`sqlite3StrICmp
(
zRight
, "full")==0 )

76837 
eMode
 = 1;

76838 }else if( 
	`sqlite3StrICmp
(
zRight
, "restart")==0 )

76841 
eMode
 = 2;

76842 }else if( 
	`sqlite3StrICmp
(
zRight
, "truncate")==0 )

76845 
eMode
 = 3;

76848 
	`setAllColumnNames
(
v
, 3, 
azCol
); ((void) (0));

76849 
pParse
->
nMem
 = 3;

76850 
	`sqlite3VdbeAddOp3
(
v
, 8, 
iBt
, 
eMode
, 1);

76851 
	`sqlite3VdbeAddOp2
(
v
, 33, 1, 3);

76856 if( 
zRight
 )

76859 
	`sqlite3_wal_autocheckpoint
(
db
, 
	`sqlite3Atoi
(
zRight
));

76861 
	`returnSingleInt
(
v
, "wal_autocheckpoint",

76862 
db
->
xWalCallback
==
sqlite3WalDefaultHook
 ?

76863 ((int)(long int)(
db
->
pWalArg
)) : 0);

76868 
	`sqlite3_db_release_memory
(
db
);

76874 if( 
zRight
 )

76877 
	`sqlite3_busy_timeout
(
db
, 
	`sqlite3Atoi
(
zRight
));

76879 
	`returnSingleInt
(
v
, "timeout", 
db
->
busyTimeout
);

76884 
sqlite3_int64
 
N
;

76885 if( 
zRight
 && 
	`sqlite3DecOrHexToI64
(zRight, &
N
)==0 )

76888 
	`sqlite3_soft_heap_limit64
(
N
);

76890 
	`returnSingleInt
(
v
, "soft_heap_limit", 
	`sqlite3_soft_heap_limit64
(-1));

76895 
sqlite3_int64
 
N
;

76896 if( 
zRight


76897 && 
	`sqlite3DecOrHexToI64
(
zRight
, &
N
)==0

76898 && 
N
>=0

76902 
	`sqlite3_limit
(
db
, 11, (int)(
N
&0x7fffffff));

76904 
	`returnSingleInt
(
v
, "threads",

76905 
	`sqlite3_limit
(
db
, 11, -1));

76911 
pragma_out
:

76912 
	`sqlite3DbFree
(
db
, 
zLeft
);

76913 
	`sqlite3DbFree
(
db
, 
zRight
);

76914 
	}
}

76916 static void 
	$corruptSchema
(

76917 
InitData
 *
pData
,

76918 const char *
zObj
,

76919 const char *
zExtra


76923 
sqlite3
 *
db
 = 
pData
->db;

76924 if( !
db
->
mallocFailed
 && (db->
flags
 & 0x00010000)==0 )

76927 char *
z
;

76928 if( 
zObj
==0 ) zObj = "?";

76929 
z
 = 
	`sqlite3MPrintf
(
db
, "malformed database schema (%s)", 
zObj
);

76930 if( 
zExtra
 ) 
z
 = 
	`sqlite3MPrintf
(
db
, "%z - %s", z, zExtra);

76931 
	`sqlite3DbFree
(
db
, *
pData
->
pzErrMsg
);

76932 *
pData
->
pzErrMsg
 = 
z
;

76934 
pData
->
rc
 = 
db
->
mallocFailed
 ? 7 : 
	`sqlite3CorruptError
(109666);

76935 
	}
}

76937 static int 
	$sqlite3InitCallback
(void *
pInit
, int 
argc
, char **
argv
, char **
NotUsed
)

76940 
InitData
 *
pData
 = (InitData*)
pInit
;

76941 
sqlite3
 *
db
 = 
pData
->db;

76942 int 
iDb
 = 
pData
->iDb;

76945 (void)(
NotUsed
),(void)(
argc
);

76947 (
db
)->
aDb
[
iDb
].
pSchema
->
schemaFlags
&=~(0x0004);

76948 if( 
db
->
mallocFailed
 )

76951 
	`corruptSchema
(
pData
, 
argv
[0], 0);

76956 if( 
argv
==0 ) return 0;

76957 if( 
argv
[1]==0 )

76960 
	`corruptSchema
(
pData
, 
argv
[0], 0);

76961 }else if( 
	`sqlite3_strnicmp
(
argv
[2],"create ",7)==0 )

76969 int 
rc
;

76970 
sqlite3_stmt
 *
pStmt
;

76974 
db
->
init
.
iDb
 = iDb;

76975 
db
->
init
.
newTnum
 = 
	`sqlite3Atoi
(
argv
[1]);

76976 
db
->
init
.
orphanTrigger
 = 0;

76977 
	`sqlite3_prepare
(
db
, 
argv
[2], -1, &
pStmt
, 0);

76978 
rc
 = 
db
->
errCode
;

76980 
db
->
init
.
iDb
 = 0;

76981 if( 0!=
rc
 )

76984 if( 
db
->
init
.
orphanTrigger
 )

76989 
pData
->
rc
 = rc;

76990 if( 
rc
==7 )

76993 
	`sqlite3OomFault
(
db
);

76994 }else if( 
rc
!=9 && (rc&0xFF)!=6 )

76997 
	`corruptSchema
(
pData
, 
argv
[0], 
	`sqlite3_errmsg
(
db
));

77001 
	`sqlite3_finalize
(
pStmt
);

77002 }else if( 
argv
[0]==0 || (argv[2]!=0 && argv[2][0]!=0) )

77005 
	`corruptSchema
(
pData
, 
argv
[0], 0);

77013 
Index
 *
pIndex
;

77014 
pIndex
 = 
	`sqlite3FindIndex
(
db
, 
argv
[0], db->
aDb
[
iDb
].
zName
);

77015 if( 
pIndex
==0 )

77024 }else if( 
	`sqlite3GetInt32
(
argv
[1], &
pIndex
->
tnum
)==0 )

77027 
	`corruptSchema
(
pData
, 
argv
[0], "invalid rootpage");

77031 
	}
}

77033 static int 
	$sqlite3InitOne
(
sqlite3
 *
db
, int 
iDb
, char **
pzErrMsg
)

77036 int 
rc
;

77037 int 
i
;

77039 int 
size
;

77041 
Db
 *
pDb
;

77042 char const *
azArg
[4];

77043 int 
meta
[5];

77044 
InitData
 
initData
;

77045 const char *
zMasterName
;

77046 int 
openedTransaction
 = 0;

77058 
azArg
[0] = 
zMasterName
 = ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master");

77059 
azArg
[1] = "1";

77060 
azArg
[2] = "CREATE TABLE x(type text,name text,tbl_name text,"

77062 
azArg
[3] = 0;

77063 
initData
.
db
 = db;

77064 
initData
.
iDb
 = iDb;

77065 
initData
.
rc
 = 0;

77066 
initData
.
pzErrMsg
 = pzErrMsg;

77067 
	`sqlite3InitCallback
(&
initData
, 3, (char **)
azArg
, 0);

77068 if( 
initData
.
rc
 )

77071 
rc
 = 
initData
.rc;

77072 goto 
error_out
;

77077 
pDb
 = &
db
->
aDb
[
iDb
];

77078 if( 
pDb
->
pBt
==0 )

77081 if( !0 && (
iDb
==1) )

77084 (
db
)->
aDb
[1].
pSchema
->
schemaFlags
|=(0x0001);

77092 
	`sqlite3BtreeEnter
(
pDb
->
pBt
);

77093 if( !
	`sqlite3BtreeIsInReadTrans
(
pDb
->
pBt
) )

77096 
rc
 = 
	`sqlite3BtreeBeginTrans
(
pDb
->
pBt
, 0);

77097 if( 
rc
!=0 )

77100 
	`sqlite3SetString
(
pzErrMsg
, 
db
, 
	`sqlite3ErrStr
(
rc
));

77101 goto 
initone_error_out
;

77103 
openedTransaction
 = 1;

77106 for(
i
=0; i<((int)(sizeof(
meta
)/sizeof(meta[0]))); i++)

77109 
	`sqlite3BtreeGetMeta
(
pDb
->
pBt
, 
i
+1, (
u32
 *)&
meta
[i]);

77111 
pDb
->
pSchema
->
schema_cookie
 = 
meta
[1 -1];

77118 if( 
meta
[5 -1] )

77121 if( 
iDb
==0 )

77125 
u8
 
encoding
;

77127 
encoding
 = (
u8
)
meta
[5 -1] & 3;

77128 if( 
encoding
==0 ) encoding = 1;

77129 ((
db
)->
enc
) = 
encoding
;

77135 if( 
meta
[5 -1]!=((
db
)->
enc
) )

77138 
	`sqlite3SetString
(
pzErrMsg
, 
db
, "attached databases must use the same"

77140 
rc
 = 1;

77141 goto 
initone_error_out
;

77145 (
db
)->
aDb
[
iDb
].
pSchema
->
schemaFlags
|=(0x0004);

77147 
pDb
->
pSchema
->
enc
 = ((
db
)->enc);

77149 if( 
pDb
->
pSchema
->
cache_size
==0 )

77153 
size
 = 
	`sqlite3AbsInt32
(
meta
[3 -1]);

77154 if( 
size
==0 )

77156 
size
 = -2000; }

77157 
pDb
->
pSchema
->
cache_size
 = 
size
;

77161 
	`sqlite3BtreeSetCacheSize
(
pDb
->
pBt
, pDb->
pSchema
->
cache_size
);

77170 
pDb
->
pSchema
->
file_format
 = (
u8
)
meta
[2 -1];

77171 if( 
pDb
->
pSchema
->
file_format
==0 )

77174 
pDb
->
pSchema
->
file_format
 = 1;

77176 if( 
pDb
->
pSchema
->
file_format
>4 )

77179 
	`sqlite3SetString
(
pzErrMsg
, 
db
, "unsupported file format");

77180 
rc
 = 1;

77181 goto 
initone_error_out
;

77189 if( 
iDb
==0 && 
meta
[2 -1]>=4 )

77192 
db
->
flags
 &= ~0x00008000;

77199 char *
zSql
;

77200 
zSql
 = 
	`sqlite3MPrintf
(
db
,

77202 
db
->
aDb
[
iDb
].
zName
, 
zMasterName
);

77205 
sqlite3_xauth
 
xAuth
;

77206 
xAuth
 = 
db
->xAuth;

77207 
db
->
xAuth
 = 0;

77209 
rc
 = 
	`sqlite3_exec
(
db
, 
zSql
, 
sqlite3InitCallback
, &
initData
, 0);

77211 
db
->
xAuth
 = xAuth;

77214 if( 
rc
==0 ) rc = 
initData
.rc;

77215 
	`sqlite3DbFree
(
db
, 
zSql
);

77217 if( 
rc
==0 )

77220 
	`sqlite3AnalysisLoad
(
db
, 
iDb
);

77224 if( 
db
->
mallocFailed
 )

77227 
rc
 = 7;

77228 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

77230 if( 
rc
==0 || (
db
->
flags
&0x00010000))

77234 (
db
)->
aDb
[
iDb
].
pSchema
->
schemaFlags
|=(0x0001);

77235 
rc
 = 0;

77242 
initone_error_out
:

77243 if( 
openedTransaction
 )

77246 
	`sqlite3BtreeCommit
(
pDb
->
pBt
);

77248 
	`sqlite3BtreeLeave
(
pDb
->
pBt
);

77250 
error_out
:

77251 if( 
rc
==7 || rc==(10 | (12<<8)) )

77254 
	`sqlite3OomFault
(
db
);

77256 return 
rc
;

77257 
	}
}

77259 static int 
	$sqlite3Init
(
sqlite3
 *
db
, char **
pzErrMsg
)

77262 int 
i
, 
rc
;

77263 int 
commit_internal
 = !(
db
->
flags
&0x00000002);

77268 
rc
 = 0;

77269 
db
->
init
.
busy
 = 1;

77270 ((
db
)->
enc
) = ((db)->
aDb
[0].
pSchema
->enc);

77271 for(
i
=0; 
rc
==0 && i<
db
->
nDb
; i++)

77274 if( (((
db
)->
aDb
[
i
].
pSchema
->
schemaFlags
&(0x0001))==(0x0001)) || i==1 ) continue;

77275 
rc
 = 
	`sqlite3InitOne
(
db
, 
i
, 
pzErrMsg
);

77276 if( 
rc
 )

77279 
	`sqlite3ResetOneSchema
(
db
, 
i
);

77289 if( 
rc
==0 && !(((
db
)->
aDb
[1].
pSchema
->
schemaFlags
&(0x0001))==(0x0001)) )

77292 
rc
 = 
	`sqlite3InitOne
(
db
, 1, 
pzErrMsg
);

77293 if( 
rc
 )

77296 
	`sqlite3ResetOneSchema
(
db
, 1);

77301 
db
->
init
.
busy
 = 0;

77302 if( 
rc
==0 && 
commit_internal
 )

77305 
	`sqlite3CommitInternalChanges
(
db
);

77308 return 
rc
;

77309 
	}
}

77315 static int 
	$sqlite3ReadSchema
(
Parse
 *
pParse
)

77318 int 
rc
 = 0;

77319 
sqlite3
 *
db
 = 
pParse
->db;

77321 if( !
db
->
init
.
busy
 )

77324 
rc
 = 
	`sqlite3Init
(
db
, &
pParse
->
zErrMsg
);

77326 if( 
rc
!=0 )

77329 
pParse
->
rc
 = rc;

77330 
pParse
->
nErr
++;

77332 return 
rc
;

77333 
	}
}

77341 static void 
	$schemaIsValid
(
Parse
 *
pParse
)

77344 
sqlite3
 *
db
 = 
pParse
->db;

77345 int 
iDb
;

77346 int 
rc
;

77347 int 
cookie
;

77351 for(
iDb
=0; iDb<
db
->
nDb
; iDb++)

77354 int 
openedTransaction
 = 0;

77355 
Btree
 *
pBt
 = 
db
->
aDb
[
iDb
].pBt;

77356 if( 
pBt
==0 ) continue;

77361 if( !
	`sqlite3BtreeIsInReadTrans
(
pBt
) )

77364 
rc
 = 
	`sqlite3BtreeBeginTrans
(
pBt
, 0);

77365 if( 
rc
==7 || rc==(10 | (12<<8)) )

77368 
	`sqlite3OomFault
(
db
);

77370 if( 
rc
!=0 ) return;

77371 
openedTransaction
 = 1;

77377 
	`sqlite3BtreeGetMeta
(
pBt
, 1, (
u32
 *)&
cookie
);

77379 if( 
cookie
!=
db
->
aDb
[
iDb
].
pSchema
->
schema_cookie
 )

77382 
	`sqlite3ResetOneSchema
(
db
, 
iDb
);

77383 
pParse
->
rc
 = 17;

77387 if( 
openedTransaction
 )

77390 
	`sqlite3BtreeCommit
(
pBt
);

77393 
	}
}

77395 static int 
	$sqlite3SchemaToIndex
(
sqlite3
 *
db
, 
Schema
 *
pSchema
)

77398 int 
i
 = -1000000;

77401 if( 
pSchema
 )

77404 for(
i
=0; (i<
db
->
nDb
); i++)

77407 if( 
db
->
aDb
[
i
].
pSchema
==pSchema )

77415 return 
i
;

77416 
	}
}

77421 static void 
	$sqlite3ParserReset
(
Parse
 *
pParse
)

77424 if( 
pParse
 )

77427 
sqlite3
 *
db
 = 
pParse
->db;

77428 
	`sqlite3DbFree
(
db
, 
pParse
->
aLabel
);

77429 
	`sqlite3ExprListDelete
(
db
, 
pParse
->
pConstExpr
);

77430 if( 
db
 )

77434 
db
->
lookaside
.
bDisable
 -= 
pParse
->
disableLookaside
;

77436 
pParse
->
disableLookaside
 = 0;

77438 
	}
}

77443 static int 
	$sqlite3Prepare
(

77444 
sqlite3
 *
db
,

77445 const char *
zSql
,

77446 int 
nBytes
,

77447 int 
saveSqlFlag
,

77448 
Vdbe
 *
pReprepare
,

77449 
sqlite3_stmt
 **
ppStmt
,

77450 const char **
pzTail


77454 
Parse
 *
pParse
;

77455 char *
zErrMsg
 = 0;

77456 int 
rc
 = 0;

77457 int 
i
;

77460 
pParse
 = 
	`sqlite3DbMallocZero
(
db
,sizeof(*pParse));

77461 if( 
pParse
==0 )

77464 
rc
 = 7;

77465 goto 
end_prepare
;

77467 
pParse
->
pReprepare
 = pReprepare;

77472 for(
i
=0; i<
db
->
nDb
; i++) {

77473 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

77474 if( 
pBt
 )

77478 
rc
 = 
	`sqlite3BtreeSchemaLocked
(
pBt
);

77479 if( 
rc
 )

77482 const char *
zDb
 = 
db
->
aDb
[
i
].
zName
;

77483 
	`sqlite3ErrorWithMsg
(
db
, 
rc
, "database schema is locked: %s", 
zDb
);

77485 goto 
end_prepare
;

77490 
	`sqlite3VtabUnlockList
(
db
);

77492 
pParse
->
db
 = db;

77493 
pParse
->
nQueryLoop
 = 0;

77494 if( 
nBytes
>=0 && (nBytes==0 || 
zSql
[nBytes-1]!=0) )

77497 char *
zSqlCopy
;

77498 int 
mxLen
 = 
db
->
aLimit
[1];

77501 if( 
nBytes
>
mxLen
 )

77504 
	`sqlite3ErrorWithMsg
(
db
, 18, "statement too long");

77505 
rc
 = 
	`sqlite3ApiExit
(
db
, 18);

77506 goto 
end_prepare
;

77508 
zSqlCopy
 = 
	`sqlite3DbStrNDup
(
db
, 
zSql
, 
nBytes
);

77509 if( 
zSqlCopy
 )

77512 
	`sqlite3RunParser
(
pParse
, 
zSqlCopy
, &
zErrMsg
);

77513 
pParse
->
zTail
 = &
zSql
[pParse->zTail-
zSqlCopy
];

77514 
	`sqlite3DbFree
(
db
, 
zSqlCopy
);

77516 
pParse
->
zTail
 = &
zSql
[
nBytes
];

77519 
	`sqlite3RunParser
(
pParse
, 
zSql
, &
zErrMsg
);

77523 if( 
pParse
->
rc
==101 ) pParse->rc = 0;

77524 if( 
pParse
->
checkSchema
 )

77527 
	`schemaIsValid
(
pParse
);

77529 if( 
db
->
mallocFailed
 )

77532 
pParse
->
rc
 = 7;

77534 if( 
pzTail
 )

77537 *
pzTail
 = 
pParse
->
zTail
;

77539 
rc
 = 
pParse
->rc;

77542 if( 
rc
==0 && 
pParse
->
pVdbe
 && pParse->
explain
 )

77545 static const char * const 
azColName
[] = {

77549 int 
iFirst
, 
mx
;

77550 if( 
pParse
->
explain
==2 )

77553 
	`sqlite3VdbeSetNumCols
(
pParse
->
pVdbe
, 4);

77554 
iFirst
 = 8;

77555 
mx
 = 12;

77557 
	`sqlite3VdbeSetNumCols
(
pParse
->
pVdbe
, 8);

77558 
iFirst
 = 0;

77559 
mx
 = 8;

77561 for(
i
=
iFirst
; i<
mx
; i++)

77564 
	`sqlite3VdbeSetColName
(
pParse
->
pVdbe
, 
i
-
iFirst
, 0,

77565 
azColName
[
i
], ((
sqlite3_destructor_type
)0));

77570 if( 
db
->
init
.
busy
==0 )

77573 
Vdbe
 *
pVdbe
 = 
pParse
->pVdbe;

77574 
	`sqlite3VdbeSetSql
(
pVdbe
, 
zSql
, (int)(
pParse
->
zTail
-zSql), 
saveSqlFlag
);

77576 if( 
pParse
->
pVdbe
 && (
rc
!=0 || 
db
->
mallocFailed
) )

77579 
	`sqlite3VdbeFinalize
(
pParse
->
pVdbe
);

77582 *
ppStmt
 = (
sqlite3_stmt
*)
pParse
->
pVdbe
;

77585 if( 
zErrMsg
 )

77588 
	`sqlite3ErrorWithMsg
(
db
, 
rc
, "%s", 
zErrMsg
);

77589 
	`sqlite3DbFree
(
db
, 
zErrMsg
);

77591 
	`sqlite3Error
(
db
, 
rc
);

77595 while( 
pParse
->
pTriggerPrg
 )

77598 
TriggerPrg
 *
pT
 = 
pParse
->
pTriggerPrg
;

77599 
pParse
->
pTriggerPrg
 = 
pT
->
pNext
;

77600 
	`sqlite3DbFree
(
db
, 
pT
);

77603 
end_prepare
:

77605 
	`sqlite3ParserReset
(
pParse
);

77606 
	`sqlite3DbFree
(
db
,
pParse
);

77607 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

77609 return 
rc
;

77610 
	}
}

77611 static int 
	$sqlite3LockAndPrepare
(

77612 
sqlite3
 *
db
,

77613 const char *
zSql
,

77614 int 
nBytes
,

77615 int 
saveSqlFlag
,

77616 
Vdbe
 *
pOld
,

77617 
sqlite3_stmt
 **
ppStmt
,

77618 const char **
pzTail


77622 int 
rc
;

77627 *
ppStmt
 = 0;

77628 if( !
	`sqlite3SafetyCheckOk
(
db
)||
zSql
==0 )

77631 return 
	`sqlite3MisuseError
(110313);

77633 
	`sqlite3_mutex_enter
(
db
->
mutex
);

77634 
	`sqlite3BtreeEnterAll
(
db
);

77635 
rc
 = 
	`sqlite3Prepare
(
db
, 
zSql
, 
nBytes
, 
saveSqlFlag
, 
pOld
, 
ppStmt
, 
pzTail
);

77636 if( 
rc
==17 )

77639 
	`sqlite3_finalize
(*
ppStmt
);

77640 
rc
 = 
	`sqlite3Prepare
(
db
, 
zSql
, 
nBytes
, 
saveSqlFlag
, 
pOld
, 
ppStmt
, 
pzTail
);

77642 
	`sqlite3BtreeLeaveAll
(
db
);

77643 
	`sqlite3_mutex_leave
(
db
->
mutex
);

77645 return 
rc
;

77646 
	}
}

77648 static int 
	$sqlite3Reprepare
(
Vdbe
 *
p
)

77651 int 
rc
;

77652 
sqlite3_stmt
 *
pNew
;

77653 const char *
zSql
;

77654 
sqlite3
 *
db
;

77657 
zSql
 = 
	`sqlite3_sql
((
sqlite3_stmt
 *)
p
);

77659 
db
 = 
	`sqlite3VdbeDb
(
p
);

77661 
rc
 = 
	`sqlite3LockAndPrepare
(
db
, 
zSql
, -1, 0, 
p
, &
pNew
, 0);

77662 if( 
rc
 )

77665 if( 
rc
==7 )

77668 
	`sqlite3OomFault
(
db
);

77671 return 
rc
;

77675 
	`sqlite3VdbeSwap
((
Vdbe
*)
pNew
, 
p
);

77676 
	`sqlite3TransferBindings
(
pNew
, (
sqlite3_stmt
*)
p
);

77677 
	`sqlite3VdbeResetStepResult
((
Vdbe
*)
pNew
);

77678 
	`sqlite3VdbeFinalize
((
Vdbe
*)
pNew
);

77680 
	}
}

77682 int 
	$sqlite3_prepare
(

77683 
sqlite3
 *
db
,

77684 const char *
zSql
,

77685 int 
nBytes
,

77686 
sqlite3_stmt
 **
ppStmt
,

77687 const char **
pzTail


77691 int 
rc
;

77692 
rc
 = 
	`sqlite3LockAndPrepare
(
db
,
zSql
,
nBytes
,0,0,
ppStmt
,
pzTail
);

77694 return 
rc
;

77695 
	}
}

77696 int 
	$sqlite3_prepare_v2
(

77697 
sqlite3
 *
db
,

77698 const char *
zSql
,

77699 int 
nBytes
,

77700 
sqlite3_stmt
 **
ppStmt
,

77701 const char **
pzTail


77705 int 
rc
;

77706 
rc
 = 
	`sqlite3LockAndPrepare
(
db
,
zSql
,
nBytes
,1,0,
ppStmt
,
pzTail
);

77708 return 
rc
;

77709 
	}
}

77716 static int 
	$sqlite3Prepare16
(

77717 
sqlite3
 *
db
,

77718 const void *
zSql
,

77719 int 
nBytes
,

77720 int 
saveSqlFlag
,

77721 
sqlite3_stmt
 **
ppStmt
,

77722 const void **
pzTail


77730 char *
zSql8
;

77731 const char *
zTail8
 = 0;

77732 int 
rc
 = 0;

77737 *
ppStmt
 = 0;

77738 if( !
	`sqlite3SafetyCheckOk
(
db
)||
zSql
==0 )

77741 return 
	`sqlite3MisuseError
(110424);

77743 if( 
nBytes
>=0 )

77746 int 
sz
;

77747 const char *
z
 = (const char*)
zSql
;

77748 for(
sz
=0; sz<
nBytes
 && (
z
[sz]!=0 || z[sz+1]!=0); sz += 2)

77751 
nBytes
 = 
sz
;

77753 
	`sqlite3_mutex_enter
(
db
->
mutex
);

77754 
zSql8
 = 
	`sqlite3Utf16to8
(
db
, 
zSql
, 
nBytes
, 2);

77755 if( 
zSql8
 )

77758 
rc
 = 
	`sqlite3LockAndPrepare
(
db
, 
zSql8
, -1, 
saveSqlFlag
, 0, 
ppStmt
, &
zTail8
);

77761 if( 
zTail8
 && 
pzTail
 )

77769 int 
chars_parsed
 = 
	`sqlite3Utf8CharLen
(
zSql8
, (int)(
zTail8
-zSql8));

77770 *
pzTail
 = (
u8
 *)
zSql
 + 
	`sqlite3Utf16ByteLen
(zSql, 
chars_parsed
);

77772 
	`sqlite3DbFree
(
db
, 
zSql8
);

77773 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

77774 
	`sqlite3_mutex_leave
(
db
->
mutex
);

77775 return 
rc
;

77776 
	}
}

77778 int 
	$sqlite3_prepare16
(

77779 
sqlite3
 *
db
,

77780 const void *
zSql
,

77781 int 
nBytes
,

77782 
sqlite3_stmt
 **
ppStmt
,

77783 const void **
pzTail


77787 int 
rc
;

77788 
rc
 = 
	`sqlite3Prepare16
(
db
,
zSql
,
nBytes
,0,
ppStmt
,
pzTail
);

77790 return 
rc
;

77791 
	}
}

77792 int 
	$sqlite3_prepare16_v2
(

77793 
sqlite3
 *
db
,

77794 const void *
zSql
,

77795 int 
nBytes
,

77796 
sqlite3_stmt
 **
ppStmt
,

77797 const void **
pzTail


77801 int 
rc
;

77802 
rc
 = 
	`sqlite3Prepare16
(
db
,
zSql
,
nBytes
,1,
ppStmt
,
pzTail
);

77804 return 
rc
;

77805 
	}
}

77807 typedef struct 
DistinctCtx
 
	tDistinctCtx
;

77808 struct 
	sDistinctCtx
 {

77809 
u8
 
	misTnct
;

77810 
u8
 
	meTnctType
;

77811 int 
	mtabTnct
;

77812 int 
	maddrTnct
;

77819 typedef struct 
SortCtx
 
	tSortCtx
;

77820 struct 
	sSortCtx
 {

77821 
ExprList
 *
	mpOrderBy
;

77822 int 
	mnOBSat
;

77823 int 
	miECursor
;

77824 int 
	mregReturn
;

77825 int 
	mlabelBkOut
;

77826 int 
	maddrSortIndex
;

77827 int 
	mlabelDone
;

77828 
u8
 
	msortFlags
;

77836 static void 
	$clearSelect
(
sqlite3
 *
db
, 
Select
 *
p
, int 
bFree
)

77839 while( 
p
 )

77842 
Select
 *
pPrior
 = 
p
->pPrior;

77843 
	`sqlite3ExprListDelete
(
db
, 
p
->
pEList
);

77844 
	`sqlite3SrcListDelete
(
db
, 
p
->
pSrc
);

77845 
	`sqlite3ExprDelete
(
db
, 
p
->
pWhere
);

77846 
	`sqlite3ExprListDelete
(
db
, 
p
->
pGroupBy
);

77847 
	`sqlite3ExprDelete
(
db
, 
p
->
pHaving
);

77848 
	`sqlite3ExprListDelete
(
db
, 
p
->
pOrderBy
);

77849 
	`sqlite3ExprDelete
(
db
, 
p
->
pLimit
);

77850 
	`sqlite3ExprDelete
(
db
, 
p
->
pOffset
);

77851 
	`sqlite3WithDelete
(
db
, 
p
->
pWith
);

77852 if( 
bFree
 ) 
	`sqlite3DbFree
(
db
, 
p
);

77853 
p
 = 
pPrior
;

77854 
bFree
 = 1;

77856 
	}
}

77861 static void 
	$sqlite3SelectDestInit
(
SelectDest
 *
pDest
, int 
eDest
, int 
iParm
)

77864 
pDest
->
eDest
 = (
u8
)eDest;

77865 
pDest
->
iSDParm
 = 
iParm
;

77866 
pDest
->
affSdst
 = 0;

77867 
pDest
->
iSdst
 = 0;

77868 
pDest
->
nSdst
 = 0;

77869 
	}
}

77876 static 
Select
 *
	$sqlite3SelectNew
(

77877 
Parse
 *
pParse
,

77878 
ExprList
 *
pEList
,

77879 
SrcList
 *
pSrc
,

77880 
Expr
 *
pWhere
,

77881 
ExprList
 *
pGroupBy
,

77882 
Expr
 *
pHaving
,

77883 
ExprList
 *
pOrderBy
,

77884 
u32
 
selFlags
,

77885 
Expr
 *
pLimit
,

77886 
Expr
 *
pOffset


77890 
Select
 *
pNew
;

77891 
Select
 
standin
;

77892 
sqlite3
 *
db
 = 
pParse
->db;

77893 
pNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(*pNew) );

77894 if( 
pNew
==0 )

77898 
pNew
 = &
standin
;

77900 if( 
pEList
==0 )

77903 
pEList
 = 
	`sqlite3ExprListAppend
(
pParse
, 0, 
	`sqlite3Expr
(
db
,158,0));

77905 
pNew
->
pEList
 = pEList;

77906 
pNew
->
op
 = 119;

77907 
pNew
->
selFlags
 = selFlags;

77908 
pNew
->
iLimit
 = 0;

77909 
pNew
->
iOffset
 = 0;

77913 
pNew
->
addrOpenEphm
[0] = -1;

77914 
pNew
->
addrOpenEphm
[1] = -1;

77915 
pNew
->
nSelectRow
 = 0;

77916 if( 
pSrc
==0 ) pSrc = 
	`sqlite3DbMallocZero
(
db
, sizeof(*pSrc));

77917 
pNew
->
pSrc
 = pSrc;

77918 
pNew
->
pWhere
 = pWhere;

77919 
pNew
->
pGroupBy
 = pGroupBy;

77920 
pNew
->
pHaving
 = pHaving;

77921 
pNew
->
pOrderBy
 = pOrderBy;

77922 
pNew
->
pPrior
 = 0;

77923 
pNew
->
pNext
 = 0;

77924 
pNew
->
pLimit
 = pLimit;

77925 
pNew
->
pOffset
 = pOffset;

77926 
pNew
->
pWith
 = 0;

77928 if( 
db
->
mallocFailed
 ) {

77929 
	`clearSelect
(
db
, 
pNew
, pNew!=&
standin
);

77930 
pNew
 = 0;

77935 return 
pNew
;

77936 
	}
}

77938 static void 
	$sqlite3SelectDelete
(
sqlite3
 *
db
, 
Select
 *
p
)

77941 
	`clearSelect
(
db
, 
p
, 1);

77942 
	}
}

77947 static 
Select
 *
	$findRightmost
(
Select
 *
p
)

77950 while( 
p
->
pNext
 ) p = p->pNext;

77951 return 
p
;

77952 
	}
}

77954 static int 
	$sqlite3JoinType
(
Parse
 *
pParse
, 
Token
 *
pA
, Token *
pB
, Token *
pC
)

77957 int 
jointype
 = 0;

77958 
Token
 *
apAll
[3];

77959 
Token
 *
p
;

77961 static const char 
zKeyText
[] = "naturaleftouterightfullinnercross";

77963 
u8
 
i
;

77964 
u8
 
nChar
;

77965 
u8
 
code
;

77966 } 
aKeyword
[] = {

77975 int 
i
, 
j
;

77976 
apAll
[0] = 
pA
;

77977 
apAll
[1] = 
pB
;

77978 
apAll
[2] = 
pC
;

77979 for(
i
=0; i<3 && 
apAll
[i]; i++)

77982 
p
 = 
apAll
[
i
];

77983 for(
j
=0; j<((int)(sizeof(
aKeyword
)/sizeof(aKeyword[0]))); j++)

77986 if( 
p
->
n
==
aKeyword
[
j
].
nChar


77987 && 
	`sqlite3_strnicmp
((char*)
p
->
z
, &
zKeyText
[
aKeyword
[
j
].
i
], p->
n
)==0 )

77990 
jointype
 |= 
aKeyword
[
j
].
code
;

77995 if( 
j
>=((int)(sizeof(
aKeyword
)/sizeof(aKeyword[0]))) )

77998 
jointype
 |= 0x0040;

78003 (
jointype
 & (0x0001|0x0020))==(0x0001|0x0020) ||

78004 (
jointype
 & 0x0040)!=0

78008 const char *
zSp
 = " ";

78010 if( 
pC
==0 )

78012 
zSp
++; }

78013 
	`sqlite3ErrorMsg
(
pParse
, "unknown or unsupported join type: "

78014 "%T %T%s%T", 
pA
, 
pB
, 
zSp
, 
pC
);

78015 
jointype
 = 0x0001;

78016 }else if( (
jointype
 & 0x0020)!=0

78017 && (
jointype
 & (0x0008|0x0010))!=0x0008 )

78020 
	`sqlite3ErrorMsg
(
pParse
,

78022 
jointype
 = 0x0001;

78024 return 
jointype
;

78025 
	}
}

78031 static int 
	$columnIndex
(
Table
 *
pTab
, const char *
zCol
)

78034 int 
i
;

78035 for(
i
=0; i<
pTab
->
nCol
; i++)

78038 if( 
	`sqlite3StrICmp
(
pTab
->
aCol
[
i
].
zName
, 
zCol
)==0 ) return i;

78041 
	}
}

78043 static int 
	$tableAndColumnIndex
(

78044 
SrcList
 *
pSrc
,

78045 int 
N
,

78046 const char *
zCol
,

78047 int *
piTab
,

78048 int *
piCol


78052 int 
i
;

78053 int 
iCol
;

78056 for(
i
=0; i<
N
; i++)

78059 
iCol
 = 
	`columnIndex
(
pSrc
->
a
[
i
].
pTab
, 
zCol
);

78060 if( 
iCol
>=0 )

78063 if( 
piTab
 )

78066 *
piTab
 = 
i
;

78067 *
piCol
 = 
iCol
;

78073 
	}
}

78075 static void 
	$addWhereTerm
(

78076 
Parse
 *
pParse
,

78077 
SrcList
 *
pSrc
,

78078 int 
iLeft
,

78079 int 
iColLeft
,

78080 int 
iRight
,

78081 int 
iColRight
,

78082 int 
isOuterJoin
,

78083 
Expr
 **
ppWhere


78087 
sqlite3
 *
db
 = 
pParse
->db;

78088 
Expr
 *
pE1
;

78089 
Expr
 *
pE2
;

78090 
Expr
 *
pEq
;

78097 
pE1
 = 
	`sqlite3CreateColumnExpr
(
db
, 
pSrc
, 
iLeft
, 
iColLeft
);

78098 
pE2
 = 
	`sqlite3CreateColumnExpr
(
db
, 
pSrc
, 
iRight
, 
iColRight
);

78100 
pEq
 = 
	`sqlite3PExpr
(
pParse
, 79, 
pE1
, 
pE2
, 0);

78101 if( 
pEq
 && 
isOuterJoin
 )

78104 (
pEq
)->
flags
|=(0x000001);

78107 
pEq
->
iRightJoinTable
 = (
i16
)
pE2
->
iTable
;

78109 *
ppWhere
 = 
	`sqlite3ExprAnd
(
db
, *ppWhere, 
pEq
);

78110 
	}
}

78112 static void 
	$setJoinExpr
(
Expr
 *
p
, int 
iTable
)

78115 while( 
p
 )

78118 (
p
)->
flags
|=(0x000001);

78121 
p
->
iRightJoinTable
 = (
i16
)
iTable
;

78122 if( 
p
->
op
==151 && p->
x
.
pList
 )

78125 int 
i
;

78126 for(
i
=0; i<
p
->
x
.
pList
->
nExpr
; i++)

78129 
	`setJoinExpr
(
p
->
x
.
pList
->
a
[
i
].
pExpr
, 
iTable
);

78132 
	`setJoinExpr
(
p
->
pLeft
, 
iTable
);

78133 
p
 = p->
pRight
;

78135 
	}
}

78137 static int 
	$sqliteProcessJoin
(
Parse
 *
pParse
, 
Select
 *
p
)

78140 
SrcList
 *
pSrc
;

78141 int 
i
, 
j
;

78142 struct 
SrcList_item
 *
pLeft
;

78143 struct 
SrcList_item
 *
pRight
;

78145 
pSrc
 = 
p
->pSrc;

78146 
pLeft
 = &
pSrc
->
a
[0];

78147 
pRight
 = &
pLeft
[1];

78148 for(
i
=0; i<
pSrc
->
nSrc
-1; i++, 
pRight
++, 
pLeft
++)

78151 
Table
 *
pLeftTab
 = 
pLeft
->
pTab
;

78152 
Table
 *
pRightTab
 = 
pRight
->
pTab
;

78153 int 
isOuter
;

78155 if( (
pLeftTab
==0 || 
pRightTab
==0) ) continue;

78156 
isOuter
 = (
pRight
->
fg
.
jointype
 & 0x0020)!=0;

78161 if( 
pRight
->
fg
.
jointype
 & 0x0004 )

78164 if( 
pRight
->
pOn
 || pRight->
pUsing
 )

78167 
	`sqlite3ErrorMsg
(
pParse
, "a NATURAL join may not have "

78171 for(
j
=0; j<
pRightTab
->
nCol
; j++)

78174 char *
zName
;

78175 int 
iLeft
;

78176 int 
iLeftCol
;

78178 
zName
 = 
pRightTab
->
aCol
[
j
].zName;

78179 if( 
	`tableAndColumnIndex
(
pSrc
, 
i
+1, 
zName
, &
iLeft
, &
iLeftCol
) )

78182 
	`addWhereTerm
(
pParse
, 
pSrc
, 
iLeft
, 
iLeftCol
, 
i
+1, 
j
,

78183 
isOuter
, &
p
->
pWhere
);

78190 if( 
pRight
->
pOn
 && pRight->
pUsing
 )

78193 
	`sqlite3ErrorMsg
(
pParse
, "cannot have both ON and USING "

78201 if( 
pRight
->
pOn
 )

78204 if( 
isOuter
 ) 
	`setJoinExpr
(
pRight
->
pOn
, pRight->
iCursor
);

78205 
p
->
pWhere
 = 
	`sqlite3ExprAnd
(
pParse
->
db
, p->pWhere, 
pRight
->
pOn
);

78206 
pRight
->
pOn
 = 0;

78209 if( 
pRight
->
pUsing
 )

78212 
IdList
 *
pList
 = 
pRight
->
pUsing
;

78213 for(
j
=0; j<
pList
->
nId
; j++)

78216 char *
zName
;

78217 int 
iLeft
;

78218 int 
iLeftCol
;

78219 int 
iRightCol
;

78221 
zName
 = 
pList
->
a
[
j
].zName;

78222 
iRightCol
 = 
	`columnIndex
(
pRightTab
, 
zName
);

78223 if( 
iRightCol
<0

78224 || !
	`tableAndColumnIndex
(
pSrc
, 
i
+1, 
zName
, &
iLeft
, &
iLeftCol
)

78228 
	`sqlite3ErrorMsg
(
pParse
, "cannot join using column %s - column "

78229 "not present in both tables", 
zName
);

78232 
	`addWhereTerm
(
pParse
, 
pSrc
, 
iLeft
, 
iLeftCol
, 
i
+1, 
iRightCol
,

78233 
isOuter
, &
p
->
pWhere
);

78238 
	}
}

78241 static 
KeyInfo
 *
keyInfoFromExprList
(

78242 
Parse
 *
pParse
,

78243 
ExprList
 *
pList
,

78244 int 
iStart
,

78245 int 
nExtra


78252 static void 
	$pushOntoSorter
(

78253 
Parse
 *
pParse
,

78254 
SortCtx
 *
pSort
,

78255 
Select
 *
pSelect
,

78256 int 
regData
,

78257 int 
regOrigData
,

78258 int 
nData
,

78259 int 
nPrefixReg


78263 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

78264 int 
bSeq
 = ((
pSort
->
sortFlags
 & 0x01)==0);

78265 int 
nExpr
 = 
pSort
->
pOrderBy
->nExpr;

78266 int 
nBase
 = 
nExpr
 + 
bSeq
 + 
nData
;

78267 int 
regBase
;

78268 int 
regRecord
 = ++
pParse
->
nMem
;

78269 int 
nOBSat
 = 
pSort
->nOBSat;

78270 int 
op
;

78271 int 
iLimit
;

78275 if( 
nPrefixReg
 )

78279 
regBase
 = 
regData
 - 
nExpr
 - 
bSeq
;

78281 
regBase
 = 
pParse
->
nMem
 + 1;

78282 
pParse
->
nMem
 += 
nBase
;

78285 
iLimit
 = 
pSelect
->
iOffset
 ? pSelect->iOffset+1 : pSelect->iLimit;

78286 
pSort
->
labelDone
 = 
	`sqlite3VdbeMakeLabel
(
v
);

78287 
	`sqlite3ExprCodeExprList
(
pParse
, 
pSort
->
pOrderBy
, 
regBase
, 
regOrigData
,

78289 if( 
bSeq
 )

78292 
	`sqlite3VdbeAddOp2
(
v
, 73, 
pSort
->
iECursor
, 
regBase
+
nExpr
);

78294 if( 
nPrefixReg
==0 )

78297 
	`sqlite3ExprCodeMove
(
pParse
, 
regData
, 
regBase
+
nExpr
+
bSeq
, 
nData
);

78299 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regBase
+
nOBSat
, 
nBase
-nOBSat, 
regRecord
);

78300 if( 
nOBSat
>0 )

78303 int 
regPrevKey
;

78304 int 
addrFirst
;

78305 int 
addrJmp
;

78306 
VdbeOp
 *
pOp
;

78307 int 
nKey
;

78308 
KeyInfo
 *
pKI
;

78310 
regPrevKey
 = 
pParse
->
nMem
+1;

78311 
pParse
->
nMem
 += 
pSort
->
nOBSat
;

78312 
nKey
 = 
nExpr
 - 
pSort
->
nOBSat
 + 
bSeq
;

78313 if( 
bSeq
 )

78316 
addrFirst
 = 
	`sqlite3VdbeAddOp1
(
v
, 46, 
regBase
+
nExpr
);

78318 
addrFirst
 = 
	`sqlite3VdbeAddOp1
(
v
, 59, 
pSort
->
iECursor
);

78321 
	`sqlite3VdbeAddOp3
(
v
, 42, 
regPrevKey
, 
regBase
, 
pSort
->
nOBSat
);

78322 
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, 
pSort
->
addrSortIndex
);

78323 if( 
pParse
->
db
->
mallocFailed
 ) return;

78324 
pOp
->
p2
 = 
nKey
 + 
nData
;

78325 
pKI
 = 
pOp
->
p4
.
pKeyInfo
;

78326 
	`memset
(
pKI
->
aSortOrder
, 0, pKI->
nField
);

78327 
	`sqlite3VdbeChangeP4
(
v
, -1, (char*)
pKI
, (-6));

78329 
pOp
->
p4
.
pKeyInfo
 = 
	`keyInfoFromExprList
(
pParse
, 
pSort
->
pOrderBy
, 
nOBSat
,

78330 
pKI
->
nXField
-1);

78331 
addrJmp
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

78332 
	`sqlite3VdbeAddOp3
(
v
, 43, 
addrJmp
+1, 0, addrJmp+1); ;

78333 
pSort
->
labelBkOut
 = 
	`sqlite3VdbeMakeLabel
(
v
);

78334 
pSort
->
regReturn
 = ++
pParse
->
nMem
;

78335 
	`sqlite3VdbeAddOp2
(
v
, 14, 
pSort
->
regReturn
, pSort->
labelBkOut
);

78336 
	`sqlite3VdbeAddOp1
(
v
, 120, 
pSort
->
iECursor
);

78337 if( 
iLimit
 )

78340 
	`sqlite3VdbeAddOp2
(
v
, 46, 
iLimit
, 
pSort
->
labelDone
);

78343 
	`sqlite3VdbeJumpHere
(
v
, 
addrFirst
);

78344 
	`sqlite3ExprCodeMove
(
pParse
, 
regBase
, 
regPrevKey
, 
pSort
->
nOBSat
);

78345 
	`sqlite3VdbeJumpHere
(
v
, 
addrJmp
);

78347 if( 
pSort
->
sortFlags
 & 0x01 )

78350 
op
 = 109;

78352 
op
 = 110;

78354 
	`sqlite3VdbeAddOp2
(
v
, 
op
, 
pSort
->
iECursor
, 
regRecord
);

78355 if( 
iLimit
 )

78358 int 
addr
;

78359 
addr
 = 
	`sqlite3VdbeAddOp3
(
v
, 140, 
iLimit
, 0, 1); ;

78360 
	`sqlite3VdbeAddOp1
(
v
, 105, 
pSort
->
iECursor
);

78361 
	`sqlite3VdbeAddOp1
(
v
, 95, 
pSort
->
iECursor
);

78362 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

78364 
	}
}

78369 static void 
	$codeOffset
(

78370 
Vdbe
 *
v
,

78371 int 
iOffset
,

78372 int 
iContinue


78376 if( 
iOffset
>0 )

78379 
	`sqlite3VdbeAddOp3
(
v
, 138, 
iOffset
, 
iContinue
, 1); ;

78382 
	}
}

78384 static void 
	$codeDistinct
(

78385 
Parse
 *
pParse
,

78386 int 
iTab
,

78387 int 
addrRepeat
,

78388 int 
N
,

78389 int 
iMem


78393 
Vdbe
 *
v
;

78394 int 
r1
;

78396 
v
 = 
pParse
->
pVdbe
;

78397 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

78398 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
iTab
, 
addrRepeat
, 
iMem
, 
N
); ;

78399 
	`sqlite3VdbeAddOp3
(
v
, 49, 
iMem
, 
N
, 
r1
);

78400 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iTab
, 
r1
);

78401 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

78402 
	}
}

78404 static int 
	$checkForMultiColumnSelectError
(

78405 
Parse
 *
pParse
,

78406 
SelectDest
 *
pDest
,

78407 int 
nExpr


78411 int 
eDest
 = 
pDest
->eDest;

78412 if( 
nExpr
>1 && (
eDest
==10 || eDest==11) )

78415 
	`sqlite3ErrorMsg
(
pParse
, "only a single result allowed for "

78421 
	}
}

78423 static void 
	$selectInnerLoop
(

78424 
Parse
 *
pParse
,

78425 
Select
 *
p
,

78426 
ExprList
 *
pEList
,

78427 int 
srcTab
,

78428 
SortCtx
 *
pSort
,

78429 
DistinctCtx
 *
pDistinct
,

78430 
SelectDest
 *
pDest
,

78431 int 
iContinue
,

78432 int 
iBreak


78436 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

78437 int 
i
;

78438 int 
hasDistinct
;

78439 int 
regResult
;

78440 int 
eDest
 = 
pDest
->eDest;

78441 int 
iParm
 = 
pDest
->
iSDParm
;

78442 int 
nResultCol
;

78443 int 
nPrefixReg
 = 0;

78447 
hasDistinct
 = 
pDistinct
 ? pDistinct->
eTnctType
 : 0;

78448 if( 
pSort
 && pSort->
pOrderBy
==0 ) pSort = 0;

78449 if( 
pSort
==0 && !
hasDistinct
 )

78453 
	`codeOffset
(
v
, 
p
->
iOffset
, 
iContinue
);

78458 
nResultCol
 = 
pEList
->
nExpr
;

78460 if( 
pDest
->
iSdst
==0 )

78463 if( 
pSort
 )

78466 
nPrefixReg
 = 
pSort
->
pOrderBy
->
nExpr
;

78467 if( !(
pSort
->
sortFlags
 & 0x01) ) 
nPrefixReg
++;

78468 
pParse
->
nMem
 += 
nPrefixReg
;

78470 
pDest
->
iSdst
 = 
pParse
->
nMem
+1;

78471 
pParse
->
nMem
 += 
nResultCol
;

78472 }else if( 
pDest
->
iSdst
+
nResultCol
 > 
pParse
->
nMem
 )

78480 
pParse
->
nMem
 += 
nResultCol
;

78482 
pDest
->
nSdst
 = 
nResultCol
;

78483 
regResult
 = 
pDest
->
iSdst
;

78484 if( 
srcTab
>=0 )

78487 for(
i
=0; i<
nResultCol
; i++)

78490 
	`sqlite3VdbeAddOp3
(
v
, 47, 
srcTab
, 
i
, 
regResult
+i);

78493 }else if( 
eDest
!=3 )

78499 
u8
 
ecelFlags
;

78500 if( 
eDest
==10 || eDest==9 || eDest==13 )

78503 
ecelFlags
 = 0x01;

78505 
ecelFlags
 = 0;

78507 
	`sqlite3ExprCodeExprList
(
pParse
, 
pEList
, 
regResult
, 0, 
ecelFlags
);

78514 if( 
hasDistinct
 )

78517 switch( 
pDistinct
->
eTnctType
 )

78521 
VdbeOp
 *
pOp
;

78522 int 
iJump
;

78523 int 
regPrev
;

78526 
regPrev
 = 
pParse
->
nMem
+1;

78527 
pParse
->
nMem
 += 
nResultCol
;

78535 
	`sqlite3VdbeChangeToNoop
(
v
, 
pDistinct
->
addrTnct
);

78536 
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, 
pDistinct
->
addrTnct
);

78537 
pOp
->
opcode
 = 25;

78538 
pOp
->
p1
 = 1;

78539 
pOp
->
p2
 = 
regPrev
;

78541 
iJump
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 
nResultCol
;

78542 for(
i
=0; i<
nResultCol
; i++)

78545 
CollSeq
 *
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pEList
->
a
[
i
].
pExpr
);

78546 if( 
i
<
nResultCol
-1 )

78549 
	`sqlite3VdbeAddOp3
(
v
, 78, 
regResult
+
i
, 
iJump
, 
regPrev
+i);

78552 
	`sqlite3VdbeAddOp3
(
v
, 79, 
regResult
+
i
, 
iContinue
, 
regPrev
+i);

78555 
	`sqlite3VdbeChangeP4
(
v
, -1, (const char *)
pColl
, (-4));

78556 
	`sqlite3VdbeChangeP5
(
v
, 0x80);

78559 
	`sqlite3VdbeAddOp3
(
v
, 30, 
regResult
, 
regPrev
, 
nResultCol
-1);

78564 
	`sqlite3VdbeChangeToNoop
(
v
, 
pDistinct
->
addrTnct
);

78570 
	`codeDistinct
(
pParse
, 
pDistinct
->
tabTnct
, 
iContinue
, 
nResultCol
,

78571 
regResult
);

78575 if( 
pSort
==0 )

78578 
	`codeOffset
(
v
, 
p
->
iOffset
, 
iContinue
);

78582 switch( 
eDest
 )

78590 int 
r1
;

78591 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

78592 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regResult
, 
nResultCol
, 
r1
);

78593 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iParm
, 
r1
);

78594 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

78603 
	`sqlite3VdbeAddOp3
(
v
, 111, 
iParm
, 
regResult
, 
nResultCol
);

78614 int 
r1
 = 
	`sqlite3GetTempRange
(
pParse
, 
nPrefixReg
+1);

78619 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regResult
, 
nResultCol
, 
r1
+
nPrefixReg
);

78621 if( 
eDest
==6 )

78629 int 
addr
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 4;

78630 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
iParm
+1, 
addr
, 
r1
, 0);

78632 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iParm
+1, 
r1
);

78636 if( 
pSort
 )

78639 
	`pushOntoSorter
(
pParse
, 
pSort
, 
p
, 
r1
+
nPrefixReg
,
regResult
,1,nPrefixReg);

78641 int 
r2
 = 
	`sqlite3GetTempReg
(
pParse
);

78642 
	`sqlite3VdbeAddOp2
(
v
, 74, 
iParm
, 
r2
);

78643 
	`sqlite3VdbeAddOp3
(
v
, 75, 
iParm
, 
r1
, 
r2
);

78644 
	`sqlite3VdbeChangeP5
(
v
, 0x08);

78645 
	`sqlite3ReleaseTempReg
(
pParse
, 
r2
);

78647 
	`sqlite3ReleaseTempRange
(
pParse
, 
r1
, 
nPrefixReg
+1);

78658 
pDest
->
affSdst
 =

78659 
	`sqlite3CompareAffinity
(
pEList
->
a
[0].
pExpr
, 
pDest
->
affSdst
);

78660 if( 
pSort
 )

78667 
	`pushOntoSorter
(
pParse
, 
pSort
, 
p
, 
regResult
, regResult, 1, 
nPrefixReg
);

78669 int 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

78670 
	`sqlite3VdbeAddOp4
(
v
, 49, 
regResult
,1,
r1
, &
pDest
->
affSdst
, 1);

78671 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
regResult
, 1);

78672 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iParm
, 
r1
);

78673 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

78681 
	`sqlite3VdbeAddOp2
(
v
, 22, 1, 
iParm
);

78692 if( 
pSort
 )

78695 
	`pushOntoSorter
(
pParse
, 
pSort
, 
p
, 
regResult
, regResult, 1, 
nPrefixReg
);

78708 if( 
pSort
 )

78711 
	`pushOntoSorter
(
pParse
, 
pSort
, 
p
, 
regResult
, regResult, 
nResultCol
,

78712 
nPrefixReg
);

78713 }else if( 
eDest
==13 )

78716 
	`sqlite3VdbeAddOp1
(
v
, 18, 
pDest
->
iSDParm
);

78718 
	`sqlite3VdbeAddOp2
(
v
, 33, 
regResult
, 
nResultCol
);

78719 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
regResult
, 
nResultCol
);

78726 int 
nKey
;

78727 int 
r1
, 
r2
, 
r3
;

78728 int 
addrTest
 = 0;

78729 
ExprList
 *
pSO
;

78730 
pSO
 = 
pDest
->
pOrderBy
;

78732 
nKey
 = 
pSO
->
nExpr
;

78733 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

78734 
r2
 = 
	`sqlite3GetTempRange
(
pParse
, 
nKey
+2);

78735 
r3
 = 
r2
+
nKey
+1;

78736 if( 
eDest
==8 )

78742 
addrTest
 = 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
iParm
+1, 0,

78743 
regResult
, 
nResultCol
);

78746 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regResult
, 
nResultCol
, 
r3
);

78747 if( 
eDest
==8 )

78750 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iParm
+1, 
r3
);

78751 
	`sqlite3VdbeChangeP5
(
v
, 0x10);

78753 for(
i
=0; i<
nKey
; i++)

78756 
	`sqlite3VdbeAddOp2
(
v
, 31,

78757 
regResult
 + 
pSO
->
a
[
i
].
u
.
x
.
iOrderByCol
 - 1,

78758 
r2
+
i
);

78760 
	`sqlite3VdbeAddOp2
(
v
, 73, 
iParm
, 
r2
+
nKey
);

78761 
	`sqlite3VdbeAddOp3
(
v
, 49, 
r2
, 
nKey
+2, 
r1
);

78762 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iParm
, 
r1
);

78763 if( 
addrTest
 ) 
	`sqlite3VdbeJumpHere
(
v
, addrTest);

78764 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

78765 
	`sqlite3ReleaseTempRange
(
pParse
, 
r2
, 
nKey
+2);

78780 if( 
pSort
==0 && 
p
->
iLimit
 )

78783 
	`sqlite3VdbeAddOp2
(
v
, 141, 
p
->
iLimit
, 
iBreak
); ;

78785 
	}
}

78791 static 
KeyInfo
 *
	$sqlite3KeyInfoAlloc
(
sqlite3
 *
db
, int 
N
, int 
X
)

78794 int 
nExtra
 = (
N
+
X
)*(sizeof(
CollSeq
*)+1);

78795 
KeyInfo
 *
p
 = 
	`sqlite3Malloc
(sizeof(KeyInfo) + 
nExtra
);

78796 if( 
p
 )

78799 
p
->
aSortOrder
 = (
u8
*)&p->
aColl
[
N
+
X
];

78800 
p
->
nField
 = (
u16
)
N
;

78801 
p
->
nXField
 = (
u16
)
X
;

78802 
p
->
enc
 = ((
db
)->enc);

78803 
p
->
db
 = db;

78804 
p
->
nRef
 = 1;

78805 
	`memset
(&
p
[1], 0, 
nExtra
);

78807 
	`sqlite3OomFault
(
db
);

78809 return 
p
;

78810 
	}
}

78815 static void 
	$sqlite3KeyInfoUnref
(
KeyInfo
 *
p
)

78818 if( 
p
 )

78822 
p
->
nRef
--;

78823 if( 
p
->
nRef
==0 ) 
	`sqlite3DbFree
(0, p);

78825 
	}
}

78830 static 
KeyInfo
 *
	$sqlite3KeyInfoRef
(
KeyInfo
 *
p
)

78833 if( 
p
 )

78837 
p
->
nRef
++;

78839 return 
p
;

78840 
	}
}

78842 static 
KeyInfo
 *
	$keyInfoFromExprList
(

78843 
Parse
 *
pParse
,

78844 
ExprList
 *
pList
,

78845 int 
iStart
,

78846 int 
nExtra


78850 int 
nExpr
;

78851 
KeyInfo
 *
pInfo
;

78852 struct 
ExprList_item
 *
pItem
;

78853 
sqlite3
 *
db
 = 
pParse
->db;

78854 int 
i
;

78856 
nExpr
 = 
pList
->nExpr;

78857 
pInfo
 = 
	`sqlite3KeyInfoAlloc
(
db
, 
nExpr
-
iStart
, 
nExtra
+1);

78858 if( 
pInfo
 )

78862 for(
i
=
iStart
, 
pItem
=
pList
->
a
+iStart; i<
nExpr
; i++, pItem++)

78865 
CollSeq
 *
pColl
;

78866 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pItem
->
pExpr
);

78867 if( !
pColl
 ) pColl = 
db
->
pDfltColl
;

78868 
pInfo
->
aColl
[
i
-
iStart
] = 
pColl
;

78869 
pInfo
->
aSortOrder
[
i
-
iStart
] = 
pItem
->
sortOrder
;

78872 return 
pInfo
;

78873 
	}
}

78878 static const char *
	$selectOpName
(int 
id
)

78881 char *
z
;

78882 switch( 
id
 )

78885 case 116: 
z
 = "UNION ALL"; break;

78886 case 118: 
z
 = "INTERSECT"; break;

78887 case 117: 
z
 = "EXCEPT"; break;

78888 default: 
z
 = "UNION"; break;

78890 return 
z
;

78891 
	}
}

78893 static void 
	$explainTempTable
(
Parse
 *
pParse
, const char *
zUsage
)

78896 if( 
pParse
->
explain
==2 )

78899 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

78900 char *
zMsg
 = 
	`sqlite3MPrintf
(
pParse
->
db
, "USE TEMP B-TREE FOR %s", 
zUsage
);

78901 
	`sqlite3VdbeAddOp4
(
v
, 161, 
pParse
->
iSelectId
, 0, 0, 
zMsg
, (-1));

78903 
	}
}

78905 static void 
	$explainComposite
(

78906 
Parse
 *
pParse
,

78907 int 
op
,

78908 int 
iSub1
,

78909 int 
iSub2
,

78910 int 
bUseTmp


78915 if( 
pParse
->
explain
==2 )

78918 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

78919 char *
zMsg
 = 
	`sqlite3MPrintf
(

78920 
pParse
->
db
, "COMPOUND SUBQUERIES %d AND %d %s(%s)", 
iSub1
, 
iSub2
,

78921 
bUseTmp
?"USING TEMP B-TREE ":"", 
	`selectOpName
(
op
)

78923 
	`sqlite3VdbeAddOp4
(
v
, 161, 
pParse
->
iSelectId
, 0, 0, 
zMsg
, (-1));

78925 
	}
}

78927 static void 
	$generateSortTail
(

78928 
Parse
 *
pParse
,

78929 
Select
 *
p
,

78930 
SortCtx
 *
pSort
,

78931 int 
nColumn
,

78932 
SelectDest
 *
pDest


78936 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

78937 int 
addrBreak
 = 
pSort
->
labelDone
;

78938 int 
addrContinue
 = 
	`sqlite3VdbeMakeLabel
(
v
);

78939 int 
addr
;

78940 int 
addrOnce
 = 0;

78941 int 
iTab
;

78942 
ExprList
 *
pOrderBy
 = 
pSort
->pOrderBy;

78943 int 
eDest
 = 
pDest
->eDest;

78944 int 
iParm
 = 
pDest
->
iSDParm
;

78945 int 
regRow
;

78946 int 
regRowid
;

78947 int 
nKey
;

78948 int 
iSortTab
;

78949 int 
nSortData
;

78950 int 
i
;

78951 int 
bSeq
;

78957 if( 
pSort
->
labelBkOut
 )

78960 
	`sqlite3VdbeAddOp2
(
v
, 14, 
pSort
->
regReturn
, pSort->
labelBkOut
);

78961 
	`sqlite3VdbeGoto
(
v
, 
addrBreak
);

78962 
	`sqlite3VdbeResolveLabel
(
v
, 
pSort
->
labelBkOut
);

78964 
iTab
 = 
pSort
->
iECursor
;

78965 if( 
eDest
==9 || eDest==13 )

78968 
regRowid
 = 0;

78969 
regRow
 = 
pDest
->
iSdst
;

78970 
nSortData
 = 
nColumn
;

78972 
regRowid
 = 
	`sqlite3GetTempReg
(
pParse
);

78973 
regRow
 = 
	`sqlite3GetTempReg
(
pParse
);

78974 
nSortData
 = 1;

78976 
nKey
 = 
pOrderBy
->
nExpr
 - 
pSort
->
nOBSat
;

78977 if( 
pSort
->
sortFlags
 & 0x01 )

78980 int 
regSortOut
 = ++
pParse
->
nMem
;

78981 
iSortTab
 = 
pParse
->
nTab
++;

78982 if( 
pSort
->
labelBkOut
 )

78985 
addrOnce
 = 
	`sqlite3CodeOnce
(
pParse
); ;

78987 
	`sqlite3VdbeAddOp3
(
v
, 60, 
iSortTab
, 
regSortOut
, 
nKey
+1+
nSortData
);

78988 if( 
addrOnce
 ) 
	`sqlite3VdbeJumpHere
(
v
, addrOnce);

78989 
addr
 = 1 + 
	`sqlite3VdbeAddOp2
(
v
, 106, 
iTab
, 
addrBreak
);

78991 
	`codeOffset
(
v
, 
p
->
iOffset
, 
addrContinue
);

78992 
	`sqlite3VdbeAddOp3
(
v
, 100, 
iTab
, 
regSortOut
, 
iSortTab
);

78993 
bSeq
 = 0;

78995 
addr
 = 1 + 
	`sqlite3VdbeAddOp2
(
v
, 107, 
iTab
, 
addrBreak
); ;

78996 
	`codeOffset
(
v
, 
p
->
iOffset
, 
addrContinue
);

78997 
iSortTab
 = 
iTab
;

78998 
bSeq
 = 1;

79000 for(
i
=0; i<
nSortData
; i++)

79003 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iSortTab
, 
nKey
+
bSeq
+
i
, 
regRow
+i);

79006 switch( 
eDest
 )

79010 
	`sqlite3VdbeAddOp2
(
v
, 74, 
iParm
, 
regRowid
);

79011 
	`sqlite3VdbeAddOp3
(
v
, 75, 
iParm
, 
regRow
, 
regRowid
);

79012 
	`sqlite3VdbeChangeP5
(
v
, 0x08);

79018 
	`sqlite3VdbeAddOp4
(
v
, 49, 
regRow
, 1, 
regRowid
,

79019 &
pDest
->
affSdst
, 1);

79020 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
regRow
, 1);

79021 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iParm
, 
regRowid
);

79026 
	`sqlite3ExprCodeMove
(
pParse
, 
regRow
, 
iParm
, 1);

79035 if( 
eDest
==9 )

79038 
	`sqlite3VdbeAddOp2
(
v
, 33, 
pDest
->
iSdst
, 
nColumn
);

79039 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
pDest
->
iSdst
, 
nColumn
);

79041 
	`sqlite3VdbeAddOp1
(
v
, 18, 
pDest
->
iSDParm
);

79046 if( 
regRowid
 )

79049 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRow
);

79050 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRowid
);

79054 
	`sqlite3VdbeResolveLabel
(
v
, 
addrContinue
);

79055 if( 
pSort
->
sortFlags
 & 0x01 )

79058 
	`sqlite3VdbeAddOp2
(
v
, 3, 
iTab
, 
addr
); ;

79060 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iTab
, 
addr
); ;

79062 if( 
pSort
->
regReturn
 ) 
	`sqlite3VdbeAddOp1
(
v
, 15, pSort->regReturn);

79063 
	`sqlite3VdbeResolveLabel
(
v
, 
addrBreak
);

79064 
	}
}

79066 static const char *
	$columnTypeImpl
(

79067 
NameContext
 *
pNC
,

79068 
Expr
 *
pExpr
,

79074 
u8
 *
pEstWidth


79078 char const *
zType
 = 0;

79079 int 
j
;

79080 
u8
 
estWidth
 = 1;

79089 switch( 
pExpr
->
op
 )

79098 
Table
 *
pTab
 = 0;

79099 
Select
 *
pS
 = 0;

79100 int 
iCol
 = 
pExpr
->
iColumn
;

79103 while( 
pNC
 && !
pTab
 )

79106 
SrcList
 *
pTabList
 = 
pNC
->
pSrcList
;

79107 for(
j
=0;j<
pTabList
->
nSrc
 && pTabList->
a
[j].
iCursor
!=
pExpr
->
iTable
;j++);

79108 if( 
j
<
pTabList
->
nSrc
 )

79111 
pTab
 = 
pTabList
->
a
[
j
].pTab;

79112 
pS
 = 
pTabList
->
a
[
j
].
pSelect
;

79114 
pNC
 = pNC->
pNext
;

79118 if( 
pTab
==0 )

79126 if( 
pS
 )

79133 if( 
iCol
>=0 && (iCol<
pS
->
pEList
->
nExpr
) )

79143 
NameContext
 
sNC
;

79144 
Expr
 *
p
 = 
pS
->
pEList
->
a
[
iCol
].
pExpr
;

79145 
sNC
.
pSrcList
 = 
pS
->
pSrc
;

79146 
sNC
.
pNext
 = 
pNC
;

79147 
sNC
.
pParse
 = 
pNC
->pParse;

79148 
zType
 = 
	`columnTypeImpl
(&
sNC
,
p
,&
estWidth
);

79150 }else if( 
pTab
->
pSchema
 )

79155 if( 
iCol
<0 ) iCol = 
pTab
->
iPKey
;

79158 if( 
iCol
<0 )

79161 
zType
 = "INTEGER";

79163 
zType
 = 
	`sqlite3ColumnType
(&
pTab
->
aCol
[
iCol
],0);

79164 
estWidth
 = 
pTab
->
aCol
[
iCol
].
szEst
;

79176 
NameContext
 
sNC
;

79177 
Select
 *
pS
 = 
pExpr
->
x
.
pSelect
;

79178 
Expr
 *
p
 = 
pS
->
pEList
->
a
[0].
pExpr
;

79180 
sNC
.
pSrcList
 = 
pS
->
pSrc
;

79181 
sNC
.
pNext
 = 
pNC
;

79182 
sNC
.
pParse
 = 
pNC
->pParse;

79183 
zType
 = 
	`columnTypeImpl
(&
sNC
,
p
,&
estWidth
);

79189 if( 
pEstWidth
 ) *pEstWidth = 
estWidth
;

79190 return 
zType
;

79191 
	}
}

79197 static void 
	$generateColumnTypes
(

79198 
Parse
 *
pParse
,

79199 
SrcList
 *
pTabList
,

79200 
ExprList
 *
pEList


79205 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

79206 int 
i
;

79207 
NameContext
 
sNC
;

79208 
sNC
.
pSrcList
 = 
pTabList
;

79209 
sNC
.
pParse
 = pParse;

79210 for(
i
=0; i<
pEList
->
nExpr
; i++)

79213 
Expr
 *
p
 = 
pEList
->
a
[
i
].
pExpr
;

79214 const char *
zType
;

79216 
zType
 = 
	`columnTypeImpl
(&
sNC
,
p
,0);

79218 
	`sqlite3VdbeSetColName
(
v
, 
i
, 1, 
zType
, ((
sqlite3_destructor_type
)-1));

79221 
	}
}

79228 static void 
	$generateColumnNames
(

79229 
Parse
 *
pParse
,

79230 
SrcList
 *
pTabList
,

79231 
ExprList
 *
pEList


79235 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

79236 int 
i
, 
j
;

79237 
sqlite3
 *
db
 = 
pParse
->db;

79238 int 
fullNames
, 
shortNames
;

79242 if( 
pParse
->
explain
 )

79249 if( 
pParse
->
colNamesSet
 || 
db
->
mallocFailed
 ) return;

79252 
pParse
->
colNamesSet
 = 1;

79253 
fullNames
 = (
db
->
flags
 & 0x00000004)!=0;

79254 
shortNames
 = (
db
->
flags
 & 0x00000040)!=0;

79255 
	`sqlite3VdbeSetNumCols
(
v
, 
pEList
->
nExpr
);

79256 for(
i
=0; i<
pEList
->
nExpr
; i++)

79259 
Expr
 *
p
;

79260 
p
 = 
pEList
->
a
[
i
].
pExpr
;

79261 if( (
p
==0) ) continue;

79262 if( 
pEList
->
a
[
i
].
zName
 )

79265 char *
zName
 = 
pEList
->
a
[
i
].zName;

79266 
	`sqlite3VdbeSetColName
(
v
, 
i
, 0, 
zName
, ((
sqlite3_destructor_type
)-1));

79267 }else if( 
p
->
op
==152 || p->op==154 )

79270 
Table
 *
pTab
;

79271 char *
zCol
;

79272 int 
iCol
 = 
p
->
iColumn
;

79273 for(
j
=0; (j<
pTabList
->
nSrc
); j++)

79276 if( 
pTabList
->
a
[
j
].
iCursor
==
p
->
iTable
 ) break;

79279 
pTab
 = 
pTabList
->
a
[
j
].pTab;

79280 if( 
iCol
<0 ) iCol = 
pTab
->
iPKey
;

79282 if( 
iCol
<0 )

79285 
zCol
 = "rowid";

79287 
zCol
 = 
pTab
->
aCol
[
iCol
].
zName
;

79289 if( !
shortNames
 && !
fullNames
 )

79292 
	`sqlite3VdbeSetColName
(
v
, 
i
, 0,

79293 
	`sqlite3DbStrDup
(
db
, 
pEList
->
a
[
i
].
zSpan
), ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

79294 }else if( 
fullNames
 )

79297 char *
zName
 = 0;

79298 
zName
 = 
	`sqlite3MPrintf
(
db
, "%s.%s", 
pTab
->zName, 
zCol
);

79299 
	`sqlite3VdbeSetColName
(
v
, 
i
, 0, 
zName
, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

79301 
	`sqlite3VdbeSetColName
(
v
, 
i
, 0, 
zCol
, ((
sqlite3_destructor_type
)-1));

79304 const char *
z
 = 
pEList
->
a
[
i
].
zSpan
;

79305 
z
 = z==0 ? 
	`sqlite3MPrintf
(
db
, "column%d", 
i
+1) : 
	`sqlite3DbStrDup
(db, z);

79306 
	`sqlite3VdbeSetColName
(
v
, 
i
, 0, 
z
, ((
sqlite3_destructor_type
)
sqlite3MallocSize
));

79309 
	`generateColumnTypes
(
pParse
, 
pTabList
, 
pEList
);

79310 
	}
}

79312 static int 
	$sqlite3ColumnsFromExprList
(

79313 
Parse
 *
pParse
,

79314 
ExprList
 *
pEList
,

79315 
i16
 *
pnCol
,

79316 
Column
 **
paCol


79320 
sqlite3
 *
db
 = 
pParse
->db;

79321 int 
i
, 
j
;

79322 
u32
 
cnt
;

79323 
Column
 *
aCol
, *
pCol
;

79324 int 
nCol
;

79325 
Expr
 *
p
;

79326 char *
zName
;

79327 int 
nName
;

79328 
Hash
 
ht
;

79330 
	`sqlite3HashInit
(&
ht
);

79331 if( 
pEList
 )

79334 
nCol
 = 
pEList
->
nExpr
;

79335 
aCol
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(aCol[0])*
nCol
);

79338 
nCol
 = 0;

79339 
aCol
 = 0;

79342 *
pnCol
 = 
nCol
;

79343 *
paCol
 = 
aCol
;

79345 for(
i
=0, 
pCol
=
aCol
; i<
nCol
 && !
db
->
mallocFailed
; i++, pCol++)

79350 
p
 = 
	`sqlite3ExprSkipCollate
(
pEList
->
a
[
i
].
pExpr
);

79351 if( (
zName
 = 
pEList
->
a
[
i
].zName)!=0 )

79356 
Expr
 *
pColExpr
 = 
p
;

79357 
Table
 *
pTab
;

79358 while( 
pColExpr
->
op
==122 )

79361 
pColExpr
 = pColExpr->
pRight
;

79364 if( 
pColExpr
->
op
==152 && (pColExpr->
pTab
!=0) )

79368 int 
iCol
 = 
pColExpr
->
iColumn
;

79369 
pTab
 = 
pColExpr
->pTab;

79370 if( 
iCol
<0 ) iCol = 
pTab
->
iPKey
;

79371 
zName
 = 
iCol
>=0 ? 
pTab
->
aCol
[iCol].zName : "rowid";

79372 }else if( 
pColExpr
->
op
==27 )

79376 
zName
 = 
pColExpr
->
u
.
zToken
;

79379 
zName
 = 
pEList
->
a
[
i
].
zSpan
;

79382 
zName
 = 
	`sqlite3MPrintf
(
db
, "%s", zName);

79387 
cnt
 = 0;

79388 while( 
zName
 && 
	`sqlite3HashFind
(&
ht
, zName)!=0 )

79391 
nName
 = 
	`sqlite3Strlen30
(
zName
);

79392 if( 
nName
>0 )

79395 for(
j
=
nName
-1; j>0 && (
sqlite3CtypeMap
[(unsigned char)(
zName
[j])]&0x04); j--)

79398 if( 
zName
[
j
]==':' ) 
nName
 = j;

79400 
zName
 = 
	`sqlite3MPrintf
(
db
, "%.*z:%u", 
nName
, zName, ++
cnt
);

79401 if( 
cnt
>3 ) 
	`sqlite3_randomness
(sizeof(cnt), &cnt);

79403 
pCol
->
zName
 = zName;

79405 if( 
zName
 && 
	`sqlite3HashInsert
(&
ht
, zName, 
pCol
)==pCol )

79408 
	`sqlite3OomFault
(
db
);

79411 
	`sqlite3HashClear
(&
ht
);

79412 if( 
db
->
mallocFailed
 )

79415 for(
j
=0; j<
i
; j++)

79418 
	`sqlite3DbFree
(
db
, 
aCol
[
j
].
zName
);

79420 
	`sqlite3DbFree
(
db
, 
aCol
);

79421 *
paCol
 = 0;

79422 *
pnCol
 = 0;

79426 
	}
}

79428 static void 
	$selectAddColumnTypeAndCollation
(

79429 
Parse
 *
pParse
,

79430 
Table
 *
pTab
,

79431 
Select
 *
pSelect


79435 
sqlite3
 *
db
 = 
pParse
->db;

79436 
NameContext
 
sNC
;

79437 
Column
 *
pCol
;

79438 
CollSeq
 *
pColl
;

79439 int 
i
;

79440 
Expr
 *
p
;

79441 struct 
ExprList_item
 *
a
;

79442 
u64
 
szAll
 = 0;

79447 if( 
db
->
mallocFailed
 ) return;

79448 
	`memset
(&
sNC
, 0, sizeof(sNC));

79449 
sNC
.
pSrcList
 = 
pSelect
->
pSrc
;

79450 
a
 = 
pSelect
->
pEList
->a;

79451 for(
i
=0, 
pCol
=
pTab
->
aCol
; i<pTab->
nCol
; i++, pCol++)

79454 
p
 = 
a
[
i
].
pExpr
;

79455 
	`columnTypeImpl
(&
sNC
,
p
,&
pCol
->
szEst
);

79456 
szAll
 += 
pCol
->
szEst
;

79457 
pCol
->
affinity
 = 
	`sqlite3ExprAffinity
(
p
);

79458 if( 
pCol
->
affinity
==0 ) pCol->affinity = 'A';

79459 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
p
);

79460 if( 
pColl
 && 
pCol
->
zColl
==0 )

79463 
pCol
->
zColl
 = 
	`sqlite3DbStrDup
(
db
, 
pColl
->
zName
);

79466 
pTab
->
szTabRow
 = 
	`sqlite3LogEst
(
szAll
*4);

79467 
	}
}

79473 static 
Table
 *
	$sqlite3ResultSetOfSelect
(
Parse
 *
pParse
, 
Select
 *
pSelect
)

79476 
Table
 *
pTab
;

79477 
sqlite3
 *
db
 = 
pParse
->db;

79478 int 
savedFlags
;

79480 
savedFlags
 = 
db
->
flags
;

79481 
db
->
flags
 &= ~0x00000004;

79482 
db
->
flags
 |= 0x00000040;

79483 
	`sqlite3SelectPrep
(
pParse
, 
pSelect
, 0);

79484 if( 
pParse
->
nErr
 ) return 0;

79485 while( 
pSelect
->
pPrior
 ) pSelect = pSelect->pPrior;

79486 
db
->
flags
 = 
savedFlags
;

79487 
pTab
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
Table
) );

79488 if( 
pTab
==0 )

79496 
pTab
->
nRef
 = 1;

79497 
pTab
->
zName
 = 0;

79498 
pTab
->
nRowLogEst
 = 200; ((void) (0));

79499 
	`sqlite3ColumnsFromExprList
(
pParse
, 
pSelect
->
pEList
, &
pTab
->
nCol
, &pTab->
aCol
);

79500 
	`selectAddColumnTypeAndCollation
(
pParse
, 
pTab
, 
pSelect
);

79501 
pTab
->
iPKey
 = -1;

79502 if( 
db
->
mallocFailed
 )

79505 
	`sqlite3DeleteTable
(
db
, 
pTab
);

79508 return 
pTab
;

79509 
	}
}

79515 static 
Vdbe
 *
	$sqlite3GetVdbe
(
Parse
 *
pParse
)

79518 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

79519 if( 
v
==0 )

79522 
v
 = 
pParse
->
pVdbe
 = 
	`sqlite3VdbeCreate
(pParse);

79523 if( 
v
 ) 
	`sqlite3VdbeAddOp0
(v, 158);

79524 if( 
pParse
->
pToplevel
==0

79525 && (((
pParse
->
db
)->
dbOptFlags
&(0x0008))==0)

79529 
pParse
->
okConstFactor
 = 1;

79533 return 
v
;

79534 
	}
}

79536 static void 
	$computeLimitRegisters
(
Parse
 *
pParse
, 
Select
 *
p
, int 
iBreak
)

79539 
Vdbe
 *
v
 = 0;

79540 int 
iLimit
 = 0;

79541 int 
iOffset
;

79542 int 
n
;

79543 if( 
p
->
iLimit
 ) return;

79551 
	`sqlite3ExprCacheClear
(
pParse
);

79553 if( 
p
->
pLimit
 )

79556 
p
->
iLimit
 = iLimit = ++
pParse
->
nMem
;

79557 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

79559 if( 
	`sqlite3ExprIsInteger
(
p
->
pLimit
, &
n
) )

79562 
	`sqlite3VdbeAddOp2
(
v
, 22, 
n
, 
iLimit
);

79564 if( 
n
==0 )

79567 
	`sqlite3VdbeGoto
(
v
, 
iBreak
);

79568 }else if( 
n
>=0 && 
p
->
nSelectRow
>
	`sqlite3LogEst
((
u64
)n) )

79571 
p
->
nSelectRow
 = 
	`sqlite3LogEst
((
u64
)
n
);

79572 
p
->
selFlags
 |= 0x04000;

79575 
	`sqlite3ExprCode
(
pParse
, 
p
->
pLimit
, 
iLimit
);

79576 
	`sqlite3VdbeAddOp1
(
v
, 38, 
iLimit
); ;

79578 
	`sqlite3VdbeAddOp2
(
v
, 46, 
iLimit
, 
iBreak
); ;

79580 if( 
p
->
pOffset
 )

79583 
p
->
iOffset
 = iOffset = ++
pParse
->
nMem
;

79584 
pParse
->
nMem
++;

79585 
	`sqlite3ExprCode
(
pParse
, 
p
->
pOffset
, 
iOffset
);

79586 
	`sqlite3VdbeAddOp1
(
v
, 38, 
iOffset
); ;

79588 
	`sqlite3VdbeAddOp3
(
v
, 139, 
iLimit
, 
iOffset
+1, iOffset);

79592 
	}
}

79594 static 
CollSeq
 *
	$multiSelectCollSeq
(
Parse
 *
pParse
, 
Select
 *
p
, int 
iCol
)

79597 
CollSeq
 *
pRet
;

79598 if( 
p
->
pPrior
 )

79601 
pRet
 = 
	`multiSelectCollSeq
(
pParse
, 
p
->
pPrior
, 
iCol
);

79603 
pRet
 = 0;

79609 if( 
pRet
==0 && (
iCol
<
p
->
pEList
->
nExpr
) )

79612 
pRet
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
p
->
pEList
->
a
[
iCol
].
pExpr
);

79614 return 
pRet
;

79615 
	}
}

79617 static 
KeyInfo
 *
	$multiSelectOrderByKeyInfo
(
Parse
 *
pParse
, 
Select
 *
p
, int 
nExtra
)

79620 
ExprList
 *
pOrderBy
 = 
p
->pOrderBy;

79621 int 
nOrderBy
 = 
p
->
pOrderBy
->
nExpr
;

79622 
sqlite3
 *
db
 = 
pParse
->db;

79623 
KeyInfo
 *
pRet
 = 
	`sqlite3KeyInfoAlloc
(
db
, 
nOrderBy
+
nExtra
, 1);

79624 if( 
pRet
 )

79627 int 
i
;

79628 for(
i
=0; i<
nOrderBy
; i++)

79631 struct 
ExprList_item
 *
pItem
 = &
pOrderBy
->
a
[
i
];

79632 
Expr
 *
pTerm
 = 
pItem
->
pExpr
;

79633 
CollSeq
 *
pColl
;

79635 if( 
pTerm
->
flags
 & 0x000100 )

79638 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pTerm
);

79640 
pColl
 = 
	`multiSelectCollSeq
(
pParse
, 
p
, 
pItem
->
u
.
x
.
iOrderByCol
-1);

79641 if( 
pColl
==0 ) pColl = 
db
->
pDfltColl
;

79642 
pOrderBy
->
a
[
i
].
pExpr
 =

79643 
	`sqlite3ExprAddCollateString
(
pParse
, 
pTerm
, 
pColl
->
zName
);

79646 
pRet
->
aColl
[
i
] = 
pColl
;

79647 
pRet
->
aSortOrder
[
i
] = 
pOrderBy
->
a
[i].
sortOrder
;

79651 return 
pRet
;

79652 
	}
}

79654 static void 
	$generateWithRecursiveQuery
(

79655 
Parse
 *
pParse
,

79656 
Select
 *
p
,

79657 
SelectDest
 *
pDest


79661 
SrcList
 *
pSrc
 = 
p
->pSrc;

79662 int 
nCol
 = 
p
->
pEList
->
nExpr
;

79663 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

79664 
Select
 *
pSetup
 = 
p
->
pPrior
;

79665 int 
addrTop
;

79666 int 
addrCont
, 
addrBreak
;

79667 int 
iCurrent
 = 0;

79668 int 
regCurrent
;

79669 int 
iQueue
;

79670 int 
iDistinct
 = 0;

79671 int 
eDest
 = 5;

79672 
SelectDest
 
destQueue
;

79673 int 
i
;

79674 int 
rc
;

79675 
ExprList
 *
pOrderBy
;

79676 
Expr
 *
pLimit
, *
pOffset
;

79677 int 
regLimit
, 
regOffset
;

79680 if( 
	`sqlite3AuthCheck
(
pParse
, 33, 0, 0, 0) ) return;

79683 
addrBreak
 = 
	`sqlite3VdbeMakeLabel
(
v
);

79684 
	`computeLimitRegisters
(
pParse
, 
p
, 
addrBreak
);

79685 
pLimit
 = 
p
->pLimit;

79686 
pOffset
 = 
p
->pOffset;

79687 
regLimit
 = 
p
->
iLimit
;

79688 
regOffset
 = 
p
->
iOffset
;

79689 
p
->
pLimit
 = p->
pOffset
 = 0;

79690 
p
->
iLimit
 = p->
iOffset
 = 0;

79691 
pOrderBy
 = 
p
->pOrderBy;

79694 for(
i
=0; (i<
pSrc
->
nSrc
); i++)

79697 if( 
pSrc
->
a
[
i
].
fg
.
isRecursive
 )

79700 
iCurrent
 = 
pSrc
->
a
[
i
].
iCursor
;

79708 
iQueue
 = 
pParse
->
nTab
++;

79709 if( 
p
->
op
==115 )

79712 
eDest
 = 
pOrderBy
 ? 8 : 6;

79713 
iDistinct
 = 
pParse
->
nTab
++;

79715 
eDest
 = 
pOrderBy
 ? 7 : 5;

79717 
	`sqlite3SelectDestInit
(&
destQueue
, 
eDest
, 
iQueue
);

79720 
regCurrent
 = ++
pParse
->
nMem
;

79721 
	`sqlite3VdbeAddOp3
(
v
, 60, 
iCurrent
, 
regCurrent
, 
nCol
);

79722 if( 
pOrderBy
 )

79725 
KeyInfo
 *
pKeyInfo
 = 
	`multiSelectOrderByKeyInfo
(
pParse
, 
p
, 1);

79726 
	`sqlite3VdbeAddOp4
(
v
, 57, 
iQueue
, 
pOrderBy
->
nExpr
+2, 0,

79727 (char*)
pKeyInfo
, (-6));

79728 
destQueue
.
pOrderBy
 = pOrderBy;

79730 
	`sqlite3VdbeAddOp2
(
v
, 57, 
iQueue
, 
nCol
);

79733 if( 
iDistinct
 )

79736 
p
->
addrOpenEphm
[0] = 
	`sqlite3VdbeAddOp2
(
v
, 57, 
iDistinct
, 0);

79737 
p
->
selFlags
 |= 0x00010;

79741 
p
->
pOrderBy
 = 0;

79744 
pSetup
->
pNext
 = 0;

79745 
rc
 = 
	`sqlite3Select
(
pParse
, 
pSetup
, &
destQueue
);

79746 
pSetup
->
pNext
 = 
p
;

79747 if( 
rc
 ) goto 
end_of_recursive_query
;

79750 
addrTop
 = 
	`sqlite3VdbeAddOp2
(
v
, 108, 
iQueue
, 
addrBreak
); ;

79753 
	`sqlite3VdbeAddOp1
(
v
, 104, 
iCurrent
);

79754 if( 
pOrderBy
 )

79757 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iQueue
, 
pOrderBy
->
nExpr
+1, 
regCurrent
);

79759 
	`sqlite3VdbeAddOp2
(
v
, 102, 
iQueue
, 
regCurrent
);

79761 
	`sqlite3VdbeAddOp1
(
v
, 95, 
iQueue
);

79764 
addrCont
 = 
	`sqlite3VdbeMakeLabel
(
v
);

79765 
	`codeOffset
(
v
, 
regOffset
, 
addrCont
);

79766 
	`selectInnerLoop
(
pParse
, 
p
, p->
pEList
, 
iCurrent
,

79767 0, 0, 
pDest
, 
addrCont
, 
addrBreak
);

79768 if( 
regLimit
 )

79771 
	`sqlite3VdbeAddOp2
(
v
, 141, 
regLimit
, 
addrBreak
);

79774 
	`sqlite3VdbeResolveLabel
(
v
, 
addrCont
);

79779 if( 
p
->
selFlags
 & 0x00008 )

79782 
	`sqlite3ErrorMsg
(
pParse
, "recursive aggregate queries not supported");

79784 
p
->
pPrior
 = 0;

79785 
	`sqlite3Select
(
pParse
, 
p
, &
destQueue
);

79787 
p
->
pPrior
 = 
pSetup
;

79791 
	`sqlite3VdbeGoto
(
v
, 
addrTop
);

79792 
	`sqlite3VdbeResolveLabel
(
v
, 
addrBreak
);

79794 
end_of_recursive_query
:

79795 
	`sqlite3ExprListDelete
(
pParse
->
db
, 
p
->
pOrderBy
);

79796 
p
->
pOrderBy
 = pOrderBy;

79797 
p
->
pLimit
 = pLimit;

79798 
p
->
pOffset
 = pOffset;

79800 
	}
}

79804 static int 
multiSelectOrderBy
(

79805 
Parse
 *
pParse
,

79806 
Select
 *
p
,

79807 
SelectDest
 *
pDest


79810 static int 
	$multiSelectValues
(

79811 
Parse
 *
pParse
,

79812 
Select
 *
p
,

79813 
SelectDest
 *
pDest


79817 
Select
 *
pPrior
;

79818 int 
nRow
 = 1;

79819 int 
rc
 = 0;

79827 if( 
p
->
pPrior
==0 ) break;

79829 
p
 = p->
pPrior
;

79830 
nRow
++;

79832 while( 
p
 )

79835 
pPrior
 = 
p
->pPrior;

79836 
p
->
pPrior
 = 0;

79837 
rc
 = 
	`sqlite3Select
(
pParse
, 
p
, 
pDest
);

79838 
p
->
pPrior
 = pPrior;

79839 if( 
rc
 ) break;

79840 
p
->
nSelectRow
 = 
nRow
;

79841 
p
 = p->
pNext
;

79843 return 
rc
;

79844 
	}
}

79846 static int 
	$multiSelect
(

79847 
Parse
 *
pParse
,

79848 
Select
 *
p
,

79849 
SelectDest
 *
pDest


79853 int 
rc
 = 0;

79854 
Select
 *
pPrior
;

79855 
Vdbe
 *
v
;

79856 
SelectDest
 
dest
;

79857 
Select
 *
pDelete
 = 0;

79858 
sqlite3
 *
db
;

79860 int 
iSub1
 = 0;

79861 int 
iSub2
 = 0;

79869 
db
 = 
pParse
->db;

79870 
pPrior
 = 
p
->pPrior;

79871 
dest
 = *
pDest
;

79872 if( 
pPrior
->
pOrderBy
 )

79875 
	`sqlite3ErrorMsg
(
pParse
,"ORDER BY clause should come after %s not before",

79876 
	`selectOpName
(
p
->
op
));

79877 
rc
 = 1;

79878 goto 
multi_select_end
;

79880 if( 
pPrior
->
pLimit
 )

79883 
	`sqlite3ErrorMsg
(
pParse
,"LIMIT clause should come after %s not before",

79884 
	`selectOpName
(
p
->
op
));

79885 
rc
 = 1;

79886 goto 
multi_select_end
;

79889 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

79894 if( 
dest
.
eDest
==12 )

79898 
	`sqlite3VdbeAddOp2
(
v
, 57, 
dest
.
iSDParm
, 
p
->
pEList
->
nExpr
);

79899 
dest
.
eDest
 = 14;

79904 if( 
p
->
selFlags
 & 0x00200 )

79907 
rc
 = 
	`multiSelectValues
(
pParse
, 
p
, &
dest
);

79908 goto 
multi_select_end
;

79918 if( 
p
->
selFlags
 & 0x02000 )

79921 
	`generateWithRecursiveQuery
(
pParse
, 
p
, &
dest
);

79927 if( 
p
->
pOrderBy
 )

79930 return 
	`multiSelectOrderBy
(
pParse
, 
p
, 
pDest
);

79935 switch( 
p
->
op
 )

79939 int 
addr
 = 0;

79940 int 
nLimit
;

79942 
pPrior
->
iLimit
 = 
p
->iLimit;

79943 
pPrior
->
iOffset
 = 
p
->iOffset;

79944 
pPrior
->
pLimit
 = 
p
->pLimit;

79945 
pPrior
->
pOffset
 = 
p
->pOffset;

79946 
iSub1
 = 
pParse
->
iNextSelectId
;

79947 
rc
 = 
	`sqlite3Select
(
pParse
, 
pPrior
, &
dest
);

79948 
p
->
pLimit
 = 0;

79949 
p
->
pOffset
 = 0;

79950 if( 
rc
 )

79953 goto 
multi_select_end
;

79955 
p
->
pPrior
 = 0;

79956 
p
->
iLimit
 = 
pPrior
->iLimit;

79957 
p
->
iOffset
 = 
pPrior
->iOffset;

79958 if( 
p
->
iLimit
 )

79961 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 46, 
p
->
iLimit
); ;

79963 if( 
p
->
iOffset
 )

79966 
	`sqlite3VdbeAddOp3
(
v
, 139,

79967 
p
->
iLimit
, p->
iOffset
+1, p->iOffset);

79970 
iSub2
 = 
pParse
->
iNextSelectId
;

79971 
rc
 = 
	`sqlite3Select
(
pParse
, 
p
, &
dest
);

79973 
pDelete
 = 
p
->
pPrior
;

79974 
p
->
pPrior
 = pPrior;

79975 
p
->
nSelectRow
 = 
	`sqlite3LogEstAdd
(p->nSelectRow, 
pPrior
->nSelectRow);

79976 if( 
pPrior
->
pLimit


79977 && 
	`sqlite3ExprIsInteger
(
pPrior
->
pLimit
, &
nLimit
)

79978 && 
nLimit
>0 && 
p
->
nSelectRow
 > 
	`sqlite3LogEst
((
u64
)nLimit)

79982 
p
->
nSelectRow
 = 
	`sqlite3LogEst
((
u64
)
nLimit
);

79984 if( 
addr
 )

79987 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

79993 int 
unionTab
;

79994 
u8
 
op
 = 0;

79995 int 
priorOp
;

79996 
Expr
 *
pLimit
, *
pOffset
;

79997 int 
addr
;

79998 
SelectDest
 
uniondest
;

80002 
priorOp
 = 1;

80003 if( 
dest
.
eDest
==
priorOp
 )

80011 
unionTab
 = 
dest
.
iSDParm
;

80016 
unionTab
 = 
pParse
->
nTab
++;

80018 
addr
 = 
	`sqlite3VdbeAddOp2
(
v
, 57, 
unionTab
, 0);

80020 
p
->
addrOpenEphm
[0] = 
addr
;

80021 
	`findRightmost
(
p
)->
selFlags
 |= 0x00010;

80028 
	`sqlite3SelectDestInit
(&
uniondest
, 
priorOp
, 
unionTab
);

80029 
iSub1
 = 
pParse
->
iNextSelectId
;

80030 
rc
 = 
	`sqlite3Select
(
pParse
, 
pPrior
, &
uniondest
);

80031 if( 
rc
 )

80034 goto 
multi_select_end
;

80039 if( 
p
->
op
==117 )

80042 
op
 = 2;

80045 
op
 = 1;

80047 
p
->
pPrior
 = 0;

80048 
pLimit
 = 
p
->pLimit;

80049 
p
->
pLimit
 = 0;

80050 
pOffset
 = 
p
->pOffset;

80051 
p
->
pOffset
 = 0;

80052 
uniondest
.
eDest
 = 
op
;

80053 
iSub2
 = 
pParse
->
iNextSelectId
;

80054 
rc
 = 
	`sqlite3Select
(
pParse
, 
p
, &
uniondest
);

80058 
	`sqlite3ExprListDelete
(
db
, 
p
->
pOrderBy
);

80059 
pDelete
 = 
p
->
pPrior
;

80060 
p
->
pPrior
 = pPrior;

80061 
p
->
pOrderBy
 = 0;

80062 if( 
p
->
op
==115 )

80065 
p
->
nSelectRow
 = 
	`sqlite3LogEstAdd
(p->nSelectRow, 
pPrior
->nSelectRow);

80067 
	`sqlite3ExprDelete
(
db
, 
p
->
pLimit
);

80068 
p
->
pLimit
 = pLimit;

80069 
p
->
pOffset
 = pOffset;

80070 
p
->
iLimit
 = 0;

80071 
p
->
iOffset
 = 0;

80077 if( 
dest
.
eDest
!=
priorOp
 )

80080 int 
iCont
, 
iBreak
, 
iStart
;

80082 if( 
dest
.
eDest
==9 )

80085 
Select
 *
pFirst
 = 
p
;

80086 while( 
pFirst
->
pPrior
 ) pFirst = pFirst->pPrior;

80087 
	`generateColumnNames
(
pParse
, 
pFirst
->
pSrc
, pFirst->
pEList
);

80089 
iBreak
 = 
	`sqlite3VdbeMakeLabel
(
v
);

80090 
iCont
 = 
	`sqlite3VdbeMakeLabel
(
v
);

80091 
	`computeLimitRegisters
(
pParse
, 
p
, 
iBreak
);

80092 
	`sqlite3VdbeAddOp2
(
v
, 108, 
unionTab
, 
iBreak
); ;

80093 
iStart
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

80094 
	`selectInnerLoop
(
pParse
, 
p
, p->
pEList
, 
unionTab
,

80095 0, 0, &
dest
, 
iCont
, 
iBreak
);

80096 
	`sqlite3VdbeResolveLabel
(
v
, 
iCont
);

80097 
	`sqlite3VdbeAddOp2
(
v
, 7, 
unionTab
, 
iStart
); ;

80098 
	`sqlite3VdbeResolveLabel
(
v
, 
iBreak
);

80099 
	`sqlite3VdbeAddOp2
(
v
, 61, 
unionTab
, 0);

80104 int 
tab1
, 
tab2
;

80105 int 
iCont
, 
iBreak
, 
iStart
;

80106 
Expr
 *
pLimit
, *
pOffset
;

80107 int 
addr
;

80108 
SelectDest
 
intersectdest
;

80109 int 
r1
;

80115 
tab1
 = 
pParse
->
nTab
++;

80116 
tab2
 = 
pParse
->
nTab
++;

80119 
addr
 = 
	`sqlite3VdbeAddOp2
(
v
, 57, 
tab1
, 0);

80121 
p
->
addrOpenEphm
[0] = 
addr
;

80122 
	`findRightmost
(
p
)->
selFlags
 |= 0x00010;

80127 
	`sqlite3SelectDestInit
(&
intersectdest
, 1, 
tab1
);

80128 
iSub1
 = 
pParse
->
iNextSelectId
;

80129 
rc
 = 
	`sqlite3Select
(
pParse
, 
pPrior
, &
intersectdest
);

80130 if( 
rc
 )

80133 goto 
multi_select_end
;

80138 
addr
 = 
	`sqlite3VdbeAddOp2
(
v
, 57, 
tab2
, 0);

80140 
p
->
addrOpenEphm
[1] = 
addr
;

80141 
p
->
pPrior
 = 0;

80142 
pLimit
 = 
p
->pLimit;

80143 
p
->
pLimit
 = 0;

80144 
pOffset
 = 
p
->pOffset;

80145 
p
->
pOffset
 = 0;

80146 
intersectdest
.
iSDParm
 = 
tab2
;

80147 
iSub2
 = 
pParse
->
iNextSelectId
;

80148 
rc
 = 
	`sqlite3Select
(
pParse
, 
p
, &
intersectdest
);

80150 
pDelete
 = 
p
->
pPrior
;

80151 
p
->
pPrior
 = pPrior;

80152 if( 
p
->
nSelectRow
>
pPrior
->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;

80153 
	`sqlite3ExprDelete
(
db
, 
p
->
pLimit
);

80154 
p
->
pLimit
 = pLimit;

80155 
p
->
pOffset
 = pOffset;

80161 if( 
dest
.
eDest
==9 )

80164 
Select
 *
pFirst
 = 
p
;

80165 while( 
pFirst
->
pPrior
 ) pFirst = pFirst->pPrior;

80166 
	`generateColumnNames
(
pParse
, 
pFirst
->
pSrc
, pFirst->
pEList
);

80168 
iBreak
 = 
	`sqlite3VdbeMakeLabel
(
v
);

80169 
iCont
 = 
	`sqlite3VdbeMakeLabel
(
v
);

80170 
	`computeLimitRegisters
(
pParse
, 
p
, 
iBreak
);

80171 
	`sqlite3VdbeAddOp2
(
v
, 108, 
tab1
, 
iBreak
); ;

80172 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

80173 
iStart
 = 
	`sqlite3VdbeAddOp2
(
v
, 101, 
tab1
, 
r1
);

80174 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
tab2
, 
iCont
, 
r1
, 0); ;

80175 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

80176 
	`selectInnerLoop
(
pParse
, 
p
, p->
pEList
, 
tab1
,

80177 0, 0, &
dest
, 
iCont
, 
iBreak
);

80178 
	`sqlite3VdbeResolveLabel
(
v
, 
iCont
);

80179 
	`sqlite3VdbeAddOp2
(
v
, 7, 
tab1
, 
iStart
); ;

80180 
	`sqlite3VdbeResolveLabel
(
v
, 
iBreak
);

80181 
	`sqlite3VdbeAddOp2
(
v
, 61, 
tab2
, 0);

80182 
	`sqlite3VdbeAddOp2
(
v
, 61, 
tab1
, 0);

80187 
	`explainComposite
(
pParse
, 
p
->
op
, 
iSub1
, 
iSub2
, p->op!=116);

80189 if( 
p
->
selFlags
 & 0x00010 )

80192 int 
i
;

80193 
KeyInfo
 *
pKeyInfo
;

80194 
Select
 *
pLoop
;

80195 
CollSeq
 **
apColl
;

80196 int 
nCol
;

80199 
nCol
 = 
p
->
pEList
->
nExpr
;

80200 
pKeyInfo
 = 
	`sqlite3KeyInfoAlloc
(
db
, 
nCol
, 1);

80201 if( !
pKeyInfo
 )

80204 
rc
 = 7;

80205 goto 
multi_select_end
;

80207 for(
i
=0, 
apColl
=
pKeyInfo
->
aColl
; i<
nCol
; i++, apColl++)

80210 *
apColl
 = 
	`multiSelectCollSeq
(
pParse
, 
p
, 
i
);

80211 if( 0==*
apColl
 )

80214 *
apColl
 = 
db
->
pDfltColl
;

80218 for(
pLoop
=
p
; pLoop; pLoop=pLoop->
pPrior
)

80221 for(
i
=0; i<2; i++)

80224 int 
addr
 = 
pLoop
->
addrOpenEphm
[
i
];

80225 if( 
addr
<0 )

80233 
	`sqlite3VdbeChangeP2
(
v
, 
addr
, 
nCol
);

80234 
	`sqlite3VdbeChangeP4
(
v
, 
addr
, (char*)
	`sqlite3KeyInfoRef
(
pKeyInfo
),

80236 
pLoop
->
addrOpenEphm
[
i
] = -1;

80239 
	`sqlite3KeyInfoUnref
(
pKeyInfo
);

80242 
multi_select_end
:

80243 
pDest
->
iSdst
 = 
dest
.iSdst;

80244 
pDest
->
nSdst
 = 
dest
.nSdst;

80245 
	`sqlite3SelectDelete
(
db
, 
pDelete
);

80246 return 
rc
;

80247 
	}
}

80254 static void 
	$sqlite3SelectWrongNumTermsError
(
Parse
 *
pParse
, 
Select
 *
p
)

80257 if( 
p
->
selFlags
 & 0x00100 )

80260 
	`sqlite3ErrorMsg
(
pParse
, "all VALUES must have the same number of terms");

80262 
	`sqlite3ErrorMsg
(
pParse
, "SELECTs to the left and right of %s"

80263 " do not have the same number of result columns", 
	`selectOpName
(
p
->
op
));

80265 
	}
}

80267 static int 
	$generateOutputSubroutine
(

80268 
Parse
 *
pParse
,

80269 
Select
 *
p
,

80270 
SelectDest
 *
pIn
,

80271 
SelectDest
 *
pDest
,

80272 int 
regReturn
,

80273 int 
regPrev
,

80274 
KeyInfo
 *
pKeyInfo
,

80275 int 
iBreak


80279 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

80280 int 
iContinue
;

80281 int 
addr
;

80283 
addr
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

80284 
iContinue
 = 
	`sqlite3VdbeMakeLabel
(
v
);

80288 if( 
regPrev
 )

80291 int 
addr1
, 
addr2
;

80292 
addr1
 = 
	`sqlite3VdbeAddOp1
(
v
, 46, 
regPrev
); ;

80293 
addr2
 = 
	`sqlite3VdbeAddOp4
(
v
, 42, 
pIn
->
iSdst
, 
regPrev
+1, pIn->
nSdst
,

80294 (char*)
	`sqlite3KeyInfoRef
(
pKeyInfo
), (-6));

80295 
	`sqlite3VdbeAddOp3
(
v
, 43, 
addr2
+2, 
iContinue
, addr2+2); ;

80296 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

80297 
	`sqlite3VdbeAddOp3
(
v
, 30, 
pIn
->
iSdst
, 
regPrev
+1, pIn->
nSdst
-1);

80298 
	`sqlite3VdbeAddOp2
(
v
, 22, 1, 
regPrev
);

80300 if( 
pParse
->
db
->
mallocFailed
 ) return 0;

80304 
	`codeOffset
(
v
, 
p
->
iOffset
, 
iContinue
);

80308 switch( 
pDest
->
eDest
 )

80314 int 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

80315 int 
r2
 = 
	`sqlite3GetTempReg
(
pParse
);

80316 
	`sqlite3VdbeAddOp3
(
v
, 49, 
pIn
->
iSdst
, pIn->
nSdst
, 
r1
);

80317 
	`sqlite3VdbeAddOp2
(
v
, 74, 
pDest
->
iSDParm
, 
r2
);

80318 
	`sqlite3VdbeAddOp3
(
v
, 75, 
pDest
->
iSDParm
, 
r1
, 
r2
);

80319 
	`sqlite3VdbeChangeP5
(
v
, 0x08);

80320 
	`sqlite3ReleaseTempReg
(
pParse
, 
r2
);

80321 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

80331 int 
r1
;

80333 
pDest
->
affSdst
 =

80334 
	`sqlite3CompareAffinity
(
p
->
pEList
->
a
[0].
pExpr
, 
pDest
->
affSdst
);

80335 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

80336 
	`sqlite3VdbeAddOp4
(
v
, 49, 
pIn
->
iSdst
, 1, 
r1
, &
pDest
->
affSdst
,1);

80337 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
pIn
->
iSdst
, 1);

80338 
	`sqlite3VdbeAddOp2
(
v
, 110, 
pDest
->
iSDParm
, 
r1
);

80339 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

80349 
	`sqlite3ExprCodeMove
(
pParse
, 
pIn
->
iSdst
, 
pDest
->
iSDParm
, 1);

80359 if( 
pDest
->
iSdst
==0 )

80362 
pDest
->
iSdst
 = 
	`sqlite3GetTempRange
(
pParse
, 
pIn
->
nSdst
);

80363 
pDest
->
nSdst
 = 
pIn
->nSdst;

80365 
	`sqlite3ExprCodeMove
(
pParse
, 
pIn
->
iSdst
, 
pDest
->iSdst, pIn->
nSdst
);

80366 
	`sqlite3VdbeAddOp1
(
v
, 18, 
pDest
->
iSDParm
);

80372 
	`sqlite3VdbeAddOp2
(
v
, 33, 
pIn
->
iSdst
, pIn->
nSdst
);

80373 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
pIn
->
iSdst
, pIn->
nSdst
);

80380 if( 
p
->
iLimit
 )

80383 
	`sqlite3VdbeAddOp2
(
v
, 141, 
p
->
iLimit
, 
iBreak
); ;

80388 
	`sqlite3VdbeResolveLabel
(
v
, 
iContinue
);

80389 
	`sqlite3VdbeAddOp1
(
v
, 15, 
regReturn
);

80391 return 
addr
;

80392 
	}
}

80394 static int 
	$multiSelectOrderBy
(

80395 
Parse
 *
pParse
,

80396 
Select
 *
p
,

80397 
SelectDest
 *
pDest


80401 int 
i
, 
j
;

80402 
Select
 *
pPrior
;

80403 
Vdbe
 *
v
;

80404 
SelectDest
 
destA
;

80405 
SelectDest
 
destB
;

80406 int 
regAddrA
;

80407 int 
regAddrB
;

80408 int 
addrSelectA
;

80409 int 
addrSelectB
;

80410 int 
regOutA
;

80411 int 
regOutB
;

80412 int 
addrOutA
;

80413 int 
addrOutB
 = 0;

80414 int 
addrEofA
;

80415 int 
addrEofA_noB
;

80416 int 
addrEofB
;

80417 int 
addrAltB
;

80418 int 
addrAeqB
;

80419 int 
addrAgtB
;

80420 int 
regLimitA
;

80421 int 
regLimitB
;

80422 int 
regPrev
;

80423 int 
savedLimit
;

80424 int 
savedOffset
;

80425 int 
labelCmpr
;

80426 int 
labelEnd
;

80427 int 
addr1
;

80428 int 
op
;

80429 
KeyInfo
 *
pKeyDup
 = 0;

80430 
KeyInfo
 *
pKeyMerge
;

80431 
sqlite3
 *
db
;

80432 
ExprList
 *
pOrderBy
;

80433 int 
nOrderBy
;

80434 int *
aPermute
;

80436 int 
iSub1
;

80437 int 
iSub2
;

80442 
db
 = 
pParse
->db;

80443 
v
 = 
pParse
->
pVdbe
;

80445 
labelEnd
 = 
	`sqlite3VdbeMakeLabel
(
v
);

80446 
labelCmpr
 = 
	`sqlite3VdbeMakeLabel
(
v
);

80451 
op
 = 
p
->op;

80452 
pPrior
 = 
p
->pPrior;

80454 
pOrderBy
 = 
p
->pOrderBy;

80456 
nOrderBy
 = 
pOrderBy
->
nExpr
;

80462 if( 
op
!=116 )

80465 for(
i
=1; 
db
->
mallocFailed
==0 && i<=
p
->
pEList
->
nExpr
; i++)

80468 struct 
ExprList_item
 *
pItem
;

80469 for(
j
=0, 
pItem
=
pOrderBy
->
a
; j<
nOrderBy
; j++, pItem++)

80473 if( 
pItem
->
u
.
x
.
iOrderByCol
==
i
 ) break;

80475 if( 
j
==
nOrderBy
 )

80478 
Expr
 *
pNew
 = 
	`sqlite3Expr
(
db
, 132, 0);

80479 if( 
pNew
==0 ) return 7;

80480 
pNew
->
flags
 |= 0x000400;

80481 
pNew
->
u
.
iValue
 = 
i
;

80482 
pOrderBy
 = 
	`sqlite3ExprListAppend
(
pParse
, pOrderBy, 
pNew
);

80483 if( 
pOrderBy
 ) pOrderBy->
a
[
nOrderBy
++].
u
.
x
.
iOrderByCol
 = (
u16
)
i
;

80488 
aPermute
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(int)*(
nOrderBy
 + 1));

80489 if( 
aPermute
 )

80492 struct 
ExprList_item
 *
pItem
;

80493 
aPermute
[0] = 
nOrderBy
;

80494 for(
i
=1, 
pItem
=
pOrderBy
->
a
; i<=
nOrderBy
; i++, pItem++)

80499 
aPermute
[
i
] = 
pItem
->
u
.
x
.
iOrderByCol
 - 1;

80501 
pKeyMerge
 = 
	`multiSelectOrderByKeyInfo
(
pParse
, 
p
, 1);

80503 
pKeyMerge
 = 0;

80508 
p
->
pOrderBy
 = pOrderBy;

80509 
pPrior
->
pOrderBy
 = 
	`sqlite3ExprListDup
(
pParse
->
db
, pOrderBy, 0);

80515 if( 
op
==116 )

80518 
regPrev
 = 0;

80520 int 
nExpr
 = 
p
->
pEList
->nExpr;

80522 
regPrev
 = 
pParse
->
nMem
+1;

80523 
pParse
->
nMem
 += 
nExpr
+1;

80524 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
regPrev
);

80525 
pKeyDup
 = 
	`sqlite3KeyInfoAlloc
(
db
, 
nExpr
, 1);

80526 if( 
pKeyDup
 )

80530 for(
i
=0; i<
nExpr
; i++)

80533 
pKeyDup
->
aColl
[
i
] = 
	`multiSelectCollSeq
(
pParse
, 
p
, i);

80534 
pKeyDup
->
aSortOrder
[
i
] = 0;

80541 
p
->
pPrior
 = 0;

80542 
pPrior
->
pNext
 = 0;

80543 
	`sqlite3ResolveOrderGroupBy
(
pParse
, 
p
, p->
pOrderBy
, "ORDER");

80544 if( 
pPrior
->pPrior==0 )

80547 
	`sqlite3ResolveOrderGroupBy
(
pParse
, 
pPrior
, pPrior->
pOrderBy
, "ORDER");

80551 
	`computeLimitRegisters
(
pParse
, 
p
, 
labelEnd
);

80552 if( 
p
->
iLimit
 && 
op
==116 )

80555 
regLimitA
 = ++
pParse
->
nMem
;

80556 
regLimitB
 = ++
pParse
->
nMem
;

80557 
	`sqlite3VdbeAddOp2
(
v
, 30, 
p
->
iOffset
 ? p->iOffset+1 : p->
iLimit
,

80558 
regLimitA
);

80559 
	`sqlite3VdbeAddOp2
(
v
, 30, 
regLimitA
, 
regLimitB
);

80561 
regLimitA
 = 
regLimitB
 = 0;

80563 
	`sqlite3ExprDelete
(
db
, 
p
->
pLimit
);

80564 
p
->
pLimit
 = 0;

80565 
	`sqlite3ExprDelete
(
db
, 
p
->
pOffset
);

80566 
p
->
pOffset
 = 0;

80568 
regAddrA
 = ++
pParse
->
nMem
;

80569 
regAddrB
 = ++
pParse
->
nMem
;

80570 
regOutA
 = ++
pParse
->
nMem
;

80571 
regOutB
 = ++
pParse
->
nMem
;

80572 
	`sqlite3SelectDestInit
(&
destA
, 13, 
regAddrA
);

80573 
	`sqlite3SelectDestInit
(&
destB
, 13, 
regAddrB
);

80578 
addrSelectA
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 1;

80579 
addr1
 = 
	`sqlite3VdbeAddOp3
(
v
, 16, 
regAddrA
, 0, 
addrSelectA
);

80581 
pPrior
->
iLimit
 = 
regLimitA
;

80582 
iSub1
 = 
pParse
->
iNextSelectId
;

80583 
	`sqlite3Select
(
pParse
, 
pPrior
, &
destA
);

80584 
	`sqlite3VdbeEndCoroutine
(
v
, 
regAddrA
);

80585 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

80590 
addrSelectB
 = 
	`sqlite3VdbeCurrentAddr
(
v
) + 1;

80591 
addr1
 = 
	`sqlite3VdbeAddOp3
(
v
, 16, 
regAddrB
, 0, 
addrSelectB
);

80593 
savedLimit
 = 
p
->
iLimit
;

80594 
savedOffset
 = 
p
->
iOffset
;

80595 
p
->
iLimit
 = 
regLimitB
;

80596 
p
->
iOffset
 = 0;

80597 
iSub2
 = 
pParse
->
iNextSelectId
;

80598 
	`sqlite3Select
(
pParse
, 
p
, &
destB
);

80599 
p
->
iLimit
 = 
savedLimit
;

80600 
p
->
iOffset
 = 
savedOffset
;

80601 
	`sqlite3VdbeEndCoroutine
(
v
, 
regAddrB
);

80607 
addrOutA
 = 
	`generateOutputSubroutine
(
pParse
,

80608 
p
, &
destA
, 
pDest
, 
regOutA
,

80609 
regPrev
, 
pKeyDup
, 
labelEnd
);

80614 if( 
op
==116 || op==115 )

80618 
addrOutB
 = 
	`generateOutputSubroutine
(
pParse
,

80619 
p
, &
destB
, 
pDest
, 
regOutB
,

80620 
regPrev
, 
pKeyDup
, 
labelEnd
);

80622 
	`sqlite3KeyInfoUnref
(
pKeyDup
);

80627 if( 
op
==117 || op==118 )

80630 
addrEofA_noB
 = 
addrEofA
 = 
labelEnd
;

80633 
addrEofA
 = 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regOutB
, 
addrOutB
);

80634 
addrEofA_noB
 = 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regAddrB
, 
labelEnd
);

80636 
	`sqlite3VdbeGoto
(
v
, 
addrEofA
);

80637 
p
->
nSelectRow
 = 
	`sqlite3LogEstAdd
(p->nSelectRow, 
pPrior
->nSelectRow);

80643 if( 
op
==118 )

80646 
addrEofB
 = 
addrEofA
;

80647 if( 
p
->
nSelectRow
 > 
pPrior
->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;

80650 
addrEofB
 = 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regOutA
, 
addrOutA
);

80651 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regAddrA
, 
labelEnd
); ;

80652 
	`sqlite3VdbeGoto
(
v
, 
addrEofB
);

80658 
addrAltB
 = 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regOutA
, 
addrOutA
);

80659 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regAddrA
, 
addrEofA
); ;

80660 
	`sqlite3VdbeGoto
(
v
, 
labelCmpr
);

80664 if( 
op
==116 )

80667 
addrAeqB
 = 
addrAltB
;

80668 }else if( 
op
==118 )

80671 
addrAeqB
 = 
addrAltB
;

80672 
addrAltB
++;

80675 
addrAeqB
 =

80676 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regAddrA
, 
addrEofA
); ;

80677 
	`sqlite3VdbeGoto
(
v
, 
labelCmpr
);

80683 
addrAgtB
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

80684 if( 
op
==116 || op==115 )

80687 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regOutB
, 
addrOutB
);

80689 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regAddrB
, 
addrEofB
); ;

80690 
	`sqlite3VdbeGoto
(
v
, 
labelCmpr
);

80694 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

80695 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regAddrA
, 
addrEofA_noB
); ;

80696 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regAddrB
, 
addrEofB
); ;

80700 
	`sqlite3VdbeResolveLabel
(
v
, 
labelCmpr
);

80701 
	`sqlite3VdbeAddOp4
(
v
, 41, 0, 0, 0, (char*)
aPermute
, (-15));

80702 
	`sqlite3VdbeAddOp4
(
v
, 42, 
destA
.
iSdst
, 
destB
.iSdst, 
nOrderBy
,

80703 (char*)
pKeyMerge
, (-6));

80704 
	`sqlite3VdbeChangeP5
(
v
, 0x01);

80705 
	`sqlite3VdbeAddOp3
(
v
, 43, 
addrAltB
, 
addrAeqB
, 
addrAgtB
); ;

80709 
	`sqlite3VdbeResolveLabel
(
v
, 
labelEnd
);

80713 if( 
pDest
->
eDest
==9 )

80716 
Select
 *
pFirst
 = 
pPrior
;

80717 while( 
pFirst
->
pPrior
 ) pFirst = pFirst->pPrior;

80718 
	`generateColumnNames
(
pParse
, 
pFirst
->
pSrc
, pFirst->
pEList
);

80723 if( 
p
->
pPrior
 )

80726 
	`sqlite3SelectDelete
(
db
, 
p
->
pPrior
);

80728 
p
->
pPrior
 = pPrior;

80729 
pPrior
->
pNext
 = 
p
;

80733 
	`explainComposite
(
pParse
, 
p
->
op
, 
iSub1
, 
iSub2
, 0);

80734 return 
pParse
->
nErr
!=0;

80735 
	}
}

80740 static void 
substExprList
(
sqlite3
*, 
ExprList
*, int, ExprList*);

80741 static void 
substSelect
(
sqlite3
*, 
Select
 *, int, 
ExprList
*, int);

80743 static 
Expr
 *
	$substExpr
(

80744 
sqlite3
 *
db
,

80745 
Expr
 *
pExpr
,

80746 int 
iTable
,

80747 
ExprList
 *
pEList


80751 if( 
pExpr
==0 ) return 0;

80752 if( 
pExpr
->
op
==152 && pExpr->
iTable
==iTable )

80755 if( 
pExpr
->
iColumn
<0 )

80758 
pExpr
->
op
 = 101;

80760 
Expr
 *
pNew
;

80763 
pNew
 = 
	`sqlite3ExprDup
(
db
, 
pEList
->
a
[
pExpr
->
iColumn
].pExpr, 0);

80764 
	`sqlite3ExprDelete
(
db
, 
pExpr
);

80765 
pExpr
 = 
pNew
;

80768 
pExpr
->
pLeft
 = 
	`substExpr
(
db
, pExpr->pLeft, 
iTable
, 
pEList
);

80769 
pExpr
->
pRight
 = 
	`substExpr
(
db
, pExpr->pRight, 
iTable
, 
pEList
);

80770 if( (((
pExpr
)->
flags
&(0x000800))!=0) )

80773 
	`substSelect
(
db
, 
pExpr
->
x
.
pSelect
, 
iTable
, 
pEList
, 1);

80775 
	`substExprList
(
db
, 
pExpr
->
x
.
pList
, 
iTable
, 
pEList
);

80778 return 
pExpr
;

80779 
	}
}

80780 static void 
	$substExprList
(

80781 
sqlite3
 *
db
,

80782 
ExprList
 *
pList
,

80783 int 
iTable
,

80784 
ExprList
 *
pEList


80788 int 
i
;

80789 if( 
pList
==0 ) return;

80790 for(
i
=0; i<
pList
->
nExpr
; i++)

80793 
pList
->
a
[
i
].
pExpr
 = 
	`substExpr
(
db
, pList->a[i].pExpr, 
iTable
, 
pEList
);

80795 
	}
}

80796 static void 
	$substSelect
(

80797 
sqlite3
 *
db
,

80798 
Select
 *
p
,

80799 int 
iTable
,

80800 
ExprList
 *
pEList
,

80801 int 
doPrior


80805 
SrcList
 *
pSrc
;

80806 struct 
SrcList_item
 *
pItem
;

80807 int 
i
;

80808 if( !
p
 ) return;

80810 
	`substExprList
(
db
, 
p
->
pEList
, 
iTable
, pEList);

80811 
	`substExprList
(
db
, 
p
->
pGroupBy
, 
iTable
, 
pEList
);

80812 
	`substExprList
(
db
, 
p
->
pOrderBy
, 
iTable
, 
pEList
);

80813 
p
->
pHaving
 = 
	`substExpr
(
db
, p->pHaving, 
iTable
, 
pEList
);

80814 
p
->
pWhere
 = 
	`substExpr
(
db
, p->pWhere, 
iTable
, 
pEList
);

80815 
pSrc
 = 
p
->pSrc;

80817 for(
i
=
pSrc
->
nSrc
, 
pItem
=pSrc->
a
; i>0; i--, pItem++)

80820 
	`substSelect
(
db
, 
pItem
->
pSelect
, 
iTable
, 
pEList
, 1);

80821 if( 
pItem
->
fg
.
isTabFunc
 )

80824 
	`substExprList
(
db
, 
pItem
->
u1
.
pFuncArg
, 
iTable
, 
pEList
);

80827 }while( 
doPrior
 && (
p
 = p->
pPrior
)!=0 );

80828 
	}
}

80830 static int 
	$flattenSubquery
(

80831 
Parse
 *
pParse
,

80832 
Select
 *
p
,

80833 int 
iFrom
,

80834 int 
isAgg
,

80835 int 
subqueryIsAgg


80839 const char *
zSavedAuthContext
 = 
pParse
->
zAuthContext
;

80840 
Select
 *
pParent
;

80841 
Select
 *
pSub
;

80842 
Select
 *
pSub1
;

80843 
SrcList
 *
pSrc
;

80844 
SrcList
 *
pSubSrc
;

80845 
ExprList
 *
pList
;

80846 int 
iParent
;

80847 int 
i
;

80848 
Expr
 *
pWhere
;

80849 struct 
SrcList_item
 *
pSubitem
;

80850 
sqlite3
 *
db
 = 
pParse
->db;

80856 if( (((
db
)->
dbOptFlags
&(0x0001))!=0) ) return 0;

80857 
pSrc
 = 
p
->pSrc;

80859 
pSubitem
 = &
pSrc
->
a
[
iFrom
];

80860 
iParent
 = 
pSubitem
->
iCursor
;

80861 
pSub
 = 
pSubitem
->
pSelect
;

80863 if( 
subqueryIsAgg
 )

80866 if( 
isAgg
 ) return 0;

80867 if( 
pSrc
->
nSrc
>1 ) return 0;

80868 if( (
p
->
pWhere
 && (((p->pWhere)->
flags
&(0x200000))!=0))

80869 || (
	`sqlite3ExprListFlags
(
p
->
pEList
) & 0x200000)!=0

80870 || (
	`sqlite3ExprListFlags
(
p
->
pOrderBy
) & 0x200000)!=0

80878 
pSubSrc
 = 
pSub
->
pSrc
;

80885 if( 
pSub
->
pLimit
 && 
p
->pLimit ) return 0;

80886 if( 
pSub
->
pOffset
 ) return 0;

80887 if( (
p
->
selFlags
 & 0x00080)!=0 && 
pSub
->
pLimit
 )

80892 if( 
pSubSrc
->
nSrc
==0 ) return 0;

80893 if( 
pSub
->
selFlags
 & 0x00001 ) return 0;

80894 if( 
pSub
->
pLimit
 && (
pSrc
->
nSrc
>1 || 
isAgg
) )

80899 if( (
p
->
selFlags
 & 0x00001)!=0 && 
subqueryIsAgg
 )

80904 if( 
p
->
pOrderBy
 && 
pSub
->pOrderBy )

80909 if( 
isAgg
 && 
pSub
->
pOrderBy
 ) return 0;

80910 if( 
pSub
->
pLimit
 && 
p
->
pWhere
 ) return 0;

80911 if( 
pSub
->
pLimit
 && (
p
->
selFlags
 & 0x00001)!=0 )

80918 if( 
pSub
->
selFlags
 & (0x02000|0x01000) )

80923 if( (
p
->
selFlags
 & 0x02000) && 
pSub
->
pPrior
 )

80929 if( (
pSubitem
->
fg
.
jointype
 & 0x0020)!=0 )

80940 if( 
pSub
->
pPrior
 )

80943 if( 
pSub
->
pOrderBy
 )

80948 if( 
isAgg
 || (
p
->
selFlags
 & 0x00001)!=0 || 
pSrc
->
nSrc
!=1 )

80953 for(
pSub1
=
pSub
; pSub1; pSub1=pSub1->
pPrior
)

80960 if( (
pSub1
->
selFlags
 & (0x00001|0x00008))!=0

80961 || (
pSub1
->
pPrior
 && pSub1->
op
!=116)

80962 || 
pSub1
->
pSrc
->
nSrc
<1

80972 if( 
p
->
pOrderBy
 )

80975 int 
ii
;

80976 for(
ii
=0; ii<
p
->
pOrderBy
->
nExpr
; ii++)

80979 if( 
p
->
pOrderBy
->
a
[
ii
].
u
.
x
.
iOrderByCol
==0 ) return 0;

80989 
pParse
->
zAuthContext
 = 
pSubitem
->
zName
;

80990 
	`sqlite3AuthCheck
(
pParse
, 21, 0, 0, 0);

80992 
pParse
->
zAuthContext
 = 
zSavedAuthContext
;

80994 for(
pSub
=pSub->
pPrior
; pSub; pSub=pSub->pPrior)

80997 
Select
 *
pNew
;

80998 
ExprList
 *
pOrderBy
 = 
p
->pOrderBy;

80999 
Expr
 *
pLimit
 = 
p
->pLimit;

81000 
Expr
 *
pOffset
 = 
p
->pOffset;

81001 
Select
 *
pPrior
 = 
p
->pPrior;

81002 
p
->
pOrderBy
 = 0;

81003 
p
->
pSrc
 = 0;

81004 
p
->
pPrior
 = 0;

81005 
p
->
pLimit
 = 0;

81006 
p
->
pOffset
 = 0;

81007 
pNew
 = 
	`sqlite3SelectDup
(
db
, 
p
, 0);

81009 
p
->
pOffset
 = pOffset;

81010 
p
->
pLimit
 = pLimit;

81011 
p
->
pOrderBy
 = pOrderBy;

81012 
p
->
pSrc
 = pSrc;

81013 
p
->
op
 = 116;

81014 if( 
pNew
==0 )

81017 
p
->
pPrior
 = pPrior;

81019 
pNew
->
pPrior
 = pPrior;

81020 if( 
pPrior
 ) pPrior->
pNext
 = 
pNew
;

81021 
pNew
->
pNext
 = 
p
;

81022 
p
->
pPrior
 = 
pNew
;

81027 if( 
db
->
mallocFailed
 ) return 1;

81033 
pSub
 = 
pSub1
 = 
pSubitem
->
pSelect
;

81038 
	`sqlite3DbFree
(
db
, 
pSubitem
->
zDatabase
);

81039 
	`sqlite3DbFree
(
db
, 
pSubitem
->
zName
);

81040 
	`sqlite3DbFree
(
db
, 
pSubitem
->
zAlias
);

81041 
pSubitem
->
zDatabase
 = 0;

81042 
pSubitem
->
zName
 = 0;

81043 
pSubitem
->
zAlias
 = 0;

81044 
pSubitem
->
pSelect
 = 0;

81046 if( (
pSubitem
->
pTab
!=0) )

81049 
Table
 *
pTabToDel
 = 
pSubitem
->
pTab
;

81050 if( 
pTabToDel
->
nRef
==1 )

81053 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

81054 
pTabToDel
->
pNextZombie
 = 
pToplevel
->
pZombieTab
;

81055 
pToplevel
->
pZombieTab
 = 
pTabToDel
;

81057 
pTabToDel
->
nRef
--;

81059 
pSubitem
->
pTab
 = 0;

81062 for(
pParent
=
p
; pParent; pParent=pParent->
pPrior
, 
pSub
=pSub->pPrior)

81065 int 
nSubSrc
;

81066 
u8
 
jointype
 = 0;

81067 
pSubSrc
 = 
pSub
->
pSrc
;

81068 
nSubSrc
 = 
pSubSrc
->
nSrc
;

81069 
pSrc
 = 
pParent
->pSrc;

81071 if( 
pSrc
 )

81075 
jointype
 = 
pSubitem
->
fg
.jointype;

81078 
pSrc
 = 
pParent
->pSrc = 
	`sqlite3SrcListAppend
(
db
, 0, 0, 0);

81079 if( 
pSrc
==0 )

81087 if( 
nSubSrc
>1 )

81090 
pParent
->
pSrc
 = pSrc = 
	`sqlite3SrcListEnlarge
(
db
, pSrc, 
nSubSrc
-1,
iFrom
+1);

81091 if( 
db
->
mallocFailed
 )

81101 for(
i
=0; i<
nSubSrc
; i++)

81104 
	`sqlite3IdListDelete
(
db
, 
pSrc
->
a
[
i
+
iFrom
].
pUsing
);

81106 
pSrc
->
a
[
i
+
iFrom
] = 
pSubSrc
->a[i];

81107 
	`memset
(&
pSubSrc
->
a
[
i
], 0, sizeof(pSubSrc->a[i]));

81109 
pSrc
->
a
[
iFrom
].
fg
.
jointype
 = jointype;

81111 
pList
 = 
pParent
->
pEList
;

81112 for(
i
=0; i<
pList
->
nExpr
; i++)

81115 if( 
pList
->
a
[
i
].
zName
==0 )

81118 char *
zName
 = 
	`sqlite3DbStrDup
(
db
, 
pList
->
a
[
i
].
zSpan
);

81119 
	`sqlite3Dequote
(
zName
);

81120 
pList
->
a
[
i
].
zName
 = zName;

81123 if( 
pSub
->
pOrderBy
 )

81127 
ExprList
 *
pOrderBy
 = 
pSub
->pOrderBy;

81128 for(
i
=0; i<
pOrderBy
->
nExpr
; i++)

81131 
pOrderBy
->
a
[
i
].
u
.
x
.
iOrderByCol
 = 0;

81135 
pParent
->
pOrderBy
 = pOrderBy;

81136 
pSub
->
pOrderBy
 = 0;

81138 
pWhere
 = 
	`sqlite3ExprDup
(
db
, 
pSub
->pWhere, 0);

81139 if( 
subqueryIsAgg
 )

81143 
pParent
->
pHaving
 = pParent->
pWhere
;

81144 
pParent
->
pWhere
 = pWhere;

81145 
pParent
->
pHaving
 = 
	`sqlite3ExprAnd
(
db
, pParent->pHaving,

81146 
	`sqlite3ExprDup
(
db
, 
pSub
->
pHaving
, 0));

81148 
pParent
->
pGroupBy
 = 
	`sqlite3ExprListDup
(
db
, 
pSub
->pGroupBy, 0);

81150 
pParent
->
pWhere
 = 
	`sqlite3ExprAnd
(
db
, pParent->pWhere, pWhere);

81152 
	`substSelect
(
db
, 
pParent
, 
iParent
, 
pSub
->
pEList
, 0);

81157 
pParent
->
selFlags
 |= 
pSub
->selFlags & 0x00001;

81165 if( 
pSub
->
pLimit
 )

81168 
pParent
->
pLimit
 = 
pSub
->pLimit;

81169 
pSub
->
pLimit
 = 0;

81176 
	`sqlite3SelectDelete
(
db
, 
pSub1
);

81179 
	}
}

81181 static int 
	$pushDownWhereTerms
(

81182 
sqlite3
 *
db
,

81183 
Select
 *
pSubq
,

81184 
Expr
 *
pWhere
,

81185 int 
iCursor


81189 
Expr
 *
pNew
;

81190 int 
nChng
 = 0;

81191 if( 
pWhere
==0 ) return 0;

81192 if( (
pSubq
->
selFlags
 & (0x00008|0x02000))!=0 )

81197 if( 
pSubq
->
pLimit
!=0 )

81202 while( 
pWhere
->
op
==72 )

81205 
nChng
 += 
	`pushDownWhereTerms
(
db
, 
pSubq
, 
pWhere
->
pRight
, 
iCursor
);

81206 
pWhere
 = pWhere->
pLeft
;

81208 if( (((
pWhere
)->
flags
&(0x000001))!=0) ) return 0;

81209 if( 
	`sqlite3ExprIsTableConstant
(
pWhere
, 
iCursor
) )

81212 
nChng
++;

81213 while( 
pSubq
 )

81216 
pNew
 = 
	`sqlite3ExprDup
(
db
, 
pWhere
, 0);

81217 
pNew
 = 
	`substExpr
(
db
, pNew, 
iCursor
, 
pSubq
->
pEList
);

81218 
pSubq
->
pWhere
 = 
	`sqlite3ExprAnd
(
db
, pSubq->pWhere, 
pNew
);

81219 
pSubq
 = pSubq->
pPrior
;

81222 return 
nChng
;

81223 
	}
}

81225 static 
u8
 
	$minMaxQuery
(
AggInfo
 *
pAggInfo
, 
ExprList
 **
ppMinMax
)

81228 int 
eRet
 = 0x0000;

81230 *
ppMinMax
 = 0;

81231 if( 
pAggInfo
->
nFunc
==1 )

81234 
Expr
 *
pExpr
 = 
pAggInfo
->
aFunc
[0].pExpr;

81235 
ExprList
 *
pEList
 = 
pExpr
->
x
.
pList
;

81238 if( 
pEList
 && pEList->
nExpr
==1 && pEList->
a
[0].
pExpr
->
op
==154 )

81241 const char *
zFunc
 = 
pExpr
->
u
.
zToken
;

81242 if( 
	`sqlite3StrICmp
(
zFunc
, "min")==0 )

81245 
eRet
 = 0x0001;

81246 *
ppMinMax
 = 
pEList
;

81247 }else if( 
	`sqlite3StrICmp
(
zFunc
, "max")==0 )

81250 
eRet
 = 0x0002;

81251 *
ppMinMax
 = 
pEList
;

81257 return 
eRet
;

81258 
	}
}

81260 static 
Table
 *
	$isSimpleCount
(
Select
 *
p
, 
AggInfo
 *
pAggInfo
)

81263 
Table
 *
pTab
;

81264 
Expr
 *
pExpr
;

81268 if( 
p
->
pWhere
 || p->
pEList
->
nExpr
!=1

81269 || 
p
->
pSrc
->
nSrc
!=1 || p->pSrc->
a
[0].
pSelect


81275 
pTab
 = 
p
->
pSrc
->
a
[0].pTab;

81276 
pExpr
 = 
p
->
pEList
->
a
[0].pExpr;

81279 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) ) return 0;

81280 if( 
pExpr
->
op
!=153 ) return 0;

81281 if( (
pAggInfo
->
nFunc
==0) ) return 0;

81282 if( (
pAggInfo
->
aFunc
[0].
pFunc
->
funcFlags
&0x0100)==0 ) return 0;

81283 if( 
pExpr
->
flags
&0x000010 ) return 0;

81285 return 
pTab
;

81286 
	}
}

81288 static int 
	$sqlite3IndexedByLookup
(
Parse
 *
pParse
, struct 
SrcList_item
 *
pFrom
)

81291 if( 
pFrom
->
pTab
 && pFrom->
fg
.
isIndexedBy
 )

81294 
Table
 *
pTab
 = 
pFrom
->pTab;

81295 char *
zIndexedBy
 = 
pFrom
->
u1
.zIndexedBy;

81296 
Index
 *
pIdx
;

81297 for(
pIdx
=
pTab
->
pIndex
;

81298 
pIdx
 && 
	`sqlite3StrICmp
(pIdx->
zName
, 
zIndexedBy
);

81299 
pIdx
=pIdx->
pNext


81301 if( !
pIdx
 )

81304 
	`sqlite3ErrorMsg
(
pParse
, "no such index: %s", 
zIndexedBy
, 0);

81305 
pParse
->
checkSchema
 = 1;

81308 
pFrom
->
pIBIndex
 = 
pIdx
;

81311 
	}
}

81313 static int 
	$convertCompoundSelectToSubquery
(
Walker
 *
pWalker
, 
Select
 *
p
)

81316 int 
i
;

81317 
Select
 *
pNew
;

81318 
Select
 *
pX
;

81319 
sqlite3
 *
db
;

81320 struct 
ExprList_item
 *
a
;

81321 
SrcList
 *
pNewSrc
;

81322 
Parse
 *
pParse
;

81323 
Token
 
dummy
;

81325 if( 
p
->
pPrior
==0 ) return 0;

81326 if( 
p
->
pOrderBy
==0 ) return 0;

81327 for(
pX
=
p
; pX && (pX->
op
==116 || pX->op==119); pX=pX->
pPrior
)

81330 if( 
pX
==0 ) return 0;

81331 
a
 = 
p
->
pOrderBy
->a;

81332 for(
i
=
p
->
pOrderBy
->
nExpr
-1; i>=0; i--)

81335 if( 
a
[
i
].
pExpr
->
flags
 & 0x000100 ) break;

81337 if( 
i
<0 ) return 0;

81341 
pParse
 = 
pWalker
->pParse;

81342 
db
 = 
pParse
->db;

81343 
pNew
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(*pNew) );

81344 if( 
pNew
==0 ) return 2;

81345 
	`memset
(&
dummy
, 0, sizeof(dummy));

81346 
pNewSrc
 = 
	`sqlite3SrcListAppendFromTerm
(
pParse
,0,0,0,&
dummy
,
pNew
,0,0);

81347 if( 
pNewSrc
==0 ) return 2;

81348 *
pNew
 = *
p
;

81349 
p
->
pSrc
 = 
pNewSrc
;

81350 
p
->
pEList
 = 
	`sqlite3ExprListAppend
(
pParse
, 0, 
	`sqlite3Expr
(
db
, 158, 0));

81351 
p
->
op
 = 119;

81352 
p
->
pWhere
 = 0;

81353 
pNew
->
pGroupBy
 = 0;

81354 
pNew
->
pHaving
 = 0;

81355 
pNew
->
pOrderBy
 = 0;

81356 
p
->
pPrior
 = 0;

81357 
p
->
pNext
 = 0;

81358 
p
->
pWith
 = 0;

81359 
p
->
selFlags
 &= ~0x00080;

81361 
p
->
selFlags
 |= 0x08000;

81363 
pNew
->
pPrior
->
pNext
 = pNew;

81364 
pNew
->
pLimit
 = 0;

81365 
pNew
->
pOffset
 = 0;

81367 
	}
}

81374 static int 
	$cannotBeFunction
(
Parse
 *
pParse
, struct 
SrcList_item
 *
pFrom
)

81377 if( 
pFrom
->
fg
.
isTabFunc
 )

81380 
	`sqlite3ErrorMsg
(
pParse
, "'%s' is not a function", 
pFrom
->
zName
);

81384 
	}
}

81386 static struct 
Cte
 *
	$searchWith
(

81387 
With
 *
pWith
,

81388 struct 
SrcList_item
 *
pItem
,

81389 
With
 **
ppContext


81393 const char *
zName
;

81394 if( 
pItem
->
zDatabase
==0 && (
zName
 = pItem->zName)!=0 )

81397 
With
 *
p
;

81398 for(
p
=
pWith
; p; p=p->
pOuter
)

81401 int 
i
;

81402 for(
i
=0; i<
p
->
nCte
; i++)

81405 if( 
	`sqlite3StrICmp
(
zName
, 
p
->
a
[
i
].zName)==0 )

81408 *
ppContext
 = 
p
;

81409 return &
p
->
a
[
i
];

81415 
	}
}

81417 static void 
	$sqlite3WithPush
(
Parse
 *
pParse
, 
With
 *
pWith
, 
u8
 
bFree
)

81421 if( 
pWith
 )

81425 
pWith
->
pOuter
 = 
pParse
->pWith;

81426 
pParse
->
pWith
 = pWith;

81427 if( 
bFree
 ) 
pParse
->
pWithToFree
 = 
pWith
;

81429 
	}
}

81431 static int 
	$withExpand
(

81432 
Walker
 *
pWalker
,

81433 struct 
SrcList_item
 *
pFrom


81437 
Parse
 *
pParse
 = 
pWalker
->pParse;

81438 
sqlite3
 *
db
 = 
pParse
->db;

81439 struct 
Cte
 *
pCte
;

81440 
With
 *
pWith
;

81444 
pCte
 = 
	`searchWith
(
pParse
->
pWith
, 
pFrom
, &pWith);

81445 if( 
pCte
 )

81448 
Table
 *
pTab
;

81449 
ExprList
 *
pEList
;

81450 
Select
 *
pSel
;

81451 
Select
 *
pLeft
;

81452 int 
bMayRecursive
;

81453 
With
 *
pSavedWith
;

81459 if( 
pCte
->
zCteErr
 )

81462 
	`sqlite3ErrorMsg
(
pParse
, 
pCte
->
zCteErr
, pCte->
zName
);

81465 if( 
	`cannotBeFunction
(
pParse
, 
pFrom
) ) return 1;

81468 
pFrom
->
pTab
 = pTab = 
	`sqlite3DbMallocZero
(
db
, sizeof(
Table
));

81469 if( 
pTab
==0 ) return 2;

81470 
pTab
->
nRef
 = 1;

81471 
pTab
->
zName
 = 
	`sqlite3DbStrDup
(
db
, 
pCte
->zName);

81472 
pTab
->
iPKey
 = -1;

81473 
pTab
->
nRowLogEst
 = 200; ((void) (0));

81474 
pTab
->
tabFlags
 |= 0x02 | 0x40;

81475 
pFrom
->
pSelect
 = 
	`sqlite3SelectDup
(
db
, 
pCte
->pSelect, 0);

81476 if( 
db
->
mallocFailed
 ) return 7;

81480 
pSel
 = 
pFrom
->
pSelect
;

81481 
bMayRecursive
 = ( 
pSel
->
op
==116 || pSel->op==115 );

81482 if( 
bMayRecursive
 )

81485 int 
i
;

81486 
SrcList
 *
pSrc
 = 
pFrom
->
pSelect
->pSrc;

81487 for(
i
=0; i<
pSrc
->
nSrc
; i++)

81490 struct 
SrcList_item
 *
pItem
 = &
pSrc
->
a
[
i
];

81491 if( 
pItem
->
zDatabase
==0

81492 && 
pItem
->
zName
!=0

81493 && 0==
	`sqlite3StrICmp
(
pItem
->
zName
, 
pCte
->zName)

81497 
pItem
->
pTab
 = pTab;

81498 
pItem
->
fg
.
isRecursive
 = 1;

81499 
pTab
->
nRef
++;

81500 
pSel
->
selFlags
 |= 0x02000;

81506 if( 
pTab
->
nRef
>2 )

81509 
	`sqlite3ErrorMsg
(

81510 
pParse
, "multiple references to recursive table: %s", 
pCte
->
zName


81516 
pCte
->
zCteErr
 = "circular reference: %s";

81517 
pSavedWith
 = 
pParse
->
pWith
;

81518 
pParse
->
pWith
 = pWith;

81519 
	`sqlite3WalkSelect
(
pWalker
, 
bMayRecursive
 ? 
pSel
->
pPrior
 : pSel);

81520 
pParse
->
pWith
 = pWith;

81522 for(
pLeft
=
pSel
; pLeft->
pPrior
; pLeft=pLeft->pPrior);

81523 
pEList
 = 
pLeft
->pEList;

81524 if( 
pCte
->
pCols
 )

81527 if( 
pEList
 && pEList->
nExpr
!=
pCte
->
pCols
->nExpr )

81530 
	`sqlite3ErrorMsg
(
pParse
, "table %s has %d values for %d columns",

81531 
pCte
->
zName
, 
pEList
->
nExpr
, pCte->
pCols
->nExpr

81533 
pParse
->
pWith
 = 
pSavedWith
;

81536 
pEList
 = 
pCte
->
pCols
;

81539 
	`sqlite3ColumnsFromExprList
(
pParse
, 
pEList
, &
pTab
->
nCol
, &pTab->
aCol
);

81540 if( 
bMayRecursive
 )

81543 if( 
pSel
->
selFlags
 & 0x02000 )

81546 
pCte
->
zCteErr
 = "multiple recursive references: %s";

81548 
pCte
->
zCteErr
 = "recursive reference in a subquery: %s";

81550 
	`sqlite3WalkSelect
(
pWalker
, 
pSel
);

81552 
pCte
->
zCteErr
 = 0;

81553 
pParse
->
pWith
 = 
pSavedWith
;

81557 
	}
}

81559 static void 
	$selectPopWith
(
Walker
 *
pWalker
, 
Select
 *
p
)

81562 
Parse
 *
pParse
 = 
pWalker
->pParse;

81563 
With
 *
pWith
 = 
	`findRightmost
(
p
)->pWith;

81564 if( 
pWith
!=0 )

81568 
pParse
->
pWith
 = pWith->
pOuter
;

81570 
	}
}

81572 static int 
	$selectExpander
(
Walker
 *
pWalker
, 
Select
 *
p
)

81575 
Parse
 *
pParse
 = 
pWalker
->pParse;

81576 int 
i
, 
j
, 
k
;

81577 
SrcList
 *
pTabList
;

81578 
ExprList
 *
pEList
;

81579 struct 
SrcList_item
 *
pFrom
;

81580 
sqlite3
 *
db
 = 
pParse
->db;

81581 
Expr
 *
pE
, *
pRight
, *
pExpr
;

81582 
u16
 
selFlags
 = 
p
->selFlags;

81584 
p
->
selFlags
 |= 0x00020;

81585 if( 
db
->
mallocFailed
 )

81590 if( (
p
->
pSrc
==0) || (
selFlags
 & 0x00020)!=0 )

81595 
pTabList
 = 
p
->
pSrc
;

81596 
pEList
 = 
p
->pEList;

81597 if( 
pWalker
->
xSelectCallback2
==
selectPopWith
 )

81600 
	`sqlite3WithPush
(
pParse
, 
	`findRightmost
(
p
)->
pWith
, 0);

81606 
	`sqlite3SrcListAssignCursors
(
pParse
, 
pTabList
);

81612 for(
i
=0, 
pFrom
=
pTabList
->
a
; i<pTabList->
nSrc
; i++, pFrom++)

81615 
Table
 *
pTab
;

81617 if( 
pFrom
->
fg
.
isRecursive
 ) continue;

81620 if( 
	`withExpand
(
pWalker
, 
pFrom
) ) return 2;

81621 if( 
pFrom
->
pTab
 ) {} else

81623 if( 
pFrom
->
zName
==0 )

81627 
Select
 *
pSel
 = 
pFrom
->
pSelect
;

81631 if( 
	`sqlite3WalkSelect
(
pWalker
, 
pSel
) ) return 2;

81632 
pFrom
->
pTab
 = pTab = 
	`sqlite3DbMallocZero
(
db
, sizeof(
Table
));

81633 if( 
pTab
==0 ) return 2;

81634 
pTab
->
nRef
 = 1;

81635 
pTab
->
zName
 = 
	`sqlite3MPrintf
(
db
, "sqlite_sq_%p", (void*)pTab);

81636 while( 
pSel
->
pPrior
 )

81638 
pSel
 = pSel->
pPrior
; }

81639 
	`sqlite3ColumnsFromExprList
(
pParse
, 
pSel
->
pEList
,&
pTab
->
nCol
,&pTab->
aCol
);

81640 
pTab
->
iPKey
 = -1;

81641 
pTab
->
nRowLogEst
 = 200; ((void) (0));

81642 
pTab
->
tabFlags
 |= 0x02;

81647 
pFrom
->
pTab
 = pTab = 
	`sqlite3LocateTableItem
(
pParse
, 0, pFrom);

81648 if( 
pTab
==0 ) return 2;

81649 if( 
pTab
->
nRef
==0xffff )

81652 
	`sqlite3ErrorMsg
(
pParse
, "too many references to \"%s\": max 65535",

81653 
pTab
->
zName
);

81654 
pFrom
->
pTab
 = 0;

81657 
pTab
->
nRef
++;

81658 if( !(((
pTab
)->
tabFlags
 & 0x10)!=0) && 
	`cannotBeFunction
(
pParse
, 
pFrom
) )

81664 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) || pTab->
pSelect
 )

81667 
i16
 
nCol
;

81668 if( 
	`sqlite3ViewGetColumnNames
(
pParse
, 
pTab
) ) return 2;

81670 
pFrom
->
pSelect
 = 
	`sqlite3SelectDup
(
db
, 
pTab
->pSelect, 0);

81672 
nCol
 = 
pTab
->nCol;

81673 
pTab
->
nCol
 = -1;

81674 
	`sqlite3WalkSelect
(
pWalker
, 
pFrom
->
pSelect
);

81675 
pTab
->
nCol
 = nCol;

81681 if( 
	`sqlite3IndexedByLookup
(
pParse
, 
pFrom
) )

81690 if( 
db
->
mallocFailed
 || 
	`sqliteProcessJoin
(
pParse
, 
p
) )

81696 for(
k
=0; k<
pEList
->
nExpr
; k++)

81699 
pE
 = 
pEList
->
a
[
k
].
pExpr
;

81700 if( 
pE
->
op
==158 ) break;

81703 if( 
pE
->
op
==122 && pE->
pRight
->op==158 ) break;

81705 if( 
k
<
pEList
->
nExpr
 )

81713 struct 
ExprList_item
 *
a
 = 
pEList
->a;

81714 
ExprList
 *
pNew
 = 0;

81715 int 
flags
 = 
pParse
->
db
->flags;

81716 int 
longNames
 = (
flags
 & 0x00000004)!=0

81717 && (
flags
 & 0x00000040)==0;

81719 for(
k
=0; k<
pEList
->
nExpr
; k++)

81722 
pE
 = 
a
[
k
].
pExpr
;

81723 
pRight
 = 
pE
->pRight;

81725 if( 
pE
->
op
!=158

81726 && (
pE
->
op
!=122 || 
pRight
->op!=158)

81732 
pNew
 = 
	`sqlite3ExprListAppend
(
pParse
, pNew, 
a
[
k
].
pExpr
);

81733 if( 
pNew
 )

81736 
pNew
->
a
[pNew->
nExpr
-1].
zName
 = a[
k
].zName;

81737 
pNew
->
a
[pNew->
nExpr
-1].
zSpan
 = a[
k
].zSpan;

81738 
a
[
k
].
zName
 = 0;

81739 
a
[
k
].
zSpan
 = 0;

81741 
a
[
k
].
pExpr
 = 0;

81745 int 
tableSeen
 = 0;

81746 char *
zTName
 = 0;

81747 if( 
pE
->
op
==122 )

81752 
zTName
 = 
pE
->
pLeft
->
u
.
zToken
;

81754 for(
i
=0, 
pFrom
=
pTabList
->
a
; i<pTabList->
nSrc
; i++, pFrom++)

81757 
Table
 *
pTab
 = 
pFrom
->pTab;

81758 
Select
 *
pSub
 = 
pFrom
->
pSelect
;

81759 char *
zTabName
 = 
pFrom
->
zAlias
;

81760 const char *
zSchemaName
 = 0;

81761 int 
iDb
;

81762 if( 
zTabName
==0 )

81765 
zTabName
 = 
pTab
->
zName
;

81767 if( 
db
->
mallocFailed
 ) break;

81768 if( 
pSub
==0 || (pSub->
selFlags
 & 0x00400)==0 )

81771 
pSub
 = 0;

81772 if( 
zTName
 && 
	`sqlite3StrICmp
(zTName, 
zTabName
)!=0 )

81777 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

81778 
zSchemaName
 = 
iDb
>=0 ? 
db
->
aDb
[iDb].
zName
 : "*";

81780 for(
j
=0; j<
pTab
->
nCol
; j++)

81783 char *
zName
 = 
pTab
->
aCol
[
j
].zName;

81784 char *
zColname
;

81785 char *
zToFree
;

81786 
Token
 
sColname
;

81789 if( 
zTName
 && 
pSub


81790 && 
	`sqlite3MatchSpanName
(
pSub
->
pEList
->
a
[
j
].
zSpan
, 0, 
zTName
, 0)==0

81801 if( (
p
->
selFlags
 & 0x10000)==0

81802 && (((&
pTab
->
aCol
[
j
])->
colFlags
 & 0x0002)!=0)

81808 
tableSeen
 = 1;

81810 if( 
i
>0 && 
zTName
==0 )

81813 if( (
pFrom
->
fg
.
jointype
 & 0x0004)!=0

81814 && 
	`tableAndColumnIndex
(
pTabList
, 
i
, 
zName
, 0, 0)

81822 if( 
	`sqlite3IdListIndex
(
pFrom
->
pUsing
, 
zName
)>=0 )

81830 
pRight
 = 
	`sqlite3Expr
(
db
, 27, 
zName
);

81831 
zColname
 = 
zName
;

81832 
zToFree
 = 0;

81833 if( 
longNames
 || 
pTabList
->
nSrc
>1 )

81836 
Expr
 *
pLeft
;

81837 
pLeft
 = 
	`sqlite3Expr
(
db
, 27, 
zTabName
);

81838 
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 122, 
pLeft
, 
pRight
, 0);

81839 if( 
zSchemaName
 )

81842 
pLeft
 = 
	`sqlite3Expr
(
db
, 27, 
zSchemaName
);

81843 
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 122, 
pLeft
, pExpr, 0);

81845 if( 
longNames
 )

81848 
zColname
 = 
	`sqlite3MPrintf
(
db
, "%s.%s", 
zTabName
, 
zName
);

81849 
zToFree
 = 
zColname
;

81852 
pExpr
 = 
pRight
;

81854 
pNew
 = 
	`sqlite3ExprListAppend
(
pParse
, pNew, 
pExpr
);

81855 
	`sqlite3TokenInit
(&
sColname
, 
zColname
);

81856 
	`sqlite3ExprListSetName
(
pParse
, 
pNew
, &
sColname
, 0);

81857 if( 
pNew
 && (
p
->
selFlags
 & 0x00400)!=0 )

81860 struct 
ExprList_item
 *
pX
 = &
pNew
->
a
[pNew->
nExpr
-1];

81861 if( 
pSub
 )

81864 
pX
->
zSpan
 = 
	`sqlite3DbStrDup
(
db
, 
pSub
->
pEList
->
a
[
j
].zSpan);

81867 
pX
->
zSpan
 = 
	`sqlite3MPrintf
(
db
, "%s.%s.%s",

81868 
zSchemaName
, 
zTabName
, 
zColname
);

81871 
pX
->
bSpanIsTab
 = 1;

81873 
	`sqlite3DbFree
(
db
, 
zToFree
);

81876 if( !
tableSeen
 )

81879 if( 
zTName
 )

81882 
	`sqlite3ErrorMsg
(
pParse
, "no such table: %s", 
zTName
);

81884 
	`sqlite3ErrorMsg
(
pParse
, "no tables specified");

81889 
	`sqlite3ExprListDelete
(
db
, 
pEList
);

81890 
p
->
pEList
 = 
pNew
;

81893 if( 
p
->
pEList
 && p->pEList->
nExpr
>
db
->
aLimit
[2] )

81896 
	`sqlite3ErrorMsg
(
pParse
, "too many columns in result set");

81901 
	}
}

81903 static int 
	$sqlite3ExprWalkNoop
(
Walker
 *
NotUsed
, 
Expr
 *
NotUsed2
)

81906 (void)(
NotUsed
),(void)(
NotUsed2
);

81908 
	}
}

81910 static void 
	$sqlite3SelectExpand
(
Parse
 *
pParse
, 
Select
 *
pSelect
)

81913 
Walker
 
w
;

81914 
	`memset
(&
w
, 0, sizeof(w));

81915 
w
.
xExprCallback
 = 
sqlite3ExprWalkNoop
;

81916 
w
.
pParse
 = pParse;

81917 if( 
pParse
->
hasCompound
 )

81920 
w
.
xSelectCallback
 = 
convertCompoundSelectToSubquery
;

81921 
	`sqlite3WalkSelect
(&
w
, 
pSelect
);

81923 
w
.
xSelectCallback
 = 
selectExpander
;

81924 if( (
pSelect
->
selFlags
 & 0x00200)==0 )

81927 
w
.
xSelectCallback2
 = 
selectPopWith
;

81929 
	`sqlite3WalkSelect
(&
w
, 
pSelect
);

81930 
	}
}

81932 static void 
	$selectAddSubqueryTypeInfo
(
Walker
 *
pWalker
, 
Select
 *
p
)

81935 
Parse
 *
pParse
;

81936 int 
i
;

81937 
SrcList
 *
pTabList
;

81938 struct 
SrcList_item
 *
pFrom
;

81942 
p
->
selFlags
 |= 0x00040;

81943 
pParse
 = 
pWalker
->pParse;

81944 
pTabList
 = 
p
->
pSrc
;

81945 for(
i
=0, 
pFrom
=
pTabList
->
a
; i<pTabList->
nSrc
; i++, pFrom++)

81948 
Table
 *
pTab
 = 
pFrom
->pTab;

81950 if( (
pTab
->
tabFlags
 & 0x02)!=0 )

81954 
Select
 *
pSel
 = 
pFrom
->
pSelect
;

81955 if( 
pSel
 )

81958 while( 
pSel
->
pPrior
 ) pSel = pSel->pPrior;

81959 
	`selectAddColumnTypeAndCollation
(
pParse
, 
pTab
, 
pSel
);

81963 
	}
}

81965 static void 
	$sqlite3SelectAddTypeInfo
(
Parse
 *
pParse
, 
Select
 *
pSelect
)

81969 
Walker
 
w
;

81970 
	`memset
(&
w
, 0, sizeof(w));

81971 
w
.
xSelectCallback2
 = 
selectAddSubqueryTypeInfo
;

81972 
w
.
xExprCallback
 = 
sqlite3ExprWalkNoop
;

81973 
w
.
pParse
 = pParse;

81974 
	`sqlite3WalkSelect
(&
w
, 
pSelect
);

81976 
	}
}

81978 static void 
	$sqlite3SelectPrep
(

81979 
Parse
 *
pParse
,

81980 
Select
 *
p
,

81981 
NameContext
 *
pOuterNC


81985 
sqlite3
 *
db
;

81986 if( (
p
==0) ) return;

81987 
db
 = 
pParse
->db;

81988 if( 
db
->
mallocFailed
 ) return;

81989 if( 
p
->
selFlags
 & 0x00040 ) return;

81990 
	`sqlite3SelectExpand
(
pParse
, 
p
);

81991 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 ) return;

81992 
	`sqlite3ResolveSelectNames
(
pParse
, 
p
, 
pOuterNC
);

81993 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 ) return;

81994 
	`sqlite3SelectAddTypeInfo
(
pParse
, 
p
);

81995 
	}
}

81997 static void 
	$resetAccumulator
(
Parse
 *
pParse
, 
AggInfo
 *
pAggInfo
)

82000 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

82001 int 
i
;

82002 struct 
AggInfo_func
 *
pFunc
;

82003 int 
nReg
 = 
pAggInfo
->
nFunc
 + pAggInfo->
nColumn
;

82004 if( 
nReg
==0 ) return;

82006 
	`sqlite3VdbeAddOp3
(
v
, 25, 0, 
pAggInfo
->
mnReg
, pAggInfo->
mxReg
);

82007 for(
pFunc
=
pAggInfo
->
aFunc
, 
i
=0; i<pAggInfo->
nFunc
; i++, pFunc++)

82010 if( 
pFunc
->
iDistinct
>=0 )

82013 
Expr
 *
pE
 = 
pFunc
->
pExpr
;

82015 if( 
pE
->
x
.
pList
==0 || pE->x.pList->
nExpr
!=1 )

82018 
	`sqlite3ErrorMsg
(
pParse
, "DISTINCT aggregates must have exactly one "

82020 
pFunc
->
iDistinct
 = -1;

82022 
KeyInfo
 *
pKeyInfo
 = 
	`keyInfoFromExprList
(
pParse
, 
pE
->
x
.
pList
, 0, 0);

82023 
	`sqlite3VdbeAddOp4
(
v
, 57, 
pFunc
->
iDistinct
, 0, 0,

82024 (char*)
pKeyInfo
, (-6));

82028 
	}
}

82034 static void 
	$finalizeAggFunctions
(
Parse
 *
pParse
, 
AggInfo
 *
pAggInfo
)

82037 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

82038 int 
i
;

82039 struct 
AggInfo_func
 *
pF
;

82040 for(
i
=0, 
pF
=
pAggInfo
->
aFunc
; i<pAggInfo->
nFunc
; i++, pF++)

82043 
ExprList
 *
pList
 = 
pF
->
pExpr
->
x
.pList;

82045 
	`sqlite3VdbeAddOp4
(
v
, 145, 
pF
->
iMem
, 
pList
 ? pList->
nExpr
 : 0, 0,

82046 (void*)
pF
->
pFunc
, (-5));

82048 
	}
}

82054 static void 
	$updateAccumulator
(
Parse
 *
pParse
, 
AggInfo
 *
pAggInfo
)

82057 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

82058 int 
i
;

82059 int 
regHit
 = 0;

82060 int 
addrHitTest
 = 0;

82061 struct 
AggInfo_func
 *
pF
;

82062 struct 
AggInfo_col
 *
pC
;

82064 
pAggInfo
->
directMode
 = 1;

82065 for(
i
=0, 
pF
=
pAggInfo
->
aFunc
; i<pAggInfo->
nFunc
; i++, pF++)

82068 int 
nArg
;

82069 int 
addrNext
 = 0;

82070 int 
regAgg
;

82071 
ExprList
 *
pList
 = 
pF
->
pExpr
->
x
.pList;

82073 if( 
pList
 )

82076 
nArg
 = 
pList
->
nExpr
;

82077 
regAgg
 = 
	`sqlite3GetTempRange
(
pParse
, 
nArg
);

82078 
	`sqlite3ExprCodeExprList
(
pParse
, 
pList
, 
regAgg
, 0, 0x01);

82080 
nArg
 = 0;

82081 
regAgg
 = 0;

82083 if( 
pF
->
iDistinct
>=0 )

82086 
addrNext
 = 
	`sqlite3VdbeMakeLabel
(
v
);

82089 
	`codeDistinct
(
pParse
, 
pF
->
iDistinct
, 
addrNext
, 1, 
regAgg
);

82091 if( 
pF
->
pFunc
->
funcFlags
 & 0x0020 )

82094 
CollSeq
 *
pColl
 = 0;

82095 struct 
ExprList_item
 *
pItem
;

82096 int 
j
;

82098 for(
j
=0, 
pItem
=
pList
->
a
; !
pColl
 && j<
nArg
; j++, pItem++)

82101 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pItem
->
pExpr
);

82103 if( !
pColl
 )

82106 
pColl
 = 
pParse
->
db
->
pDfltColl
;

82108 if( 
regHit
==0 && 
pAggInfo
->
nAccumulator
 ) regHit = ++
pParse
->
nMem
;

82109 
	`sqlite3VdbeAddOp4
(
v
, 34, 
regHit
, 0, 0, (char *)
pColl
, (-4));

82111 
	`sqlite3VdbeAddOp4
(
v
, 143, 0, 
regAgg
, 
pF
->
iMem
,

82112 (void*)
pF
->
pFunc
, (-5));

82113 
	`sqlite3VdbeChangeP5
(
v
, (
u8
)
nArg
);

82114 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
regAgg
, 
nArg
);

82115 
	`sqlite3ReleaseTempRange
(
pParse
, 
regAgg
, 
nArg
);

82116 if( 
addrNext
 )

82119 
	`sqlite3VdbeResolveLabel
(
v
, 
addrNext
);

82120 
	`sqlite3ExprCacheClear
(
pParse
);

82124 if( 
regHit
 )

82127 
addrHitTest
 = 
	`sqlite3VdbeAddOp1
(
v
, 45, 
regHit
); ;

82129 
	`sqlite3ExprCacheClear
(
pParse
);

82130 for(
i
=0, 
pC
=
pAggInfo
->
aCol
; i<pAggInfo->
nAccumulator
; i++, pC++)

82133 
	`sqlite3ExprCode
(
pParse
, 
pC
->
pExpr
, pC->
iMem
);

82135 
pAggInfo
->
directMode
 = 0;

82136 
	`sqlite3ExprCacheClear
(
pParse
);

82137 if( 
addrHitTest
 )

82140 
	`sqlite3VdbeJumpHere
(
v
, 
addrHitTest
);

82142 
	}
}

82149 static void 
	$explainSimpleCount
(

82150 
Parse
 *
pParse
,

82151 
Table
 *
pTab
,

82152 
Index
 *
pIdx


82156 if( 
pParse
->
explain
==2 )

82159 int 
bCover
 = (
pIdx
!=0 && ((((
pTab
)->
tabFlags
 & 0x20)==0) || !((pIdx)->
idxType
==2)));

82160 char *
zEqp
 = 
	`sqlite3MPrintf
(
pParse
->
db
, "SCAN TABLE %s%s%s",

82161 
pTab
->
zName
,

82162 
bCover
 ? " USING COVERING INDEX " : "",

82163 
bCover
 ? 
pIdx
->
zName
 : ""

82165 
	`sqlite3VdbeAddOp4
(

82166 
pParse
->
pVdbe
, 161, pParse->
iSelectId
, 0, 0, 
zEqp
, (-1)

82169 
	}
}

82171 static int 
	$sqlite3Select
(

82172 
Parse
 *
pParse
,

82173 
Select
 *
p
,

82174 
SelectDest
 *
pDest


82178 int 
i
, 
j
;

82179 
WhereInfo
 *
pWInfo
;

82180 
Vdbe
 *
v
;

82181 int 
isAgg
;

82182 
ExprList
 *
pEList
 = 0;

82183 
SrcList
 *
pTabList
;

82184 
Expr
 *
pWhere
;

82185 
ExprList
 *
pGroupBy
;

82186 
Expr
 *
pHaving
;

82187 int 
rc
 = 1;

82188 
DistinctCtx
 
sDistinct
;

82189 
SortCtx
 
sSort
;

82190 
AggInfo
 
sAggInfo
;

82191 int 
iEnd
;

82192 
sqlite3
 *
db
;

82195 int 
iRestoreSelectId
 = 
pParse
->
iSelectId
;

82196 
pParse
->
iSelectId
 = pParse->
iNextSelectId
++;

82199 
db
 = 
pParse
->db;

82200 if( 
p
==0 || 
db
->
mallocFailed
 || 
pParse
->
nErr
 )

82205 if( 
	`sqlite3AuthCheck
(
pParse
, 21, 0, 0, 0) ) return 1;

82206 
	`memset
(&
sAggInfo
, 0, sizeof(sAggInfo));

82212 if( ((
pDest
->
eDest
)<=8) )

82221 
	`sqlite3ExprListDelete
(
db
, 
p
->
pOrderBy
);

82222 
p
->
pOrderBy
 = 0;

82223 
p
->
selFlags
 &= ~0x00001;

82225 
	`sqlite3SelectPrep
(
pParse
, 
p
, 0);

82226 
	`memset
(&
sSort
, 0, sizeof(sSort));

82227 
sSort
.
pOrderBy
 = 
p
->pOrderBy;

82228 
pTabList
 = 
p
->
pSrc
;

82229 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 )

82232 goto 
select_end
;

82235 
isAgg
 = (
p
->
selFlags
 & 0x00008)!=0;

82237 if( 
	`checkForMultiColumnSelectError
(
pParse
, 
pDest
, 
p
->
pEList
->
nExpr
) )

82240 goto 
select_end
;

82247 for(
i
=0; !
p
->
pPrior
 && i<
pTabList
->
nSrc
; i++)

82250 struct 
SrcList_item
 *
pItem
 = &
pTabList
->
a
[
i
];

82251 
Select
 *
pSub
 = 
pItem
->
pSelect
;

82252 int 
isAggSub
;

82253 
Table
 *
pTab
 = 
pItem
->pTab;

82254 if( 
pSub
==0 ) continue;

82258 if( 
pTab
->
nCol
!=
pSub
->
pEList
->
nExpr
 )

82261 
	`sqlite3ErrorMsg
(
pParse
, "expected %d columns for '%s' but got %d",

82262 
pTab
->
nCol
, pTab->
zName
, 
pSub
->
pEList
->
nExpr
);

82263 goto 
select_end
;

82266 
isAggSub
 = (
pSub
->
selFlags
 & 0x00008)!=0;

82267 if( 
	`flattenSubquery
(
pParse
, 
p
, 
i
, 
isAgg
, 
isAggSub
) )

82271 if( 
isAggSub
 )

82274 
isAgg
 = 1;

82275 
p
->
selFlags
 |= 0x00008;

82277 
i
 = -1;

82279 
pTabList
 = 
p
->
pSrc
;

82280 if( 
db
->
mallocFailed
 ) goto 
select_end
;

82281 if( !((
pDest
->
eDest
)<=8) )

82284 
sSort
.
pOrderBy
 = 
p
->pOrderBy;

82291 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

82292 if( 
v
==0 ) goto 
select_end
;

82298 if( 
p
->
pPrior
 )

82301 
rc
 = 
	`multiSelect
(
pParse
, 
p
, 
pDest
);

82302 
pParse
->
iSelectId
 = 
iRestoreSelectId
;

82307 return 
rc
;

82314 for(
i
=0; i<
pTabList
->
nSrc
; i++)

82317 struct 
SrcList_item
 *
pItem
 = &
pTabList
->
a
[
i
];

82318 
SelectDest
 
dest
;

82319 
Select
 *
pSub
 = 
pItem
->
pSelect
;

82320 if( 
pSub
==0 ) continue;

82328 if( 
pItem
->
addrFillSub
 )

82331 if( 
pItem
->
fg
.
viaCoroutine
==0 )

82334 
	`sqlite3VdbeAddOp2
(
v
, 14, 
pItem
->
regReturn
, pItem->
addrFillSub
);

82339 
pParse
->
nHeight
 += 
	`sqlite3SelectExprHeight
(
p
);

82344 if( (
pItem
->
fg
.
jointype
 & 0x0020)==0

82345 && 
	`pushDownWhereTerms
(
db
, 
pSub
, 
p
->
pWhere
, 
pItem
->
iCursor
)

82357 if( 
i
==0

82358 && (
pTabList
->
nSrc
==1

82359 || (
pTabList
->
a
[1].
fg
.
jointype
&(0x0008|0x0002))!=0)

82360 && (
p
->
selFlags
 & 0x00002)==0

82361 && (((
db
)->
dbOptFlags
&(0x0100))==0)

82368 int 
addrTop
 = 
	`sqlite3VdbeCurrentAddr
(
v
)+1;

82369 
pItem
->
regReturn
 = ++
pParse
->
nMem
;

82370 
	`sqlite3VdbeAddOp3
(
v
, 16, 
pItem
->
regReturn
, 0, 
addrTop
);

82372 
pItem
->
addrFillSub
 = 
addrTop
;

82373 
	`sqlite3SelectDestInit
(&
dest
, 13, 
pItem
->
regReturn
);

82374 
pItem
->
iSelectId
 = (
u8
)
pParse
->
iNextSelectId
;

82375 
	`sqlite3Select
(
pParse
, 
pSub
, &
dest
);

82376 
pItem
->
pTab
->
nRowLogEst
 = 
pSub
->
nSelectRow
;

82377 
pItem
->
fg
.
viaCoroutine
 = 1;

82378 
pItem
->
regResult
 = 
dest
.
iSdst
;

82379 
	`sqlite3VdbeEndCoroutine
(
v
, 
pItem
->
regReturn
);

82380 
	`sqlite3VdbeJumpHere
(
v
, 
addrTop
-1);

82381 
	`sqlite3ClearTempRegCache
(
pParse
);

82388 int 
topAddr
;

82389 int 
onceAddr
 = 0;

82390 int 
retAddr
;

82392 
pItem
->
regReturn
 = ++
pParse
->
nMem
;

82393 
topAddr
 = 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
pItem
->
regReturn
);

82394 
pItem
->
addrFillSub
 = 
topAddr
+1;

82395 if( 
pItem
->
fg
.
isCorrelated
==0 )

82401 
onceAddr
 = 
	`sqlite3CodeOnce
(
pParse
); ;

82406 
	`sqlite3SelectDestInit
(&
dest
, 12, 
pItem
->
iCursor
);

82407 
pItem
->
iSelectId
 = (
u8
)
pParse
->
iNextSelectId
;

82408 
	`sqlite3Select
(
pParse
, 
pSub
, &
dest
);

82409 
pItem
->
pTab
->
nRowLogEst
 = 
pSub
->
nSelectRow
;

82410 if( 
onceAddr
 ) 
	`sqlite3VdbeJumpHere
(
v
, onceAddr);

82411 
retAddr
 = 
	`sqlite3VdbeAddOp1
(
v
, 15, 
pItem
->
regReturn
);

82413 
	`sqlite3VdbeChangeP1
(
v
, 
topAddr
, 
retAddr
);

82414 
	`sqlite3ClearTempRegCache
(
pParse
);

82416 if( 
db
->
mallocFailed
 ) goto 
select_end
;

82417 
pParse
->
nHeight
 -= 
	`sqlite3SelectExprHeight
(
p
);

82423 
pEList
 = 
p
->pEList;

82424 
pWhere
 = 
p
->pWhere;

82425 
pGroupBy
 = 
p
->pGroupBy;

82426 
pHaving
 = 
p
->pHaving;

82427 
sDistinct
.
isTnct
 = (
p
->
selFlags
 & 0x00001)!=0;

82429 if( (
p
->
selFlags
 & (0x00001|0x00008))==0x00001

82430 && 
	`sqlite3ExprListCompare
(
sSort
.
pOrderBy
, 
pEList
, -1)==0

82434 
p
->
selFlags
 &= ~0x00001;

82435 
pGroupBy
 = 
p
->pGroupBy = 
	`sqlite3ExprListDup
(
db
, 
pEList
, 0);

82442 if( 
sSort
.
pOrderBy
 )

82445 
KeyInfo
 *
pKeyInfo
;

82446 
pKeyInfo
 = 
	`keyInfoFromExprList
(
pParse
, 
sSort
.
pOrderBy
, 0, 
pEList
->
nExpr
);

82447 
sSort
.
iECursor
 = 
pParse
->
nTab
++;

82448 
sSort
.
addrSortIndex
 =

82449 
	`sqlite3VdbeAddOp4
(
v
, 57,

82450 
sSort
.
iECursor
, sSort.
pOrderBy
->
nExpr
+1+
pEList
->nExpr, 0,

82451 (char*)
pKeyInfo
, (-6)

82454 
sSort
.
addrSortIndex
 = -1;

82459 if( 
pDest
->
eDest
==12 )

82462 
	`sqlite3VdbeAddOp2
(
v
, 57, 
pDest
->
iSDParm
, 
pEList
->
nExpr
);

82467 
iEnd
 = 
	`sqlite3VdbeMakeLabel
(
v
);

82468 
p
->
nSelectRow
 = 320;

82469 
	`computeLimitRegisters
(
pParse
, 
p
, 
iEnd
);

82470 if( 
p
->
iLimit
==0 && 
sSort
.
addrSortIndex
>=0 )

82473 
	`sqlite3VdbeChangeOpcode
(
v
, 
sSort
.
addrSortIndex
, 58);

82474 
sSort
.
sortFlags
 |= 0x01;

82479 if( 
p
->
selFlags
 & 0x00001 )

82482 
sDistinct
.
tabTnct
 = 
pParse
->
nTab
++;

82483 
sDistinct
.
addrTnct
 = 
	`sqlite3VdbeAddOp4
(
v
, 57,

82484 
sDistinct
.
tabTnct
, 0, 0,

82485 (char*)
	`keyInfoFromExprList
(
pParse
, 
p
->
pEList
,0,0),

82487 
	`sqlite3VdbeChangeP5
(
v
, 8);

82488 
sDistinct
.
eTnctType
 = 3;

82490 
sDistinct
.
eTnctType
 = 0;

82493 if( !
isAgg
 && 
pGroupBy
==0 )

82497 
u16
 
wctrlFlags
 = (
sDistinct
.
isTnct
 ? 0x0400 : 0);

82499 
wctrlFlags
 |= 
p
->
selFlags
 & 0x04000;

82502 
pWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pTabList
, 
pWhere
, 
sSort
.
pOrderBy
,

82503 
p
->
pEList
, 
wctrlFlags
, p->
nSelectRow
);

82504 if( 
pWInfo
==0 ) goto 
select_end
;

82505 if( 
	`sqlite3WhereOutputRowCount
(
pWInfo
) < 
p
->
nSelectRow
 )

82508 
p
->
nSelectRow
 = 
	`sqlite3WhereOutputRowCount
(
pWInfo
);

82510 if( 
sDistinct
.
isTnct
 && 
	`sqlite3WhereIsDistinct
(
pWInfo
) )

82513 
sDistinct
.
eTnctType
 = 
	`sqlite3WhereIsDistinct
(
pWInfo
);

82515 if( 
sSort
.
pOrderBy
 )

82518 
sSort
.
nOBSat
 = 
	`sqlite3WhereIsOrdered
(
pWInfo
);

82519 if( 
sSort
.
nOBSat
==sSort.
pOrderBy
->
nExpr
 )

82522 
sSort
.
pOrderBy
 = 0;

82530 if( 
sSort
.
addrSortIndex
>=0 && sSort.
pOrderBy
==0 )

82533 
	`sqlite3VdbeChangeToNoop
(
v
, 
sSort
.
addrSortIndex
);

82537 
	`selectInnerLoop
(
pParse
, 
p
, 
pEList
, -1, &
sSort
, &
sDistinct
, 
pDest
,

82538 
	`sqlite3WhereContinueLabel
(
pWInfo
),

82539 
	`sqlite3WhereBreakLabel
(
pWInfo
));

82543 
	`sqlite3WhereEnd
(
pWInfo
);

82547 
NameContext
 
sNC
;

82548 int 
iAMem
;

82549 int 
iBMem
;

82550 int 
iUseFlag
;

82553 int 
iAbortFlag
;

82554 int 
groupBySort
;

82555 int 
addrEnd
;

82556 int 
sortPTab
 = 0;

82557 int 
sortOut
 = 0;

82558 int 
orderByGrp
 = 0;

82563 if( 
pGroupBy
 )

82566 int 
k
;

82567 struct 
ExprList_item
 *
pItem
;

82569 for(
k
=
p
->
pEList
->
nExpr
, 
pItem
=p->pEList->
a
; k>0; k--, pItem++)

82572 
pItem
->
u
.
x
.
iAlias
 = 0;

82574 for(
k
=
pGroupBy
->
nExpr
, 
pItem
=pGroupBy->
a
; k>0; k--, pItem++)

82577 
pItem
->
u
.
x
.
iAlias
 = 0;

82580 if( 
p
->
nSelectRow
>66 ) p->nSelectRow = 66;

82583 
p
->
nSelectRow
 = 0;

82586 if( 
	`sqlite3ExprListCompare
(
pGroupBy
, 
sSort
.
pOrderBy
, -1)==0 )

82589 
orderByGrp
 = 1;

82593 
addrEnd
 = 
	`sqlite3VdbeMakeLabel
(
v
);

82599 
	`memset
(&
sNC
, 0, sizeof(sNC));

82600 
sNC
.
pParse
 = pParse;

82601 
sNC
.
pSrcList
 = 
pTabList
;

82602 
sNC
.
pAggInfo
 = &
sAggInfo
;

82603 
sAggInfo
.
mnReg
 = 
pParse
->
nMem
+1;

82604 
sAggInfo
.
nSortingColumn
 = 
pGroupBy
 ? pGroupBy->
nExpr
 : 0;

82605 
sAggInfo
.
pGroupBy
 = pGroupBy;

82606 
	`sqlite3ExprAnalyzeAggList
(&
sNC
, 
pEList
);

82607 
	`sqlite3ExprAnalyzeAggList
(&
sNC
, 
sSort
.
pOrderBy
);

82608 if( 
pHaving
 )

82611 
	`sqlite3ExprAnalyzeAggregates
(&
sNC
, 
pHaving
);

82613 
sAggInfo
.
nAccumulator
 = sAggInfo.
nColumn
;

82614 for(
i
=0; i<
sAggInfo
.
nFunc
; i++)

82618 
sNC
.
ncFlags
 |= 0x0008;

82619 
	`sqlite3ExprAnalyzeAggList
(&
sNC
, 
sAggInfo
.
aFunc
[
i
].
pExpr
->
x
.
pList
);

82620 
sNC
.
ncFlags
 &= ~0x0008;

82622 
sAggInfo
.
mxReg
 = 
pParse
->
nMem
;

82623 if( 
db
->
mallocFailed
 ) goto 
select_end
;

82628 if( 
pGroupBy
 )

82631 
KeyInfo
 *
pKeyInfo
;

82632 int 
addr1
;

82633 int 
addrOutputRow
;

82634 int 
regOutputRow
;

82635 int 
addrSetAbort
;

82636 int 
addrTopOfLoop
;

82637 int 
addrSortingIdx
;

82638 int 
addrReset
;

82639 int 
regReset
;

82646 
sAggInfo
.
sortingIdx
 = 
pParse
->
nTab
++;

82647 
pKeyInfo
 = 
	`keyInfoFromExprList
(
pParse
, 
pGroupBy
, 0, 
sAggInfo
.
nColumn
);

82648 
addrSortingIdx
 = 
	`sqlite3VdbeAddOp4
(
v
, 58,

82649 
sAggInfo
.
sortingIdx
, sAggInfo.
nSortingColumn
,

82650 0, (char*)
pKeyInfo
, (-6));

82654 
iUseFlag
 = ++
pParse
->
nMem
;

82655 
iAbortFlag
 = ++
pParse
->
nMem
;

82656 
regOutputRow
 = ++
pParse
->
nMem
;

82657 
addrOutputRow
 = 
	`sqlite3VdbeMakeLabel
(
v
);

82658 
regReset
 = ++
pParse
->
nMem
;

82659 
addrReset
 = 
	`sqlite3VdbeMakeLabel
(
v
);

82660 
iAMem
 = 
pParse
->
nMem
 + 1;

82661 
pParse
->
nMem
 += 
pGroupBy
->
nExpr
;

82662 
iBMem
 = 
pParse
->
nMem
 + 1;

82663 
pParse
->
nMem
 += 
pGroupBy
->
nExpr
;

82664 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
iAbortFlag
);

82666 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
iUseFlag
);

82668 
	`sqlite3VdbeAddOp3
(
v
, 25, 0, 
iAMem
, iAMem+
pGroupBy
->
nExpr
-1);

82675 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regReset
, 
addrReset
);

82676 
pWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pTabList
, 
pWhere
, 
pGroupBy
, 0,

82677 0x0100 | (
orderByGrp
 ? 0x0800 : 0), 0

82679 if( 
pWInfo
==0 ) goto 
select_end
;

82680 if( 
	`sqlite3WhereIsOrdered
(
pWInfo
)==
pGroupBy
->
nExpr
 )

82687 
groupBySort
 = 0;

82694 int 
regBase
;

82695 int 
regRecord
;

82696 int 
nCol
;

82697 int 
nGroupBy
;

82699 
	`explainTempTable
(
pParse
,

82700 (
sDistinct
.
isTnct
 && (
p
->
selFlags
&0x00001)==0) ?

82703 
groupBySort
 = 1;

82704 
nGroupBy
 = 
pGroupBy
->
nExpr
;

82705 
nCol
 = 
nGroupBy
;

82706 
j
 = 
nGroupBy
;

82707 for(
i
=0; i<
sAggInfo
.
nColumn
; i++)

82710 if( 
sAggInfo
.
aCol
[
i
].
iSorterColumn
>=
j
 )

82713 
nCol
++;

82714 
j
++;

82717 
regBase
 = 
	`sqlite3GetTempRange
(
pParse
, 
nCol
);

82718 
	`sqlite3ExprCacheClear
(
pParse
);

82719 
	`sqlite3ExprCodeExprList
(
pParse
, 
pGroupBy
, 
regBase
, 0, 0);

82720 
j
 = 
nGroupBy
;

82721 for(
i
=0; i<
sAggInfo
.
nColumn
; i++)

82724 struct 
AggInfo_col
 *
pCol
 = &
sAggInfo
.
aCol
[
i
];

82725 if( 
pCol
->
iSorterColumn
>=
j
 )

82728 int 
r1
 = 
j
 + 
regBase
;

82729 
	`sqlite3ExprCodeGetColumnToReg
(
pParse
,

82730 
pCol
->
pTab
, pCol->
iColumn
, pCol->
iTable
, 
r1
);

82731 
j
++;

82734 
regRecord
 = 
	`sqlite3GetTempReg
(
pParse
);

82735 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regBase
, 
nCol
, 
regRecord
);

82736 
	`sqlite3VdbeAddOp2
(
v
, 109, 
sAggInfo
.
sortingIdx
, 
regRecord
);

82737 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRecord
);

82738 
	`sqlite3ReleaseTempRange
(
pParse
, 
regBase
, 
nCol
);

82739 
	`sqlite3WhereEnd
(
pWInfo
);

82740 
sAggInfo
.
sortingIdxPTab
 = 
sortPTab
 = 
pParse
->
nTab
++;

82741 
sortOut
 = 
	`sqlite3GetTempReg
(
pParse
);

82742 
	`sqlite3VdbeAddOp3
(
v
, 60, 
sortPTab
, 
sortOut
, 
nCol
);

82743 
	`sqlite3VdbeAddOp2
(
v
, 106, 
sAggInfo
.
sortingIdx
, 
addrEnd
);

82745 
sAggInfo
.
useSortingIdx
 = 1;

82746 
	`sqlite3ExprCacheClear
(
pParse
);

82750 if( 
orderByGrp
 && (((
db
)->
dbOptFlags
&(0x0004))==0)

82751 && (
groupBySort
 || 
	`sqlite3WhereIsSorted
(
pWInfo
))

82755 
sSort
.
pOrderBy
 = 0;

82756 
	`sqlite3VdbeChangeToNoop
(
v
, 
sSort
.
addrSortIndex
);

82764 
addrTopOfLoop
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

82765 
	`sqlite3ExprCacheClear
(
pParse
);

82766 if( 
groupBySort
 )

82769 
	`sqlite3VdbeAddOp3
(
v
, 100, 
sAggInfo
.
sortingIdx
,

82770 
sortOut
, 
sortPTab
);

82772 for(
j
=0; j<
pGroupBy
->
nExpr
; j++)

82775 if( 
groupBySort
 )

82778 
	`sqlite3VdbeAddOp3
(
v
, 47, 
sortPTab
, 
j
, 
iBMem
+j);

82780 
sAggInfo
.
directMode
 = 1;

82781 
	`sqlite3ExprCode
(
pParse
, 
pGroupBy
->
a
[
j
].
pExpr
, 
iBMem
+j);

82784 
	`sqlite3VdbeAddOp4
(
v
, 42, 
iAMem
, 
iBMem
, 
pGroupBy
->
nExpr
,

82785 (char*)
	`sqlite3KeyInfoRef
(
pKeyInfo
), (-6));

82786 
addr1
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

82787 
	`sqlite3VdbeAddOp3
(
v
, 43, 
addr1
+1, 0, addr1+1); ;

82789 
	`sqlite3ExprCodeMove
(
pParse
, 
iBMem
, 
iAMem
, 
pGroupBy
->
nExpr
);

82790 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regOutputRow
, 
addrOutputRow
);

82792 
	`sqlite3VdbeAddOp2
(
v
, 138, 
iAbortFlag
, 
addrEnd
); ;

82794 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regReset
, 
addrReset
);

82800 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

82801 
	`updateAccumulator
(
pParse
, &
sAggInfo
);

82802 
	`sqlite3VdbeAddOp2
(
v
, 22, 1, 
iUseFlag
);

82807 if( 
groupBySort
 )

82810 
	`sqlite3VdbeAddOp2
(
v
, 3, 
sAggInfo
.
sortingIdx
, 
addrTopOfLoop
);

82813 
	`sqlite3WhereEnd
(
pWInfo
);

82814 
	`sqlite3VdbeChangeToNoop
(
v
, 
addrSortingIdx
);

82819 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regOutputRow
, 
addrOutputRow
);

82824 
	`sqlite3VdbeGoto
(
v
, 
addrEnd
);

82826 
addrSetAbort
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

82827 
	`sqlite3VdbeAddOp2
(
v
, 22, 1, 
iAbortFlag
);

82829 
	`sqlite3VdbeAddOp1
(
v
, 15, 
regOutputRow
);

82830 
	`sqlite3VdbeResolveLabel
(
v
, 
addrOutputRow
);

82831 
addrOutputRow
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

82832 
	`sqlite3VdbeAddOp2
(
v
, 138, 
iUseFlag
, 
addrOutputRow
+2);

82835 
	`sqlite3VdbeAddOp1
(
v
, 15, 
regOutputRow
);

82836 
	`finalizeAggFunctions
(
pParse
, &
sAggInfo
);

82837 
	`sqlite3ExprIfFalse
(
pParse
, 
pHaving
, 
addrOutputRow
+1, 0x10);

82838 
	`selectInnerLoop
(
pParse
, 
p
, p->
pEList
, -1, &
sSort
,

82839 &
sDistinct
, 
pDest
,

82840 
addrOutputRow
+1, 
addrSetAbort
);

82841 
	`sqlite3VdbeAddOp1
(
v
, 15, 
regOutputRow
);

82846 
	`sqlite3VdbeResolveLabel
(
v
, 
addrReset
);

82847 
	`resetAccumulator
(
pParse
, &
sAggInfo
);

82848 
	`sqlite3VdbeAddOp1
(
v
, 15, 
regReset
);

82852 
ExprList
 *
pDel
 = 0;

82854 
Table
 *
pTab
;

82855 if( (
pTab
 = 
	`isSimpleCount
(
p
, &
sAggInfo
))!=0 )

82859 const int 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

82860 const int 
iCsr
 = 
pParse
->
nTab
++;

82861 
Index
 *
pIdx
;

82862 
KeyInfo
 *
pKeyInfo
 = 0;

82863 
Index
 *
pBest
 = 0;

82864 int 
iRoot
 = 
pTab
->
tnum
;

82866 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

82867 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 0, pTab->
zName
);

82869 if( !(((
pTab
)->
tabFlags
 & 0x20)==0) ) 
pBest
 = 
	`sqlite3PrimaryKeyIndex
(pTab);

82870 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

82873 if( 
pIdx
->
bUnordered
==0

82874 && 
pIdx
->
szIdxRow
<
pTab
->
szTabRow


82875 && 
pIdx
->
pPartIdxWhere
==0

82876 && (!
pBest
 || 
pIdx
->
szIdxRow
<pBest->szIdxRow)

82880 
pBest
 = 
pIdx
;

82883 if( 
pBest
 )

82886 
iRoot
 = 
pBest
->
tnum
;

82887 
pKeyInfo
 = 
	`sqlite3KeyInfoOfIndex
(
pParse
, 
pBest
);

82891 
	`sqlite3VdbeAddOp4Int
(
v
, 54, 
iCsr
, 
iRoot
, 
iDb
, 1);

82892 if( 
pKeyInfo
 )

82895 
	`sqlite3VdbeChangeP4
(
v
, -1, (char *)
pKeyInfo
, (-6));

82897 
	`sqlite3VdbeAddOp2
(
v
, 50, 
iCsr
, 
sAggInfo
.
aFunc
[0].
iMem
);

82898 
	`sqlite3VdbeAddOp1
(
v
, 61, 
iCsr
);

82899 
	`explainSimpleCount
(
pParse
, 
pTab
, 
pBest
);

82904 
ExprList
 *
pMinMax
 = 0;

82905 
u8
 
flag
 = 0x0000;

82909 if( 
p
->
pHaving
==0 )

82912 
flag
 = 
	`minMaxQuery
(&
sAggInfo
, &
pMinMax
);

82916 if( 
flag
 )

82919 
pMinMax
 = 
	`sqlite3ExprListDup
(
db
, pMinMax, 0);

82920 
pDel
 = 
pMinMax
;

82922 if( !
db
->
mallocFailed
 )

82925 
pMinMax
->
a
[0].
sortOrder
 = 
flag
!=0x0001 ?1:0;

82926 
pMinMax
->
a
[0].
pExpr
->
op
 = 152;

82934 
	`resetAccumulator
(
pParse
, &
sAggInfo
);

82935 
pWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pTabList
, 
pWhere
, 
pMinMax
,0,
flag
,0);

82936 if( 
pWInfo
==0 )

82939 
	`sqlite3ExprListDelete
(
db
, 
pDel
);

82940 goto 
select_end
;

82942 
	`updateAccumulator
(
pParse
, &
sAggInfo
);

82944 if( 
	`sqlite3WhereIsOrdered
(
pWInfo
)>0 )

82947 
	`sqlite3VdbeGoto
(
v
, 
	`sqlite3WhereBreakLabel
(
pWInfo
));

82951 
	`sqlite3WhereEnd
(
pWInfo
);

82952 
	`finalizeAggFunctions
(
pParse
, &
sAggInfo
);

82955 
sSort
.
pOrderBy
 = 0;

82956 
	`sqlite3ExprIfFalse
(
pParse
, 
pHaving
, 
addrEnd
, 0x10);

82957 
	`selectInnerLoop
(
pParse
, 
p
, p->
pEList
, -1, 0, 0,

82958 
pDest
, 
addrEnd
, addrEnd);

82959 
	`sqlite3ExprListDelete
(
db
, 
pDel
);

82961 
	`sqlite3VdbeResolveLabel
(
v
, 
addrEnd
);

82965 if( 
sDistinct
.
eTnctType
==3 )

82968 
	`explainTempTable
(
pParse
, "DISTINCT");

82974 if( 
sSort
.
pOrderBy
 )

82977 
	`explainTempTable
(
pParse
,

82978 
sSort
.
nOBSat
>0 ? "RIGHT PART OF ORDER BY":"ORDER BY");

82979 
	`generateSortTail
(
pParse
, 
p
, &
sSort
, 
pEList
->
nExpr
, 
pDest
);

82984 
	`sqlite3VdbeResolveLabel
(
v
, 
iEnd
);

82988 
rc
 = (
pParse
->
nErr
>0);

82993 
select_end
:

82994 
pParse
->
iSelectId
 = 
iRestoreSelectId
;

82998 if( 
rc
==0 && 
pDest
->
eDest
==9 )

83001 
	`generateColumnNames
(
pParse
, 
pTabList
, 
pEList
);

83004 
	`sqlite3DbFree
(
db
, 
sAggInfo
.
aCol
);

83005 
	`sqlite3DbFree
(
db
, 
sAggInfo
.
aFunc
);

83010 return 
rc
;

83011 
	}
}

83013 typedef struct 
	sTabResult
 {

83014 char **
	mazResult
;

83015 char *
	mzErrMsg
;

83016 
u32
 
	mnAlloc
;

83017 
u32
 
	mnRow
;

83018 
u32
 
	mnColumn
;

83019 
u32
 
	mnData
;

83020 int 
	mrc
;

83021 } 
	tTabResult
;

83028 static int 
	$sqlite3_get_table_cb
(void *
pArg
, int 
nCol
, char **
argv
, char **
colv
)

83031 
TabResult
 *
p
 = (TabResult*)
pArg
;

83032 int 
need
;

83033 int 
i
;

83034 char *
z
;

83039 if( 
p
->
nRow
==0 && 
argv
!=0 )

83042 
need
 = 
nCol
*2;

83044 
need
 = 
nCol
;

83046 if( 
p
->
nData
 + 
need
 > p->
nAlloc
 )

83049 char **
azNew
;

83050 
p
->
nAlloc
 = p->nAlloc*2 + 
need
;

83051 
azNew
 = 
	`sqlite3_realloc64
( 
p
->
azResult
, sizeof(char*)*p->
nAlloc
 );

83052 if( 
azNew
==0 ) goto 
malloc_failed
;

83053 
p
->
azResult
 = 
azNew
;

83059 if( 
p
->
nRow
==0 )

83062 
p
->
nColumn
 = 
nCol
;

83063 for(
i
=0; i<
nCol
; i++)

83066 
z
 = 
	`sqlite3_mprintf
("%s", 
colv
[
i
]);

83067 if( 
z
==0 ) goto 
malloc_failed
;

83068 
p
->
azResult
[p->
nData
++] = 
z
;

83070 }else if( (int)
p
->
nColumn
!=
nCol
 )

83073 
	`sqlite3_free
(
p
->
zErrMsg
);

83074 
p
->
zErrMsg
 = 
	`sqlite3_mprintf
(

83077 
p
->
rc
 = 1;

83083 if( 
argv
!=0 )

83086 for(
i
=0; i<
nCol
; i++)

83089 if( 
argv
[
i
]==0 )

83092 
z
 = 0;

83094 int 
n
 = 
	`sqlite3Strlen30
(
argv
[
i
])+1;

83095 
z
 = 
	`sqlite3_malloc64
( 
n
 );

83096 if( 
z
==0 ) goto 
malloc_failed
;

83097 
	`memcpy
(
z
, 
argv
[
i
], 
n
);

83099 
p
->
azResult
[p->
nData
++] = 
z
;

83101 
p
->
nRow
++;

83105 
malloc_failed
:

83106 
p
->
rc
 = 7;

83108 
	}
}

83110 int 
	$sqlite3_get_table
(

83111 
sqlite3
 *
db
,

83112 const char *
zSql
,

83113 char ***
pazResult
,

83114 int *
pnRow
,

83115 int *
pnColumn
,

83116 char **
pzErrMsg


83120 int 
rc
;

83121 
TabResult
 
res
;

83126 *
pazResult
 = 0;

83127 if( 
pnColumn
 ) *pnColumn = 0;

83128 if( 
pnRow
 ) *pnRow = 0;

83129 if( 
pzErrMsg
 ) *pzErrMsg = 0;

83130 
res
.
zErrMsg
 = 0;

83131 
res
.
nRow
 = 0;

83132 
res
.
nColumn
 = 0;

83133 
res
.
nData
 = 1;

83134 
res
.
nAlloc
 = 20;

83135 
res
.
rc
 = 0;

83136 
res
.
azResult
 = 
	`sqlite3_malloc64
(sizeof(char*)*res.
nAlloc
 );

83137 if( 
res
.
azResult
==0 )

83140 
db
->
errCode
 = 7;

83143 
res
.
azResult
[0] = 0;

83144 
rc
 = 
	`sqlite3_exec
(
db
, 
zSql
, 
sqlite3_get_table_cb
, &
res
, 
pzErrMsg
);

83146 
res
.
azResult
[0] = ((void*)(long int)(res.
nData
));

83147 if( (
rc
&0xff)==4 )

83150 
	`sqlite3_free_table
(&
res
.
azResult
[1]);

83151 if( 
res
.
zErrMsg
 )

83154 if( 
pzErrMsg
 )

83157 
	`sqlite3_free
(*
pzErrMsg
);

83158 *
pzErrMsg
 = 
	`sqlite3_mprintf
("%s",
res
.
zErrMsg
);

83160 
	`sqlite3_free
(
res
.
zErrMsg
);

83162 
db
->
errCode
 = 
res
.
rc
;

83163 return 
res
.
rc
;

83165 
	`sqlite3_free
(
res
.
zErrMsg
);

83166 if( 
rc
!=0 )

83169 
	`sqlite3_free_table
(&
res
.
azResult
[1]);

83170 return 
rc
;

83172 if( 
res
.
nAlloc
>res.
nData
 )

83175 char **
azNew
;

83176 
azNew
 = 
	`sqlite3_realloc64
( 
res
.
azResult
, sizeof(char*)*res.
nData
 );

83177 if( 
azNew
==0 )

83180 
	`sqlite3_free_table
(&
res
.
azResult
[1]);

83181 
db
->
errCode
 = 7;

83184 
res
.
azResult
 = 
azNew
;

83186 *
pazResult
 = &
res
.
azResult
[1];

83187 if( 
pnColumn
 ) *pnColumn = 
res
.
nColumn
;

83188 if( 
pnRow
 ) *pnRow = 
res
.
nRow
;

83189 return 
rc
;

83190 
	}
}

83195 void 
	$sqlite3_free_table
(

83196 char **
azResult


83200 if( 
azResult
 )

83203 int 
i
, 
n
;

83204 
azResult
--;

83206 
n
 = ((int)(long int)(
azResult
[0]));

83207 for(
i
=1; i<
n
; i++)

83209 if( 
azResult
[
i
] ) 
	`sqlite3_free
(azResult[i]); }

83210 
	`sqlite3_free
(
azResult
);

83212 
	}
}

83214 static void 
	$sqlite3DeleteTriggerStep
(
sqlite3
 *
db
, 
TriggerStep
 *
pTriggerStep
)

83217 while( 
pTriggerStep
 )

83220 
TriggerStep
 * 
pTmp
 = 
pTriggerStep
;

83221 
pTriggerStep
 = pTriggerStep->
pNext
;

83223 
	`sqlite3ExprDelete
(
db
, 
pTmp
->
pWhere
);

83224 
	`sqlite3ExprListDelete
(
db
, 
pTmp
->
pExprList
);

83225 
	`sqlite3SelectDelete
(
db
, 
pTmp
->
pSelect
);

83226 
	`sqlite3IdListDelete
(
db
, 
pTmp
->
pIdList
);

83228 
	`sqlite3DbFree
(
db
, 
pTmp
);

83230 
	}
}

83232 static 
Trigger
 *
	$sqlite3TriggerList
(
Parse
 *
pParse
, 
Table
 *
pTab
)

83235 
Schema
 * const 
pTmpSchema
 = 
pParse
->
db
->
aDb
[1].
pSchema
;

83236 
Trigger
 *
pList
 = 0;

83238 if( 
pParse
->
disableTriggers
 )

83244 if( 
pTmpSchema
!=
pTab
->
pSchema
 )

83247 
HashElem
 *
p
;

83249 for(
p
=((&
pTmpSchema
->
trigHash
)->
first
); p; p=((p)->
next
))

83252 
Trigger
 *
pTrig
 = (Trigger *)((
p
)->
data
);

83253 if( 
pTrig
->
pTabSchema
==
pTab
->
pSchema


83254 && 0==
	`sqlite3StrICmp
(
pTrig
->
table
, 
pTab
->
zName
)

83258 
pTrig
->
pNext
 = (
pList
 ? pList : 
pTab
->
pTrigger
);

83259 
pList
 = 
pTrig
;

83264 return (
pList
 ? pList : 
pTab
->
pTrigger
);

83265 
	}
}

83267 static void 
	$sqlite3BeginTrigger
(

83268 
Parse
 *
pParse
,

83269 
Token
 *
pName1
,

83270 
Token
 *
pName2
,

83271 int 
tr_tm
,

83272 int 
op
,

83273 
IdList
 *
pColumns
,

83274 
SrcList
 *
pTableName
,

83275 
Expr
 *
pWhen
,

83276 int 
isTemp
,

83277 int 
noErr


83281 
Trigger
 *
pTrigger
 = 0;

83282 
Table
 *
pTab
;

83283 char *
zName
 = 0;

83284 
sqlite3
 *
db
 = 
pParse
->db;

83285 int 
iDb
;

83286 
Token
 *
pName
;

83287 
DbFixer
 
sFix
;

83288 int 
iTabDb
;

83294 if( 
isTemp
 )

83298 if( 
pName2
->
n
>0 )

83301 
	`sqlite3ErrorMsg
(
pParse
, "temporary trigger may not have qualified name");

83302 goto 
trigger_cleanup
;

83304 
iDb
 = 1;

83305 
pName
 = 
pName1
;

83308 
iDb
 = 
	`sqlite3TwoPartName
(
pParse
, 
pName1
, 
pName2
, &
pName
);

83309 if( 
iDb
<0 )

83312 goto 
trigger_cleanup
;

83315 if( !
pTableName
 || 
db
->
mallocFailed
 )

83318 goto 
trigger_cleanup
;

83321 if( 
db
->
init
.
busy
 && 
iDb
!=1 )

83324 
	`sqlite3DbFree
(
db
, 
pTableName
->
a
[0].
zDatabase
);

83325 
pTableName
->
a
[0].
zDatabase
 = 0;

83333 
pTab
 = 
	`sqlite3SrcListLookup
(
pParse
, 
pTableName
);

83334 if( 
db
->
init
.
busy
==0 && 
pName2
->
n
==0 && 
pTab


83335 && 
pTab
->
pSchema
==
db
->
aDb
[1].pSchema )

83338 
iDb
 = 1;

83342 if( 
db
->
mallocFailed
 ) goto 
trigger_cleanup
;

83344 
	`sqlite3FixInit
(&
sFix
, 
pParse
, 
iDb
, "trigger", 
pName
);

83345 if( 
	`sqlite3FixSrcList
(&
sFix
, 
pTableName
) )

83348 goto 
trigger_cleanup
;

83350 
pTab
 = 
	`sqlite3SrcListLookup
(
pParse
, 
pTableName
);

83351 if( !
pTab
 )

83355 if( 
db
->
init
.
iDb
==1 )

83359 
db
->
init
.
orphanTrigger
 = 1;

83361 goto 
trigger_cleanup
;

83363 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

83366 
	`sqlite3ErrorMsg
(
pParse
, "cannot create triggers on virtual tables");

83367 goto 
trigger_cleanup
;

83372 
zName
 = 
	`sqlite3NameFromToken
(
db
, 
pName
);

83373 if( !
zName
 || 0!=
	`sqlite3CheckObjectName
(
pParse
, zName) )

83376 goto 
trigger_cleanup
;

83379 if( 
	`sqlite3HashFind
(&(
db
->
aDb
[
iDb
].
pSchema
->
trigHash
),
zName
) )

83382 if( !
noErr
 )

83385 
	`sqlite3ErrorMsg
(
pParse
, "trigger %T already exists", 
pName
);

83388 
	`sqlite3CodeVerifySchema
(
pParse
, 
iDb
);

83390 goto 
trigger_cleanup
;

83394 if( 
	`sqlite3_strnicmp
(
pTab
->
zName
, "sqlite_", 7)==0 )

83397 
	`sqlite3ErrorMsg
(
pParse
, "cannot create trigger on system table");

83398 goto 
trigger_cleanup
;

83404 if( 
pTab
->
pSelect
 && 
tr_tm
!=49 )

83407 
	`sqlite3ErrorMsg
(
pParse
, "cannot create %s trigger on view: %S",

83408 (
tr_tm
 == 35)?"BEFORE":"AFTER", 
pTableName
, 0);

83409 goto 
trigger_cleanup
;

83411 if( !
pTab
->
pSelect
 && 
tr_tm
==49 )

83414 
	`sqlite3ErrorMsg
(
pParse
, "cannot create INSTEAD OF"

83415 " trigger on table: %S", 
pTableName
, 0);

83416 goto 
trigger_cleanup
;

83418 
iTabDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

83422 int 
code
 = 7;

83423 const char *
zDb
 = 
db
->
aDb
[
iTabDb
].
zName
;

83424 const char *
zDbTrig
 = 
isTemp
 ? 
db
->
aDb
[1].
zName
 : 
zDb
;

83425 if( 
iTabDb
==1 || 
isTemp
 ) 
code
 = 5;

83426 if( 
	`sqlite3AuthCheck
(
pParse
, 
code
, 
zName
, 
pTab
->zName, 
zDbTrig
) )

83429 goto 
trigger_cleanup
;

83431 if( 
	`sqlite3AuthCheck
(
pParse
, 18, ((!0)&&(
iTabDb
==1)?"sqlite_temp_master":"sqlite_master"),0,
zDb
))

83434 goto 
trigger_cleanup
;

83444 if (
tr_tm
 == 49)

83447 
tr_tm
 = 35;

83451 
pTrigger
 = (
Trigger
*)
	`sqlite3DbMallocZero
(
db
, sizeof(Trigger));

83452 if( 
pTrigger
==0 ) goto 
trigger_cleanup
;

83453 
pTrigger
->
zName
 = zName;

83454 
zName
 = 0;

83455 
pTrigger
->
table
 = 
	`sqlite3DbStrDup
(
db
, 
pTableName
->
a
[0].
zName
);

83456 
pTrigger
->
pSchema
 = 
db
->
aDb
[
iDb
].pSchema;

83457 
pTrigger
->
pTabSchema
 = 
pTab
->
pSchema
;

83458 
pTrigger
->
op
 = (
u8
)op;

83459 
pTrigger
->
tr_tm
 = tr_tm==35 ? 1 : 2;

83460 
pTrigger
->
pWhen
 = 
	`sqlite3ExprDup
(
db
, pWhen, 0x0001);

83461 
pTrigger
->
pColumns
 = 
	`sqlite3IdListDup
(
db
, pColumns);

83463 
pParse
->
pNewTrigger
 = 
pTrigger
;

83465 
trigger_cleanup
:

83466 
	`sqlite3DbFree
(
db
, 
zName
);

83467 
	`sqlite3SrcListDelete
(
db
, 
pTableName
);

83468 
	`sqlite3IdListDelete
(
db
, 
pColumns
);

83469 
	`sqlite3ExprDelete
(
db
, 
pWhen
);

83470 if( !
pParse
->
pNewTrigger
 )

83473 
	`sqlite3DeleteTrigger
(
db
, 
pTrigger
);

83477 
	}
}

83483 static void 
	$sqlite3FinishTrigger
(

83484 
Parse
 *
pParse
,

83485 
TriggerStep
 *
pStepList
,

83486 
Token
 *
pAll


83490 
Trigger
 *
pTrig
 = 
pParse
->
pNewTrigger
;

83491 char *
zName
;

83492 
sqlite3
 *
db
 = 
pParse
->db;

83493 
DbFixer
 
sFix
;

83494 int 
iDb
;

83495 
Token
 
nameToken
;

83497 
pParse
->
pNewTrigger
 = 0;

83498 if( (
pParse
->
nErr
) || !
pTrig
 ) goto 
triggerfinish_cleanup
;

83499 
zName
 = 
pTrig
->zName;

83500 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTrig
->
pSchema
);

83501 
pTrig
->
step_list
 = 
pStepList
;

83502 while( 
pStepList
 )

83505 
pStepList
->
pTrig
 = pTrig;

83506 
pStepList
 = pStepList->
pNext
;

83508 
	`sqlite3TokenInit
(&
nameToken
, 
pTrig
->
zName
);

83509 
	`sqlite3FixInit
(&
sFix
, 
pParse
, 
iDb
, "trigger", &
nameToken
);

83510 if( 
	`sqlite3FixTriggerStep
(&
sFix
, 
pTrig
->
step_list
)

83511 || 
	`sqlite3FixExpr
(&
sFix
, 
pTrig
->
pWhen
)

83515 goto 
triggerfinish_cleanup
;

83521 if( !
db
->
init
.
busy
 )

83524 
Vdbe
 *
v
;

83525 char *
z
;

83528 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

83529 if( 
v
==0 ) goto 
triggerfinish_cleanup
;

83530 
	`sqlite3BeginWriteOperation
(
pParse
, 0, 
iDb
);

83531 
z
 = 
	`sqlite3DbStrNDup
(
db
, (char*)
pAll
->z, pAll->
n
);

83532 
	`sqlite3NestedParse
(
pParse
,

83534 
db
->
aDb
[
iDb
].
zName
, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), zName,

83535 
pTrig
->
table
, 
z
);

83536 
	`sqlite3DbFree
(
db
, 
z
);

83537 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

83538 
	`sqlite3VdbeAddParseSchemaOp
(
v
, 
iDb
,

83539 
	`sqlite3MPrintf
(
db
, "type='trigger' AND name='%q'", 
zName
));

83542 if( 
db
->
init
.
busy
 )

83545 
Trigger
 *
pLink
 = 
pTrig
;

83546 
Hash
 *
pHash
 = &
db
->
aDb
[
iDb
].
pSchema
->
trigHash
;

83548 
pTrig
 = 
	`sqlite3HashInsert
(
pHash
, 
zName
, pTrig);

83549 if( 
pTrig
 )

83552 
	`sqlite3OomFault
(
db
);

83553 }else if( 
pLink
->
pSchema
==pLink->
pTabSchema
 )

83556 
Table
 *
pTab
;

83557 
pTab
 = 
	`sqlite3HashFind
(&
pLink
->
pTabSchema
->
tblHash
, pLink->
table
);

83559 
pLink
->
pNext
 = 
pTab
->
pTrigger
;

83560 
pTab
->
pTrigger
 = 
pLink
;

83564 
triggerfinish_cleanup
:

83565 
	`sqlite3DeleteTrigger
(
db
, 
pTrig
);

83567 
	`sqlite3DeleteTriggerStep
(
db
, 
pStepList
);

83568 
	}
}

83570 static 
TriggerStep
 *
	$sqlite3TriggerSelectStep
(
sqlite3
 *
db
, 
Select
 *
pSelect
)

83573 
TriggerStep
 *
pTriggerStep
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(TriggerStep));

83574 if( 
pTriggerStep
==0 ) {

83575 
	`sqlite3SelectDelete
(
db
, 
pSelect
);

83578 
pTriggerStep
->
op
 = 119;

83579 
pTriggerStep
->
pSelect
 = pSelect;

83580 
pTriggerStep
->
orconf
 = 10;

83581 return 
pTriggerStep
;

83582 
	}
}

83590 static 
TriggerStep
 *
	$triggerStepAllocate
(

83591 
sqlite3
 *
db
,

83592 
u8
 
op
,

83593 
Token
 *
pName


83597 
TriggerStep
 *
pTriggerStep
;

83599 
pTriggerStep
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
TriggerStep
) + 
pName
->
n
 + 1);

83600 if( 
pTriggerStep
 )

83603 char *
z
 = (char*)&
pTriggerStep
[1];

83604 
	`memcpy
(
z
, 
pName
->z, pName->
n
);

83605 
	`sqlite3Dequote
(
z
);

83606 
pTriggerStep
->
zTarget
 = 
z
;

83607 
pTriggerStep
->
op
 = op;

83609 return 
pTriggerStep
;

83610 
	}
}

83612 static 
TriggerStep
 *
	$sqlite3TriggerInsertStep
(

83613 
sqlite3
 *
db
,

83614 
Token
 *
pTableName
,

83615 
IdList
 *
pColumn
,

83616 
Select
 *
pSelect
,

83617 
u8
 
orconf


83621 
TriggerStep
 *
pTriggerStep
;

83625 
pTriggerStep
 = 
	`triggerStepAllocate
(
db
, 108, 
pTableName
);

83626 if( 
pTriggerStep
 )

83629 
pTriggerStep
->
pSelect
 = 
	`sqlite3SelectDup
(
db
, pSelect, 0x0001);

83630 
pTriggerStep
->
pIdList
 = 
pColumn
;

83631 
pTriggerStep
->
orconf
 = orconf;

83633 
	`sqlite3IdListDelete
(
db
, 
pColumn
);

83635 
	`sqlite3SelectDelete
(
db
, 
pSelect
);

83637 return 
pTriggerStep
;

83638 
	}
}

83645 static 
TriggerStep
 *
	$sqlite3TriggerUpdateStep
(

83646 
sqlite3
 *
db
,

83647 
Token
 *
pTableName
,

83648 
ExprList
 *
pEList
,

83649 
Expr
 *
pWhere
,

83650 
u8
 
orconf


83654 
TriggerStep
 *
pTriggerStep
;

83656 
pTriggerStep
 = 
	`triggerStepAllocate
(
db
, 110, 
pTableName
);

83657 if( 
pTriggerStep
 )

83660 
pTriggerStep
->
pExprList
 = 
	`sqlite3ExprListDup
(
db
, 
pEList
, 0x0001);

83661 
pTriggerStep
->
pWhere
 = 
	`sqlite3ExprDup
(
db
, pWhere, 0x0001);

83662 
pTriggerStep
->
orconf
 = orconf;

83664 
	`sqlite3ExprListDelete
(
db
, 
pEList
);

83665 
	`sqlite3ExprDelete
(
db
, 
pWhere
);

83666 return 
pTriggerStep
;

83667 
	}
}

83674 static 
TriggerStep
 *
	$sqlite3TriggerDeleteStep
(

83675 
sqlite3
 *
db
,

83676 
Token
 *
pTableName
,

83677 
Expr
 *
pWhere


83681 
TriggerStep
 *
pTriggerStep
;

83683 
pTriggerStep
 = 
	`triggerStepAllocate
(
db
, 109, 
pTableName
);

83684 if( 
pTriggerStep
 )

83687 
pTriggerStep
->
pWhere
 = 
	`sqlite3ExprDup
(
db
, pWhere, 0x0001);

83688 
pTriggerStep
->
orconf
 = 10;

83690 
	`sqlite3ExprDelete
(
db
, 
pWhere
);

83691 return 
pTriggerStep
;

83692 
	}
}

83697 static void 
	$sqlite3DeleteTrigger
(
sqlite3
 *
db
, 
Trigger
 *
pTrigger
)

83700 if( 
pTrigger
==0 ) return;

83701 
	`sqlite3DeleteTriggerStep
(
db
, 
pTrigger
->
step_list
);

83702 
	`sqlite3DbFree
(
db
, 
pTrigger
->
zName
);

83703 
	`sqlite3DbFree
(
db
, 
pTrigger
->
table
);

83704 
	`sqlite3ExprDelete
(
db
, 
pTrigger
->
pWhen
);

83705 
	`sqlite3IdListDelete
(
db
, 
pTrigger
->
pColumns
);

83706 
	`sqlite3DbFree
(
db
, 
pTrigger
);

83707 
	}
}

83709 static void 
	$sqlite3DropTrigger
(
Parse
 *
pParse
, 
SrcList
 *
pName
, int 
noErr
)

83712 
Trigger
 *
pTrigger
 = 0;

83713 int 
i
;

83714 const char *
zDb
;

83715 const char *
zName
;

83716 
sqlite3
 *
db
 = 
pParse
->db;

83718 if( 
db
->
mallocFailed
 ) goto 
drop_trigger_cleanup
;

83719 if( 0!=
	`sqlite3ReadSchema
(
pParse
) )

83722 goto 
drop_trigger_cleanup
;

83726 
zDb
 = 
pName
->
a
[0].
zDatabase
;

83727 
zName
 = 
pName
->
a
[0].zName;

83729 for(
i
=0; i<
db
->
nDb
; i++)

83732 int 
j
 = (
i
<2) ? i^1 : i;

83733 if( 
zDb
 && 
	`sqlite3StrICmp
(
db
->
aDb
[
j
].
zName
, zDb) ) continue;

83735 
pTrigger
 = 
	`sqlite3HashFind
(&(
db
->
aDb
[
j
].
pSchema
->
trigHash
), 
zName
);

83736 if( 
pTrigger
 ) break;

83738 if( !
pTrigger
 )

83741 if( !
noErr
 )

83744 
	`sqlite3ErrorMsg
(
pParse
, "no such trigger: %S", 
pName
, 0);

83746 
	`sqlite3CodeVerifyNamedSchema
(
pParse
, 
zDb
);

83748 
pParse
->
checkSchema
 = 1;

83749 goto 
drop_trigger_cleanup
;

83751 
	`sqlite3DropTriggerPtr
(
pParse
, 
pTrigger
);

83753 
drop_trigger_cleanup
:

83754 
	`sqlite3SrcListDelete
(
db
, 
pName
);

83755 
	}
}

83761 static 
Table
 *
	$tableOfTrigger
(
Trigger
 *
pTrigger
)

83764 return 
	`sqlite3HashFind
(&
pTrigger
->
pTabSchema
->
tblHash
, pTrigger->
table
);

83765 
	}
}

83771 static void 
	$sqlite3DropTriggerPtr
(
Parse
 *
pParse
, 
Trigger
 *
pTrigger
)

83774 
Table
 *
pTable
;

83775 
Vdbe
 *
v
;

83776 
sqlite3
 *
db
 = 
pParse
->db;

83777 int 
iDb
;

83779 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTrigger
->
pSchema
);

83781 
pTable
 = 
	`tableOfTrigger
(
pTrigger
);

83786 int 
code
 = 16;

83787 const char *
zDb
 = 
db
->
aDb
[
iDb
].
zName
;

83788 const char *
zTab
 = ((!0)&&(
iDb
==1)?"sqlite_temp_master":"sqlite_master");

83789 if( 
iDb
==1 ) 
code
 = 14;

83790 if( 
	`sqlite3AuthCheck
(
pParse
, 
code
, 
pTrigger
->
zName
, 
pTable
->zName, 
zDb
) ||

83791 
	`sqlite3AuthCheck
(
pParse
, 9, 
zTab
, 0, 
zDb
) )

83802 if( (
v
 = 
	`sqlite3GetVdbe
(
pParse
))!=0 )

83805 
	`sqlite3NestedParse
(
pParse
,

83807 
db
->
aDb
[
iDb
].
zName
, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), 
pTrigger
->zName

83809 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

83810 
	`sqlite3VdbeAddOp4
(
v
, 127, 
iDb
, 0, 0, 
pTrigger
->
zName
, 0);

83812 
	}
}

83817 static void 
	$sqlite3UnlinkAndDeleteTrigger
(
sqlite3
 *
db
, int 
iDb
, const char *
zName
)

83820 
Trigger
 *
pTrigger
;

83821 
Hash
 *
pHash
;

83824 
pHash
 = &(
db
->
aDb
[
iDb
].
pSchema
->
trigHash
);

83825 
pTrigger
 = 
	`sqlite3HashInsert
(
pHash
, 
zName
, 0);

83826 if( (
pTrigger
) )

83829 if( 
pTrigger
->
pSchema
==pTrigger->
pTabSchema
 )

83832 
Table
 *
pTab
 = 
	`tableOfTrigger
(
pTrigger
);

83833 
Trigger
 **
pp
;

83834 for(
pp
=&
pTab
->
pTrigger
; *pp!=pTrigger; pp=&((*pp)->
pNext
));

83835 *
pp
 = (*pp)->
pNext
;

83837 
	`sqlite3DeleteTrigger
(
db
, 
pTrigger
);

83838 
db
->
flags
 |= 0x00000002;

83840 
	}
}

83842 static int 
	$checkColumnOverlap
(
IdList
 *
pIdList
, 
ExprList
 *
pEList
)

83845 int 
e
;

83846 if( 
pIdList
==0 || (
pEList
==0) ) return 1;

83847 for(
e
=0; e<
pEList
->
nExpr
; e++)

83850 if( 
	`sqlite3IdListIndex
(
pIdList
, 
pEList
->
a
[
e
].
zName
)>=0 ) return 1;

83853 
	}
}

83861 static 
Trigger
 *
	$sqlite3TriggersExist
(

83862 
Parse
 *
pParse
,

83863 
Table
 *
pTab
,

83864 int 
op
,

83865 
ExprList
 *
pChanges
,

83866 int *
pMask


83870 int 
mask
 = 0;

83871 
Trigger
 *
pList
 = 0;

83872 
Trigger
 *
p
;

83874 if( (
pParse
->
db
->
flags
 & 0x00800000)!=0 )

83877 
pList
 = 
	`sqlite3TriggerList
(
pParse
, 
pTab
);

83880 for(
p
=
pList
; p; p=p->
pNext
)

83883 if( 
p
->
op
==op && 
	`checkColumnOverlap
(p->
pColumns
, 
pChanges
) )

83886 
mask
 |= 
p
->
tr_tm
;

83889 if( 
pMask
 )

83892 *
pMask
 = 
mask
;

83894 return (
mask
 ? 
pList
 : 0);

83895 
	}
}

83897 static 
SrcList
 *
	$targetSrcList
(

83898 
Parse
 *
pParse
,

83899 
TriggerStep
 *
pStep


83903 
sqlite3
 *
db
 = 
pParse
->db;

83904 int 
iDb
;

83905 
SrcList
 *
pSrc
;

83907 
pSrc
 = 
	`sqlite3SrcListAppend
(
db
, 0, 0, 0);

83908 if( 
pSrc
 )

83912 
pSrc
->
a
[pSrc->
nSrc
-1].
zName
 = 
	`sqlite3DbStrDup
(
db
, 
pStep
->
zTarget
);

83913 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pStep
->
pTrig
->
pSchema
);

83914 if( 
iDb
==0 || iDb>=2 )

83918 
pSrc
->
a
[pSrc->
nSrc
-1].
zDatabase
 = 
	`sqlite3DbStrDup
(
db
, db->
aDb
[
iDb
].
zName
);

83921 return 
pSrc
;

83922 
	}
}

83928 static int 
	$codeTriggerProgram
(

83929 
Parse
 *
pParse
,

83930 
TriggerStep
 *
pStepList
,

83931 int 
orconf


83935 
TriggerStep
 *
pStep
;

83936 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

83937 
sqlite3
 *
db
 = 
pParse
->db;

83942 for(
pStep
=
pStepList
; pStep; pStep=pStep->
pNext
)

83946 
pParse
->
eOrconf
 = (
orconf
==10)?
pStep
->orconf:(
u8
)orconf;

83949 switch( 
pStep
->
op
 )

83953 
	`sqlite3Update
(
pParse
,

83954 
	`targetSrcList
(
pParse
, 
pStep
),

83955 
	`sqlite3ExprListDup
(
db
, 
pStep
->
pExprList
, 0),

83956 
	`sqlite3ExprDup
(
db
, 
pStep
->
pWhere
, 0),

83957 
pParse
->
eOrconf


83962 
	`sqlite3Insert
(
pParse
,

83963 
	`targetSrcList
(
pParse
, 
pStep
),

83964 
	`sqlite3SelectDup
(
db
, 
pStep
->
pSelect
, 0),

83965 
	`sqlite3IdListDup
(
db
, 
pStep
->
pIdList
),

83966 
pParse
->
eOrconf


83971 
	`sqlite3DeleteFrom
(
pParse
,

83972 
	`targetSrcList
(
pParse
, 
pStep
),

83973 
	`sqlite3ExprDup
(
db
, 
pStep
->
pWhere
, 0)

83978 
SelectDest
 
sDest
;

83979 
Select
 *
pSelect
 = 
	`sqlite3SelectDup
(
db
, 
pStep
->pSelect, 0);

83980 
	`sqlite3SelectDestInit
(&
sDest
, 4, 0);

83981 
	`sqlite3Select
(
pParse
, 
pSelect
, &
sDest
);

83982 
	`sqlite3SelectDelete
(
db
, 
pSelect
);

83986 if( 
pStep
->
op
!=119 )

83989 
	`sqlite3VdbeAddOp0
(
v
, 98);

83994 
	}
}

83996 static void 
	$transferParseError
(
Parse
 *
pTo
, Parse *
pFrom
)

84001 if( 
pTo
->
nErr
==0 )

84004 
pTo
->
zErrMsg
 = 
pFrom
->zErrMsg;

84005 
pTo
->
nErr
 = 
pFrom
->nErr;

84006 
pTo
->
rc
 = 
pFrom
->rc;

84008 
	`sqlite3DbFree
(
pFrom
->
db
, pFrom->
zErrMsg
);

84010 
	}
}

84016 static 
TriggerPrg
 *
	$codeRowTrigger
(

84017 
Parse
 *
pParse
,

84018 
Trigger
 *
pTrigger
,

84019 
Table
 *
pTab
,

84020 int 
orconf


84024 
Parse
 *
pTop
 = ((
pParse
)->
pToplevel
 ? (pParse)->pToplevel : (pParse));

84025 
sqlite3
 *
db
 = 
pParse
->db;

84026 
TriggerPrg
 *
pPrg
;

84027 
Expr
 *
pWhen
 = 0;

84028 
Vdbe
 *
v
;

84029 
NameContext
 
sNC
;

84030 
SubProgram
 *
pProgram
 = 0;

84031 
Parse
 *
pSubParse
;

84032 int 
iEndTrigger
 = 0;

84040 
pPrg
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
TriggerPrg
));

84041 if( !
pPrg
 ) return 0;

84042 
pPrg
->
pNext
 = 
pTop
->
pTriggerPrg
;

84043 
pTop
->
pTriggerPrg
 = 
pPrg
;

84044 
pPrg
->
pProgram
 = pProgram = 
	`sqlite3DbMallocZero
(
db
, sizeof(
SubProgram
));

84045 if( !
pProgram
 ) return 0;

84046 
	`sqlite3VdbeLinkSubProgram
(
pTop
->
pVdbe
, 
pProgram
);

84047 
pPrg
->
pTrigger
 = pTrigger;

84048 
pPrg
->
orconf
 = orconf;

84049 
pPrg
->
aColmask
[0] = 0xffffffff;

84050 
pPrg
->
aColmask
[1] = 0xffffffff;

84054 
pSubParse
 = 
	`sqlite3DbMallocZero
(
db
,sizeof(
Parse
));

84055 if( !
pSubParse
 ) return 0;

84056 
	`memset
(&
sNC
, 0, sizeof(sNC));

84057 
sNC
.
pParse
 = 
pSubParse
;

84058 
pSubParse
->
db
 = db;

84059 
pSubParse
->
pTriggerTab
 = 
pTab
;

84060 
pSubParse
->
pToplevel
 = 
pTop
;

84061 
pSubParse
->
zAuthContext
 = 
pTrigger
->
zName
;

84062 
pSubParse
->
eTriggerOp
 = 
pTrigger
->
op
;

84063 
pSubParse
->
nQueryLoop
 = 
pParse
->nQueryLoop;

84065 
v
 = 
	`sqlite3GetVdbe
(
pSubParse
);

84066 if( 
v
 )

84078 
	`sqlite3VdbeChangeP4
(
v
, -1,

84079 
	`sqlite3MPrintf
(
db
, "-- TRIGGER %s", 
pTrigger
->
zName
), (-1)

84086 if( 
pTrigger
->
pWhen
 )

84089 
pWhen
 = 
	`sqlite3ExprDup
(
db
, 
pTrigger
->pWhen, 0);

84090 if( 0==
	`sqlite3ResolveExprNames
(&
sNC
, 
pWhen
)

84091 && 
db
->
mallocFailed
==0

84095 
iEndTrigger
 = 
	`sqlite3VdbeMakeLabel
(
v
);

84096 
	`sqlite3ExprIfFalse
(
pSubParse
, 
pWhen
, 
iEndTrigger
, 0x10);

84098 
	`sqlite3ExprDelete
(
db
, 
pWhen
);

84102 
	`codeTriggerProgram
(
pSubParse
, 
pTrigger
->
step_list
, 
orconf
);

84105 if( 
iEndTrigger
 )

84108 
	`sqlite3VdbeResolveLabel
(
v
, 
iEndTrigger
);

84110 
	`sqlite3VdbeAddOp0
(
v
, 21);

84113 
	`transferParseError
(
pParse
, 
pSubParse
);

84114 if( 
db
->
mallocFailed
==0 )

84117 
pProgram
->
aOp
 = 
	`sqlite3VdbeTakeOpArray
(
v
, &pProgram->
nOp
, &
pTop
->
nMaxArg
);

84119 
pProgram
->
nMem
 = 
pSubParse
->nMem;

84120 
pProgram
->
nCsr
 = 
pSubParse
->
nTab
;

84121 
pProgram
->
nOnce
 = 
pSubParse
->nOnce;

84122 
pProgram
->
token
 = (void *)
pTrigger
;

84123 
pPrg
->
aColmask
[0] = 
pSubParse
->
oldmask
;

84124 
pPrg
->
aColmask
[1] = 
pSubParse
->
newmask
;

84125 
	`sqlite3VdbeDelete
(
v
);

84130 
	`sqlite3ParserReset
(
pSubParse
);

84131 
	`sqlite3DbFree
(
db
,
pSubParse
);

84133 return 
pPrg
;

84134 
	}
}

84142 static 
TriggerPrg
 *
	$getRowTrigger
(

84143 
Parse
 *
pParse
,

84144 
Trigger
 *
pTrigger
,

84145 
Table
 *
pTab
,

84146 int 
orconf


84150 
Parse
 *
pRoot
 = ((
pParse
)->
pToplevel
 ? (pParse)->pToplevel : (pParse));

84151 
TriggerPrg
 *
pPrg
;

84159 for(
pPrg
=
pRoot
->
pTriggerPrg
;

84160 
pPrg
 && (pPrg->
pTrigger
!=pTrigger || pPrg->
orconf
!=orconf);

84161 
pPrg
=pPrg->
pNext


84165 if( !
pPrg
 )

84168 
pPrg
 = 
	`codeRowTrigger
(
pParse
, 
pTrigger
, 
pTab
, 
orconf
);

84171 return 
pPrg
;

84172 
	}
}

84180 static void 
	$sqlite3CodeRowTriggerDirect
(

84181 
Parse
 *
pParse
,

84182 
Trigger
 *
p
,

84183 
Table
 *
pTab
,

84184 int 
reg
,

84185 int 
orconf
,

84186 int 
ignoreJump


84190 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

84191 
TriggerPrg
 *
pPrg
;

84192 
pPrg
 = 
	`getRowTrigger
(
pParse
, 
p
, 
pTab
, 
orconf
);

84197 if( 
pPrg
 )

84200 int 
bRecursive
 = (
p
->
zName
 && 0==(
pParse
->
db
->
flags
&0x00040000));

84202 
	`sqlite3VdbeAddOp4
(
v
, 132, 
reg
, 
ignoreJump
, ++
pParse
->
nMem
,

84203 (const char *)
pPrg
->
pProgram
, (-18));

84212 
	`sqlite3VdbeChangeP5
(
v
, (
u8
)
bRecursive
);

84214 
	}
}

84216 static void 
	$sqlite3CodeRowTrigger
(

84217 
Parse
 *
pParse
,

84218 
Trigger
 *
pTrigger
,

84219 int 
op
,

84220 
ExprList
 *
pChanges
,

84221 int 
tr_tm
,

84222 
Table
 *
pTab
,

84223 int 
reg
,

84224 int 
orconf
,

84225 int 
ignoreJump


84229 
Trigger
 *
p
;

84235 for(
p
=
pTrigger
; p; p=p->
pNext
)

84248 if( 
p
->
op
==op

84249 && 
p
->
tr_tm
==tr_tm

84250 && 
	`checkColumnOverlap
(
p
->
pColumns
, 
pChanges
)

84254 
	`sqlite3CodeRowTriggerDirect
(
pParse
, 
p
, 
pTab
, 
reg
, 
orconf
, 
ignoreJump
);

84257 
	}
}

84259 static 
u32
 
	$sqlite3TriggerColmask
(

84260 
Parse
 *
pParse
,

84261 
Trigger
 *
pTrigger
,

84262 
ExprList
 *
pChanges
,

84263 int 
isNew
,

84264 int 
tr_tm
,

84265 
Table
 *
pTab
,

84266 int 
orconf


84270 const int 
op
 = 
pChanges
 ? 110 : 109;

84271 
u32
 
mask
 = 0;

84272 
Trigger
 *
p
;

84275 for(
p
=
pTrigger
; p; p=p->
pNext
)

84278 if( 
p
->
op
==op && (
tr_tm
&p->tr_tm)

84279 && 
	`checkColumnOverlap
(
p
->
pColumns
,
pChanges
)

84283 
TriggerPrg
 *
pPrg
;

84284 
pPrg
 = 
	`getRowTrigger
(
pParse
, 
p
, 
pTab
, 
orconf
);

84285 if( 
pPrg
 )

84288 
mask
 |= 
pPrg
->
aColmask
[
isNew
];

84293 return 
mask
;

84294 
	}
}

84296 static void 
updateVirtualTable
(

84297 
Parse
 *
pParse
,

84298 
SrcList
 *
pSrc
,

84299 
Table
 *
pTab
,

84300 
ExprList
 *
pChanges
,

84301 
Expr
 *
pRowidExpr
,

84302 int *
aXRef
,

84303 
Expr
 *
pWhere
,

84304 int 
onError


84307 static void 
	$sqlite3ColumnDefault
(
Vdbe
 *
v
, 
Table
 *
pTab
, int 
i
, int 
iReg
)

84311 if( !
pTab
->
pSelect
 )

84314 
sqlite3_value
 *
pValue
 = 0;

84315 
u8
 
enc
 = ((
	`sqlite3VdbeDb
(
v
))->enc);

84316 
Column
 *
pCol
 = &
pTab
->
aCol
[
i
];

84319 
	`sqlite3ValueFromExpr
(
	`sqlite3VdbeDb
(
v
), 
pCol
->
pDflt
, 
enc
,

84320 
pCol
->
affinity
, &
pValue
);

84321 if( 
pValue
 )

84324 
	`sqlite3VdbeChangeP4
(
v
, -1, (const char *)
pValue
, (-8));

84327 if( 
pTab
->
aCol
[
i
].
affinity
=='E' )

84330 
	`sqlite3VdbeAddOp1
(
v
, 39, 
iReg
);

84334 
	}
}

84336 static void 
	$sqlite3Update
(

84337 
Parse
 *
pParse
,

84338 
SrcList
 *
pTabList
,

84339 
ExprList
 *
pChanges
,

84340 
Expr
 *
pWhere
,

84341 int 
onError


84345 int 
i
, 
j
;

84346 
Table
 *
pTab
;

84347 int 
addrTop
 = 0;

84348 
WhereInfo
 *
pWInfo
;

84349 
Vdbe
 *
v
;

84350 
Index
 *
pIdx
;

84351 
Index
 *
pPk
;

84352 int 
nIdx
;

84353 int 
iBaseCur
;

84354 int 
iDataCur
;

84355 int 
iIdxCur
;

84356 
sqlite3
 *
db
;

84357 int *
aRegIdx
 = 0;

84358 int *
aXRef
 = 0;

84361 
u8
 *
aToOpen
;

84362 
u8
 
chngPk
;

84363 
u8
 
chngRowid
;

84364 
u8
 
chngKey
;

84365 
Expr
 *
pRowidExpr
 = 0;

84366 
AuthContext
 
sContext
;

84367 
NameContext
 
sNC
;

84368 int 
iDb
;

84369 int 
okOnePass
;

84370 int 
hasFK
;

84371 int 
labelBreak
;

84372 int 
labelContinue
;

84375 int 
isView
;

84376 
Trigger
 *
pTrigger
;

84377 int 
tmask
;

84379 int 
newmask
;

84380 int 
iEph
 = 0;

84381 int 
nKey
 = 0;

84382 int 
aiCurOnePass
[2];

84385 int 
regRowCount
 = 0;

84386 int 
regOldRowid
 = 0;

84387 int 
regNewRowid
 = 0;

84388 int 
regNew
 = 0;

84389 int 
regOld
 = 0;

84390 int 
regRowSet
 = 0;

84391 int 
regKey
 = 0;

84393 
	`memset
(&
sContext
, 0, sizeof(sContext));

84394 
db
 = 
pParse
->db;

84395 if( 
pParse
->
nErr
 || 
db
->
mallocFailed
 )

84398 goto 
update_cleanup
;

84404 
pTab
 = 
	`sqlite3SrcListLookup
(
pParse
, 
pTabList
);

84405 if( 
pTab
==0 ) goto 
update_cleanup
;

84406 
iDb
 = 
	`sqlite3SchemaToIndex
(
pParse
->
db
, 
pTab
->
pSchema
);

84412 
pTrigger
 = 
	`sqlite3TriggersExist
(
pParse
, 
pTab
, 110, 
pChanges
, &
tmask
);

84413 
isView
 = 
pTab
->
pSelect
!=0;

84416 if( 
	`sqlite3ViewGetColumnNames
(
pParse
, 
pTab
) )

84419 goto 
update_cleanup
;

84421 if( 
	`sqlite3IsReadOnly
(
pParse
, 
pTab
, 
tmask
) )

84424 goto 
update_cleanup
;

84432 
pTabList
->
a
[0].
iCursor
 = 
iBaseCur
 = 
iDataCur
 = 
pParse
->
nTab
++;

84433 
iIdxCur
 = 
iDataCur
+1;

84434 
pPk
 = (((
pTab
)->
tabFlags
 & 0x20)==0) ? 0 : 
	`sqlite3PrimaryKeyIndex
(pTab);

84435 for(
nIdx
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, nIdx++)

84438 if( ((
pIdx
)->
idxType
==2) && 
pPk
!=0 )

84441 
iDataCur
 = 
pParse
->
nTab
;

84442 
pTabList
->
a
[0].
iCursor
 = 
iDataCur
;

84444 
pParse
->
nTab
++;

84450 
aXRef
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(int) * (
pTab
->
nCol
+
nIdx
) + nIdx+2 );

84451 if( 
aXRef
==0 ) goto 
update_cleanup
;

84452 
aRegIdx
 = 
aXRef
+
pTab
->
nCol
;

84453 
aToOpen
 = (
u8
*)(
aRegIdx
+
nIdx
);

84454 
	`memset
(
aToOpen
, 1, 
nIdx
+1);

84455 
aToOpen
[
nIdx
+1] = 0;

84456 for(
i
=0; i<
pTab
->
nCol
; i++) 
aXRef
[i] = -1;

84459 
	`memset
(&
sNC
, 0, sizeof(sNC));

84460 
sNC
.
pParse
 = pParse;

84461 
sNC
.
pSrcList
 = 
pTabList
;

84469 
chngRowid
 = 
chngPk
 = 0;

84470 for(
i
=0; i<
pChanges
->
nExpr
; i++)

84473 if( 
	`sqlite3ResolveExprNames
(&
sNC
, 
pChanges
->
a
[
i
].
pExpr
) )

84476 goto 
update_cleanup
;

84478 for(
j
=0; j<
pTab
->
nCol
; j++)

84481 if( 
	`sqlite3StrICmp
(
pTab
->
aCol
[
j
].
zName
, 
pChanges
->
a
[
i
].zName)==0 )

84484 if( 
j
==
pTab
->
iPKey
 )

84487 
chngRowid
 = 1;

84488 
pRowidExpr
 = 
pChanges
->
a
[
i
].
pExpr
;

84489 }else if( 
pPk
 && (
pTab
->
aCol
[
j
].
colFlags
 & 0x0001)!=0 )

84492 
chngPk
 = 1;

84494 
aXRef
[
j
] = 
i
;

84498 if( 
j
>=
pTab
->
nCol
 )

84501 if( 
pPk
==0 && 
	`sqlite3IsRowid
(
pChanges
->
a
[
i
].
zName
) )

84504 
j
 = -1;

84505 
chngRowid
 = 1;

84506 
pRowidExpr
 = 
pChanges
->
a
[
i
].
pExpr
;

84508 
	`sqlite3ErrorMsg
(
pParse
, "no such column: %s", 
pChanges
->
a
[
i
].
zName
);

84509 
pParse
->
checkSchema
 = 1;

84510 goto 
update_cleanup
;

84515 int 
rc
;

84516 
rc
 = 
	`sqlite3AuthCheck
(
pParse
, 23, 
pTab
->
zName
,

84517 
j
<0 ? "ROWID" : 
pTab
->
aCol
[j].
zName
,

84518 
db
->
aDb
[
iDb
].
zName
);

84519 if( 
rc
==1 )

84522 goto 
update_cleanup
;

84523 }else if( 
rc
==2 )

84526 
aXRef
[
j
] = -1;

84534 
chngKey
 = 
chngRowid
 + 
chngPk
;

84541 
pTabList
->
a
[0].
colUsed
 = (((
pTab
)->
tabFlags
 & 0x10)!=0) ? ((
Bitmask
)-1) : 0;

84543 
hasFK
 = 
	`sqlite3FkRequired
(
pParse
, 
pTab
, 
aXRef
, 
chngKey
);

84551 for(
j
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, j++)

84554 int 
reg
;

84555 if( 
chngKey
 || 
hasFK
 || 
pIdx
->
pPartIdxWhere
 || pIdx==
pPk
 )

84558 
reg
 = ++
pParse
->
nMem
;

84560 
reg
 = 0;

84561 for(
i
=0; i<
pIdx
->
nKeyCol
; i++)

84564 
i16
 
iIdxCol
 = 
pIdx
->
aiColumn
[
i
];

84565 if( 
iIdxCol
<0 || 
aXRef
[iIdxCol]>=0 )

84568 
reg
 = ++
pParse
->
nMem
;

84573 if( 
reg
==0 ) 
aToOpen
[
j
+1] = 0;

84574 
aRegIdx
[
j
] = 
reg
;

84578 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

84579 if( 
v
==0 ) goto 
update_cleanup
;

84580 if( 
pParse
->
nested
==0 ) 
	`sqlite3VdbeCountChanges
(
v
);

84581 
	`sqlite3BeginWriteOperation
(
pParse
, 1, 
iDb
);

84584 if( !(((
pTab
)->
tabFlags
 & 0x10)!=0) )

84587 
regRowSet
 = ++
pParse
->
nMem
;

84588 
regOldRowid
 = 
regNewRowid
 = ++
pParse
->
nMem
;

84589 if( 
chngPk
 || 
pTrigger
 || 
hasFK
 )

84592 
regOld
 = 
pParse
->
nMem
 + 1;

84593 
pParse
->
nMem
 += 
pTab
->
nCol
;

84595 if( 
chngKey
 || 
pTrigger
 || 
hasFK
 )

84598 
regNewRowid
 = ++
pParse
->
nMem
;

84600 
regNew
 = 
pParse
->
nMem
 + 1;

84601 
pParse
->
nMem
 += 
pTab
->
nCol
;

84605 if( 
isView
 )

84608 
	`sqlite3AuthContextPush
(
pParse
, &
sContext
, 
pTab
->
zName
);

84615 if( 
isView
 )

84618 
	`sqlite3MaterializeView
(
pParse
, 
pTab
, 
pWhere
, 
iDataCur
);

84625 if( 
	`sqlite3ResolveExprNames
(&
sNC
, 
pWhere
) )

84628 goto 
update_cleanup
;

84633 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

84636 
	`updateVirtualTable
(
pParse
, 
pTabList
, 
pTab
, 
pChanges
, 
pRowidExpr
, 
aXRef
,

84637 
pWhere
, 
onError
);

84638 goto 
update_cleanup
;

84644 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

84647 
	`sqlite3VdbeAddOp3
(
v
, 25, 0, 
regRowSet
, 
regOldRowid
);

84648 
pWInfo
 = 
	`sqlite3WhereBegin
(

84649 
pParse
, 
pTabList
, 
pWhere
, 0, 0, 0x0004, 
iIdxCur


84651 if( 
pWInfo
==0 ) goto 
update_cleanup
;

84652 
okOnePass
 = 
	`sqlite3WhereOkOnePass
(
pWInfo
, 
aiCurOnePass
);

84656 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iDataCur
, 
regOldRowid
);

84657 if( !
okOnePass
 )

84660 
	`sqlite3VdbeAddOp2
(
v
, 129, 
regRowSet
, 
regOldRowid
);

84665 
	`sqlite3WhereEnd
(
pWInfo
);

84667 int 
iPk
;

84668 
i16
 
nPk
;

84669 int 
addrOpen
;

84672 
nPk
 = 
pPk
->
nKeyCol
;

84673 
iPk
 = 
pParse
->
nMem
+1;

84674 
pParse
->
nMem
 += 
nPk
;

84675 
regKey
 = ++
pParse
->
nMem
;

84676 
iEph
 = 
pParse
->
nTab
++;

84677 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
iPk
);

84678 
addrOpen
 = 
	`sqlite3VdbeAddOp2
(
v
, 57, 
iEph
, 
nPk
);

84679 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pPk
);

84680 
pWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pTabList
, 
pWhere
, 0, 0,

84681 0x0004, 
iIdxCur
);

84682 if( 
pWInfo
==0 ) goto 
update_cleanup
;

84683 
okOnePass
 = 
	`sqlite3WhereOkOnePass
(
pWInfo
, 
aiCurOnePass
);

84684 for(
i
=0; i<
nPk
; i++)

84688 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 
iDataCur
, 
pPk
->
aiColumn
[
i
],

84689 
iPk
+
i
);

84691 if( 
okOnePass
 )

84694 
	`sqlite3VdbeChangeToNoop
(
v
, 
addrOpen
);

84695 
nKey
 = 
nPk
;

84696 
regKey
 = 
iPk
;

84698 
	`sqlite3VdbeAddOp4
(
v
, 49, 
iPk
, 
nPk
, 
regKey
,

84699 
	`sqlite3IndexAffinityStr
(
db
, 
pPk
), 
nPk
);

84700 
	`sqlite3VdbeAddOp2
(
v
, 110, 
iEph
, 
regKey
);

84702 
	`sqlite3WhereEnd
(
pWInfo
);

84707 if( (
db
->
flags
 & 0x00000080) && !
pParse
->
pTriggerTab
 )

84710 
regRowCount
 = ++
pParse
->
nMem
;

84711 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
regRowCount
);

84714 
labelBreak
 = 
	`sqlite3VdbeMakeLabel
(
v
);

84715 if( !
isView
 )

84724 if( 
onError
==5 )

84727 
	`memset
(
aToOpen
, 1, 
nIdx
+1);

84729 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

84732 if( 
pIdx
->
onError
==5 )

84735 
	`memset
(
aToOpen
, 1, 
nIdx
+1);

84740 if( 
okOnePass
 )

84743 if( 
aiCurOnePass
[0]>=0 ) 
aToOpen
[aiCurOnePass[0]-
iBaseCur
] = 0;

84744 if( 
aiCurOnePass
[1]>=0 ) 
aToOpen
[aiCurOnePass[1]-
iBaseCur
] = 0;

84746 
	`sqlite3OpenTableAndIndices
(
pParse
, 
pTab
, 55, 0, 
iBaseCur
, 
aToOpen
,

84751 if( 
okOnePass
 )

84754 if( 
aToOpen
[
iDataCur
-
iBaseCur
] && !
isView
 )

84758 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
iDataCur
, 
labelBreak
, 
regKey
, 
nKey
);

84761 
labelContinue
 = 
labelBreak
;

84762 
	`sqlite3VdbeAddOp2
(
v
, 76, 
pPk
 ? 
regKey
 : 
regOldRowid
, 
labelBreak
);

84765 }else if( 
pPk
 )

84768 
labelContinue
 = 
	`sqlite3VdbeMakeLabel
(
v
);

84769 
	`sqlite3VdbeAddOp2
(
v
, 108, 
iEph
, 
labelBreak
); ;

84770 
addrTop
 = 
	`sqlite3VdbeAddOp2
(
v
, 101, 
iEph
, 
regKey
);

84771 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
iDataCur
, 
labelContinue
, 
regKey
, 0);

84774 
labelContinue
 = 
	`sqlite3VdbeAddOp3
(
v
, 130, 
regRowSet
, 
labelBreak
,

84775 
regOldRowid
);

84777 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iDataCur
, 
labelContinue
, 
regOldRowid
);

84786 if( 
chngRowid
 )

84789 
	`sqlite3ExprCode
(
pParse
, 
pRowidExpr
, 
regNewRowid
);

84790 
	`sqlite3VdbeAddOp1
(
v
, 38, 
regNewRowid
); ;

84795 if( 
chngPk
 || 
hasFK
 || 
pTrigger
 )

84798 
u32
 
oldmask
 = (
hasFK
 ? 
	`sqlite3FkOldmask
(
pParse
, 
pTab
) : 0);

84799 
oldmask
 |= 
	`sqlite3TriggerColmask
(
pParse
,

84800 
pTrigger
, 
pChanges
, 0, 1|2, 
pTab
, 
onError


84802 for(
i
=0; i<
pTab
->
nCol
; i++)

84805 if( 
oldmask
==0xffffffff

84806 || (
i
<32 && (
oldmask
 & (((unsigned int)1)<<(i)))!=0)

84807 || (
pTab
->
aCol
[
i
].
colFlags
 & 0x0001)!=0

84812 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 
iDataCur
, 
i
, 
regOld
+i);

84814 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regOld
+
i
);

84817 if( 
chngRowid
==0 && 
pPk
==0 )

84820 
	`sqlite3VdbeAddOp2
(
v
, 30, 
regOldRowid
, 
regNewRowid
);

84824 
newmask
 = 
	`sqlite3TriggerColmask
(

84825 
pParse
, 
pTrigger
, 
pChanges
, 1, 1, 
pTab
, 
onError


84827 for(
i
=0; i<
pTab
->
nCol
; i++)

84830 if( 
i
==
pTab
->
iPKey
 )

84833 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regNew
+
i
);

84835 
j
 = 
aXRef
[
i
];

84836 if( 
j
>=0 )

84839 
	`sqlite3ExprCode
(
pParse
, 
pChanges
->
a
[
j
].
pExpr
, 
regNew
+
i
);

84840 }else if( 0==(
tmask
&1) || 
i
>31 || (
newmask
 & (((unsigned int)1)<<(i))) )

84850 
	`sqlite3ExprCodeGetColumnToReg
(
pParse
, 
pTab
, 
i
, 
iDataCur
, 
regNew
+i);

84852 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regNew
+
i
);

84860 if( 
tmask
&1 )

84863 
	`sqlite3TableAffinity
(
v
, 
pTab
, 
regNew
);

84864 
	`sqlite3CodeRowTrigger
(
pParse
, 
pTrigger
, 110, 
pChanges
,

84865 1, 
pTab
, 
regOldRowid
, 
onError
, 
labelContinue
);

84873 if( 
pPk
 )

84876 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
iDataCur
, 
labelContinue
,
regKey
,
nKey
);

84879 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iDataCur
, 
labelContinue
, 
regOldRowid
);

84888 for(
i
=0; i<
pTab
->
nCol
; i++)

84891 if( 
aXRef
[
i
]<0 && i!=
pTab
->
iPKey
 )

84894 
	`sqlite3ExprCodeGetColumnOfTable
(
v
, 
pTab
, 
iDataCur
, 
i
, 
regNew
+i);

84899 if( !
isView
 )

84902 int 
addr1
 = 0;

84903 int 
bReplace
 = 0;

84907 
	`sqlite3GenerateConstraintChecks
(
pParse
, 
pTab
, 
aRegIdx
, 
iDataCur
, 
iIdxCur
,

84908 
regNewRowid
, 
regOldRowid
, 
chngKey
, 
onError
, 
labelContinue
, &
bReplace
,

84909 
aXRef
);

84912 if( 
hasFK
 )

84915 
	`sqlite3FkCheck
(
pParse
, 
pTab
, 
regOldRowid
, 0, 
aXRef
, 
chngKey
);

84919 if( 
bReplace
 || 
chngKey
 )

84922 if( 
pPk
 )

84925 
addr1
 = 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
iDataCur
, 0, 
regKey
, 
nKey
);

84927 
addr1
 = 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iDataCur
, 0, 
regOldRowid
);

84931 
	`sqlite3GenerateRowIndexDelete
(
pParse
, 
pTab
, 
iDataCur
, 
iIdxCur
, 
aRegIdx
, -1);

84934 if( 
hasFK
 || 
chngKey
 || 
pPk
!=0 )

84937 
	`sqlite3VdbeAddOp2
(
v
, 95, 
iDataCur
, 0);

84939 if( 
bReplace
 || 
chngKey
 )

84942 
	`sqlite3VdbeJumpHere
(
v
, 
addr1
);

84945 if( 
hasFK
 )

84948 
	`sqlite3FkCheck
(
pParse
, 
pTab
, 0, 
regNewRowid
, 
aXRef
, 
chngKey
);

84952 
	`sqlite3CompleteInsertion
(
pParse
, 
pTab
, 
iDataCur
, 
iIdxCur
,

84953 
regNewRowid
, 
aRegIdx
, 1, 0, 0);

84958 if( 
hasFK
 )

84961 
	`sqlite3FkActions
(
pParse
, 
pTab
, 
pChanges
, 
regOldRowid
, 
aXRef
, 
chngKey
);

84967 if( (
db
->
flags
 & 0x00000080) && !
pParse
->
pTriggerTab
)

84970 
	`sqlite3VdbeAddOp2
(
v
, 37, 
regRowCount
, 1);

84973 
	`sqlite3CodeRowTrigger
(
pParse
, 
pTrigger
, 110, 
pChanges
,

84974 2, 
pTab
, 
regOldRowid
, 
onError
, 
labelContinue
);

84979 if( 
okOnePass
 )

84983 }else if( 
pPk
 )

84986 
	`sqlite3VdbeResolveLabel
(
v
, 
labelContinue
);

84987 
	`sqlite3VdbeAddOp2
(
v
, 7, 
iEph
, 
addrTop
); ;

84989 
	`sqlite3VdbeGoto
(
v
, 
labelContinue
);

84991 
	`sqlite3VdbeResolveLabel
(
v
, 
labelBreak
);

84994 for(
i
=0, 
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
, i++)

84998 if( 
aToOpen
[
i
+1] )

85001 
	`sqlite3VdbeAddOp2
(
v
, 61, 
iIdxCur
+
i
, 0);

85004 if( 
iDataCur
<
iIdxCur
 ) 
	`sqlite3VdbeAddOp2
(
v
, 61, iDataCur, 0);

85010 if( 
pParse
->
nested
==0 && pParse->
pTriggerTab
==0 )

85013 
	`sqlite3AutoincrementEnd
(
pParse
);

85021 if( (
db
->
flags
&0x00000080) && !
pParse
->
pTriggerTab
 && !pParse->
nested
 )

85024 
	`sqlite3VdbeAddOp2
(
v
, 33, 
regRowCount
, 1);

85025 
	`sqlite3VdbeSetNumCols
(
v
, 1);

85026 
	`sqlite3VdbeSetColName
(
v
, 0, 0, "rows updated", ((
sqlite3_destructor_type
)0));

85029 
update_cleanup
:

85030 
	`sqlite3AuthContextPop
(&
sContext
);

85031 
	`sqlite3DbFree
(
db
, 
aXRef
);

85032 
	`sqlite3SrcListDelete
(
db
, 
pTabList
);

85033 
	`sqlite3ExprListDelete
(
db
, 
pChanges
);

85034 
	`sqlite3ExprDelete
(
db
, 
pWhere
);

85036 
	}
}

85038 static void 
	$updateVirtualTable
(

85039 
Parse
 *
pParse
,

85040 
SrcList
 *
pSrc
,

85041 
Table
 *
pTab
,

85042 
ExprList
 *
pChanges
,

85043 
Expr
 *
pRowid
,

85044 int *
aXRef
,

85045 
Expr
 *
pWhere
,

85046 int 
onError


85050 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

85051 int 
ephemTab
;

85052 int 
i
;

85053 
sqlite3
 *
db
 = 
pParse
->db;

85054 const char *
pVTab
 = (const char*)
	`sqlite3GetVTable
(
db
, 
pTab
);

85055 
WhereInfo
 *
pWInfo
;

85056 int 
nArg
 = 2 + 
pTab
->
nCol
;

85057 int 
regArg
;

85058 int 
regRec
;

85059 int 
regRowid
;

85060 int 
iCsr
 = 
pSrc
->
a
[0].
iCursor
;

85061 int 
aDummy
[2];

85062 int 
bOnePass
;

85063 int 
addr
;

85069 
ephemTab
 = 
pParse
->
nTab
++;

85070 
addr
= 
	`sqlite3VdbeAddOp2
(
v
, 57, 
ephemTab
, 
nArg
);

85071 
regArg
 = 
pParse
->
nMem
 + 1;

85072 
pParse
->
nMem
 += 
nArg
;

85073 
regRec
 = ++
pParse
->
nMem
;

85074 
regRowid
 = ++
pParse
->
nMem
;

85077 
pWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pSrc
, 
pWhere
, 0,0,0x0004,0);

85078 if( 
pWInfo
==0 ) return;

85081 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iCsr
, 
regArg
);

85082 if( 
pRowid
 )

85085 
	`sqlite3ExprCode
(
pParse
, 
pRowid
, 
regArg
+1);

85087 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iCsr
, 
regArg
+1);

85089 for(
i
=0; i<
pTab
->
nCol
; i++)

85092 if( 
aXRef
[
i
]>=0 )

85095 
	`sqlite3ExprCode
(
pParse
, 
pChanges
->
a
[
aXRef
[
i
]].
pExpr
, 
regArg
+2+i);

85097 
	`sqlite3VdbeAddOp3
(
v
, 153, 
iCsr
, 
i
, 
regArg
+2+i);

85101 
bOnePass
 = 
	`sqlite3WhereOkOnePass
(
pWInfo
, 
aDummy
);

85103 if( 
bOnePass
 )

85109 
	`sqlite3VdbeChangeToNoop
(
v
, 
addr
);

85110 if( ((
pParse
)->
pToplevel
==0) )

85113 
pParse
->
isMultiWrite
 = 0;

85118 
	`sqlite3VdbeAddOp3
(
v
, 49, 
regArg
, 
nArg
, 
regRec
);

85119 
	`sqlite3VdbeAddOp2
(
v
, 74, 
ephemTab
, 
regRowid
);

85120 
	`sqlite3VdbeAddOp3
(
v
, 75, 
ephemTab
, 
regRec
, 
regRowid
);

85124 if( 
bOnePass
==0 )

85128 
	`sqlite3WhereEnd
(
pWInfo
);

85131 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 108, 
ephemTab
); ;

85135 for(
i
=0; i<
nArg
; i++)

85138 
	`sqlite3VdbeAddOp3
(
v
, 47, 
ephemTab
, 
i
, 
regArg
+i);

85141 
	`sqlite3VtabMakeWritable
(
pParse
, 
pTab
);

85142 
	`sqlite3VdbeAddOp4
(
v
, 12, 0, 
nArg
, 
regArg
, 
pVTab
, (-10));

85143 
	`sqlite3VdbeChangeP5
(
v
, 
onError
==10 ? 2 : onError);

85144 
	`sqlite3MayAbort
(
pParse
);

85148 if( 
bOnePass
==0 )

85151 
	`sqlite3VdbeAddOp2
(
v
, 7, 
ephemTab
, 
addr
+1); ;

85152 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

85153 
	`sqlite3VdbeAddOp2
(
v
, 61, 
ephemTab
, 0);

85155 
	`sqlite3WhereEnd
(
pWInfo
);

85157 
	}
}

85159 static int 
	$vacuumFinalize
(
sqlite3
 *
db
, 
sqlite3_stmt
 *
pStmt
, char **
pzErrMsg
)

85162 int 
rc
;

85163 
rc
 = 
	`sqlite3VdbeFinalize
((
Vdbe
*)
pStmt
);

85164 if( 
rc
 )

85167 
	`sqlite3SetString
(
pzErrMsg
, 
db
, 
	`sqlite3_errmsg
(db));

85169 return 
rc
;

85170 
	}
}

85175 static int 
	$execSql
(
sqlite3
 *
db
, char **
pzErrMsg
, const char *
zSql
)

85178 
sqlite3_stmt
 *
pStmt
;

85180 if( !
zSql
 )

85185 if( 0!=
	`sqlite3_prepare
(
db
, 
zSql
, -1, &
pStmt
, 0) )

85188 
	`sqlite3SetString
(
pzErrMsg
, 
db
, 
	`sqlite3_errmsg
(db));

85189 return 
	`sqlite3_errcode
(
db
);

85191 
	`sqlite3_step
(
pStmt
);

85193 return 
	`vacuumFinalize
(
db
, 
pStmt
, 
pzErrMsg
);

85194 
	}
}

85200 static int 
	$execExecSql
(
sqlite3
 *
db
, char **
pzErrMsg
, const char *
zSql
)

85203 
sqlite3_stmt
 *
pStmt
;

85204 int 
rc
;

85206 
rc
 = 
	`sqlite3_prepare
(
db
, 
zSql
, -1, &
pStmt
, 0);

85207 if( 
rc
!=0 ) return rc;

85209 while( 100==
	`sqlite3_step
(
pStmt
) )

85212 
rc
 = 
	`execSql
(
db
, 
pzErrMsg
, (char*)
	`sqlite3_column_text
(
pStmt
, 0));

85213 if( 
rc
!=0 )

85216 
	`vacuumFinalize
(
db
, 
pStmt
, 
pzErrMsg
);

85217 return 
rc
;

85221 return 
	`vacuumFinalize
(
db
, 
pStmt
, 
pzErrMsg
);

85222 
	}
}

85224 static void 
	$sqlite3Vacuum
(
Parse
 *
pParse
)

85227 
Vdbe
 *
v
 = 
	`sqlite3GetVdbe
(
pParse
);

85228 if( 
v
 )

85231 
	`sqlite3VdbeAddOp2
(
v
, 10, 0, 0);

85232 
	`sqlite3VdbeUsesBtree
(
v
, 0);

85235 
	}
}

85240 static int 
	$sqlite3RunVacuum
(char **
pzErrMsg
, 
sqlite3
 *
db
)

85243 int 
rc
 = 0;

85244 
Btree
 *
pMain
;

85245 
Btree
 *
pTemp
;

85246 char *
zSql
 = 0;

85247 int 
saved_flags
;

85248 int 
saved_nChange
;

85249 int 
saved_nTotalChange
;

85250 void (*
saved_xTrace
)(void*,const char*);

85251 
Db
 *
pDb
 = 0;

85252 int 
isMemDb
;

85253 int 
nRes
;

85254 int 
nDb
;

85256 if( !
db
->
autoCommit
 )

85259 
	`sqlite3SetString
(
pzErrMsg
, 
db
, "cannot VACUUM from within a transaction");

85262 if( 
db
->
nVdbeActive
>1 )

85265 
	`sqlite3SetString
(
pzErrMsg
, 
db
,"cannot VACUUM - SQL statements in progress");

85272 
saved_flags
 = 
db
->
flags
;

85273 
saved_nChange
 = 
db
->
nChange
;

85274 
saved_nTotalChange
 = 
db
->
nTotalChange
;

85275 
saved_xTrace
 = 
db
->
xTrace
;

85276 
db
->
flags
 |= 0x00000800 | 0x00002000 | 0x00200000;

85277 
db
->
flags
 &= ~(0x00080000 | 0x00020000);

85278 
db
->
xTrace
 = 0;

85280 
pMain
 = 
db
->
aDb
[0].
pBt
;

85281 
isMemDb
 = 
	`sqlite3PagerIsMemdb
(
	`sqlite3BtreePager
(
pMain
));

85283 
nDb
 = 
db
->nDb;

85284 if( 
	`sqlite3TempInMemory
(
db
) )

85287 
zSql
 = "ATTACH ':memory:' AS vacuum_db;";

85289 
zSql
 = "ATTACH '' AS vacuum_db;";

85291 
rc
 = 
	`execSql
(
db
, 
pzErrMsg
, 
zSql
);

85292 if( 
db
->
nDb
>nDb )

85295 
pDb
 = &
db
->
aDb
[db->
nDb
-1];

85298 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85299 
pTemp
 = 
db
->
aDb
[db->
nDb
-1].
pBt
;

85305 
	`sqlite3BtreeCommit
(
pTemp
);

85307 
nRes
 = 
	`sqlite3BtreeGetOptimalReserve
(
pMain
);

85309 
rc
 = 
	`execSql
(
db
, 
pzErrMsg
, "PRAGMA vacuum_db.synchronous=OFF");

85310 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85316 
rc
 = 
	`execSql
(
db
, 
pzErrMsg
, "BEGIN;");

85317 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85318 
rc
 = 
	`sqlite3BtreeBeginTrans
(
pMain
, 2);

85319 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85322 if( 
	`sqlite3PagerGetJournalMode
(
	`sqlite3BtreePager
(
pMain
))

85326 
db
->
nextPagesize
 = 0;

85329 if( 
	`sqlite3BtreeSetPageSize
(
pTemp
, 
	`sqlite3BtreeGetPageSize
(
pMain
), 
nRes
, 0)

85330 || (!
isMemDb
 && 
	`sqlite3BtreeSetPageSize
(
pTemp
, 
db
->
nextPagesize
, 
nRes
, 0))

85331 || (
db
->
mallocFailed
)

85335 
rc
 = 7;

85336 goto 
end_of_vacuum
;

85340 
	`sqlite3BtreeSetAutoVacuum
(
pTemp
, 
db
->
nextAutovac
>=0 ? db->nextAutovac :

85341 
	`sqlite3BtreeGetAutoVacuum
(
pMain
));

85347 
rc
 = 
	`execExecSql
(
db
, 
pzErrMsg
,

85352 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85353 
rc
 = 
	`execExecSql
(
db
, 
pzErrMsg
,

85356 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85357 
rc
 = 
	`execExecSql
(
db
, 
pzErrMsg
,

85360 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85367 
db
->
flags
 |= 0x08000000;

85368 
rc
 = 
	`execExecSql
(
db
, 
pzErrMsg
,

85376 
db
->
flags
 &= ~0x08000000;

85377 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85381 
rc
 = 
	`execExecSql
(
db
, 
pzErrMsg
,

85385 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85386 
rc
 = 
	`execExecSql
(
db
, 
pzErrMsg
,

85391 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85399 
rc
 = 
	`execSql
(
db
, 
pzErrMsg
,

85406 if( 
rc
 ) goto 
end_of_vacuum
;

85415 
u32
 
meta
;

85416 int 
i
;

85424 static const unsigned char 
aCopy
[] = {

85436 for(
i
=0; i<((int)(sizeof(
aCopy
)/sizeof(aCopy[0]))); i+=2)

85441 
	`sqlite3BtreeGetMeta
(
pMain
, 
aCopy
[
i
], &
meta
);

85442 
rc
 = 
	`sqlite3BtreeUpdateMeta
(
pTemp
, 
aCopy
[
i
], 
meta
+aCopy[i+1]);

85443 if( (
rc
!=0) ) goto 
end_of_vacuum
;

85446 
rc
 = 
	`sqlite3BtreeCopyFile
(
pMain
, 
pTemp
);

85447 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85448 
rc
 = 
	`sqlite3BtreeCommit
(
pTemp
);

85449 if( 
rc
!=0 ) goto 
end_of_vacuum
;

85451 
	`sqlite3BtreeSetAutoVacuum
(
pMain
, 
	`sqlite3BtreeGetAutoVacuum
(
pTemp
));

85456 
rc
 = 
	`sqlite3BtreeSetPageSize
(
pMain
, 
	`sqlite3BtreeGetPageSize
(
pTemp
), 
nRes
,1);

85458 
end_of_vacuum
:

85460 
db
->
flags
 = 
saved_flags
;

85461 
db
->
nChange
 = 
saved_nChange
;

85462 
db
->
nTotalChange
 = 
saved_nTotalChange
;

85463 
db
->
xTrace
 = 
saved_xTrace
;

85464 
	`sqlite3BtreeSetPageSize
(
pMain
, -1, -1, 1);

85466 
db
->
autoCommit
 = 1;

85468 if( 
pDb
 )

85471 
	`sqlite3BtreeClose
(
pDb
->
pBt
);

85472 
pDb
->
pBt
 = 0;

85473 
pDb
->
pSchema
 = 0;

85478 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

85480 return 
rc
;

85481 
	}
}

85483 struct 
	sVtabCtx
 {

85484 
VTable
 *
	mpVTable
;

85485 
Table
 *
	mpTab
;

85486 
VtabCtx
 *
	mpPrior
;

85487 int 
	mbDeclared
;

85495 static int 
createModule
(

85496 
sqlite3
 *
db
,

85497 const char *
zName
,

85498 const 
sqlite3_module
 *
pModule
,

85499 void *
pAux
,

85500 void (*
xDestroy
)(void *)

85504 int 
rc
 = 0;

85505 int 
nName
;

85507 
	`sqlite3_mutex_enter
(
db
->
mutex
);

85508 
nName
 = 
	`sqlite3Strlen30
(
zName
);

85509 if( 
	`sqlite3HashFind
(&
db
->
aModule
, 
zName
) )

85512 
rc
 = 
	`sqlite3MisuseError
(118695);

85514 
Module
 *
pMod
;

85515 
pMod
 = (
Module
 *)
	`sqlite3DbMallocRawNN
(
db
, sizeof(Module) + 
nName
 + 1);

85516 if( 
pMod
 )

85519 
Module
 *
pDel
;

85520 char *
zCopy
 = (char *)(&
pMod
[1]);

85521 
	`memcpy
(
zCopy
, 
zName
, 
nName
+1);

85522 
pMod
->
zName
 = 
zCopy
;

85523 
pMod
->
pModule
 = pModule;

85524 
pMod
->
pAux
 = pAux;

85525 
pMod
->
xDestroy
 = xDestroy;

85526 
pMod
->
pEpoTab
 = 0;

85527 
pDel
 = (
Module
 *)
	`sqlite3HashInsert
(&
db
->
aModule
,
zCopy
,(void*)
pMod
);

85529 if( 
pDel
 )

85532 
	`sqlite3OomFault
(
db
);

85533 
	`sqlite3DbFree
(
db
, 
pDel
);

85537 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

85538 if( 
rc
!=0 && 
xDestroy
 ) 
	`xDestroy
(
pAux
);

85540 
	`sqlite3_mutex_leave
(
db
->
mutex
);

85541 return 
rc
;

85542 
	}
}

85548 int 
	$sqlite3_create_module
(

85549 
sqlite3
 *
db
,

85550 const char *
zName
,

85551 const 
sqlite3_module
 *
pModule
,

85552 void *
pAux


85559 return 
	`createModule
(
db
, 
zName
, 
pModule
, 
pAux
, 0);

85560 
	}
}

85565 int 
sqlite3_create_module_v2
(

85566 
sqlite3
 *
db
,

85567 const char *
zName
,

85568 const 
sqlite3_module
 *
pModule
,

85569 void *
pAux
,

85570 void (*
xDestroy
)(void *)

85577 return 
	`createModule
(
db
, 
zName
, 
pModule
, 
pAux
, 
xDestroy
);

85578 
	}
}

85580 static void 
	$sqlite3VtabLock
(
VTable
 *
pVTab
)

85583 
pVTab
->
nRef
++;

85584 
	}
}

85592 static 
VTable
 *
	$sqlite3GetVTable
(
sqlite3
 *
db
, 
Table
 *
pTab
)

85595 
VTable
 *
pVtab
;

85597 for(
pVtab
=
pTab
->
pVTable
; pVtab && pVtab->
db
!=db; pVtab=pVtab->
pNext
);

85598 return 
pVtab
;

85599 
	}
}

85605 static void 
	$sqlite3VtabUnlock
(
VTable
 *
pVTab
)

85608 
sqlite3
 *
db
 = 
pVTab
->db;

85614 
pVTab
->
nRef
--;

85615 if( 
pVTab
->
nRef
==0 )

85618 
sqlite3_vtab
 *
p
 = 
pVTab
->
pVtab
;

85619 if( 
p
 )

85622 
p
->
pModule
->
	`xDisconnect
(p);

85624 
	`sqlite3DbFree
(
db
, 
pVTab
);

85626 
	}
}

85628 static 
VTable
 *
	$vtabDisconnectAll
(
sqlite3
 *
db
, 
Table
 *
p
)

85631 
VTable
 *
pRet
 = 0;

85632 
VTable
 *
pVTable
 = 
p
->pVTable;

85633 
p
->
pVTable
 = 0;

85643 while( 
pVTable
 )

85646 
sqlite3
 *
db2
 = 
pVTable
->
db
;

85647 
VTable
 *
pNext
 = 
pVTable
->pNext;

85649 if( 
db2
==
db
 )

85652 
pRet
 = 
pVTable
;

85653 
p
->
pVTable
 = 
pRet
;

85654 
pRet
->
pNext
 = 0;

85656 
pVTable
->
pNext
 = 
db2
->
pDisconnect
;

85657 
db2
->
pDisconnect
 = 
pVTable
;

85659 
pVTable
 = 
pNext
;

85663 return 
pRet
;

85664 
	}
}

85666 static void 
	$sqlite3VtabDisconnect
(
sqlite3
 *
db
, 
Table
 *
p
)

85669 
VTable
 **
ppVTab
;

85675 for(
ppVTab
=&
p
->
pVTable
; *ppVTab; ppVTab=&(*ppVTab)->
pNext
)

85678 if( (*
ppVTab
)->
db
==db )

85681 
VTable
 *
pVTab
 = *
ppVTab
;

85682 *
ppVTab
 = 
pVTab
->
pNext
;

85683 
	`sqlite3VtabUnlock
(
pVTab
);

85687 
	}
}

85689 static void 
	$sqlite3VtabUnlockList
(
sqlite3
 *
db
)

85692 
VTable
 *
p
 = 
db
->
pDisconnect
;

85693 
db
->
pDisconnect
 = 0;

85698 if( 
p
 )

85701 
	`sqlite3ExpirePreparedStatements
(
db
);

85703 
VTable
 *
pNext
 = 
p
->pNext;

85704 
	`sqlite3VtabUnlock
(
p
);

85705 
p
 = 
pNext
;

85706 }while( 
p
 );

85708 
	}
}

85710 static void 
	$sqlite3VtabClear
(
sqlite3
 *
db
, 
Table
 *
p
)

85713 if( !
db
 || db->
pnBytesFreed
==0 ) 
	`vtabDisconnectAll
(0, 
p
);

85714 if( 
p
->
azModuleArg
 )

85717 int 
i
;

85718 for(
i
=0; i<
p
->
nModuleArg
; i++)

85721 if( 
i
!=1 ) 
	`sqlite3DbFree
(
db
, 
p
->
azModuleArg
[i]);

85723 
	`sqlite3DbFree
(
db
, 
p
->
azModuleArg
);

85725 
	}
}

85733 static void 
	$addModuleArgument
(
sqlite3
 *
db
, 
Table
 *
pTable
, char *
zArg
)

85736 int 
nBytes
 = sizeof(char *)*(2+
pTable
->
nModuleArg
);

85737 char **
azModuleArg
;

85738 
azModuleArg
 = 
	`sqlite3DbRealloc
(
db
, 
pTable
->azModuleArg, 
nBytes
);

85739 if( 
azModuleArg
==0 )

85742 
	`sqlite3DbFree
(
db
, 
zArg
);

85744 int 
i
 = 
pTable
->
nModuleArg
++;

85745 
azModuleArg
[
i
] = 
zArg
;

85746 
azModuleArg
[
i
+1] = 0;

85747 
pTable
->
azModuleArg
 = azModuleArg;

85749 
	}
}

85756 static void 
	$sqlite3VtabBeginParse
(

85757 
Parse
 *
pParse
,

85758 
Token
 *
pName1
,

85759 
Token
 *
pName2
,

85760 
Token
 *
pModuleName
,

85761 int 
ifNotExists


85765 int 
iDb
;

85766 
Table
 *
pTable
;

85767 
sqlite3
 *
db
;

85769 
	`sqlite3StartTable
(
pParse
, 
pName1
, 
pName2
, 0, 0, 1, 
ifNotExists
);

85770 
pTable
 = 
pParse
->
pNewTable
;

85771 if( 
pTable
==0 ) return;

85774 
db
 = 
pParse
->db;

85775 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTable
->
pSchema
);

85778 
pTable
->
tabFlags
 |= 0x10;

85779 
pTable
->
nModuleArg
 = 0;

85780 
	`addModuleArgument
(
db
, 
pTable
, 
	`sqlite3NameFromToken
(db, 
pModuleName
));

85781 
	`addModuleArgument
(
db
, 
pTable
, 0);

85782 
	`addModuleArgument
(
db
, 
pTable
, 
	`sqlite3DbStrDup
(db, pTable->
zName
));

85786 
pParse
->
sNameToken
.
n
 = (int)(

85787 &
pModuleName
->
z
[pModuleName->
n
] - 
pParse
->
sNameToken
.z

85796 if( 
pTable
->
azModuleArg
 )

85799 
	`sqlite3AuthCheck
(
pParse
, 29, 
pTable
->
zName
,

85800 
pTable
->
azModuleArg
[0], 
pParse
->
db
->
aDb
[
iDb
].
zName
);

85803 
	}
}

85810 static void 
	$addArgumentToVtab
(
Parse
 *
pParse
)

85813 if( 
pParse
->
sArg
.
z
 && pParse->
pNewTable
 )

85816 const char *
z
 = (const char*)
pParse
->
sArg
.z;

85817 int 
n
 = 
pParse
->
sArg
.n;

85818 
sqlite3
 *
db
 = 
pParse
->db;

85819 
	`addModuleArgument
(
db
, 
pParse
->
pNewTable
, 
	`sqlite3DbStrNDup
(db, 
z
, 
n
));

85821 
	}
}

85827 static void 
	$sqlite3VtabFinishParse
(
Parse
 *
pParse
, 
Token
 *
pEnd
)

85830 
Table
 *
pTab
 = 
pParse
->
pNewTable
;

85831 
sqlite3
 *
db
 = 
pParse
->db;

85833 if( 
pTab
==0 ) return;

85834 
	`addArgumentToVtab
(
pParse
);

85835 
pParse
->
sArg
.
z
 = 0;

85836 if( 
pTab
->
nModuleArg
<1 ) return;

85844 if( !
db
->
init
.
busy
 )

85847 char *
zStmt
;

85848 char *
zWhere
;

85849 int 
iDb
;

85850 int 
iReg
;

85851 
Vdbe
 *
v
;

85854 if( 
pEnd
 )

85857 
pParse
->
sNameToken
.
n
 = (int)(
pEnd
->
z
 - pParse->sNameToken.z) + pEnd->n;

85859 
zStmt
 = 
	`sqlite3MPrintf
(
db
, "CREATE VIRTUAL TABLE %T", &
pParse
->
sNameToken
);

85861 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

85862 
	`sqlite3NestedParse
(
pParse
,

85866 
db
->
aDb
[
iDb
].
zName
, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"),

85867 
pTab
->
zName
,

85868 
pTab
->
zName
,

85869 
zStmt
,

85870 
pParse
->
regRowid


85872 
	`sqlite3DbFree
(
db
, 
zStmt
);

85873 
v
 = 
	`sqlite3GetVdbe
(
pParse
);

85874 
	`sqlite3ChangeCookie
(
pParse
, 
iDb
);

85876 
	`sqlite3VdbeAddOp2
(
v
, 147, 0, 0);

85877 
zWhere
 = 
	`sqlite3MPrintf
(
db
, "name='%q' AND type='table'", 
pTab
->
zName
);

85878 
	`sqlite3VdbeAddParseSchemaOp
(
v
, 
iDb
, 
zWhere
);

85880 
iReg
 = ++
pParse
->
nMem
;

85881 
	`sqlite3VdbeLoadString
(
v
, 
iReg
, 
pTab
->
zName
);

85882 
	`sqlite3VdbeAddOp2
(
v
, 150, 
iDb
, 
iReg
);

85891 
Table
 *
pOld
;

85892 
Schema
 *
pSchema
 = 
pTab
->pSchema;

85893 const char *
zName
 = 
pTab
->zName;

85895 
pOld
 = 
	`sqlite3HashInsert
(&
pSchema
->
tblHash
, 
zName
, 
pTab
);

85896 if( 
pOld
 )

85899 
	`sqlite3OomFault
(
db
);

85903 
pParse
->
pNewTable
 = 0;

85905 
	}
}

85911 static void 
	$sqlite3VtabArgInit
(
Parse
 *
pParse
)

85914 
	`addArgumentToVtab
(
pParse
);

85915 
pParse
->
sArg
.
z
 = 0;

85916 
pParse
->
sArg
.
n
 = 0;

85917 
	}
}

85923 static void 
	$sqlite3VtabArgExtend
(
Parse
 *
pParse
, 
Token
 *
p
)

85926 
Token
 *
pArg
 = &
pParse
->
sArg
;

85927 if( 
pArg
->
z
==0 )

85930 
pArg
->
z
 = 
p
->z;

85931 
pArg
->
n
 = 
p
->n;

85934 
pArg
->
n
 = (int)(&
p
->
z
[p->n] - pArg->z);

85936 
	}
}

85943 static int 
vtabCallConstructor
(

85944 
sqlite3
 *
db
,

85945 
Table
 *
pTab
,

85946 
Module
 *
pMod
,

85947 int (*
xConstruct
)(
sqlite3
*,void*,int,const char*const*,
sqlite3_vtab
**,char**),

85948 char **
pzErr


85952 
VtabCtx
 
sCtx
;

85953 
VTable
 *
pVTable
;

85954 int 
rc
;

85955 const char *const*
azArg
 = (const char *const*)
pTab
->
azModuleArg
;

85956 int 
nArg
 = 
pTab
->
nModuleArg
;

85957 char *
zErr
 = 0;

85958 char *
zModuleName
;

85959 int 
iDb
;

85960 
VtabCtx
 *
pCtx
;

85963 for(
pCtx
=
db
->
pVtabCtx
; pCtx; pCtx=pCtx->
pPrior
)

85966 if( 
pCtx
->
pTab
==pTab )

85969 *
pzErr
 = 
	`sqlite3MPrintf
(
db
,

85970 "vtable constructor called recursively: %s", 
pTab
->
zName


85976 
zModuleName
 = 
	`sqlite3MPrintf
(
db
, "%s", 
pTab
->
zName
);

85977 if( !
zModuleName
 )

85983 
pVTable
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
VTable
));

85984 if( !
pVTable
 )

85987 
	`sqlite3DbFree
(
db
, 
zModuleName
);

85990 
pVTable
->
db
 = db;

85991 
pVTable
->
pMod
 = pMod;

85993 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

85994 
pTab
->
azModuleArg
[1] = 
db
->
aDb
[
iDb
].
zName
;

85999 
sCtx
.
pTab
 = pTab;

86000 
sCtx
.
pVTable
 = pVTable;

86001 
sCtx
.
pPrior
 = 
db
->
pVtabCtx
;

86002 
sCtx
.
bDeclared
 = 0;

86003 
db
->
pVtabCtx
 = &
sCtx
;

86004 
rc
 = 
	`xConstruct
(
db
, 
pMod
->
pAux
, 
nArg
, 
azArg
, &
pVTable
->
pVtab
, &
zErr
);

86005 
db
->
pVtabCtx
 = 
sCtx
.
pPrior
;

86006 if( 
rc
==7 ) 
	`sqlite3OomFault
(
db
);

86009 if( 0!=
rc
 )

86012 if( 
zErr
==0 )

86015 *
pzErr
 = 
	`sqlite3MPrintf
(
db
, "vtable constructor failed: %s", 
zModuleName
);

86017 *
pzErr
 = 
	`sqlite3MPrintf
(
db
, "%s", 
zErr
);

86018 
	`sqlite3_free
(
zErr
);

86020 
	`sqlite3DbFree
(
db
, 
pVTable
);

86021 }else if( (
pVTable
->
pVtab
) )

86026 
	`memset
(
pVTable
->
pVtab
, 0, sizeof(pVTable->pVtab[0]));

86027 
pVTable
->
pVtab
->
pModule
 = 
pMod
->pModule;

86028 
pVTable
->
nRef
 = 1;

86029 if( 
sCtx
.
bDeclared
==0 )

86032 const char *
zFormat
 = "vtable constructor did not declare schema: %s";

86033 *
pzErr
 = 
	`sqlite3MPrintf
(
db
, 
zFormat
, 
pTab
->
zName
);

86034 
	`sqlite3VtabUnlock
(
pVTable
);

86035 
rc
 = 1;

86037 int 
iCol
;

86038 
u8
 
oooHidden
 = 0;

86044 
pVTable
->
pNext
 = 
pTab
->pVTable;

86045 
pTab
->
pVTable
 = pVTable;

86047 for(
iCol
=0; iCol<
pTab
->
nCol
; iCol++)

86050 char *
zType
 = 
	`sqlite3ColumnType
(&
pTab
->
aCol
[
iCol
], "");

86051 int 
nType
;

86052 int 
i
 = 0;

86053 
nType
 = 
	`sqlite3Strlen30
(
zType
);

86054 for(
i
=0; i<
nType
; i++)

86057 if( 0==
	`sqlite3_strnicmp
("hidden", &
zType
[
i
], 6)

86058 && (
i
==0 || 
zType
[i-1]==' ')

86059 && (
zType
[
i
+6]=='\0' || zType[i+6]==' ')

86066 if( 
i
<
nType
 )

86069 int 
j
;

86070 int 
nDel
 = 6 + (
zType
[
i
+6] ? 1 : 0);

86071 for(
j
=
i
; (j+
nDel
)<=
nType
; j++)

86074 
zType
[
j
] = zType[j+
nDel
];

86076 if( 
zType
[
i
]=='\0' && i>0 )

86080 
zType
[
i
-1] = '\0';

86082 
pTab
->
aCol
[
iCol
].
colFlags
 |= 0x0002;

86083 
oooHidden
 = 0x80;

86085 
pTab
->
tabFlags
 |= 
oooHidden
;

86091 
	`sqlite3DbFree
(
db
, 
zModuleName
);

86092 return 
rc
;

86093 
	}
}

86095 static int 
	$sqlite3VtabCallConnect
(
Parse
 *
pParse
, 
Table
 *
pTab
)

86098 
sqlite3
 *
db
 = 
pParse
->db;

86099 const char *
zMod
;

86100 
Module
 *
pMod
;

86101 int 
rc
;

86104 if( (
pTab
->
tabFlags
 & 0x10)==0 || 
	`sqlite3GetVTable
(
db
, pTab) )

86111 
zMod
 = 
pTab
->
azModuleArg
[0];

86112 
pMod
 = (
Module
*)
	`sqlite3HashFind
(&
db
->
aModule
, 
zMod
);

86114 if( !
pMod
 )

86117 const char *
zModule
 = 
pTab
->
azModuleArg
[0];

86118 
	`sqlite3ErrorMsg
(
pParse
, "no such module: %s", 
zModule
);

86119 
rc
 = 1;

86121 char *
zErr
 = 0;

86122 
rc
 = 
	`vtabCallConstructor
(
db
, 
pTab
, 
pMod
, pMod->
pModule
->
xConnect
, &
zErr
);

86123 if( 
rc
!=0 )

86126 
	`sqlite3ErrorMsg
(
pParse
, "%s", 
zErr
);

86128 
	`sqlite3DbFree
(
db
, 
zErr
);

86131 return 
rc
;

86132 
	}
}

86137 static int 
	$growVTrans
(
sqlite3
 *
db
)

86140 const int 
ARRAY_INCR
 = 5;

86143 if( (
db
->
nVTrans
%
ARRAY_INCR
)==0 )

86146 
VTable
 **
aVTrans
;

86147 int 
nBytes
 = sizeof(
sqlite3_vtab
 *) * (
db
->
nVTrans
 + 
ARRAY_INCR
);

86148 
aVTrans
 = 
	`sqlite3DbRealloc
(
db
, (void *)db->aVTrans, 
nBytes
);

86149 if( !
aVTrans
 )

86154 
	`memset
(&
aVTrans
[
db
->
nVTrans
], 0, sizeof(
sqlite3_vtab
 *)*
ARRAY_INCR
);

86155 
db
->
aVTrans
 = aVTrans;

86159 
	}
}

86165 static void 
	$addToVTrans
(
sqlite3
 *
db
, 
VTable
 *
pVTab
)

86169 
db
->
aVTrans
[db->
nVTrans
++] = 
pVTab
;

86170 
	`sqlite3VtabLock
(
pVTab
);

86171 
	}
}

86173 static int 
	$sqlite3VtabCallCreate
(
sqlite3
 *
db
, int 
iDb
, const char *
zTab
, char **
pzErr
)

86176 int 
rc
 = 0;

86177 
Table
 *
pTab
;

86178 
Module
 *
pMod
;

86179 const char *
zMod
;

86181 
pTab
 = 
	`sqlite3FindTable
(
db
, 
zTab
, db->
aDb
[
iDb
].
zName
);

86185 
zMod
 = 
pTab
->
azModuleArg
[0];

86186 
pMod
 = (
Module
*)
	`sqlite3HashFind
(&
db
->
aModule
, 
zMod
);

86192 if( 
pMod
==0 || pMod->
pModule
->
xCreate
==0 || pMod->pModule->
xDestroy
==0 )

86195 *
pzErr
 = 
	`sqlite3MPrintf
(
db
, "no such module: %s", 
zMod
);

86196 
rc
 = 1;

86198 
rc
 = 
	`vtabCallConstructor
(
db
, 
pTab
, 
pMod
, pMod->
pModule
->
xCreate
, 
pzErr
);

86203 if( 
rc
==0 && (
	`sqlite3GetVTable
(
db
, 
pTab
)) )

86206 
rc
 = 
	`growVTrans
(
db
);

86207 if( 
rc
==0 )

86210 
	`addToVTrans
(
db
, 
	`sqlite3GetVTable
(db, 
pTab
));

86214 return 
rc
;

86215 
	}
}

86222 int 
	$sqlite3_declare_vtab
(
sqlite3
 *
db
, const char *
zCreateTable
)

86225 
VtabCtx
 *
pCtx
;

86226 
Parse
 *
pParse
;

86227 int 
rc
 = 0;

86228 
Table
 *
pTab
;

86229 char *
zErr
 = 0;

86236 
	`sqlite3_mutex_enter
(
db
->
mutex
);

86237 
pCtx
 = 
db
->
pVtabCtx
;

86238 if( !
pCtx
 || pCtx->
bDeclared
 )

86241 
	`sqlite3Error
(
db
, 21);

86242 
	`sqlite3_mutex_leave
(
db
->
mutex
);

86243 return 
	`sqlite3MisuseError
(119383);

86245 
pTab
 = 
pCtx
->pTab;

86248 
pParse
 = 
	`sqlite3DbMallocZero
(
db
,sizeof(*pParse));

86249 if( 
pParse
==0 )

86252 
rc
 = 7;

86254 
pParse
->
declareVtab
 = 1;

86255 
pParse
->
db
 = db;

86256 
pParse
->
nQueryLoop
 = 1;

86258 if( 0==
	`sqlite3RunParser
(
pParse
, 
zCreateTable
, &
zErr
)

86259 && 
pParse
->
pNewTable


86260 && !
db
->
mallocFailed


86261 && !
pParse
->
pNewTable
->
pSelect


86262 && (
pParse
->
pNewTable
->
tabFlags
 & 0x10)==0

86266 if( !
pTab
->
aCol
 )

86269 
pTab
->
aCol
 = 
pParse
->
pNewTable
->aCol;

86270 
pTab
->
nCol
 = 
pParse
->
pNewTable
->nCol;

86271 
pParse
->
pNewTable
->
nCol
 = 0;

86272 
pParse
->
pNewTable
->
aCol
 = 0;

86274 
pCtx
->
bDeclared
 = 1;

86276 
	`sqlite3ErrorWithMsg
(
db
, 1, (
zErr
 ? "%s" : 0), zErr);

86277 
	`sqlite3DbFree
(
db
, 
zErr
);

86278 
rc
 = 1;

86280 
pParse
->
declareVtab
 = 0;

86282 if( 
pParse
->
pVdbe
 )

86285 
	`sqlite3VdbeFinalize
(
pParse
->
pVdbe
);

86287 
	`sqlite3DeleteTable
(
db
, 
pParse
->
pNewTable
);

86288 
	`sqlite3ParserReset
(
pParse
);

86289 
	`sqlite3DbFree
(
db
,
pParse
);

86293 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

86294 
	`sqlite3_mutex_leave
(
db
->
mutex
);

86295 return 
rc
;

86296 
	}
}

86298 static int 
	$sqlite3VtabCallDestroy
(
sqlite3
 *
db
, int 
iDb
, const char *
zTab
)

86301 int 
rc
 = 0;

86302 
Table
 *
pTab
;

86304 
pTab
 = 
	`sqlite3FindTable
(
db
, 
zTab
, db->
aDb
[
iDb
].
zName
);

86305 if( (
pTab
!=0 && pTab->
pVTable
!=0) )

86308 
VTable
 *
p
;

86309 int (*
xDestroy
)(
sqlite3_vtab
 *);

86310 for(
p
=
pTab
->
pVTable
; p; p=p->
pNext
)

86314 if( 
p
->
pVtab
->
nRef
>0 )

86320 
p
 = 
	`vtabDisconnectAll
(
db
, 
pTab
);

86321 
xDestroy
 = 
p
->
pMod
->
pModule
->xDestroy;

86323 
rc
 = 
	`xDestroy
(
p
->
pVtab
);

86325 if( 
rc
==0 )

86329 
p
->
pVtab
 = 0;

86330 
pTab
->
pVTable
 = 0;

86331 
	`sqlite3VtabUnlock
(
p
);

86335 return 
rc
;

86336 
	}
}

86338 static void 
	$callFinaliser
(
sqlite3
 *
db
, int 
offset
)

86341 int 
i
;

86342 if( 
db
->
aVTrans
 )

86345 
VTable
 **
aVTrans
 = 
db
->aVTrans;

86346 
db
->
aVTrans
 = 0;

86347 for(
i
=0; i<
db
->
nVTrans
; i++)

86350 
VTable
 *
pVTab
 = 
aVTrans
[
i
];

86351 
sqlite3_vtab
 *
p
 = 
pVTab
->
pVtab
;

86352 if( 
p
 )

86355 int (*
x
)(
sqlite3_vtab
 *);

86356 
x
 = *(int (**)(
sqlite3_vtab
 *))((char *)
p
->
pModule
 + 
offset
);

86357 if( 
x
 ) 
	`x
(
p
);

86359 
pVTab
->
iSavepoint
 = 0;

86360 
	`sqlite3VtabUnlock
(
pVTab
);

86362 
	`sqlite3DbFree
(
db
, 
aVTrans
);

86363 
db
->
nVTrans
 = 0;

86365 
	}
}

86367 static int 
	$sqlite3VtabSync
(
sqlite3
 *
db
, 
Vdbe
 *
p
)

86370 int 
i
;

86371 int 
rc
 = 0;

86372 
VTable
 **
aVTrans
 = 
db
->aVTrans;

86374 
db
->
aVTrans
 = 0;

86375 for(
i
=0; 
rc
==0 && i<
db
->
nVTrans
; i++)

86378 int (*
x
)(
sqlite3_vtab
 *);

86379 
sqlite3_vtab
 *
pVtab
 = 
aVTrans
[
i
]->pVtab;

86380 if( 
pVtab
 && (
x
 = pVtab->
pModule
->
xSync
)!=0 )

86383 
rc
 = 
	`x
(
pVtab
);

86384 
	`sqlite3VtabImportErrmsg
(
p
, 
pVtab
);

86387 
db
->
aVTrans
 = aVTrans;

86388 return 
rc
;

86389 
	}
}

86395 static int 
	$sqlite3VtabRollback
(
sqlite3
 *
db
)

86398 
	`callFinaliser
(
db
, 
	`__builtin_offsetof
 (
sqlite3_module
, 
xRollback
));

86400 
	}
}

86406 static int 
	$sqlite3VtabCommit
(
sqlite3
 *
db
)

86409 
	`callFinaliser
(
db
, 
	`__builtin_offsetof
 (
sqlite3_module
, 
xCommit
));

86411 
	}
}

86413 static int 
	$sqlite3VtabBegin
(
sqlite3
 *
db
, 
VTable
 *
pVTab
)

86416 int 
rc
 = 0;

86417 const 
sqlite3_module
 *
pModule
;

86424 if( ((
db
)->
nVTrans
>0 && (db)->
aVTrans
==0) )

86429 if( !
pVTab
 )

86434 
pModule
 = 
pVTab
->
pVtab
->pModule;

86436 if( 
pModule
->
xBegin
 )

86439 int 
i
;

86442 for(
i
=0; i<
db
->
nVTrans
; i++)

86445 if( 
db
->
aVTrans
[
i
]==
pVTab
 )

86454 
rc
 = 
	`growVTrans
(
db
);

86455 if( 
rc
==0 )

86458 
rc
 = 
pModule
->
	`xBegin
(
pVTab
->
pVtab
);

86459 if( 
rc
==0 )

86462 int 
iSvpt
 = 
db
->
nStatement
 + db->
nSavepoint
;

86463 
	`addToVTrans
(
db
, 
pVTab
);

86464 if( 
iSvpt
 ) 
rc
 = 
	`sqlite3VtabSavepoint
(
db
, 0, iSvpt-1);

86468 return 
rc
;

86469 
	}
}

86471 static int 
	$sqlite3VtabSavepoint
(
sqlite3
 *
db
, int 
op
, int 
iSavepoint
)

86474 int 
rc
 = 0;

86478 if( 
db
->
aVTrans
 )

86481 int 
i
;

86482 for(
i
=0; 
rc
==0 && i<
db
->
nVTrans
; i++)

86485 
VTable
 *
pVTab
 = 
db
->
aVTrans
[
i
];

86486 const 
sqlite3_module
 *
pMod
 = 
pVTab
->pMod->
pModule
;

86487 if( 
pVTab
->
pVtab
 && 
pMod
->
iVersion
>=2 )

86490 int (*
xMethod
)(
sqlite3_vtab
 *, int);

86491 switch( 
op
 )

86495 
xMethod
 = 
pMod
->
xSavepoint
;

86496 
pVTab
->
iSavepoint
 = iSavepoint+1;

86499 
xMethod
 = 
pMod
->
xRollbackTo
;

86502 
xMethod
 = 
pMod
->
xRelease
;

86505 if( 
xMethod
 && 
pVTab
->
iSavepoint
>iSavepoint )

86508 
rc
 = 
	`xMethod
(
pVTab
->
pVtab
, 
iSavepoint
);

86513 return 
rc
;

86514 
	}
}

86516 static 
FuncDef
 *
	$sqlite3VtabOverloadFunction
(

86517 
sqlite3
 *
db
,

86518 
FuncDef
 *
pDef
,

86519 int 
nArg
,

86520 
Expr
 *
pExpr


86524 
Table
 *
pTab
;

86525 
sqlite3_vtab
 *
pVtab
;

86526 
sqlite3_module
 *
pMod
;

86527 void (*
xSFunc
)(
sqlite3_context
*,int,
sqlite3_value
**) = 0;

86528 void *
pArg
 = 0;

86529 
FuncDef
 *
pNew
;

86530 int 
rc
 = 0;

86531 char *
zLowerName
;

86532 unsigned char *
z
;

86536 if( (
pExpr
==0) ) return 
pDef
;

86537 if( 
pExpr
->
op
!=152 ) return 
pDef
;

86538 
pTab
 = 
pExpr
->pTab;

86539 if( (
pTab
==0) ) return 
pDef
;

86540 if( (
pTab
->
tabFlags
 & 0x10)==0 ) return 
pDef
;

86541 
pVtab
 = 
	`sqlite3GetVTable
(
db
, 
pTab
)->pVtab;

86544 
pMod
 = (
sqlite3_module
 *)
pVtab
->
pModule
;

86545 if( 
pMod
->
xFindFunction
==0 ) return 
pDef
;

86550 
zLowerName
 = 
	`sqlite3DbStrDup
(
db
, 
pDef
->
zName
);

86551 if( 
zLowerName
 )

86554 for(
z
=(unsigned char*)
zLowerName
; *z; z++)

86557 *
z
 = 
sqlite3UpperToLower
[*z];

86559 
rc
 = 
pMod
->
	`xFindFunction
(
pVtab
, 
nArg
, 
zLowerName
, &
xSFunc
, &
pArg
);

86560 
	`sqlite3DbFree
(
db
, 
zLowerName
);

86562 if( 
rc
==0 )

86565 return 
pDef
;

86570 
pNew
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(*pNew)

86571 + 
	`sqlite3Strlen30
(
pDef
->
zName
) + 1);

86572 if( 
pNew
==0 )

86575 return 
pDef
;

86577 *
pNew
 = *
pDef
;

86578 
pNew
->
zName
 = (const char*)&pNew[1];

86579 
	`memcpy
((char*)&
pNew
[1], 
pDef
->
zName
, 
	`sqlite3Strlen30
(pDef->zName)+1);

86580 
pNew
->
xSFunc
 = xSFunc;

86581 
pNew
->
pUserData
 = 
pArg
;

86582 
pNew
->
funcFlags
 |= 0x0010;

86583 return 
pNew
;

86584 
	}
}

86592 static void 
	$sqlite3VtabMakeWritable
(
Parse
 *
pParse
, 
Table
 *
pTab
)

86595 
Parse
 *
pToplevel
 = ((
pParse
)->pToplevel ? (pParse)->pToplevel : (pParse));

86596 int 
i
, 
n
;

86597 
Table
 **
apVtabLock
;

86600 for(
i
=0; i<
pToplevel
->
nVtabLock
; i++)

86603 if( 
pTab
==
pToplevel
->
apVtabLock
[
i
] ) return;

86605 
n
 = (
pToplevel
->
nVtabLock
+1)*sizeof(pToplevel->
apVtabLock
[0]);

86606 
apVtabLock
 = 
	`sqlite3_realloc64
(
pToplevel
->apVtabLock, 
n
);

86607 if( 
apVtabLock
 )

86610 
pToplevel
->
apVtabLock
 = apVtabLock;

86611 
pToplevel
->
apVtabLock
[pToplevel->
nVtabLock
++] = 
pTab
;

86613 
	`sqlite3OomFault
(
pToplevel
->
db
);

86615 
	}
}

86617 static int 
	$sqlite3VtabEponymousTableInit
(
Parse
 *
pParse
, 
Module
 *
pMod
)

86620 const 
sqlite3_module
 *
pModule
 = 
pMod
->pModule;

86621 
Table
 *
pTab
;

86622 char *
zErr
 = 0;

86623 int 
nName
;

86624 int 
rc
;

86625 
sqlite3
 *
db
 = 
pParse
->db;

86626 if( 
pMod
->
pEpoTab
 ) return 1;

86627 if( 
pModule
->
xCreate
!=0 && pModule->xCreate!=pModule->
xConnect
 ) return 0;

86628 
nName
 = 
	`sqlite3Strlen30
(
pMod
->
zName
) + 1;

86629 
pTab
 = 
	`sqlite3DbMallocZero
(
db
, sizeof(
Table
) + 
nName
);

86630 if( 
pTab
==0 ) return 0;

86631 
pMod
->
pEpoTab
 = 
pTab
;

86632 
pTab
->
zName
 = (char*)&pTab[1];

86633 
	`memcpy
(
pTab
->
zName
, 
pMod
->zName, 
nName
);

86634 
pTab
->
nRef
 = 1;

86635 
pTab
->
pSchema
 = 
db
->
aDb
[0].pSchema;

86636 
pTab
->
tabFlags
 |= 0x10;

86637 
pTab
->
nModuleArg
 = 0;

86638 
pTab
->
iPKey
 = -1;

86639 
	`addModuleArgument
(
db
, 
pTab
, 
	`sqlite3DbStrDup
(db, pTab->
zName
));

86640 
	`addModuleArgument
(
db
, 
pTab
, 0);

86641 
	`addModuleArgument
(
db
, 
pTab
, 
	`sqlite3DbStrDup
(db, pTab->
zName
));

86642 
rc
 = 
	`vtabCallConstructor
(
db
, 
pTab
, 
pMod
, 
pModule
->
xConnect
, &
zErr
);

86643 if( 
rc
 )

86646 
	`sqlite3ErrorMsg
(
pParse
, "%s", 
zErr
);

86647 
	`sqlite3DbFree
(
db
, 
zErr
);

86648 
	`sqlite3VtabEponymousTableClear
(
db
, 
pMod
);

86652 
	}
}

86658 static void 
	$sqlite3VtabEponymousTableClear
(
sqlite3
 *
db
, 
Module
 *
pMod
)

86661 
Table
 *
pTab
 = 
pMod
->
pEpoTab
;

86662 if( 
pTab
!=0 )

86665 
	`sqlite3DeleteColumnNames
(
db
, 
pTab
);

86666 
	`sqlite3VtabClear
(
db
, 
pTab
);

86667 
	`sqlite3DbFree
(
db
, 
pTab
);

86668 
pMod
->
pEpoTab
 = 0;

86670 
	}
}

86672 int 
	$sqlite3_vtab_on_conflict
(
sqlite3
 *
db
)

86675 static const unsigned char 
aMap
[] = {

86684 return (int)
aMap
[
db
->
vtabOnConflict
-1];

86685 
	}
}

86692 int 
	$sqlite3_vtab_config
(
sqlite3
 *
db
, int 
op
, ...)

86695 
va_list
 
ap
;

86696 int 
rc
 = 0;

86701 
	`sqlite3_mutex_enter
(
db
->
mutex
);

86702 
	`__builtin_va_start
(
ap
,
op
);

86703 switch( 
op
 )

86707 
VtabCtx
 *
p
 = 
db
->
pVtabCtx
;

86708 if( !
p
 )

86711 
rc
 = 
	`sqlite3MisuseError
(119834);

86714 
p
->
pVTable
->
bConstraint
 = (
u8
)
	`__builtin_va_arg
(
ap
,int);

86719 
rc
 = 
	`sqlite3MisuseError
(119842);

86722 
	`__builtin_va_end
(
ap
);

86724 if( 
rc
!=0 ) 
	`sqlite3Error
(
db
, rc);

86725 
	`sqlite3_mutex_leave
(
db
->
mutex
);

86726 return 
rc
;

86727 
	}
}

86729 typedef struct 
WhereClause
 
	tWhereClause
;

86730 typedef struct 
WhereMaskSet
 
	tWhereMaskSet
;

86731 typedef struct 
WhereOrInfo
 
	tWhereOrInfo
;

86732 typedef struct 
WhereAndInfo
 
	tWhereAndInfo
;

86733 typedef struct 
WhereLevel
 
	tWhereLevel
;

86734 typedef struct 
WhereLoop
 
	tWhereLoop
;

86735 typedef struct 
WherePath
 
	tWherePath
;

86736 typedef struct 
WhereTerm
 
	tWhereTerm
;

86737 typedef struct 
WhereLoopBuilder
 
	tWhereLoopBuilder
;

86738 typedef struct 
WhereScan
 
	tWhereScan
;

86739 typedef struct 
WhereOrCost
 
	tWhereOrCost
;

86740 typedef struct 
WhereOrSet
 
	tWhereOrSet
;

86742 struct 
	sWhereLevel
 {

86743 int 
	miLeftJoin
;

86744 int 
	miTabCur
;

86745 int 
	miIdxCur
;

86746 int 
	maddrBrk
;

86747 int 
	maddrNxt
;

86748 int 
	maddrSkip
;

86749 int 
	maddrCont
;

86750 int 
	maddrFirst
;

86751 int 
	maddrBody
;

86753 int 
	miLikeRepCntr
;

86754 int 
	maddrLikeRep
;

86756 
u8
 
	miFrom
;

86757 
u8
 
	mop
, 
	mp3
, 
	mp5
;

86758 int 
	mp1
, 
	mp2
;

86761 int 
	mnIn
;

86762 struct 
	sInLoop
 {

86763 int 
	miCur
;

86764 int 
	maddrInTop
;

86765 
u8
 
	meEndLoopOp
;

86766 } *
	maInLoop
;

86767 } 
	min
;

86768 
Index
 *
	mpCovidx
;

86769 } 
	mu
;

86770 struct 
WhereLoop
 *
	mpWLoop
;

86771 
Bitmask
 
	mnotReady
;

86777 struct 
	sWhereLoop
 {

86778 
Bitmask
 
	mprereq
;

86779 
Bitmask
 
	mmaskSelf
;

86783 
u8
 
	miTab
;

86784 
u8
 
	miSortIdx
;

86785 
LogEst
 
	mrSetup
;

86786 
LogEst
 
	mrRun
;

86787 
LogEst
 
	mnOut
;

86790 
u16
 
	mnEq
;

86791 
Index
 *
	mpIndex
;

86792 } 
	mbtree
;

86794 int 
	midxNum
;

86795 
u8
 
	mneedFree
;

86796 
i8
 
	misOrdered
;

86797 
u16
 
	momitMask
;

86798 char *
	midxStr
;

86799 } 
	mvtab
;

86800 } 
	mu
;

86801 
u32
 
	mwsFlags
;

86802 
u16
 
	mnLTerm
;

86803 
u16
 
	mnSkip
;

86806 
u16
 
	mnLSlot
;

86807 
WhereTerm
 **
	maLTerm
;

86808 
WhereLoop
 *
	mpNextLoop
;

86809 
WhereTerm
 *
	maLTermSpace
[3];

86816 struct 
	sWhereOrCost
 {

86817 
Bitmask
 
	mprereq
;

86818 
LogEst
 
	mrRun
;

86819 
LogEst
 
	mnOut
;

86827 struct 
	sWhereOrSet
 {

86828 
u16
 
	mn
;

86829 
WhereOrCost
 
	ma
[3];

86832 struct 
	sWherePath
 {

86833 
Bitmask
 
	mmaskLoop
;

86834 
Bitmask
 
	mrevLoop
;

86835 
LogEst
 
	mnRow
;

86836 
LogEst
 
	mrCost
;

86837 
LogEst
 
	mrUnsorted
;

86838 
i8
 
	misOrdered
;

86839 
WhereLoop
 **
	maLoop
;

86842 struct 
	sWhereTerm
 {

86843 
Expr
 *
	mpExpr
;

86844 int 
	miParent
;

86845 int 
	mleftCursor
;

86847 int 
	mleftColumn
;

86848 
WhereOrInfo
 *
	mpOrInfo
;

86849 
WhereAndInfo
 *
	mpAndInfo
;

86850 } 
	mu
;

86851 
LogEst
 
	mtruthProb
;

86852 
u16
 
	meOperator
;

86853 
u16
 
	mwtFlags
;

86854 
u8
 
	mnChild
;

86855 
u8
 
	meMatchOp
;

86856 
WhereClause
 *
	mpWC
;

86857 
Bitmask
 
	mprereqRight
;

86858 
Bitmask
 
	mprereqAll
;

86861 struct 
	sWhereScan
 {

86862 
WhereClause
 *
	mpOrigWC
;

86863 
WhereClause
 *
	mpWC
;

86864 const char *
	mzCollName
;

86865 
Expr
 *
	mpIdxExpr
;

86866 char 
	midxaff
;

86867 unsigned char 
	mnEquiv
;

86868 unsigned char 
	miEquiv
;

86869 
u32
 
	mopMask
;

86870 int 
	mk
;

86871 int 
	maiCur
[11];

86872 
i16
 
	maiColumn
[11];

86875 struct 
	sWhereClause
 {

86876 
WhereInfo
 *
	mpWInfo
;

86877 
WhereClause
 *
	mpOuter
;

86878 
u8
 
	mop
;

86879 int 
	mnTerm
;

86880 int 
	mnSlot
;

86881 
WhereTerm
 *
	ma
;

86885 
WhereTerm
 
	maStatic
[8];

86893 struct 
	sWhereOrInfo
 {

86894 
WhereClause
 
	mwc
;

86895 
Bitmask
 
	mindexable
;

86902 struct 
	sWhereAndInfo
 {

86903 
WhereClause
 
	mwc
;

86906 struct 
	sWhereMaskSet
 {

86907 int 
	mn
;

86908 int 
	mix
[((int)(sizeof(
Bitmask
)*8))];

86911 struct 
	sWhereLoopBuilder
 {

86912 
WhereInfo
 *
	mpWInfo
;

86913 
WhereClause
 *
	mpWC
;

86914 
ExprList
 *
	mpOrderBy
;

86915 
WhereLoop
 *
	mpNew
;

86916 
WhereOrSet
 *
	mpOrSet
;

86923 struct 
	sWhereInfo
 {

86924 
Parse
 *
	mpParse
;

86925 
SrcList
 *
	mpTabList
;

86926 
ExprList
 *
	mpOrderBy
;

86927 
ExprList
 *
	mpResultSet
;

86928 
WhereLoop
 *
	mpLoops
;

86929 
Bitmask
 
	mrevMask
;

86930 
LogEst
 
	mnRowOut
;

86931 
LogEst
 
	miLimit
;

86932 
u16
 
	mwctrlFlags
;

86933 
i8
 
	mnOBSat
;

86934 
u8
 
	msorted
;

86935 
u8
 
	meOnePass
;

86936 
u8
 
	muntestedTerms
;

86937 
u8
 
	meDistinct
;

86938 
u8
 
	mnLevel
;

86939 int 
	miTop
;

86940 int 
	miContinue
;

86941 int 
	miBreak
;

86942 int 
	msavedNQueryLoop
;

86943 int 
	maiCurOnePass
[2];

86944 
WhereMaskSet
 
	msMaskSet
;

86945 
WhereClause
 
	msWC
;

86946 
WhereLevel
 
	ma
[1];

86954 static 
Bitmask
 
sqlite3WhereGetMask
(
WhereMaskSet
*,int);

86955 static 
WhereTerm
 *
sqlite3WhereFindTerm
(

86956 
WhereClause
 *
pWC
,

86957 int 
iCur
,

86958 int 
iColumn
,

86959 
Bitmask
 
notReady
,

86960 
u32
 
op
,

86961 
Index
 *
pIdx


86966 static int 
sqlite3WhereExplainOneScan
(

86967 
Parse
 *
pParse
,

86968 
SrcList
 *
pTabList
,

86969 
WhereLevel
 *
pLevel
,

86970 int 
iLevel
,

86971 int 
iFrom
,

86972 
u16
 
wctrlFlags


86975 static 
Bitmask
 
sqlite3WhereCodeOneLoopStart
(

86976 
WhereInfo
 *
pWInfo
,

86977 int 
iLevel
,

86978 
Bitmask
 
notReady


86982 static void 
sqlite3WhereClauseInit
(
WhereClause
*,
WhereInfo
*);

86983 static void 
sqlite3WhereClauseClear
(
WhereClause
*);

86984 static void 
sqlite3WhereSplit
(
WhereClause
*,
Expr
*,
u8
);

86985 static 
Bitmask
 
sqlite3WhereExprUsage
(
WhereMaskSet
*, 
Expr
*);

86986 static 
Bitmask
 
sqlite3WhereExprListUsage
(
WhereMaskSet
*, 
ExprList
*);

86987 static void 
sqlite3WhereExprAnalyze
(
SrcList
*, 
WhereClause
*);

86988 static void 
sqlite3WhereTabFuncArgs
(
Parse
*, struct 
SrcList_item
*, 
WhereClause
*);

86990 static void 
	$explainAppendTerm
(

86991 
StrAccum
 *
pStr
,

86992 int 
iTerm
,

86993 const char *
zColumn
,

86994 const char *
zOp


86998 if( 
iTerm
 ) 
	`sqlite3StrAccumAppend
(
pStr
, " AND ", 5);

86999 
	`sqlite3StrAccumAppendAll
(
pStr
, 
zColumn
);

87000 
	`sqlite3StrAccumAppend
(
pStr
, 
zOp
, 1);

87001 
	`sqlite3StrAccumAppend
(
pStr
, "?", 1);

87002 
	}
}

87007 static const char *
	$explainIndexColumnName
(
Index
 *
pIdx
, int 
i
)

87010 
i
 = 
pIdx
->
aiColumn
[i];

87011 if( 
i
==(-2) ) return "<expr>";

87012 if( 
i
==(-1) ) return "rowid";

87013 return 
pIdx
->
pTable
->
aCol
[
i
].
zName
;

87014 
	}
}

87016 static void 
	$explainIndexRange
(
StrAccum
 *
pStr
, 
WhereLoop
 *
pLoop
)

87019 
Index
 *
pIndex
 = 
pLoop
->
u
.
btree
.pIndex;

87020 
u16
 
nEq
 = 
pLoop
->
u
.
btree
.nEq;

87021 
u16
 
nSkip
 = 
pLoop
->nSkip;

87022 int 
i
, 
j
;

87024 if( 
nEq
==0 && (
pLoop
->
wsFlags
&(0x00000020|0x00000010))==0 ) return;

87025 
	`sqlite3StrAccumAppend
(
pStr
, " (", 2);

87026 for(
i
=0; i<
nEq
; i++)

87029 const char *
z
 = 
	`explainIndexColumnName
(
pIndex
, 
i
);

87030 if( 
i
 ) 
	`sqlite3StrAccumAppend
(
pStr
, " AND ", 5);

87031 
	`sqlite3XPrintf
(
pStr
, 
i
>=
nSkip
 ? "%s=?" : "ANY(%s)", 
z
);

87034 
j
 = 
i
;

87035 if( 
pLoop
->
wsFlags
&0x00000020 )

87038 const char *
z
 = 
	`explainIndexColumnName
(
pIndex
, 
i
);

87039 
	`explainAppendTerm
(
pStr
, 
i
++, 
z
, ">");

87041 if( 
pLoop
->
wsFlags
&0x00000010 )

87044 const char *
z
 = 
	`explainIndexColumnName
(
pIndex
, 
j
);

87045 
	`explainAppendTerm
(
pStr
, 
i
, 
z
, "<");

87047 
	`sqlite3StrAccumAppend
(
pStr
, ")", 1);

87048 
	}
}

87050 static int 
	$sqlite3WhereExplainOneScan
(

87051 
Parse
 *
pParse
,

87052 
SrcList
 *
pTabList
,

87053 
WhereLevel
 *
pLevel
,

87054 int 
iLevel
,

87055 int 
iFrom
,

87056 
u16
 
wctrlFlags


87060 int 
ret
 = 0;

87062 if( 
pParse
->
explain
==2 )

87065 struct 
SrcList_item
 *
pItem
 = &
pTabList
->
a
[
pLevel
->
iFrom
];

87066 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

87067 
sqlite3
 *
db
 = 
pParse
->db;

87068 int 
iId
 = 
pParse
->
iSelectId
;

87069 int 
isSearch
;

87070 
WhereLoop
 *
pLoop
;

87071 
u32
 
flags
;

87072 char *
zMsg
;

87073 
StrAccum
 
str
;

87074 char 
zBuf
[100];

87076 
pLoop
 = 
pLevel
->
pWLoop
;

87077 
flags
 = 
pLoop
->
wsFlags
;

87078 if( (
flags
&0x00002000) || (
wctrlFlags
&0x0040) ) return 0;

87080 
isSearch
 = (
flags
&(0x00000020|0x00000010))!=0

87081 || ((
flags
&0x00000400)==0 && (
pLoop
->
u
.
btree
.
nEq
>0))

87082 || (
wctrlFlags
&(0x0001|0x0002));

87084 
	`sqlite3StrAccumInit
(&
str
, 
db
, 
zBuf
, sizeof(zBuf), 1000000000);

87085 
	`sqlite3StrAccumAppendAll
(&
str
, 
isSearch
 ? "SEARCH" : "SCAN");

87086 if( 
pItem
->
pSelect
 )

87089 
	`sqlite3XPrintf
(&
str
, " SUBQUERY %d", 
pItem
->
iSelectId
);

87091 
	`sqlite3XPrintf
(&
str
, " TABLE %s", 
pItem
->
zName
);

87094 if( 
pItem
->
zAlias
 )

87097 
	`sqlite3XPrintf
(&
str
, " AS %s", 
pItem
->
zAlias
);

87099 if( (
flags
 & (0x00000100|0x00000400))==0 )

87102 const char *
zFmt
 = 0;

87103 
Index
 *
pIdx
;

87106 
pIdx
 = 
pLoop
->
u
.
btree
.
pIndex
;

87108 if( !(((
pItem
->
pTab
)->
tabFlags
 & 0x20)==0) && ((
pIdx
)->
idxType
==2) )

87111 if( 
isSearch
 )

87114 
zFmt
 = "PRIMARY KEY";

87116 }else if( 
flags
 & 0x00020000 )

87119 
zFmt
 = "AUTOMATIC PARTIAL COVERING INDEX";

87120 }else if( 
flags
 & 0x00004000 )

87123 
zFmt
 = "AUTOMATIC COVERING INDEX";

87124 }else if( 
flags
 & 0x00000040 )

87127 
zFmt
 = "COVERING INDEX %s";

87129 
zFmt
 = "INDEX %s";

87131 if( 
zFmt
 )

87134 
	`sqlite3StrAccumAppend
(&
str
, " USING ", 7);

87135 
	`sqlite3XPrintf
(&
str
, 
zFmt
, 
pIdx
->
zName
);

87136 
	`explainIndexRange
(&
str
, 
pLoop
);

87138 }else if( (
flags
 & 0x00000100)!=0 && (flags & 0x0000000f)!=0 )

87141 const char *
zRangeOp
;

87142 if( 
flags
&(0x00000001|0x00000004) )

87145 
zRangeOp
 = "=";

87146 }else if( (
flags
&0x00000030)==0x00000030 )

87149 
zRangeOp
 = ">? AND rowid<";

87150 }else if( 
flags
&0x00000020 )

87153 
zRangeOp
 = ">";

87156 
zRangeOp
 = "<";

87158 
	`sqlite3XPrintf
(&
str
, " USING INTEGER PRIMARY KEY (rowid%s?)",
zRangeOp
);

87161 else if( (
flags
 & 0x00000400)!=0 )

87164 
	`sqlite3XPrintf
(&
str
, " VIRTUAL TABLE INDEX %d:%s",

87165 
pLoop
->
u
.
vtab
.
idxNum
, pLoop->u.vtab.
idxStr
);

87168 
zMsg
 = 
	`sqlite3StrAccumFinish
(&
str
);

87169 
ret
 = 
	`sqlite3VdbeAddOp4
(
v
, 161, 
iId
, 
iLevel
, 
iFrom
, 
zMsg
,(-1));

87171 return 
ret
;

87172 
	}
}

87174 static void 
	$disableTerm
(
WhereLevel
 *
pLevel
, 
WhereTerm
 *
pTerm
)

87177 int 
nLoop
 = 0;

87178 while( 
pTerm


87179 && (
pTerm
->
wtFlags
 & 0x04)==0

87180 && (
pLevel
->
iLeftJoin
==0 || (((
pTerm
->
pExpr
)->
flags
&(0x000001))!=0))

87181 && (
pLevel
->
notReady
 & 
pTerm
->
prereqAll
)==0

87185 if( 
nLoop
 && (
pTerm
->
wtFlags
 & 0x400)!=0 )

87188 
pTerm
->
wtFlags
 |= 0x200;

87190 
pTerm
->
wtFlags
 |= 0x04;

87192 if( 
pTerm
->
iParent
<0 ) break;

87193 
pTerm
 = &pTerm->
pWC
->
a
[pTerm->
iParent
];

87194 
pTerm
->
nChild
--;

87195 if( 
pTerm
->
nChild
!=0 ) break;

87196 
nLoop
++;

87198 
	}
}

87200 static void 
	$codeApplyAffinity
(
Parse
 *
pParse
, int 
base
, int 
n
, char *
zAff
)

87203 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

87204 if( 
zAff
==0 )

87215 while( 
n
>0 && 
zAff
[0]=='A' )

87218 
n
--;

87219 
base
++;

87220 
zAff
++;

87222 while( 
n
>1 && 
zAff
[n-1]=='A' )

87225 
n
--;

87229 if( 
n
>0 )

87232 
	`sqlite3VdbeAddOp4
(
v
, 48, 
base
, 
n
, 0, 
zAff
, n);

87233 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
base
, 
n
);

87235 
	}
}

87237 static int 
	$codeEqualityTerm
(

87238 
Parse
 *
pParse
,

87239 
WhereTerm
 *
pTerm
,

87240 
WhereLevel
 *
pLevel
,

87241 int 
iEq
,

87242 int 
bRev
,

87243 int 
iTarget


87247 
Expr
 *
pX
 = 
pTerm
->
pExpr
;

87248 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

87249 int 
iReg
;

87252 if( 
pX
->
op
==79 || pX->op==73 )

87255 
iReg
 = 
	`sqlite3ExprCodeTarget
(
pParse
, 
pX
->
pRight
, 
iTarget
);

87256 }else if( 
pX
->
op
==76 )

87259 
iReg
 = 
iTarget
;

87260 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
iReg
);

87263 int 
eType
;

87264 int 
iTab
;

87265 struct 
InLoop
 *
pIn
;

87266 
WhereLoop
 *
pLoop
 = 
pLevel
->
pWLoop
;

87268 if( (
pLoop
->
wsFlags
 & 0x00000400)==0

87269 && 
pLoop
->
u
.
btree
.
pIndex
!=0

87270 && 
pLoop
->
u
.
btree
.
pIndex
->
aSortOrder
[
iEq
]

87276 
bRev
 = !bRev;

87279 
iReg
 = 
iTarget
;

87280 
eType
 = 
	`sqlite3FindInIndex
(
pParse
, 
pX
, 0x0004, 0);

87281 if( 
eType
==4 )

87285 
bRev
 = !bRev;

87287 
iTab
 = 
pX
->
iTable
;

87288 
	`sqlite3VdbeAddOp2
(
v
, 
bRev
 ? 105 : 108, 
iTab
, 0);

87292 
pLoop
->
wsFlags
 |= 0x00000800;

87293 if( 
pLevel
->
u
.
in
.
nIn
==0 )

87296 
pLevel
->
addrNxt
 = 
	`sqlite3VdbeMakeLabel
(
v
);

87298 
pLevel
->
u
.
in
.
nIn
++;

87299 
pLevel
->
u
.
in
.
aInLoop
 =

87300 
	`sqlite3DbReallocOrFree
(
pParse
->
db
, 
pLevel
->
u
.
in
.
aInLoop
,

87301 sizeof(
pLevel
->
u
.
in
.
aInLoop
[0])*pLevel->u.in.
nIn
);

87302 
pIn
 = 
pLevel
->
u
.
in
.
aInLoop
;

87303 if( 
pIn
 )

87306 
pIn
 += 
pLevel
->
u
.
in
.
nIn
 - 1;

87307 
pIn
->
iCur
 = 
iTab
;

87308 if( 
eType
==1 )

87311 
pIn
->
addrInTop
 = 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iTab
, 
iReg
);

87313 
pIn
->
addrInTop
 = 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iTab
, 0, 
iReg
);

87315 
pIn
->
eEndLoopOp
 = 
bRev
 ? 4 : 5;

87316 
	`sqlite3VdbeAddOp1
(
v
, 76, 
iReg
); ;

87318 
pLevel
->
u
.
in
.
nIn
 = 0;

87322 
	`disableTerm
(
pLevel
, 
pTerm
);

87323 return 
iReg
;

87324 
	}
}

87326 static int 
	$codeAllEqualityTerms
(

87327 
Parse
 *
pParse
,

87328 
WhereLevel
 *
pLevel
,

87329 int 
bRev
,

87330 int 
nExtraReg
,

87331 char **
pzAff


87335 
u16
 
nEq
;

87336 
u16
 
nSkip
;

87337 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

87338 
Index
 *
pIdx
;

87339 
WhereTerm
 *
pTerm
;

87340 
WhereLoop
 *
pLoop
;

87341 int 
j
;

87342 int 
regBase
;

87343 int 
nReg
;

87344 char *
zAff
;

87347 
pLoop
 = 
pLevel
->
pWLoop
;

87349 
nEq
 = 
pLoop
->
u
.
btree
.nEq;

87350 
nSkip
 = 
pLoop
->nSkip;

87351 
pIdx
 = 
pLoop
->
u
.
btree
.
pIndex
;

87356 
regBase
 = 
pParse
->
nMem
 + 1;

87357 
nReg
 = 
pLoop
->
u
.
btree
.
nEq
 + 
nExtraReg
;

87358 
pParse
->
nMem
 += 
nReg
;

87360 
zAff
 = 
	`sqlite3DbStrDup
(
pParse
->
db
,
	`sqlite3IndexAffinityStr
(pParse->db,
pIdx
));

87363 if( 
nSkip
 )

87366 int 
iIdxCur
 = 
pLevel
->iIdxCur;

87367 
	`sqlite3VdbeAddOp1
(
v
, (
bRev
?105:108), 
iIdxCur
);

87371 
j
 = 
	`sqlite3VdbeAddOp0
(
v
, 13);

87372 
pLevel
->
addrSkip
 = 
	`sqlite3VdbeAddOp4Int
(
v
, (
bRev
?63:66),

87373 
iIdxCur
, 0, 
regBase
, 
nSkip
);

87376 
	`sqlite3VdbeJumpHere
(
v
, 
j
);

87377 for(
j
=0; j<
nSkip
; j++)

87380 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iIdxCur
, 
j
, 
regBase
+j);

87389 for(
j
=
nSkip
; j<
nEq
; j++)

87392 int 
r1
;

87393 
pTerm
 = 
pLoop
->
aLTerm
[
j
];

87399 
r1
 = 
	`codeEqualityTerm
(
pParse
, 
pTerm
, 
pLevel
, 
j
, 
bRev
, 
regBase
+j);

87400 if( 
r1
!=
regBase
+
j
 )

87403 if( 
nReg
==1 )

87406 
	`sqlite3ReleaseTempReg
(
pParse
, 
regBase
);

87407 
regBase
 = 
r1
;

87409 
	`sqlite3VdbeAddOp2
(
v
, 31, 
r1
, 
regBase
+
j
);

87414 if( (
pTerm
->
eOperator
 & (0x0100|0x0001))==0 )

87417 
Expr
 *
pRight
 = 
pTerm
->
pExpr
->pRight;

87418 if( (
pTerm
->
wtFlags
 & 0x800)==0 && 
	`sqlite3ExprCanBeNull
(
pRight
) )

87421 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regBase
+
j
, 
pLevel
->
addrBrk
);

87424 if( 
zAff
 )

87427 if( 
	`sqlite3CompareAffinity
(
pRight
, 
zAff
[
j
])=='A' )

87430 
zAff
[
j
] = 'A';

87432 if( 
	`sqlite3ExprNeedsNoAffinityChange
(
pRight
, 
zAff
[
j
]) )

87435 
zAff
[
j
] = 'A';

87440 *
pzAff
 = 
zAff
;

87441 return 
regBase
;

87442 
	}
}

87444 static void 
	$whereLikeOptimizationStringFixup
(

87445 
Vdbe
 *
v
,

87446 
WhereLevel
 *
pLevel
,

87447 
WhereTerm
 *
pTerm


87451 if( 
pTerm
->
wtFlags
 & 0x100 )

87454 
VdbeOp
 *
pOp
;

87456 
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, -1);

87460 
pOp
->
p3
 = 
pLevel
->
iLikeRepCntr
;

87461 
pOp
->
p5
 = 1;

87463 
	}
}

87465 static void 
	$codeDeferredSeek
(

87466 
WhereInfo
 *
pWInfo
,

87467 
Index
 *
pIdx
,

87468 int 
iCur
,

87469 int 
iIdxCur


87473 
Parse
 *
pParse
 = 
pWInfo
->pParse;

87474 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

87479 
	`sqlite3VdbeAddOp3
(
v
, 112, 
iIdxCur
, 0, 
iCur
);

87480 if( (
pWInfo
->
wctrlFlags
 & 0x0020)

87481 && (((
pParse
)->
pToplevel
 ? (pParse)->pToplevel : (pParse))->
writeMask
)==0

87485 int 
i
;

87486 
Table
 *
pTab
 = 
pIdx
->
pTable
;

87487 int *
ai
 = (int*)
	`sqlite3DbMallocZero
(
pParse
->
db
, sizeof(int)*(
pTab
->
nCol
+1));

87488 if( 
ai
 )

87491 
ai
[0] = 
pTab
->
nCol
;

87492 for(
i
=0; i<
pIdx
->
nColumn
-1; i++)

87496 if( 
pIdx
->
aiColumn
[
i
]>=0 ) 
ai
[pIdx->aiColumn[i]+1] = i+1;

87498 
	`sqlite3VdbeChangeP4
(
v
, -1, (char*)
ai
, (-15));

87501 
	}
}

87507 static 
Bitmask
 
	$sqlite3WhereCodeOneLoopStart
(

87508 
WhereInfo
 *
pWInfo
,

87509 int 
iLevel
,

87510 
Bitmask
 
notReady


87514 int 
j
, 
k
;

87515 int 
iCur
;

87516 int 
addrNxt
;

87517 int 
omitTable
;

87518 int 
bRev
;

87519 
WhereLevel
 *
pLevel
;

87520 
WhereLoop
 *
pLoop
;

87521 
WhereClause
 *
pWC
;

87522 
WhereTerm
 *
pTerm
;

87523 
Parse
 *
pParse
;

87524 
sqlite3
 *
db
;

87525 
Vdbe
 *
v
;

87526 struct 
SrcList_item
 *
pTabItem
;

87527 int 
addrBrk
;

87528 int 
addrCont
;

87529 int 
iRowidReg
 = 0;

87530 int 
iReleaseReg
 = 0;

87532 
pParse
 = 
pWInfo
->pParse;

87533 
v
 = 
pParse
->
pVdbe
;

87534 
pWC
 = &
pWInfo
->
sWC
;

87535 
db
 = 
pParse
->db;

87536 
pLevel
 = &
pWInfo
->
a
[
iLevel
];

87537 
pLoop
 = 
pLevel
->
pWLoop
;

87538 
pTabItem
 = &
pWInfo
->
pTabList
->
a
[
pLevel
->
iFrom
];

87539 
iCur
 = 
pTabItem
->
iCursor
;

87540 
pLevel
->
notReady
 = notReady & ~
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
, 
iCur
);

87541 
bRev
 = (
pWInfo
->
revMask
>>
iLevel
)&1;

87542 
omitTable
 = (
pLoop
->
wsFlags
 & 0x00000040)!=0

87543 && (
pWInfo
->
wctrlFlags
 & 0x0020)==0;

87546 
addrBrk
 = 
pLevel
->addrBrk = pLevel->
addrNxt
 = 
	`sqlite3VdbeMakeLabel
(
v
);

87547 
addrCont
 = 
pLevel
->addrCont = 
	`sqlite3VdbeMakeLabel
(
v
);

87553 if( 
pLevel
->
iFrom
>0 && (
pTabItem
[0].
fg
.
jointype
 & 0x0008)!=0 )

87556 
pLevel
->
iLeftJoin
 = ++
pParse
->
nMem
;

87557 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
pLevel
->
iLeftJoin
);

87562 if( 
pTabItem
->
fg
.
viaCoroutine
 )

87565 int 
regYield
 = 
pTabItem
->
regReturn
;

87566 
	`sqlite3VdbeAddOp3
(
v
, 16, 
regYield
, 0, 
pTabItem
->
addrFillSub
);

87567 
pLevel
->
p2
 = 
	`sqlite3VdbeAddOp2
(
v
, 18, 
regYield
, 
addrBrk
);

87570 
pLevel
->
op
 = 13;

87574 if( (
pLoop
->
wsFlags
 & 0x00000400)!=0 )

87580 int 
iReg
;

87581 int 
addrNotFound
;

87582 int 
nConstraint
 = 
pLoop
->
nLTerm
;

87583 int 
iIn
;

87585 
	`sqlite3ExprCachePush
(
pParse
);

87586 
iReg
 = 
	`sqlite3GetTempRange
(
pParse
, 
nConstraint
+2);

87587 
addrNotFound
 = 
pLevel
->
addrBrk
;

87588 for(
j
=0; j<
nConstraint
; j++)

87591 int 
iTarget
 = 
iReg
+
j
+2;

87592 
pTerm
 = 
pLoop
->
aLTerm
[
j
];

87593 if( (
pTerm
==0) ) continue;

87594 if( 
pTerm
->
eOperator
 & 0x0001 )

87597 
	`codeEqualityTerm
(
pParse
, 
pTerm
, 
pLevel
, 
j
, 
bRev
, 
iTarget
);

87598 
addrNotFound
 = 
pLevel
->
addrNxt
;

87600 
	`sqlite3ExprCode
(
pParse
, 
pTerm
->
pExpr
->
pRight
, 
iTarget
);

87603 
	`sqlite3VdbeAddOp2
(
v
, 22, 
pLoop
->
u
.
vtab
.
idxNum
, 
iReg
);

87604 
	`sqlite3VdbeAddOp2
(
v
, 22, 
nConstraint
, 
iReg
+1);

87605 
	`sqlite3VdbeAddOp4
(
v
, 11, 
iCur
, 
addrNotFound
, 
iReg
,

87606 
pLoop
->
u
.
vtab
.
idxStr
,

87607 
pLoop
->
u
.
vtab
.
needFree
 ? (-11) : (-2));

87609 
pLoop
->
u
.
vtab
.
needFree
 = 0;

87610 
pLevel
->
p1
 = 
iCur
;

87611 
pLevel
->
op
 = 
pWInfo
->
eOnePass
 ? 160 : 154;

87612 
pLevel
->
p2
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

87613 
iIn
 = 
pLevel
->
u
.
in
.
nIn
;

87614 for(
j
=
nConstraint
-1; j>=0; j--)

87617 
pTerm
 = 
pLoop
->
aLTerm
[
j
];

87618 if( 
j
<16 && (
pLoop
->
u
.
vtab
.
omitMask
>>j)&1 )

87621 
	`disableTerm
(
pLevel
, 
pTerm
);

87622 }else if( (
pTerm
->
eOperator
 & 0x0001)!=0 )

87625 
Expr
 *
pCompare
;

87626 
Expr
 *
pRight
;

87627 
VdbeOp
 *
pOp
;

87634 if( !
db
->
mallocFailed
 )

87638 
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, 
pLevel
->
u
.
in
.
aInLoop
[--
iIn
].
addrInTop
);

87643 
	`sqlite3VdbeAddOp3
(
v
, 
pOp
->
opcode
, pOp->
p1
, pOp->
p2
, pOp->
p3
);

87648 
pCompare
 = 
	`sqlite3PExpr
(
pParse
, 79, 0, 0, 0);

87650 if( 
pCompare
 )

87653 
pCompare
->
pLeft
 = 
pTerm
->
pExpr
->pLeft;

87654 
pCompare
->
pRight
 = pRight = 
	`sqlite3Expr
(
db
, 157, 0);

87655 if( 
pRight
 )

87658 
pRight
->
iTable
 = 
iReg
+
j
+2;

87659 
	`sqlite3ExprIfFalse
(
pParse
, 
pCompare
, 
pLevel
->
addrCont
, 0);

87661 
pCompare
->
pLeft
 = 0;

87662 
	`sqlite3ExprDelete
(
db
, 
pCompare
);

87666 
	`sqlite3ReleaseTempRange
(
pParse
, 
iReg
, 
nConstraint
+2);

87667 
	`sqlite3ExprCachePop
(
pParse
);

87671 if( (
pLoop
->
wsFlags
 & 0x00000100)!=0

87672 && (
pLoop
->
wsFlags
 & (0x00000004|0x00000001))!=0

87682 
pTerm
 = 
pLoop
->
aLTerm
[0];

87687 
iReleaseReg
 = ++
pParse
->
nMem
;

87688 
iRowidReg
 = 
	`codeEqualityTerm
(
pParse
, 
pTerm
, 
pLevel
, 0, 
bRev
, 
iReleaseReg
);

87689 if( 
iRowidReg
!=
iReleaseReg
 ) 
	`sqlite3ReleaseTempReg
(
pParse
, iReleaseReg);

87690 
addrNxt
 = 
pLevel
->addrNxt;

87691 
	`sqlite3VdbeAddOp2
(
v
, 38, 
iRowidReg
, 
addrNxt
); ;

87692 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iCur
, 
addrNxt
, 
iRowidReg
);

87694 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
iRowidReg
, 1);

87695 
	`sqlite3ExprCacheStore
(
pParse
, 
iCur
, -1, 
iRowidReg
);

87697 
pLevel
->
op
 = 160;

87698 }else if( (
pLoop
->
wsFlags
 & 0x00000100)!=0

87699 && (
pLoop
->
wsFlags
 & 0x00000002)!=0

87705 int 
testOp
 = 160;

87706 int 
start
;

87707 int 
memEndValue
 = 0;

87708 
WhereTerm
 *
pStart
, *
pEnd
;

87711 
j
 = 0;

87712 
pStart
 = 
pEnd
 = 0;

87713 if( 
pLoop
->
wsFlags
 & 0x00000020 ) 
pStart
 = pLoop->
aLTerm
[
j
++];

87714 if( 
pLoop
->
wsFlags
 & 0x00000010 ) 
pEnd
 = pLoop->
aLTerm
[
j
++];

87716 if( 
bRev
 )

87719 
pTerm
 = 
pStart
;

87720 
pStart
 = 
pEnd
;

87721 
pEnd
 = 
pTerm
;

87724 if( 
pStart
 )

87727 
Expr
 *
pX
;

87728 int 
r1
, 
rTemp
;

87733 const 
u8
 
aMoveOp
[] = {

87745 
pX
 = 
pStart
->
pExpr
;

87748 
r1
 = 
	`sqlite3ExprCodeTemp
(
pParse
, 
pX
->
pRight
, &
rTemp
);

87749 
	`sqlite3VdbeAddOp3
(
v
, 
aMoveOp
[
pX
->
op
-80], 
iCur
, 
addrBrk
, 
r1
);

87755 
	`sqlite3ExprCacheAffinityChange
(
pParse
, 
r1
, 1);

87756 
	`sqlite3ReleaseTempReg
(
pParse
, 
rTemp
);

87757 
	`disableTerm
(
pLevel
, 
pStart
);

87759 
	`sqlite3VdbeAddOp2
(
v
, 
bRev
 ? 105 : 108, 
iCur
, 
addrBrk
);

87763 if( 
pEnd
 )

87766 
Expr
 *
pX
;

87767 
pX
 = 
pEnd
->
pExpr
;

87772 
memEndValue
 = ++
pParse
->
nMem
;

87773 
	`sqlite3ExprCode
(
pParse
, 
pX
->
pRight
, 
memEndValue
);

87774 if( 
pX
->
op
==82 || pX->op==80 )

87777 
testOp
 = 
bRev
 ? 81 : 83;

87779 
testOp
 = 
bRev
 ? 82 : 80;

87781 
	`disableTerm
(
pLevel
, 
pEnd
);

87783 
start
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

87784 
pLevel
->
op
 = 
bRev
 ? 6 : 7;

87785 
pLevel
->
p1
 = 
iCur
;

87786 
pLevel
->
p2
 = 
start
;

87788 if( 
testOp
!=160 )

87791 
iRowidReg
 = ++
pParse
->
nMem
;

87792 
	`sqlite3VdbeAddOp2
(
v
, 103, 
iCur
, 
iRowidReg
);

87793 
	`sqlite3ExprCacheStore
(
pParse
, 
iCur
, -1, 
iRowidReg
);

87794 
	`sqlite3VdbeAddOp3
(
v
, 
testOp
, 
memEndValue
, 
addrBrk
, 
iRowidReg
);

87799 
	`sqlite3VdbeChangeP5
(
v
, 'C' | 0x10);

87801 }else if( 
pLoop
->
wsFlags
 & 0x00000200 )

87805 static const 
u8
 
aStartOp
[] = {

87815 static const 
u8
 
aEndOp
[] = {

87821 
u16
 
nEq
 = 
pLoop
->
u
.
btree
.nEq;

87822 int 
regBase
;

87823 
WhereTerm
 *
pRangeStart
 = 0;

87824 
WhereTerm
 *
pRangeEnd
 = 0;

87825 int 
startEq
;

87826 int 
endEq
;

87827 int 
start_constraints
;

87828 int 
nConstraint
;

87829 
Index
 *
pIdx
;

87830 int 
iIdxCur
;

87831 int 
nExtraReg
 = 0;

87832 int 
op
;

87833 char *
zStartAff
;

87834 char 
cEndAff
 = 0;

87835 
u8
 
bSeekPastNull
 = 0;

87836 
u8
 
bStopAtNull
 = 0;

87838 
pIdx
 = 
pLoop
->
u
.
btree
.
pIndex
;

87839 
iIdxCur
 = 
pLevel
->iIdxCur;

87845 if( (
pWInfo
->
wctrlFlags
&0x0001)!=0

87846 && 
pWInfo
->
nOBSat
>0

87847 && (
pIdx
->
nKeyCol
>
nEq
)

87852 
bSeekPastNull
 = 1;

87853 
nExtraReg
 = 1;

87859 
j
 = 
nEq
;

87860 if( 
pLoop
->
wsFlags
 & 0x00000020 )

87863 
pRangeStart
 = 
pLoop
->
aLTerm
[
j
++];

87864 
nExtraReg
 = 1;

87869 if( 
pLoop
->
wsFlags
 & 0x00000010 )

87872 
pRangeEnd
 = 
pLoop
->
aLTerm
[
j
++];

87873 
nExtraReg
 = 1;

87875 if( (
pRangeEnd
->
wtFlags
 & 0x100)!=0 )

87880 
pLevel
->
iLikeRepCntr
 = ++
pParse
->
nMem
;

87883 
	`sqlite3VdbeAddOp2
(
v
, 22,

87884 
bRev
 ^ (
pIdx
->
aSortOrder
[
nEq
]==1),

87885 
pLevel
->
iLikeRepCntr
);

87887 
pLevel
->
addrLikeRep
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

87890 if( 
pRangeStart
==0

87891 && (
j
 = 
pIdx
->
aiColumn
[
nEq
])>=0

87892 && 
pIdx
->
pTable
->
aCol
[
j
].
notNull
==0

87896 
bSeekPastNull
 = 1;

87905 if( (
nEq
<
pIdx
->
nKeyCol
 && 
bRev
==(pIdx->
aSortOrder
[nEq]==0))

87906 || (
bRev
 && 
pIdx
->
nKeyCol
==
nEq
)

87910 {
WhereTerm
 * 
t
=
pRangeEnd
; pRangeEnd=
pRangeStart
; pRangeStart=t;};

87911 {
u8
 
t
=
bSeekPastNull
; bSeekPastNull=
bStopAtNull
; bStopAtNull=t;};

87919 
regBase
 = 
	`codeAllEqualityTerms
(
pParse
,
pLevel
,
bRev
,
nExtraReg
,&
zStartAff
);

87921 if( 
zStartAff
 ) 
cEndAff
 = zStartAff[
nEq
];

87922 
addrNxt
 = 
pLevel
->addrNxt;

87928 
startEq
 = !
pRangeStart
 || pRangeStart->
eOperator
 & ((0x0002<<(81 -79))|(0x0002<<(83 -79)));

87929 
endEq
 = !
pRangeEnd
 || pRangeEnd->
eOperator
 & ((0x0002<<(81 -79))|(0x0002<<(83 -79)));

87930 
start_constraints
 = 
pRangeStart
 || 
nEq
>0;

87933 
nConstraint
 = 
nEq
;

87934 if( 
pRangeStart
 )

87937 
Expr
 *
pRight
 = 
pRangeStart
->
pExpr
->pRight;

87938 
	`sqlite3ExprCode
(
pParse
, 
pRight
, 
regBase
+
nEq
);

87939 
	`whereLikeOptimizationStringFixup
(
v
, 
pLevel
, 
pRangeStart
);

87940 if( (
pRangeStart
->
wtFlags
 & 0x00)==0

87941 && 
	`sqlite3ExprCanBeNull
(
pRight
)

87945 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regBase
+
nEq
, 
addrNxt
);

87948 if( 
zStartAff
 )

87951 if( 
	`sqlite3CompareAffinity
(
pRight
, 
zStartAff
[
nEq
])=='A')

87957 
zStartAff
[
nEq
] = 'A';

87959 if( 
	`sqlite3ExprNeedsNoAffinityChange
(
pRight
, 
zStartAff
[
nEq
]) )

87962 
zStartAff
[
nEq
] = 'A';

87965 
nConstraint
++;

87967 }else if( 
bSeekPastNull
 )

87970 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regBase
+
nEq
);

87971 
nConstraint
++;

87972 
startEq
 = 0;

87973 
start_constraints
 = 1;

87975 
	`codeApplyAffinity
(
pParse
, 
regBase
, 
nConstraint
 - 
bSeekPastNull
, 
zStartAff
);

87976 if( 
pLoop
->
nSkip
>0 && 
nConstraint
==pLoop->nSkip )

87983 
op
 = 
aStartOp
[(
start_constraints
<<2) + (
startEq
<<1) + 
bRev
];

87985 
	`sqlite3VdbeAddOp4Int
(
v
, 
op
, 
iIdxCur
, 
addrNxt
, 
regBase
, 
nConstraint
);

87998 
nConstraint
 = 
nEq
;

87999 if( 
pRangeEnd
 )

88002 
Expr
 *
pRight
 = 
pRangeEnd
->
pExpr
->pRight;

88003 
	`sqlite3ExprCacheRemove
(
pParse
, 
regBase
+
nEq
, 1);

88004 
	`sqlite3ExprCode
(
pParse
, 
pRight
, 
regBase
+
nEq
);

88005 
	`whereLikeOptimizationStringFixup
(
v
, 
pLevel
, 
pRangeEnd
);

88006 if( (
pRangeEnd
->
wtFlags
 & 0x00)==0

88007 && 
	`sqlite3ExprCanBeNull
(
pRight
)

88011 
	`sqlite3VdbeAddOp2
(
v
, 76, 
regBase
+
nEq
, 
addrNxt
);

88014 if( 
	`sqlite3CompareAffinity
(
pRight
, 
cEndAff
)!='A'

88015 && !
	`sqlite3ExprNeedsNoAffinityChange
(
pRight
, 
cEndAff
)

88019 
	`codeApplyAffinity
(
pParse
, 
regBase
+
nEq
, 1, &
cEndAff
);

88021 
nConstraint
++;

88023 }else if( 
bStopAtNull
 )

88026 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regBase
+
nEq
);

88027 
endEq
 = 0;

88028 
nConstraint
++;

88030 
	`sqlite3DbFree
(
db
, 
zStartAff
);

88033 
pLevel
->
p2
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

88036 if( 
nConstraint
 )

88039 
op
 = 
aEndOp
[
bRev
*2 + 
endEq
];

88040 
	`sqlite3VdbeAddOp4Int
(
v
, 
op
, 
iIdxCur
, 
addrNxt
, 
regBase
, 
nConstraint
);

88048 
	`disableTerm
(
pLevel
, 
pRangeStart
);

88049 
	`disableTerm
(
pLevel
, 
pRangeEnd
);

88050 if( 
omitTable
 )

88054 }else if( (((
pIdx
->
pTable
)->
tabFlags
 & 0x20)==0) )

88057 if( 
pWInfo
->
eOnePass
!=0 )

88060 
iRowidReg
 = ++
pParse
->
nMem
;

88061 
	`sqlite3VdbeAddOp2
(
v
, 113, 
iIdxCur
, 
iRowidReg
);

88062 
	`sqlite3ExprCacheStore
(
pParse
, 
iCur
, -1, 
iRowidReg
);

88063 
	`sqlite3VdbeAddOp3
(
v
, 70, 
iCur
, 0, 
iRowidReg
);

88066 
	`codeDeferredSeek
(
pWInfo
, 
pIdx
, 
iCur
, 
iIdxCur
);

88068 }else if( 
iCur
!=
iIdxCur
 )

88071 
Index
 *
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pIdx
->
pTable
);

88072 
iRowidReg
 = 
	`sqlite3GetTempRange
(
pParse
, 
pPk
->
nKeyCol
);

88073 for(
j
=0; j<
pPk
->
nKeyCol
; j++)

88076 
k
 = 
	`sqlite3ColumnOfIndex
(
pIdx
, 
pPk
->
aiColumn
[
j
]);

88077 
	`sqlite3VdbeAddOp3
(
v
, 47, 
iIdxCur
, 
k
, 
iRowidReg
+
j
);

88079 
	`sqlite3VdbeAddOp4Int
(
v
, 68, 
iCur
, 
addrCont
,

88080 
iRowidReg
, 
pPk
->
nKeyCol
); ;

88086 if( 
pLoop
->
wsFlags
 & 0x00001000 )

88089 
pLevel
->
op
 = 160;

88090 }else if( 
bRev
 )

88093 
pLevel
->
op
 = 6;

88095 
pLevel
->
op
 = 7;

88097 
pLevel
->
p1
 = 
iIdxCur
;

88098 
pLevel
->
p3
 = (
pLoop
->
wsFlags
&0x00010000)!=0 ? 1:0;

88099 if( (
pLoop
->
wsFlags
 & 0x0000000f)==0 )

88102 
pLevel
->
p5
 = 1;

88109 if( 
pLoop
->
wsFlags
 & 0x00002000 )

88113 
WhereClause
 *
pOrWc
;

88114 
SrcList
 *
pOrTab
;

88115 
Index
 *
pCov
 = 0;

88116 int 
iCovCur
 = 
pParse
->
nTab
++;

88118 int 
regReturn
 = ++
pParse
->
nMem
;

88119 int 
regRowset
 = 0;

88120 int 
regRowid
 = 0;

88121 int 
iLoopBody
 = 
	`sqlite3VdbeMakeLabel
(
v
);

88122 int 
iRetInit
;

88123 int 
untestedTerms
 = 0;

88124 int 
ii
;

88125 
u16
 
wctrlFlags
;

88126 
Expr
 *
pAndExpr
 = 0;

88127 
Table
 *
pTab
 = 
pTabItem
->pTab;

88129 
pTerm
 = 
pLoop
->
aLTerm
[0];

88133 
pOrWc
 = &
pTerm
->
u
.
pOrInfo
->
wc
;

88134 
pLevel
->
op
 = 15;

88135 
pLevel
->
p1
 = 
regReturn
;

88141 if( 
pWInfo
->
nLevel
>1 )

88144 int 
nNotReady
;

88145 struct 
SrcList_item
 *
origSrc
;

88146 
nNotReady
 = 
pWInfo
->
nLevel
 - 
iLevel
 - 1;

88147 
pOrTab
 = 
	`sqlite3DbMallocRaw
(
db
,sizeof(*pOrTab)+ 
nNotReady
*sizeof(pOrTab->
a
[0]))

88149 if( 
pOrTab
==0 ) return 
notReady
;

88150 
pOrTab
->
nAlloc
 = (
u8
)(
nNotReady
 + 1);

88151 
pOrTab
->
nSrc
 = pOrTab->
nAlloc
;

88152 
	`memcpy
(
pOrTab
->
a
, 
pTabItem
, sizeof(*pTabItem));

88153 
origSrc
 = 
pWInfo
->
pTabList
->
a
;

88154 for(
k
=1; k<=
nNotReady
; k++)

88157 
	`memcpy
(&
pOrTab
->
a
[
k
], &
origSrc
[
pLevel
[k].
iFrom
], sizeof(pOrTab->a[k]));

88160 
pOrTab
 = 
pWInfo
->
pTabList
;

88163 if( (
pWInfo
->
wctrlFlags
 & 0x0008)==0 )

88166 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

88169 
regRowset
 = ++
pParse
->
nMem
;

88170 
	`sqlite3VdbeAddOp2
(
v
, 25, 0, 
regRowset
);

88172 
Index
 *
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

88173 
regRowset
 = 
pParse
->
nTab
++;

88174 
	`sqlite3VdbeAddOp2
(
v
, 57, 
regRowset
, 
pPk
->
nKeyCol
);

88175 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pPk
);

88177 
regRowid
 = ++
pParse
->
nMem
;

88179 
iRetInit
 = 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 
regReturn
);

88181 if( 
pWC
->
nTerm
>1 )

88184 int 
iTerm
;

88185 for(
iTerm
=0; iTerm<
pWC
->
nTerm
; iTerm++)

88188 
Expr
 *
pExpr
 = 
pWC
->
a
[
iTerm
].pExpr;

88189 if( &
pWC
->
a
[
iTerm
] == 
pTerm
 ) continue;

88190 if( (((
pExpr
)->
flags
&(0x000001))!=0) ) continue;

88193 if( (
pWC
->
a
[
iTerm
].
wtFlags
 & (0x02|0x04))!=0 ) continue;

88194 if( (
pWC
->
a
[
iTerm
].
eOperator
 & 0x1fff)==0 ) continue;

88196 
pExpr
 = 
	`sqlite3ExprDup
(
db
, pExpr, 0);

88197 
pAndExpr
 = 
	`sqlite3ExprAnd
(
db
, pAndExpr, 
pExpr
);

88199 if( 
pAndExpr
 )

88202 
pAndExpr
 = 
	`sqlite3PExpr
(
pParse
, 72|0x100, 0, pAndExpr, 0);

88210 
wctrlFlags
 = 0x0010

88214 for(
ii
=0; ii<
pOrWc
->
nTerm
; ii++)

88217 
WhereTerm
 *
pOrTerm
 = &
pOrWc
->
a
[
ii
];

88218 if( 
pOrTerm
->
leftCursor
==
iCur
 || (pOrTerm->
eOperator
 & 0x0400)!=0 )

88221 
WhereInfo
 *
pSubWInfo
;

88222 
Expr
 *
pOrExpr
 = 
pOrTerm
->
pExpr
;

88223 int 
jmp1
 = 0;

88224 if( 
pAndExpr
 && !(((
pOrExpr
)->
flags
&(0x000001))!=0) )

88227 
pAndExpr
->
pLeft
 = 
pOrExpr
;

88228 
pOrExpr
 = 
pAndExpr
;

88232 
pSubWInfo
 = 
	`sqlite3WhereBegin
(
pParse
, 
pOrTab
, 
pOrExpr
, 0, 0,

88233 
wctrlFlags
, 
iCovCur
);

88235 if( 
pSubWInfo
 )

88238 
WhereLoop
 *
pSubLoop
;

88239 int 
addrExplain
 = 
	`sqlite3WhereExplainOneScan
(

88240 
pParse
, 
pOrTab
, &
pSubWInfo
->
a
[0], 
iLevel
, 
pLevel
->
iFrom
, 0

88242 ((void)
addrExplain
);

88249 if( (
pWInfo
->
wctrlFlags
 & 0x0008)==0 )

88252 int 
r
;

88253 int 
iSet
 = ((
ii
==
pOrWc
->
nTerm
-1)?-1:ii);

88254 if( (((
pTab
)->
tabFlags
 & 0x20)==0) )

88257 
r
 = 
	`sqlite3ExprCodeGetColumn
(
pParse
, 
pTab
, -1, 
iCur
, 
regRowid
, 0);

88258 
jmp1
 = 
	`sqlite3VdbeAddOp4Int
(
v
, 131, 
regRowset
, 0,

88259 
r
,
iSet
);

88262 
Index
 *
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

88263 int 
nPk
 = 
pPk
->
nKeyCol
;

88264 int 
iPk
;

88267 
r
 = 
	`sqlite3GetTempRange
(
pParse
, 
nPk
);

88268 for(
iPk
=0; iPk<
nPk
; iPk++)

88271 int 
iCol
 = 
pPk
->
aiColumn
[
iPk
];

88272 
	`sqlite3ExprCodeGetColumnToReg
(
pParse
, 
pTab
, 
iCol
, 
iCur
, 
r
+
iPk
);

88275 if( 
iSet
 )

88278 
jmp1
 = 
	`sqlite3VdbeAddOp4Int
(
v
, 69, 
regRowset
, 0, 
r
, 
nPk
);

88281 if( 
iSet
>=0 )

88284 
	`sqlite3VdbeAddOp3
(
v
, 49, 
r
, 
nPk
, 
regRowid
);

88285 
	`sqlite3VdbeAddOp3
(
v
, 110, 
regRowset
, 
regRowid
, 0);

88286 if( 
iSet
 ) 
	`sqlite3VdbeChangeP5
(
v
, 0x10);

88290 
	`sqlite3ReleaseTempRange
(
pParse
, 
r
, 
nPk
);

88295 
	`sqlite3VdbeAddOp2
(
v
, 14, 
regReturn
, 
iLoopBody
);

88299 if( 
jmp1
 ) 
	`sqlite3VdbeJumpHere
(
v
, jmp1);

88306 if( 
pSubWInfo
->
untestedTerms
 ) untestedTerms = 1;

88308 
pSubLoop
 = 
pSubWInfo
->
a
[0].
pWLoop
;

88310 if( (
pSubLoop
->
wsFlags
 & 0x00000200)!=0

88311 && (
ii
==0 || 
pSubLoop
->
u
.
btree
.
pIndex
==
pCov
)

88312 && ((((
pTab
)->
tabFlags
 & 0x20)==0) || !((
pSubLoop
->
u
.
btree
.
pIndex
)->
idxType
==2))

88317 
pCov
 = 
pSubLoop
->
u
.
btree
.
pIndex
;

88318 
wctrlFlags
 |= 0x1000;

88320 
pCov
 = 0;

88324 
	`sqlite3WhereEnd
(
pSubWInfo
);

88328 
pLevel
->
u
.
pCovidx
 = 
pCov
;

88329 if( 
pCov
 ) 
pLevel
->
iIdxCur
 = 
iCovCur
;

88330 if( 
pAndExpr
 )

88333 
pAndExpr
->
pLeft
 = 0;

88334 
	`sqlite3ExprDelete
(
db
, 
pAndExpr
);

88336 
	`sqlite3VdbeChangeP1
(
v
, 
iRetInit
, 
	`sqlite3VdbeCurrentAddr
(v));

88337 
	`sqlite3VdbeGoto
(
v
, 
pLevel
->
addrBrk
);

88338 
	`sqlite3VdbeResolveLabel
(
v
, 
iLoopBody
);

88340 if( 
pWInfo
->
nLevel
>1 ) 
	`sqlite3DbFree
(
db
,
pOrTab
);

88341 if( !
untestedTerms
 ) 
	`disableTerm
(
pLevel
, 
pTerm
);

88349 static const 
u8
 
aStep
[] = { 7, 6 };

88350 static const 
u8
 
aStart
[] = { 108, 105 };

88352 if( 
pTabItem
->
fg
.
isRecursive
 )

88357 
pLevel
->
op
 = 160;

88360 
pLevel
->
op
 = 
aStep
[
bRev
];

88361 
pLevel
->
p1
 = 
iCur
;

88362 
pLevel
->
p2
 = 1 + 
	`sqlite3VdbeAddOp2
(
v
, 
aStart
[
bRev
], 
iCur
, 
addrBrk
);

88365 
pLevel
->
p5
 = 1;

88369 for(
pTerm
=
pWC
->
a
, 
j
=pWC->
nTerm
; j>0; j--, pTerm++)

88372 
Expr
 *
pE
;

88373 int 
skipLikeAddr
 = 0;

88376 if( 
pTerm
->
wtFlags
 & (0x02|0x04) ) continue;

88377 if( (
pTerm
->
prereqAll
 & 
pLevel
->
notReady
)!=0 )

88382 
pWInfo
->
untestedTerms
 = 1;

88385 
pE
 = 
pTerm
->
pExpr
;

88387 if( 
pLevel
->
iLeftJoin
 && !(((
pE
)->
flags
&(0x000001))!=0) )

88392 if( 
pTerm
->
wtFlags
 & 0x200 )

88399 
skipLikeAddr
 = 
	`sqlite3VdbeAddOp1
(
v
, 46, 
pLevel
->
iLikeRepCntr
);

88403 
	`sqlite3ExprIfFalse
(
pParse
, 
pE
, 
addrCont
, 0x10);

88404 if( 
skipLikeAddr
 ) 
	`sqlite3VdbeJumpHere
(
v
, skipLikeAddr);

88405 
pTerm
->
wtFlags
 |= 0x04;

88408 for(
pTerm
=
pWC
->
a
, 
j
=pWC->
nTerm
; j>0; j--, pTerm++)

88411 
Expr
 *
pE
, *
pEAlt
;

88412 
WhereTerm
 *
pAlt
;

88413 if( 
pTerm
->
wtFlags
 & (0x02|0x04) ) continue;

88414 if( (
pTerm
->
eOperator
 & (0x0002|0x0080))==0 ) continue;

88415 if( (
pTerm
->
eOperator
 & 0x0800)==0 ) continue;

88416 if( 
pTerm
->
leftCursor
!=
iCur
 ) continue;

88417 if( 
pLevel
->
iLeftJoin
 ) continue;

88418 
pE
 = 
pTerm
->
pExpr
;

88421 
pAlt
 = 
	`sqlite3WhereFindTerm
(
pWC
, 
iCur
, 
pTerm
->
u
.
leftColumn
, 
notReady
,

88423 if( 
pAlt
==0 ) continue;

88424 if( 
pAlt
->
wtFlags
 & (0x04) ) continue;

88429 
pEAlt
 = 
	`sqlite3DbMallocRaw
(
db
,sizeof(*pEAlt));

88430 if( 
pEAlt
 )

88433 *
pEAlt
 = *
pAlt
->
pExpr
;

88434 
pEAlt
->
pLeft
 = 
pE
->pLeft;

88435 
	`sqlite3ExprIfFalse
(
pParse
, 
pEAlt
, 
addrCont
, 0x10);

88436 
	`sqlite3DbFree
(
db
,
pEAlt
);

88443 if( 
pLevel
->
iLeftJoin
 )

88446 
pLevel
->
addrFirst
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

88447 
	`sqlite3VdbeAddOp2
(
v
, 22, 1, 
pLevel
->
iLeftJoin
);

88449 
	`sqlite3ExprCacheClear
(
pParse
);

88450 for(
pTerm
=
pWC
->
a
, 
j
=0; j<pWC->
nTerm
; j++, pTerm++)

88455 if( 
pTerm
->
wtFlags
 & (0x02|0x04) ) continue;

88456 if( (
pTerm
->
prereqAll
 & 
pLevel
->
notReady
)!=0 )

88463 
	`sqlite3ExprIfFalse
(
pParse
, 
pTerm
->
pExpr
, 
addrCont
, 0x10);

88464 
pTerm
->
wtFlags
 |= 0x04;

88468 return 
pLevel
->
notReady
;

88469 
	}
}

88471 static void 
exprAnalyze
(
SrcList
*, 
WhereClause
*, int);

88476 static void 
	$whereOrInfoDelete
(
sqlite3
 *
db
, 
WhereOrInfo
 *
p
)

88479 
	`sqlite3WhereClauseClear
(&
p
->
wc
);

88480 
	`sqlite3DbFree
(
db
, 
p
);

88481 
	}
}

88486 static void 
	$whereAndInfoDelete
(
sqlite3
 *
db
, 
WhereAndInfo
 *
p
)

88489 
	`sqlite3WhereClauseClear
(&
p
->
wc
);

88490 
	`sqlite3DbFree
(
db
, 
p
);

88491 
	}
}

88493 static int 
	$whereClauseInsert
(
WhereClause
 *
pWC
, 
Expr
 *
p
, 
u16
 
wtFlags
)

88496 
WhereTerm
 *
pTerm
;

88497 int 
idx
;

88499 if( 
pWC
->
nTerm
>=pWC->
nSlot
 )

88502 
WhereTerm
 *
pOld
 = 
pWC
->
a
;

88503 
sqlite3
 *
db
 = 
pWC
->
pWInfo
->
pParse
->db;

88504 
pWC
->
a
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(pWC->a[0])*pWC->
nSlot
*2 );

88505 if( 
pWC
->
a
==0 )

88508 if( 
wtFlags
 & 0x01 )

88511 
	`sqlite3ExprDelete
(
db
, 
p
);

88513 
pWC
->
a
 = 
pOld
;

88516 
	`memcpy
(
pWC
->
a
, 
pOld
, sizeof(pWC->a[0])*pWC->
nTerm
);

88517 if( 
pOld
!=
pWC
->
aStatic
 )

88520 
	`sqlite3DbFree
(
db
, 
pOld
);

88522 
pWC
->
nSlot
 = 
	`sqlite3DbMallocSize
(
db
, pWC->
a
)/sizeof(pWC->a[0]);

88523 
	`memset
(&
pWC
->
a
[pWC->
nTerm
], 0, sizeof(pWC->a[0])*(pWC->
nSlot
-pWC->nTerm));

88525 
pTerm
 = &
pWC
->
a
[
idx
 = pWC->
nTerm
++];

88526 if( 
p
 && (((p)->
flags
&(0x040000))!=0) )

88529 
pTerm
->
truthProb
 = 
	`sqlite3LogEst
(
p
->
iTable
) - 270;

88531 
pTerm
->
truthProb
 = 1;

88533 
pTerm
->
pExpr
 = 
	`sqlite3ExprSkipCollate
(
p
);

88534 
pTerm
->
wtFlags
 = wtFlags;

88535 
pTerm
->
pWC
 = pWC;

88536 
pTerm
->
iParent
 = -1;

88537 return 
idx
;

88538 
	}
}

88545 static int 
	$allowedOp
(int 
op
)

88552 return 
op
==75 || (op>=79 && op<=83) || op==76 || op==73;

88553 
	}
}

88555 static void 
	$exprCommute
(
Parse
 *
pParse
, 
Expr
 *
pExpr
)

88558 
u16
 
expRight
 = (
pExpr
->
pRight
->
flags
 & 0x000100);

88559 
u16
 
expLeft
 = (
pExpr
->
pLeft
->
flags
 & 0x000100);

88561 if( 
expRight
==
expLeft
 )

88565 if( 
expRight
 )

88570 
pExpr
->
pRight
->
flags
 &= ~0x000100;

88571 }else if( 
	`sqlite3ExprCollSeq
(
pParse
, 
pExpr
->
pLeft
)!=0 )

88577 
pExpr
->
pLeft
->
flags
 |= 0x000100;

88580 {
Expr
* 
t
=
pExpr
->
pRight
; pExpr->pRight=pExpr->
pLeft
; pExpr->pLeft=t;};

88581 if( 
pExpr
->
op
>=80 )

88589 
pExpr
->
op
 = ((pExpr->op-80)^2)+80;

88591 
	}
}

88596 static 
u16
 
	$operatorMask
(int 
op
)

88599 
u16
 
c
;

88601 if( 
op
==75 )

88604 
c
 = 0x0001;

88605 }else if( 
op
==76 )

88608 
c
 = 0x0100;

88609 }else if( 
op
==73 )

88612 
c
 = 0x0080;

88615 
c
 = (
u16
)(0x0002<<(
op
-79));

88625 return 
c
;

88626 
	}
}

88628 static int 
	$isLikeOrGlob
(

88629 
Parse
 *
pParse
,

88630 
Expr
 *
pExpr
,

88631 
Expr
 **
ppPrefix
,

88632 int *
pisComplete
,

88633 int *
pnoCase


88637 const char *
z
 = 0;

88638 
Expr
 *
pRight
, *
pLeft
;

88639 
ExprList
 *
pList
;

88640 int 
c
;

88641 int 
cnt
;

88642 char 
wc
[3];

88643 
sqlite3
 *
db
 = 
pParse
->db;

88644 
sqlite3_value
 *
pVal
 = 0;

88645 int 
op
;

88646 int 
rc
;

88648 if( !
	`sqlite3IsLikeFunction
(
db
, 
pExpr
, 
pnoCase
, 
wc
) )

88656 
pList
 = 
pExpr
->
x
.pList;

88657 
pLeft
 = 
pList
->
a
[1].
pExpr
;

88658 if( 
pLeft
->
op
!=152

88659 || 
	`sqlite3ExprAffinity
(
pLeft
)!='B'

88660 || (((
pLeft
->
pTab
)->
tabFlags
 & 0x10)!=0)

88670 
pRight
 = 
	`sqlite3ExprSkipCollate
(
pList
->
a
[0].
pExpr
);

88671 
op
 = 
pRight
->op;

88672 if( 
op
==135 )

88675 
Vdbe
 *
pReprepare
 = 
pParse
->pReprepare;

88676 int 
iCol
 = 
pRight
->
iColumn
;

88677 
pVal
 = 
	`sqlite3VdbeGetBoundValue
(
pReprepare
, 
iCol
, 'A');

88678 if( 
pVal
 && 
	`sqlite3_value_type
(pVal)==3 )

88681 
z
 = (char *)
	`sqlite3_value_text
(
pVal
);

88683 
	`sqlite3VdbeSetVarmask
(
pParse
->
pVdbe
, 
iCol
);

88685 }else if( 
op
==97 )

88688 
z
 = 
pRight
->
u
.
zToken
;

88690 if( 
z
 )

88693 
cnt
 = 0;

88694 while( (
c
=
z
[
cnt
])!=0 && c!=
wc
[0] && c!=wc[1] && c!=wc[2] )

88697 
cnt
++;

88699 if( 
cnt
!=0 && 255!=(
u8
)
z
[cnt-1] )

88702 
Expr
 *
pPrefix
;

88703 *
pisComplete
 = 
c
==
wc
[0] && 
z
[
cnt
+1]==0;

88704 
pPrefix
 = 
	`sqlite3Expr
(
db
, 97, 
z
);

88705 if( 
pPrefix
 ) pPrefix->
u
.
zToken
[
cnt
] = 0;

88706 *
ppPrefix
 = 
pPrefix
;

88707 if( 
op
==135 )

88710 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

88711 
	`sqlite3VdbeSetVarmask
(
v
, 
pRight
->
iColumn
);

88712 if( *
pisComplete
 && 
pRight
->
u
.
zToken
[1] )

88721 int 
r1
 = 
	`sqlite3GetTempReg
(
pParse
);

88722 
	`sqlite3ExprCodeTarget
(
pParse
, 
pRight
, 
r1
);

88723 
	`sqlite3VdbeChangeP3
(
v
, 
	`sqlite3VdbeCurrentAddr
(v)-1, 0);

88724 
	`sqlite3ReleaseTempReg
(
pParse
, 
r1
);

88728 
z
 = 0;

88732 
rc
 = (
z
!=0);

88733 
	`sqlite3ValueFree
(
pVal
);

88734 return 
rc
;

88735 
	}
}

88737 static int 
	$isMatchOfColumn
(

88738 
Expr
 *
pExpr
,

88739 unsigned char *
peOp2


88743 struct 
	sOp2
 {

88744 const char *
zOp
;

88745 unsigned char 
eOp2
;

88746 } 
aOp
[] = {

88752 
ExprList
 *
pList
;

88753 
Expr
 *
pCol
;

88754 int 
i
;

88756 if( 
pExpr
->
op
!=151 )

88761 
pList
 = 
pExpr
->
x
.pList;

88762 if( 
pList
==0 || pList->
nExpr
!=2 )

88767 
pCol
 = 
pList
->
a
[1].
pExpr
;

88768 if( 
pCol
->
op
!=152 || !(((pCol->
pTab
)->
tabFlags
 & 0x10)!=0) )

88773 for(
i
=0; i<((int)(sizeof(
aOp
)/sizeof(aOp[0]))); i++)

88776 if( 
	`sqlite3StrICmp
(
pExpr
->
u
.
zToken
, 
aOp
[
i
].
zOp
)==0 )

88779 *
peOp2
 = 
aOp
[
i
].
eOp2
;

88784 
	}
}

88791 static void 
	$transferJoinMarkings
(
Expr
 *
pDerived
, Expr *
pBase
)

88794 if( 
pDerived
 )

88797 
pDerived
->
flags
 |= 
pBase
->flags & 0x000001;

88798 
pDerived
->
iRightJoinTable
 = 
pBase
->iRightJoinTable;

88800 
	}
}

88805 static void 
	$markTermAsChild
(
WhereClause
 *
pWC
, int 
iChild
, int 
iParent
)

88808 
pWC
->
a
[
iChild
].
iParent
 = iParent;

88809 
pWC
->
a
[
iChild
].
truthProb
 = pWC->a[
iParent
].truthProb;

88810 
pWC
->
a
[
iParent
].
nChild
++;

88811 
	}
}

88818 static 
WhereTerm
 *
	$whereNthSubterm
(
WhereTerm
 *
pTerm
, int 
N
)

88821 if( 
pTerm
->
eOperator
!=0x0400 )

88824 return 
N
==0 ? 
pTerm
 : 0;

88826 if( 
N
<
pTerm
->
u
.
pAndInfo
->
wc
.
nTerm
 )

88829 return &
pTerm
->
u
.
pAndInfo
->
wc
.
a
[
N
];

88832 
	}
}

88834 static void 
	$whereCombineDisjuncts
(

88835 
SrcList
 *
pSrc
,

88836 
WhereClause
 *
pWC
,

88837 
WhereTerm
 *
pOne
,

88838 
WhereTerm
 *
pTwo


88842 
u16
 
eOp
 = 
pOne
->
eOperator
 | 
pTwo
->eOperator;

88843 
sqlite3
 *
db
;

88844 
Expr
 *
pNew
;

88845 int 
op
;

88846 int 
idxNew
;

88848 if( (
pOne
->
eOperator
 & (0x0002|(0x0002<<(82 -79))|(0x0002<<(81 -79))|(0x0002<<(80 -79))|(0x0002<<(83 -79))))==0 ) return;

88849 if( (
pTwo
->
eOperator
 & (0x0002|(0x0002<<(82 -79))|(0x0002<<(81 -79))|(0x0002<<(80 -79))|(0x0002<<(83 -79))))==0 ) return;

88850 if( (
eOp
 & (0x0002|(0x0002<<(82 -79))|(0x0002<<(81 -79))))!=eOp

88851 && (
eOp
 & (0x0002|(0x0002<<(80 -79))|(0x0002<<(83 -79))))!=eOp ) return;

88854 if( 
	`sqlite3ExprCompare
(
pOne
->
pExpr
->
pLeft
, 
pTwo
->pExpr->pLeft, -1) ) return;

88855 if( 
	`sqlite3ExprCompare
(
pOne
->
pExpr
->
pRight
, 
pTwo
->pExpr->pRight, -1) )return;

88857 if( (
eOp
 & (eOp-1))!=0 )

88860 if( 
eOp
 & ((0x0002<<(82 -79))|(0x0002<<(81 -79))) )

88863 
eOp
 = (0x0002<<(81 -79));

88866 
eOp
 = (0x0002<<(83 -79));

88869 
db
 = 
pWC
->
pWInfo
->
pParse
->db;

88870 
pNew
 = 
	`sqlite3ExprDup
(
db
, 
pOne
->
pExpr
, 0);

88871 if( 
pNew
==0 ) return;

88872 for(
op
=79; 
eOp
!=(0x0002<<(op-79)); op++)

88875 
pNew
->
op
 = op;

88876 
idxNew
 = 
	`whereClauseInsert
(
pWC
, 
pNew
, 0x02|0x01);

88877 
	`exprAnalyze
(
pSrc
, 
pWC
, 
idxNew
);

88878 
	}
}

88880 static void 
	$exprAnalyzeOrTerm
(

88881 
SrcList
 *
pSrc
,

88882 
WhereClause
 *
pWC
,

88883 int 
idxTerm


88887 
WhereInfo
 *
pWInfo
 = 
pWC
->pWInfo;

88888 
Parse
 *
pParse
 = 
pWInfo
->pParse;

88889 
sqlite3
 *
db
 = 
pParse
->db;

88890 
WhereTerm
 *
pTerm
 = &
pWC
->
a
[
idxTerm
];

88891 
Expr
 *
pExpr
 = 
pTerm
->pExpr;

88892 int 
i
;

88893 
WhereClause
 *
pOrWc
;

88894 
WhereTerm
 *
pOrTerm
;

88895 
WhereOrInfo
 *
pOrInfo
;

88896 
Bitmask
 
chngToIN
;

88897 
Bitmask
 
indexable
;

88906 
pTerm
->
u
.
pOrInfo
 = pOrInfo = 
	`sqlite3DbMallocZero
(
db
, sizeof(*pOrInfo));

88907 if( 
pOrInfo
==0 ) return;

88908 
pTerm
->
wtFlags
 |= 0x10;

88909 
pOrWc
 = &
pOrInfo
->
wc
;

88910 
	`memset
(
pOrWc
->
aStatic
, 0, sizeof(pOrWc->aStatic));

88911 
	`sqlite3WhereClauseInit
(
pOrWc
, 
pWInfo
);

88912 
	`sqlite3WhereSplit
(
pOrWc
, 
pExpr
, 71);

88913 
	`sqlite3WhereExprAnalyze
(
pSrc
, 
pOrWc
);

88914 if( 
db
->
mallocFailed
 ) return;

88920 
indexable
 = ~(
Bitmask
)0;

88921 
chngToIN
 = ~(
Bitmask
)0;

88922 for(
i
=
pOrWc
->
nTerm
-1, 
pOrTerm
=pOrWc->
a
; i>=0 && 
indexable
; i--, pOrTerm++)

88925 if( (
pOrTerm
->
eOperator
 & 0x01ff)==0 )

88928 
WhereAndInfo
 *
pAndInfo
;

88930 
chngToIN
 = 0;

88931 
pAndInfo
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(*pAndInfo));

88932 if( 
pAndInfo
 )

88935 
WhereClause
 *
pAndWC
;

88936 
WhereTerm
 *
pAndTerm
;

88937 int 
j
;

88938 
Bitmask
 
b
 = 0;

88939 
pOrTerm
->
u
.
pAndInfo
 = pAndInfo;

88940 
pOrTerm
->
wtFlags
 |= 0x20;

88941 
pOrTerm
->
eOperator
 = 0x0400;

88942 
pAndWC
 = &
pAndInfo
->
wc
;

88943 
	`memset
(
pAndWC
->
aStatic
, 0, sizeof(pAndWC->aStatic));

88944 
	`sqlite3WhereClauseInit
(
pAndWC
, 
pWC
->
pWInfo
);

88945 
	`sqlite3WhereSplit
(
pAndWC
, 
pOrTerm
->
pExpr
, 72);

88946 
	`sqlite3WhereExprAnalyze
(
pSrc
, 
pAndWC
);

88947 
pAndWC
->
pOuter
 = 
pWC
;

88948 if( !
db
->
mallocFailed
 )

88951 for(
j
=0, 
pAndTerm
=
pAndWC
->
a
; j<pAndWC->
nTerm
; j++, pAndTerm++)

88955 if( 
	`allowedOp
(
pAndTerm
->
pExpr
->
op
) )

88958 
b
 |= 
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
, 
pAndTerm
->
leftCursor
);

88962 
indexable
 &= 
b
;

88964 }else if( 
pOrTerm
->
wtFlags
 & 0x08 )

88970 
Bitmask
 
b
;

88971 
b
 = 
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
, 
pOrTerm
->
leftCursor
);

88972 if( 
pOrTerm
->
wtFlags
 & 0x02 )

88975 
WhereTerm
 *
pOther
 = &
pOrWc
->
a
[
pOrTerm
->
iParent
];

88976 
b
 |= 
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
, 
pOther
->
leftCursor
);

88978 
indexable
 &= 
b
;

88979 if( (
pOrTerm
->
eOperator
 & 0x0002)==0 )

88982 
chngToIN
 = 0;

88984 
chngToIN
 &= 
b
;

88993 
pOrInfo
->
indexable
 = indexable;

88994 
pTerm
->
eOperator
 = 
indexable
==0 ? 0 : 0x0200;

88998 if( 
indexable
 && 
pOrWc
->
nTerm
==2 )

89001 int 
iOne
 = 0;

89002 
WhereTerm
 *
pOne
;

89003 while( (
pOne
 = 
	`whereNthSubterm
(&
pOrWc
->
a
[0],
iOne
++))!=0 )

89006 int 
iTwo
 = 0;

89007 
WhereTerm
 *
pTwo
;

89008 while( (
pTwo
 = 
	`whereNthSubterm
(&
pOrWc
->
a
[1],
iTwo
++))!=0 )

89011 
	`whereCombineDisjuncts
(
pSrc
, 
pWC
, 
pOne
, 
pTwo
);

89016 if( 
chngToIN
 )

89019 int 
okToChngToIN
 = 0;

89020 int 
iColumn
 = -1;

89021 int 
iCursor
 = -1;

89022 int 
j
 = 0;

89030 for(
j
=0; j<2 && !
okToChngToIN
; j++)

89033 
pOrTerm
 = 
pOrWc
->
a
;

89034 for(
i
=
pOrWc
->
nTerm
-1; i>=0; i--, 
pOrTerm
++)

89038 
pOrTerm
->
wtFlags
 &= ~0x40;

89039 if( 
pOrTerm
->
leftCursor
==
iCursor
 )

89047 if( (
chngToIN
 & 
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
,

89048 
pOrTerm
->
leftCursor
))==0 )

89060 
iColumn
 = 
pOrTerm
->
u
.
leftColumn
;

89061 
iCursor
 = 
pOrTerm
->
leftCursor
;

89064 if( 
i
<0 )

89078 
okToChngToIN
 = 1;

89079 for(; 
i
>=0 && 
okToChngToIN
; i--, 
pOrTerm
++)

89083 if( 
pOrTerm
->
leftCursor
!=
iCursor
 )

89086 
pOrTerm
->
wtFlags
 &= ~0x40;

89087 }else if( 
pOrTerm
->
u
.
leftColumn
!=
iColumn
 )

89090 
okToChngToIN
 = 0;

89092 int 
affLeft
, 
affRight
;

89097 
affRight
 = 
	`sqlite3ExprAffinity
(
pOrTerm
->
pExpr
->
pRight
);

89098 
affLeft
 = 
	`sqlite3ExprAffinity
(
pOrTerm
->
pExpr
->
pLeft
);

89099 if( 
affRight
!=0 && affRight!=
affLeft
 )

89102 
okToChngToIN
 = 0;

89104 
pOrTerm
->
wtFlags
 |= 0x40;

89114 if( 
okToChngToIN
 )

89117 
Expr
 *
pDup
;

89118 
ExprList
 *
pList
 = 0;

89119 
Expr
 *
pLeft
 = 0;

89120 
Expr
 *
pNew
;

89122 for(
i
=
pOrWc
->
nTerm
-1, 
pOrTerm
=pOrWc->
a
; i>=0; i--, pOrTerm++)

89125 if( (
pOrTerm
->
wtFlags
 & 0x40)==0 ) continue;

89129 
pDup
 = 
	`sqlite3ExprDup
(
db
, 
pOrTerm
->
pExpr
->
pRight
, 0);

89130 
pList
 = 
	`sqlite3ExprListAppend
(
pWInfo
->
pParse
, pList, 
pDup
);

89131 
pLeft
 = 
pOrTerm
->
pExpr
->pLeft;

89134 
pDup
 = 
	`sqlite3ExprDup
(
db
, 
pLeft
, 0);

89135 
pNew
 = 
	`sqlite3PExpr
(
pParse
, 75, 
pDup
, 0, 0);

89136 if( 
pNew
 )

89139 int 
idxNew
;

89140 
	`transferJoinMarkings
(
pNew
, 
pExpr
);

89142 
pNew
->
x
.
pList
 = pList;

89143 
idxNew
 = 
	`whereClauseInsert
(
pWC
, 
pNew
, 0x02|0x01);

89145 
	`exprAnalyze
(
pSrc
, 
pWC
, 
idxNew
);

89146 
pTerm
 = &
pWC
->
a
[
idxTerm
];

89147 
	`markTermAsChild
(
pWC
, 
idxNew
, 
idxTerm
);

89149 
	`sqlite3ExprListDelete
(
db
, 
pList
);

89151 
pTerm
->
eOperator
 = 0x1000;

89154 
	}
}

89156 static int 
	$termIsEquivalence
(
Parse
 *
pParse
, 
Expr
 *
pExpr
)

89159 char 
aff1
, 
aff2
;

89160 
CollSeq
 *
pColl
;

89161 const char *
zColl1
, *
zColl2
;

89162 if( !(((
pParse
->
db
)->
dbOptFlags
&(0x0200))==0) ) return 0;

89163 if( 
pExpr
->
op
!=79 && pExpr->op!=73 ) return 0;

89164 if( (((
pExpr
)->
flags
&(0x000001))!=0) ) return 0;

89165 
aff1
 = 
	`sqlite3ExprAffinity
(
pExpr
->
pLeft
);

89166 
aff2
 = 
	`sqlite3ExprAffinity
(
pExpr
->
pRight
);

89167 if( 
aff1
!=
aff2


89168 && (!((
aff1
)>='C') || !((
aff2
)>='C'))

89174 
pColl
 = 
	`sqlite3BinaryCompareCollSeq
(
pParse
, 
pExpr
->
pLeft
, pExpr->
pRight
);

89175 if( 
pColl
==0 || 
	`sqlite3StrICmp
(pColl->
zName
, "BINARY")==0 ) return 1;

89176 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pExpr
->
pLeft
);

89179 
zColl1
 = (
pColl
) ? pColl->
zName
 : 0;

89180 
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pExpr
->
pRight
);

89181 
zColl2
 = (
pColl
) ? pColl->
zName
 : 0;

89182 return 
	`sqlite3StrICmp
(
zColl1
, 
zColl2
)==0;

89183 
	}
}

89190 static 
Bitmask
 
	$exprSelectUsage
(
WhereMaskSet
 *
pMaskSet
, 
Select
 *
pS
)

89193 
Bitmask
 
mask
 = 0;

89194 while( 
pS
 )

89197 
SrcList
 *
pSrc
 = 
pS
->pSrc;

89198 
mask
 |= 
	`sqlite3WhereExprListUsage
(
pMaskSet
, 
pS
->
pEList
);

89199 
mask
 |= 
	`sqlite3WhereExprListUsage
(
pMaskSet
, 
pS
->
pGroupBy
);

89200 
mask
 |= 
	`sqlite3WhereExprListUsage
(
pMaskSet
, 
pS
->
pOrderBy
);

89201 
mask
 |= 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pS
->
pWhere
);

89202 
mask
 |= 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pS
->
pHaving
);

89203 if( (
pSrc
!=0) )

89206 int 
i
;

89207 for(
i
=0; i<
pSrc
->
nSrc
; i++)

89210 
mask
 |= 
	`exprSelectUsage
(
pMaskSet
, 
pSrc
->
a
[
i
].
pSelect
);

89211 
mask
 |= 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pSrc
->
a
[
i
].
pOn
);

89214 
pS
 = pS->
pPrior
;

89216 return 
mask
;

89217 
	}
}

89219 static int 
	$exprMightBeIndexed
(

89220 
SrcList
 *
pFrom
,

89221 
Bitmask
 
mPrereq
,

89222 
Expr
 *
pExpr
,

89223 int *
piCur
,

89224 int *
piColumn


89228 
Index
 *
pIdx
;

89229 int 
i
;

89230 int 
iCur
;

89231 if( 
pExpr
->
op
==152 )

89234 *
piCur
 = 
pExpr
->
iTable
;

89235 *
piColumn
 = 
pExpr
->
iColumn
;

89238 if( 
mPrereq
==0 ) return 0;

89239 if( (
mPrereq
&(mPrereq-1))!=0 ) return 0;

89240 for(
i
=0; 
mPrereq
>1; i++, mPrereq>>=1)

89243 
iCur
 = 
pFrom
->
a
[
i
].
iCursor
;

89244 for(
pIdx
=
pFrom
->
a
[
i
].
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

89247 if( 
pIdx
->
aColExpr
==0 ) continue;

89248 for(
i
=0; i<
pIdx
->
nKeyCol
; i++)

89251 if( 
pIdx
->
aiColumn
[
i
]!=(-2) ) continue;

89252 if( 
	`sqlite3ExprCompare
(
pExpr
, 
pIdx
->
aColExpr
->
a
[
i
].pExpr, 
iCur
)==0 )

89255 *
piCur
 = 
iCur
;

89256 *
piColumn
 = -2;

89262 
	}
}

89264 static void 
	$exprAnalyze
(

89265 
SrcList
 *
pSrc
,

89266 
WhereClause
 *
pWC
,

89267 int 
idxTerm


89271 
WhereInfo
 *
pWInfo
 = 
pWC
->pWInfo;

89272 
WhereTerm
 *
pTerm
;

89273 
WhereMaskSet
 *
pMaskSet
;

89274 
Expr
 *
pExpr
;

89275 
Bitmask
 
prereqLeft
;

89276 
Bitmask
 
prereqAll
;

89277 
Bitmask
 
extraRight
 = 0;

89278 
Expr
 *
pStr1
 = 0;

89279 int 
isComplete
 = 0;

89280 int 
noCase
 = 0;

89281 int 
op
;

89282 
Parse
 *
pParse
 = 
pWInfo
->pParse;

89283 
sqlite3
 *
db
 = 
pParse
->db;

89284 unsigned char 
eOp2
;

89286 if( 
db
->
mallocFailed
 )

89291 
pTerm
 = &
pWC
->
a
[
idxTerm
];

89292 
pMaskSet
 = &
pWInfo
->
sMaskSet
;

89293 
pExpr
 = 
pTerm
->pExpr;

89295 
prereqLeft
 = 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pExpr
->
pLeft
);

89296 
op
 = 
pExpr
->op;

89297 if( 
op
==75 )

89301 if( (((
pExpr
)->
flags
&(0x000800))!=0) )

89304 
pTerm
->
prereqRight
 = 
	`exprSelectUsage
(
pMaskSet
, 
pExpr
->
x
.
pSelect
);

89306 
pTerm
->
prereqRight
 = 
	`sqlite3WhereExprListUsage
(
pMaskSet
, 
pExpr
->
x
.
pList
);

89308 }else if( 
op
==76 )

89311 
pTerm
->
prereqRight
 = 0;

89313 
pTerm
->
prereqRight
 = 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pExpr
->
pRight
);

89315 
prereqAll
 = 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pExpr
);

89316 if( (((
pExpr
)->
flags
&(0x000001))!=0) )

89319 
Bitmask
 
x
 = 
	`sqlite3WhereGetMask
(
pMaskSet
, 
pExpr
->
iRightJoinTable
);

89320 
prereqAll
 |= 
x
;

89321 
extraRight
 = 
x
-1;

89324 
pTerm
->
prereqAll
 = prereqAll;

89325 
pTerm
->
leftCursor
 = -1;

89326 
pTerm
->
iParent
 = -1;

89327 
pTerm
->
eOperator
 = 0;

89328 if( 
	`allowedOp
(
op
) )

89331 int 
iCur
, 
iColumn
;

89332 
Expr
 *
pLeft
 = 
	`sqlite3ExprSkipCollate
(
pExpr
->pLeft);

89333 
Expr
 *
pRight
 = 
	`sqlite3ExprSkipCollate
(
pExpr
->pRight);

89334 
u16
 
opMask
 = (
pTerm
->
prereqRight
 & 
prereqLeft
)==0 ? 0x1fff : 0x0800;

89335 if( 
	`exprMightBeIndexed
(
pSrc
, 
prereqLeft
, 
pLeft
, &
iCur
, &
iColumn
) )

89338 
pTerm
->
leftCursor
 = 
iCur
;

89339 
pTerm
->
u
.
leftColumn
 = 
iColumn
;

89340 
pTerm
->
eOperator
 = 
	`operatorMask
(
op
) & 
opMask
;

89342 if( 
op
==73 ) 
pTerm
->
wtFlags
 |= 0x800;

89343 if( 
pRight


89344 && 
	`exprMightBeIndexed
(
pSrc
, 
pTerm
->
prereqRight
, 
pRight
, &
iCur
, &
iColumn
)

89348 
WhereTerm
 *
pNew
;

89349 
Expr
 *
pDup
;

89350 
u16
 
eExtraOp
 = 0;

89351 if( 
pTerm
->
leftCursor
>=0 )

89354 int 
idxNew
;

89355 
pDup
 = 
	`sqlite3ExprDup
(
db
, 
pExpr
, 0);

89356 if( 
db
->
mallocFailed
 )

89359 
	`sqlite3ExprDelete
(
db
, 
pDup
);

89362 
idxNew
 = 
	`whereClauseInsert
(
pWC
, 
pDup
, 0x02|0x01);

89363 if( 
idxNew
==0 ) return;

89364 
pNew
 = &
pWC
->
a
[
idxNew
];

89365 
	`markTermAsChild
(
pWC
, 
idxNew
, 
idxTerm
);

89366 if( 
op
==73 ) 
pNew
->
wtFlags
 |= 0x800;

89367 
pTerm
 = &
pWC
->
a
[
idxTerm
];

89368 
pTerm
->
wtFlags
 |= 0x08;

89370 if( 
	`termIsEquivalence
(
pParse
, 
pDup
) )

89373 
pTerm
->
eOperator
 |= 0x0800;

89374 
eExtraOp
 = 0x0800;

89377 
pDup
 = 
pExpr
;

89378 
pNew
 = 
pTerm
;

89380 
	`exprCommute
(
pParse
, 
pDup
);

89381 
pNew
->
leftCursor
 = 
iCur
;

89382 
pNew
->
u
.
leftColumn
 = 
iColumn
;

89384 
pNew
->
prereqRight
 = 
prereqLeft
 | 
extraRight
;

89385 
pNew
->
prereqAll
 = prereqAll;

89386 
pNew
->
eOperator
 = (
	`operatorMask
(
pDup
->
op
) + 
eExtraOp
) & 
opMask
;

89390 else if( 
pExpr
->
op
==74 && 
pWC
->op==72 )

89393 
ExprList
 *
pList
 = 
pExpr
->
x
.pList;

89394 int 
i
;

89395 static const 
u8
 
ops
[] = {83, 81};

89398 for(
i
=0; i<2; i++)

89401 
Expr
 *
pNewExpr
;

89402 int 
idxNew
;

89403 
pNewExpr
 = 
	`sqlite3PExpr
(
pParse
, 
ops
[
i
],

89404 
	`sqlite3ExprDup
(
db
, 
pExpr
->
pLeft
, 0),

89405 
	`sqlite3ExprDup
(
db
, 
pList
->
a
[
i
].
pExpr
, 0), 0);

89406 
	`transferJoinMarkings
(
pNewExpr
, 
pExpr
);

89407 
idxNew
 = 
	`whereClauseInsert
(
pWC
, 
pNewExpr
, 0x02|0x01);

89409 
	`exprAnalyze
(
pSrc
, 
pWC
, 
idxNew
);

89410 
pTerm
 = &
pWC
->
a
[
idxTerm
];

89411 
	`markTermAsChild
(
pWC
, 
idxNew
, 
idxTerm
);

89420 else if( 
pExpr
->
op
==71 )

89424 
	`exprAnalyzeOrTerm
(
pSrc
, 
pWC
, 
idxTerm
);

89425 
pTerm
 = &
pWC
->
a
[
idxTerm
];

89428 if( 
pWC
->
op
==72

89429 && 
	`isLikeOrGlob
(
pParse
, 
pExpr
, &
pStr1
, &
isComplete
, &
noCase
)

89433 
Expr
 *
pLeft
;

89434 
Expr
 *
pStr2
;

89435 
Expr
 *
pNewExpr1
;

89436 
Expr
 *
pNewExpr2
;

89437 int 
idxNew1
;

89438 int 
idxNew2
;

89439 const char *
zCollSeqName
;

89440 const 
u16
 
wtFlags
 = 0x100 | 0x02 | 0x01;

89442 
pLeft
 = 
pExpr
->
x
.
pList
->
a
[1].pExpr;

89443 
pStr2
 = 
	`sqlite3ExprDup
(
db
, 
pStr1
, 0);

89449 if( 
noCase
 && !
pParse
->
db
->
mallocFailed
 )

89452 int 
i
;

89453 char 
c
;

89454 
pTerm
->
wtFlags
 |= 0x400;

89455 for(
i
=0; (
c
 = 
pStr1
->
u
.
zToken
[i])!=0; i++)

89458 
pStr1
->
u
.
zToken
[
i
] = ((
c
)&~(
sqlite3CtypeMap
[(unsigned char)(c)]&0x20));

89459 
pStr2
->
u
.
zToken
[
i
] = (
sqlite3UpperToLower
[(unsigned char)(
c
)]);

89463 if( !
db
->
mallocFailed
 )

89466 
u8
 
c
, *
pC
;

89467 
pC
 = (
u8
*)&
pStr2
->
u
.
zToken
[
	`sqlite3Strlen30
(pStr2->u.zToken)-1];

89468 
c
 = *
pC
;

89469 if( 
noCase
 )

89478 if( 
c
=='A'-1 ) 
isComplete
 = 0;

89479 
c
 = 
sqlite3UpperToLower
[c];

89481 *
pC
 = 
c
 + 1;

89483 
zCollSeqName
 = 
noCase
 ? "NOCASE" : "BINARY";

89484 
pNewExpr1
 = 
	`sqlite3ExprDup
(
db
, 
pLeft
, 0);

89485 
pNewExpr1
 = 
	`sqlite3PExpr
(
pParse
, 83,

89486 
	`sqlite3ExprAddCollateString
(
pParse
,
pNewExpr1
,
zCollSeqName
),

89487 
pStr1
, 0);

89488 
	`transferJoinMarkings
(
pNewExpr1
, 
pExpr
);

89489 
idxNew1
 = 
	`whereClauseInsert
(
pWC
, 
pNewExpr1
, 
wtFlags
);

89491 
	`exprAnalyze
(
pSrc
, 
pWC
, 
idxNew1
);

89492 
pNewExpr2
 = 
	`sqlite3ExprDup
(
db
, 
pLeft
, 0);

89493 
pNewExpr2
 = 
	`sqlite3PExpr
(
pParse
, 82,

89494 
	`sqlite3ExprAddCollateString
(
pParse
,
pNewExpr2
,
zCollSeqName
),

89495 
pStr2
, 0);

89496 
	`transferJoinMarkings
(
pNewExpr2
, 
pExpr
);

89497 
idxNew2
 = 
	`whereClauseInsert
(
pWC
, 
pNewExpr2
, 
wtFlags
);

89499 
	`exprAnalyze
(
pSrc
, 
pWC
, 
idxNew2
);

89500 
pTerm
 = &
pWC
->
a
[
idxTerm
];

89501 if( 
isComplete
 )

89504 
	`markTermAsChild
(
pWC
, 
idxNew1
, 
idxTerm
);

89505 
	`markTermAsChild
(
pWC
, 
idxNew2
, 
idxTerm
);

89509 if( 
	`isMatchOfColumn
(
pExpr
, &
eOp2
) )

89512 int 
idxNew
;

89513 
Expr
 *
pRight
, *
pLeft
;

89514 
WhereTerm
 *
pNewTerm
;

89515 
Bitmask
 
prereqColumn
, 
prereqExpr
;

89517 
pRight
 = 
pExpr
->
x
.
pList
->
a
[0].pExpr;

89518 
pLeft
 = 
pExpr
->
x
.
pList
->
a
[1].pExpr;

89519 
prereqExpr
 = 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pRight
);

89520 
prereqColumn
 = 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pLeft
);

89521 if( (
prereqExpr
 & 
prereqColumn
)==0 )

89524 
Expr
 *
pNewExpr
;

89525 
pNewExpr
 = 
	`sqlite3PExpr
(
pParse
, 51,

89526 0, 
	`sqlite3ExprDup
(
db
, 
pRight
, 0), 0);

89527 
idxNew
 = 
	`whereClauseInsert
(
pWC
, 
pNewExpr
, 0x02|0x01);

89529 
pNewTerm
 = &
pWC
->
a
[
idxNew
];

89530 
pNewTerm
->
prereqRight
 = 
prereqExpr
;

89531 
pNewTerm
->
leftCursor
 = 
pLeft
->
iTable
;

89532 
pNewTerm
->
u
.
leftColumn
 = 
pLeft
->
iColumn
;

89533 
pNewTerm
->
eOperator
 = 0x0040;

89534 
pNewTerm
->
eMatchOp
 = 
eOp2
;

89535 
	`markTermAsChild
(
pWC
, 
idxNew
, 
idxTerm
);

89536 
pTerm
 = &
pWC
->
a
[
idxTerm
];

89537 
pTerm
->
wtFlags
 |= 0x08;

89538 
pNewTerm
->
prereqAll
 = 
pTerm
->prereqAll;

89542 
pTerm
->
prereqRight
 |= 
extraRight
;

89543 
	}
}

89545 static void 
	$sqlite3WhereSplit
(
WhereClause
 *
pWC
, 
Expr
 *
pExpr
, 
u8
 
op
)

89548 
Expr
 *
pE2
 = 
	`sqlite3ExprSkipCollate
(
pExpr
);

89549 
pWC
->
op
 = op;

89550 if( 
pE2
==0 ) return;

89551 if( 
pE2
->
op
!=op )

89554 
	`whereClauseInsert
(
pWC
, 
pExpr
, 0);

89556 
	`sqlite3WhereSplit
(
pWC
, 
pE2
->
pLeft
, 
op
);

89557 
	`sqlite3WhereSplit
(
pWC
, 
pE2
->
pRight
, 
op
);

89559 
	}
}

89564 static void 
	$sqlite3WhereClauseInit
(

89565 
WhereClause
 *
pWC
,

89566 
WhereInfo
 *
pWInfo


89570 
pWC
->
pWInfo
 = pWInfo;

89571 
pWC
->
pOuter
 = 0;

89572 
pWC
->
nTerm
 = 0;

89573 
pWC
->
nSlot
 = ((int)(sizeof(pWC->
aStatic
)/sizeof(pWC->aStatic[0])));

89574 
pWC
->
a
 = pWC->
aStatic
;

89575 
	}
}

89582 static void 
	$sqlite3WhereClauseClear
(
WhereClause
 *
pWC
)

89585 int 
i
;

89586 
WhereTerm
 *
a
;

89587 
sqlite3
 *
db
 = 
pWC
->
pWInfo
->
pParse
->db;

89588 for(
i
=
pWC
->
nTerm
-1, 
a
=pWC->a; i>=0; i--, a++)

89591 if( 
a
->
wtFlags
 & 0x01 )

89594 
	`sqlite3ExprDelete
(
db
, 
a
->
pExpr
);

89596 if( 
a
->
wtFlags
 & 0x10 )

89599 
	`whereOrInfoDelete
(
db
, 
a
->
u
.
pOrInfo
);

89600 }else if( 
a
->
wtFlags
 & 0x20 )

89603 
	`whereAndInfoDelete
(
db
, 
a
->
u
.
pAndInfo
);

89606 if( 
pWC
->
a
!=pWC->
aStatic
 )

89609 
	`sqlite3DbFree
(
db
, 
pWC
->
a
);

89611 
	}
}

89619 static 
Bitmask
 
	$sqlite3WhereExprUsage
(
WhereMaskSet
 *
pMaskSet
, 
Expr
 *
p
)

89622 
Bitmask
 
mask
 = 0;

89623 if( 
p
==0 ) return 0;

89624 if( 
p
->
op
==152 )

89627 
mask
 = 
	`sqlite3WhereGetMask
(
pMaskSet
, 
p
->
iTable
);

89628 return 
mask
;

89630 
mask
 = 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
p
->
pRight
);

89631 
mask
 |= 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
p
->
pLeft
);

89632 if( (((
p
)->
flags
&(0x000800))!=0) )

89635 
mask
 |= 
	`exprSelectUsage
(
pMaskSet
, 
p
->
x
.
pSelect
);

89637 
mask
 |= 
	`sqlite3WhereExprListUsage
(
pMaskSet
, 
p
->
x
.
pList
);

89639 return 
mask
;

89640 
	}
}

89641 static 
Bitmask
 
	$sqlite3WhereExprListUsage
(
WhereMaskSet
 *
pMaskSet
, 
ExprList
 *
pList
)

89644 int 
i
;

89645 
Bitmask
 
mask
 = 0;

89646 if( 
pList
 )

89649 for(
i
=0; i<
pList
->
nExpr
; i++)

89652 
mask
 |= 
	`sqlite3WhereExprUsage
(
pMaskSet
, 
pList
->
a
[
i
].
pExpr
);

89655 return 
mask
;

89656 
	}
}

89658 static void 
	$sqlite3WhereExprAnalyze
(

89659 
SrcList
 *
pTabList
,

89660 
WhereClause
 *
pWC


89664 int 
i
;

89665 for(
i
=
pWC
->
nTerm
-1; i>=0; i--)

89668 
	`exprAnalyze
(
pTabList
, 
pWC
, 
i
);

89670 
	}
}

89672 static void 
	$sqlite3WhereTabFuncArgs
(

89673 
Parse
 *
pParse
,

89674 struct 
SrcList_item
 *
pItem
,

89675 
WhereClause
 *
pWC


89679 
Table
 *
pTab
;

89680 int 
j
, 
k
;

89681 
ExprList
 *
pArgs
;

89682 
Expr
 *
pColRef
;

89683 
Expr
 *
pTerm
;

89684 if( 
pItem
->
fg
.
isTabFunc
==0 ) return;

89685 
pTab
 = 
pItem
->pTab;

89687 
pArgs
 = 
pItem
->
u1
.
pFuncArg
;

89688 if( 
pArgs
==0 ) return;

89689 for(
j
=
k
=0; j<
pArgs
->
nExpr
; j++)

89692 while( 
k
<
pTab
->
nCol
 && (pTab->
aCol
[k].
colFlags
 & 0x0002)==0 )

89694 
k
++;}

89695 if( 
k
>=
pTab
->
nCol
 )

89698 
	`sqlite3ErrorMsg
(
pParse
, "too many arguments on %s() - max %d",

89699 
pTab
->
zName
, 
j
);

89702 
pColRef
 = 
	`sqlite3PExpr
(
pParse
, 152, 0, 0, 0);

89703 if( 
pColRef
==0 ) return;

89704 
pColRef
->
iTable
 = 
pItem
->
iCursor
;

89705 
pColRef
->
iColumn
 = 
k
++;

89706 
pColRef
->
pTab
 = pTab;

89707 
pTerm
 = 
	`sqlite3PExpr
(
pParse
, 79, 
pColRef
,

89708 
	`sqlite3ExprDup
(
pParse
->
db
, 
pArgs
->
a
[
j
].
pExpr
, 0), 0);

89709 
	`whereClauseInsert
(
pWC
, 
pTerm
, 0x01);

89711 
	}
}

89713 static int 
whereLoopResize
(
sqlite3
*, 
WhereLoop
*, int);

89715 static 
LogEst
 
	$sqlite3WhereOutputRowCount
(
WhereInfo
 *
pWInfo
)

89718 return 
pWInfo
->
nRowOut
;

89719 
	}
}

89725 static int 
	$sqlite3WhereIsDistinct
(
WhereInfo
 *
pWInfo
)

89728 return 
pWInfo
->
eDistinct
;

89729 
	}
}

89735 static int 
	$sqlite3WhereIsOrdered
(
WhereInfo
 *
pWInfo
)

89738 return 
pWInfo
->
nOBSat
;

89739 
	}
}

89745 static int 
	$sqlite3WhereContinueLabel
(
WhereInfo
 *
pWInfo
)

89749 return 
pWInfo
->
iContinue
;

89750 
	}
}

89756 static int 
	$sqlite3WhereBreakLabel
(
WhereInfo
 *
pWInfo
)

89759 return 
pWInfo
->
iBreak
;

89760 
	}
}

89762 static int 
	$sqlite3WhereOkOnePass
(
WhereInfo
 *
pWInfo
, int *
aiCur
)

89765 
	`memcpy
(
aiCur
, 
pWInfo
->
aiCurOnePass
, sizeof(int)*2);

89773 return 
pWInfo
->
eOnePass
;

89774 
	}
}

89779 static void 
	$whereOrMove
(
WhereOrSet
 *
pDest
, WhereOrSet *
pSrc
)

89782 
pDest
->
n
 = 
pSrc
->n;

89783 
	`memcpy
(
pDest
->
a
, 
pSrc
->a, pDest->
n
*sizeof(pDest->a[0]));

89784 
	}
}

89786 static int 
	$whereOrInsert
(

89787 
WhereOrSet
 *
pSet
,

89788 
Bitmask
 
prereq
,

89789 
LogEst
 
rRun
,

89790 
LogEst
 
nOut


89794 
u16
 
i
;

89795 
WhereOrCost
 *
p
;

89796 for(
i
=
pSet
->
n
, 
p
=pSet->
a
; i>0; i--, p++)

89799 if( 
rRun
<=
p
->rRun && (
prereq
 & p->prereq)==prereq )

89802 goto 
whereOrInsert_done
;

89804 if( 
p
->
rRun
<=rRun && (p->
prereq
 & prereq)==p->prereq )

89810 if( 
pSet
->
n
<3 )

89813 
p
 = &
pSet
->
a
[pSet->
n
++];

89814 
p
->
nOut
 = nOut;

89816 
p
 = 
pSet
->
a
;

89817 for(
i
=1; i<
pSet
->
n
; i++)

89820 if( 
p
->
rRun
>
pSet
->
a
[
i
].rRun ) p = pSet->a + i;

89822 if( 
p
->
rRun
<=rRun ) return 0;

89824 
whereOrInsert_done
:

89825 
p
->
prereq
 = prereq;

89826 
p
->
rRun
 = rRun;

89827 if( 
p
->
nOut
>nOut ) p->nOut = nOut;

89829 
	}
}

89835 static 
Bitmask
 
	$sqlite3WhereGetMask
(
WhereMaskSet
 *
pMaskSet
, int 
iCursor
)

89838 int 
i
;

89840 for(
i
=0; i<
pMaskSet
->
n
; i++)

89843 if( 
pMaskSet
->
ix
[
i
]==
iCursor
 )

89846 return (((
Bitmask
)1)<<(
i
));

89850 
	}
}

89852 static void 
	$createMask
(
WhereMaskSet
 *
pMaskSet
, int 
iCursor
)

89856 
pMaskSet
->
ix
[pMaskSet->
n
++] = 
iCursor
;

89857 
	}
}

89864 static 
WhereTerm
 *
	$whereScanNext
(
WhereScan
 *
pScan
)

89867 int 
iCur
;

89868 
i16
 
iColumn
;

89869 
Expr
 *
pX
;

89870 
WhereClause
 *
pWC
;

89871 
WhereTerm
 *
pTerm
;

89872 int 
k
 = 
pScan
->k;

89874 while( 
pScan
->
iEquiv
<=pScan->
nEquiv
 )

89877 
iCur
 = 
pScan
->
aiCur
[pScan->
iEquiv
-1];

89878 
iColumn
 = 
pScan
->
aiColumn
[pScan->
iEquiv
-1];

89879 if( 
iColumn
==(-2) && 
pScan
->
pIdxExpr
==0 ) return 0;

89880 while( (
pWC
 = 
pScan
->pWC)!=0 )

89883 for(
pTerm
=
pWC
->
a
+
k
; k<pWC->
nTerm
; k++, pTerm++)

89886 if( 
pTerm
->
leftCursor
==
iCur


89887 && 
pTerm
->
u
.
leftColumn
==
iColumn


89888 && (
iColumn
!=(-2)

89889 || 
	`sqlite3ExprCompare
(
pTerm
->
pExpr
->
pLeft
,
pScan
->
pIdxExpr
,
iCur
)==0)

89890 && (
pScan
->
iEquiv
<=1 || !(((
pTerm
->
pExpr
)->
flags
&(0x000001))!=0))

89894 if( (
pTerm
->
eOperator
 & 0x0800)!=0

89895 && 
pScan
->
nEquiv
<((int)(sizeof(pScan->
aiCur
)/sizeof(pScan->aiCur[0])))

89896 && (
pX
 = 
	`sqlite3ExprSkipCollate
(
pTerm
->
pExpr
->
pRight
))->
op
==152

89900 int 
j
;

89901 for(
j
=0; j<
pScan
->
nEquiv
; j++)

89904 if( 
pScan
->
aiCur
[
j
]==
pX
->
iTable


89905 && 
pScan
->
aiColumn
[
j
]==
pX
->
iColumn
 )

89911 if( 
j
==
pScan
->
nEquiv
 )

89914 
pScan
->
aiCur
[
j
] = 
pX
->
iTable
;

89915 
pScan
->
aiColumn
[
j
] = 
pX
->
iColumn
;

89916 
pScan
->
nEquiv
++;

89919 if( (
pTerm
->
eOperator
 & 
pScan
->
opMask
)!=0 )

89923 if( 
pScan
->
zCollName
 && (
pTerm
->
eOperator
 & 0x0100)==0 )

89926 
CollSeq
 *
pColl
;

89927 
Parse
 *
pParse
 = 
pWC
->
pWInfo
->pParse;

89928 
pX
 = 
pTerm
->
pExpr
;

89929 if( !
	`sqlite3IndexAffinityOk
(
pX
, 
pScan
->
idxaff
) )

89935 
pColl
 = 
	`sqlite3BinaryCompareCollSeq
(
pParse
,

89936 
pX
->
pLeft
, pX->
pRight
);

89937 if( 
pColl
==0 ) pColl = 
pParse
->
db
->
pDfltColl
;

89938 if( 
	`sqlite3StrICmp
(
pColl
->
zName
, 
pScan
->
zCollName
) )

89944 if( (
pTerm
->
eOperator
 & (0x0002|0x0080))!=0

89945 && (
pX
 = 
pTerm
->
pExpr
->
pRight
)->
op
==152

89946 && 
pX
->
iTable
==
pScan
->
aiCur
[0]

89947 && 
pX
->
iColumn
==
pScan
->
aiColumn
[0]

89954 
pScan
->
k
 = k+1;

89955 return 
pTerm
;

89959 
pScan
->
pWC
 = pScan->pWC->
pOuter
;

89960 
k
 = 0;

89962 
pScan
->
pWC
 = pScan->
pOrigWC
;

89963 
k
 = 0;

89964 
pScan
->
iEquiv
++;

89967 
	}
}

89969 static 
WhereTerm
 *
	$whereScanInit
(

89970 
WhereScan
 *
pScan
,

89971 
WhereClause
 *
pWC
,

89972 int 
iCur
,

89973 int 
iColumn
,

89974 
u32
 
opMask
,

89975 
Index
 *
pIdx


89979 int 
j
 = 0;

89982 
pScan
->
pOrigWC
 = 
pWC
;

89983 
pScan
->
pWC
 = pWC;

89984 
pScan
->
pIdxExpr
 = 0;

89985 if( 
pIdx
 )

89988 
j
 = 
iColumn
;

89989 
iColumn
 = 
pIdx
->
aiColumn
[
j
];

89990 if( 
iColumn
==(-2) ) 
pScan
->
pIdxExpr
 = 
pIdx
->
aColExpr
->
a
[
j
].
pExpr
;

89991 if( 
iColumn
==
pIdx
->
pTable
->
iPKey
 ) iColumn = (-1);

89993 if( 
pIdx
 && 
iColumn
>=0 )

89996 
pScan
->
idxaff
 = 
pIdx
->
pTable
->
aCol
[
iColumn
].
affinity
;

89997 
pScan
->
zCollName
 = 
pIdx
->
azColl
[
j
];

89999 
pScan
->
idxaff
 = 0;

90000 
pScan
->
zCollName
 = 0;

90002 
pScan
->
opMask
 = opMask;

90003 
pScan
->
k
 = 0;

90004 
pScan
->
aiCur
[0] = 
iCur
;

90005 
pScan
->
aiColumn
[0] = 
iColumn
;

90006 
pScan
->
nEquiv
 = 1;

90007 
pScan
->
iEquiv
 = 1;

90008 return 
	`whereScanNext
(
pScan
);

90009 
	}
}

90011 static 
WhereTerm
 *
	$sqlite3WhereFindTerm
(

90012 
WhereClause
 *
pWC
,

90013 int 
iCur
,

90014 int 
iColumn
,

90015 
Bitmask
 
notReady
,

90016 
u32
 
op
,

90017 
Index
 *
pIdx


90021 
WhereTerm
 *
pResult
 = 0;

90022 
WhereTerm
 *
p
;

90023 
WhereScan
 
scan
;

90025 
p
 = 
	`whereScanInit
(&
scan
, 
pWC
, 
iCur
, 
iColumn
, 
op
, 
pIdx
);

90026 
op
 &= 0x0002|0x0080;

90027 while( 
p
 )

90030 if( (
p
->
prereqRight
 & 
notReady
)==0 )

90033 if( 
p
->
prereqRight
==0 && (p->
eOperator
&
op
)!=0 )

90037 return 
p
;

90039 if( 
pResult
==0 ) pResult = 
p
;

90041 
p
 = 
	`whereScanNext
(&
scan
);

90043 return 
pResult
;

90044 
	}
}

90046 static int 
	$findIndexCol
(

90047 
Parse
 *
pParse
,

90048 
ExprList
 *
pList
,

90049 int 
iBase
,

90050 
Index
 *
pIdx
,

90051 int 
iCol


90055 int 
i
;

90056 const char *
zColl
 = 
pIdx
->
azColl
[
iCol
];

90058 for(
i
=0; i<
pList
->
nExpr
; i++)

90061 
Expr
 *
p
 = 
	`sqlite3ExprSkipCollate
(
pList
->
a
[
i
].
pExpr
);

90062 if( 
p
->
op
==152

90063 && 
p
->
iColumn
==
pIdx
->
aiColumn
[
iCol
]

90064 && 
p
->
iTable
==
iBase


90068 
CollSeq
 *
pColl
 = 
	`sqlite3ExprCollSeq
(
pParse
, 
pList
->
a
[
i
].
pExpr
);

90069 if( 
pColl
 && 0==
	`sqlite3StrICmp
(pColl->
zName
, 
zColl
) )

90072 return 
i
;

90078 
	}
}

90083 static int 
	$indexColumnNotNull
(
Index
 *
pIdx
, int 
iCol
)

90086 int 
j
;

90089 
j
 = 
pIdx
->
aiColumn
[
iCol
];

90090 if( 
j
>=0 )

90093 return 
pIdx
->
pTable
->
aCol
[
j
].
notNull
;

90094 }else if( 
j
==(-1) )

90103 
	}
}

90105 static int 
	$isDistinctRedundant
(

90106 
Parse
 *
pParse
,

90107 
SrcList
 *
pTabList
,

90108 
WhereClause
 *
pWC
,

90109 
ExprList
 *
pDistinct


90113 
Table
 *
pTab
;

90114 
Index
 *
pIdx
;

90115 int 
i
;

90116 int 
iBase
;

90121 if( 
pTabList
->
nSrc
!=1 ) return 0;

90122 
iBase
 = 
pTabList
->
a
[0].
iCursor
;

90123 
pTab
 = 
pTabList
->
a
[0].pTab;

90129 for(
i
=0; i<
pDistinct
->
nExpr
; i++)

90132 
Expr
 *
p
 = 
	`sqlite3ExprSkipCollate
(
pDistinct
->
a
[
i
].
pExpr
);

90133 if( 
p
->
op
==152 && p->
iTable
==
iBase
 && p->
iColumn
<0 ) return 1;

90136 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

90139 if( !((
pIdx
)->
onError
!=0) ) continue;

90140 for(
i
=0; i<
pIdx
->
nKeyCol
; i++)

90143 if( 0==
	`sqlite3WhereFindTerm
(
pWC
, 
iBase
, 
i
, ~(
Bitmask
)0, 0x0002, 
pIdx
) )

90146 if( 
	`findIndexCol
(
pParse
, 
pDistinct
, 
iBase
, 
pIdx
, 
i
)<0 ) break;

90147 if( 
	`indexColumnNotNull
(
pIdx
, 
i
)==0 ) break;

90150 if( 
i
==
pIdx
->
nKeyCol
 )

90159 
	}
}

90165 static 
LogEst
 
	$estLog
(
LogEst
 
N
)

90168 return 
N
<=10 ? 0 : 
	`sqlite3LogEst
(N) - 33;

90169 
	}
}

90171 static void 
	$translateColumnToCopy
(

90172 
Vdbe
 *
v
,

90173 int 
iStart
,

90174 int 
iTabCur
,

90175 int 
iRegister
,

90176 int 
bIncrRowid


90180 
VdbeOp
 *
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, 
iStart
);

90181 int 
iEnd
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

90182 for(; 
iStart
<
iEnd
; iStart++, 
pOp
++)

90185 if( 
pOp
->
p1
!=
iTabCur
 ) continue;

90186 if( 
pOp
->
opcode
==47 )

90189 
pOp
->
opcode
 = 30;

90190 
pOp
->
p1
 = pOp->
p2
 + 
iRegister
;

90191 
pOp
->
p2
 = pOp->
p3
;

90192 
pOp
->
p3
 = 0;

90193 }else if( 
pOp
->
opcode
==103 )

90196 if( 
bIncrRowid
 )

90200 
pOp
->
opcode
 = 37;

90201 
pOp
->
p1
 = pOp->
p2
;

90202 
pOp
->
p2
 = 1;

90204 
pOp
->
opcode
 = 25;

90205 
pOp
->
p1
 = 0;

90206 
pOp
->
p3
 = 0;

90210 
	}
}

90212 static int 
	$termCanDriveIndex
(

90213 
WhereTerm
 *
pTerm
,

90214 struct 
SrcList_item
 *
pSrc
,

90215 
Bitmask
 
notReady


90219 char 
aff
;

90220 if( 
pTerm
->
leftCursor
!=
pSrc
->
iCursor
 ) return 0;

90221 if( (
pTerm
->
eOperator
 & (0x0002|0x0080))==0 ) return 0;

90222 if( (
pTerm
->
prereqRight
 & 
notReady
)!=0 ) return 0;

90223 if( 
pTerm
->
u
.
leftColumn
<0 ) return 0;

90224 
aff
 = 
pSrc
->
pTab
->
aCol
[
pTerm
->
u
.
leftColumn
].
affinity
;

90225 if( !
	`sqlite3IndexAffinityOk
(
pTerm
->
pExpr
, 
aff
) ) return 0;

90228 
	}
}

90230 static void 
	$constructAutomaticIndex
(

90231 
Parse
 *
pParse
,

90232 
WhereClause
 *
pWC
,

90233 struct 
SrcList_item
 *
pSrc
,

90234 
Bitmask
 
notReady
,

90235 
WhereLevel
 *
pLevel


90239 int 
nKeyCol
;

90240 
WhereTerm
 *
pTerm
;

90241 
WhereTerm
 *
pWCEnd
;

90242 
Index
 *
pIdx
;

90243 
Vdbe
 *
v
;

90244 int 
addrInit
;

90245 
Table
 *
pTable
;

90246 int 
addrTop
;

90247 int 
regRecord
;

90248 int 
n
;

90249 int 
i
;

90250 int 
mxBitCol
;

90251 
CollSeq
 *
pColl
;

90252 
WhereLoop
 *
pLoop
;

90253 char *
zNotUsed
;

90254 
Bitmask
 
idxCols
;

90255 
Bitmask
 
extraCols
;

90256 
u8
 
sentWarning
 = 0;

90257 
Expr
 *
pPartial
 = 0;

90258 int 
iContinue
 = 0;

90259 struct 
SrcList_item
 *
pTabItem
;

90260 int 
addrCounter
 = 0;

90261 int 
regBase
;

90265 
v
 = 
pParse
->
pVdbe
;

90267 
addrInit
 = 
	`sqlite3CodeOnce
(
pParse
); ;

90271 
nKeyCol
 = 0;

90272 
pTable
 = 
pSrc
->
pTab
;

90273 
pWCEnd
 = &
pWC
->
a
[pWC->
nTerm
];

90274 
pLoop
 = 
pLevel
->
pWLoop
;

90275 
idxCols
 = 0;

90276 for(
pTerm
=
pWC
->
a
; pTerm<
pWCEnd
; pTerm++)

90279 
Expr
 *
pExpr
 = 
pTerm
->pExpr;

90283 if( 
pLoop
->
prereq
==0

90284 && (
pTerm
->
wtFlags
 & 0x02)==0

90285 && !(((
pExpr
)->
flags
&(0x000001))!=0)

90286 && 
	`sqlite3ExprIsTableConstant
(
pExpr
, 
pSrc
->
iCursor
) )

90289 
pPartial
 = 
	`sqlite3ExprAnd
(
pParse
->
db
, pPartial,

90290 
	`sqlite3ExprDup
(
pParse
->
db
, 
pExpr
, 0));

90292 if( 
	`termCanDriveIndex
(
pTerm
, 
pSrc
, 
notReady
) )

90295 int 
iCol
 = 
pTerm
->
u
.
leftColumn
;

90296 
Bitmask
 
cMask
 = 
iCol
>=((int)(sizeof(Bitmask)*8)) ? (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) : (((Bitmask)1)<<(iCol));

90299 if( !
sentWarning
 )

90302 
	`sqlite3_log
((28 | (1<<8)),

90303 "automatic index on %s(%s)", 
pTable
->
zName
,

90304 
pTable
->
aCol
[
iCol
].
zName
);

90305 
sentWarning
 = 1;

90307 if( (
idxCols
 & 
cMask
)==0 )

90310 if( 
	`whereLoopResize
(
pParse
->
db
, 
pLoop
, 
nKeyCol
+1) )

90313 goto 
end_auto_index_create
;

90315 
pLoop
->
aLTerm
[
nKeyCol
++] = 
pTerm
;

90316 
idxCols
 |= 
cMask
;

90321 
pLoop
->
u
.
btree
.
nEq
 = pLoop->
nLTerm
 = 
nKeyCol
;

90322 
pLoop
->
wsFlags
 = 0x00000001 | 0x00000040 | 0x00000200

90325 
extraCols
 = 
pSrc
->
colUsed
 & (~
idxCols
 | (((
Bitmask
)1)<<(((int)(sizeof(Bitmask)*8))-1)));

90326 
mxBitCol
 = ((((int)(sizeof(
Bitmask
)*8))-1)<(
pTable
->
nCol
)?(((int)(sizeof(Bitmask)*8))-1):(pTable->nCol));

90329 for(
i
=0; i<
mxBitCol
; i++)

90332 if( 
extraCols
 & (((
Bitmask
)1)<<(
i
)) ) 
nKeyCol
++;

90334 if( 
pSrc
->
colUsed
 & (((
Bitmask
)1)<<(((int)(sizeof(Bitmask)*8))-1)) )

90337 
nKeyCol
 += 
pTable
->
nCol
 - ((int)(sizeof(
Bitmask
)*8)) + 1;

90341 
pIdx
 = 
	`sqlite3AllocateIndexObject
(
pParse
->
db
, 
nKeyCol
+1, 0, &
zNotUsed
);

90342 if( 
pIdx
==0 ) goto 
end_auto_index_create
;

90343 
pLoop
->
u
.
btree
.
pIndex
 = 
pIdx
;

90344 
pIdx
->
zName
 = "auto-index";

90345 
pIdx
->
pTable
 = pTable;

90346 
n
 = 0;

90347 
idxCols
 = 0;

90348 for(
pTerm
=
pWC
->
a
; pTerm<
pWCEnd
; pTerm++)

90351 if( 
	`termCanDriveIndex
(
pTerm
, 
pSrc
, 
notReady
) )

90354 int 
iCol
 = 
pTerm
->
u
.
leftColumn
;

90355 
Bitmask
 
cMask
 = 
iCol
>=((int)(sizeof(Bitmask)*8)) ? (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) : (((Bitmask)1)<<(iCol));

90358 if( (
idxCols
 & 
cMask
)==0 )

90361 
Expr
 *
pX
 = 
pTerm
->
pExpr
;

90362 
idxCols
 |= 
cMask
;

90363 
pIdx
->
aiColumn
[
n
] = 
pTerm
->
u
.
leftColumn
;

90364 
pColl
 = 
	`sqlite3BinaryCompareCollSeq
(
pParse
, 
pX
->
pLeft
, pX->
pRight
);

90365 
pIdx
->
azColl
[
n
] = 
pColl
 ? pColl->
zName
 : 
sqlite3StrBINARY
;

90366 
n
++;

90374 for(
i
=0; i<
mxBitCol
; i++)

90377 if( 
extraCols
 & (((
Bitmask
)1)<<(
i
)) )

90380 
pIdx
->
aiColumn
[
n
] = 
i
;

90381 
pIdx
->
azColl
[
n
] = 
sqlite3StrBINARY
;

90382 
n
++;

90385 if( 
pSrc
->
colUsed
 & (((
Bitmask
)1)<<(((int)(sizeof(Bitmask)*8))-1)) )

90388 for(
i
=((int)(sizeof(
Bitmask
)*8))-1; i<
pTable
->
nCol
; i++)

90391 
pIdx
->
aiColumn
[
n
] = 
i
;

90392 
pIdx
->
azColl
[
n
] = 
sqlite3StrBINARY
;

90393 
n
++;

90397 
pIdx
->
aiColumn
[
n
] = (-1);

90398 
pIdx
->
azColl
[
n
] = 
sqlite3StrBINARY
;

90402 
pLevel
->
iIdxCur
 = 
pParse
->
nTab
++;

90403 
	`sqlite3VdbeAddOp2
(
v
, 56, 
pLevel
->
iIdxCur
, 
nKeyCol
+1);

90404 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pIdx
);

90408 
	`sqlite3ExprCachePush
(
pParse
);

90409 
pTabItem
 = &
pWC
->
pWInfo
->
pTabList
->
a
[
pLevel
->
iFrom
];

90410 if( 
pTabItem
->
fg
.
viaCoroutine
 )

90413 int 
regYield
 = 
pTabItem
->
regReturn
;

90414 
addrCounter
 = 
	`sqlite3VdbeAddOp2
(
v
, 22, 0, 0);

90415 
	`sqlite3VdbeAddOp3
(
v
, 16, 
regYield
, 0, 
pTabItem
->
addrFillSub
);

90416 
addrTop
 = 
	`sqlite3VdbeAddOp1
(
v
, 18, 
regYield
);

90420 
addrTop
 = 
	`sqlite3VdbeAddOp1
(
v
, 108, 
pLevel
->
iTabCur
); ;

90422 if( 
pPartial
 )

90425 
iContinue
 = 
	`sqlite3VdbeMakeLabel
(
v
);

90426 
	`sqlite3ExprIfFalse
(
pParse
, 
pPartial
, 
iContinue
, 0x10);

90427 
pLoop
->
wsFlags
 |= 0x00020000;

90429 
regRecord
 = 
	`sqlite3GetTempReg
(
pParse
);

90430 
regBase
 = 
	`sqlite3GenerateIndexKey
(

90431 
pParse
, 
pIdx
, 
pLevel
->
iTabCur
, 
regRecord
, 0, 0, 0, 0

90433 
	`sqlite3VdbeAddOp2
(
v
, 110, 
pLevel
->
iIdxCur
, 
regRecord
);

90434 
	`sqlite3VdbeChangeP5
(
v
, 0x10);

90435 if( 
pPartial
 ) 
	`sqlite3VdbeResolveLabel
(
v
, 
iContinue
);

90436 if( 
pTabItem
->
fg
.
viaCoroutine
 )

90439 
	`sqlite3VdbeChangeP2
(
v
, 
addrCounter
, 
regBase
+
n
);

90440 
	`translateColumnToCopy
(
v
, 
addrTop
, 
pLevel
->
iTabCur
, 
pTabItem
->
regResult
, 1);

90441 
	`sqlite3VdbeGoto
(
v
, 
addrTop
);

90442 
pTabItem
->
fg
.
viaCoroutine
 = 0;

90444 
	`sqlite3VdbeAddOp2
(
v
, 7, 
pLevel
->
iTabCur
, 
addrTop
+1); ;

90446 
	`sqlite3VdbeChangeP5
(
v
, 3);

90447 
	`sqlite3VdbeJumpHere
(
v
, 
addrTop
);

90448 
	`sqlite3ReleaseTempReg
(
pParse
, 
regRecord
);

90449 
	`sqlite3ExprCachePop
(
pParse
);

90452 
	`sqlite3VdbeJumpHere
(
v
, 
addrInit
);

90454 
end_auto_index_create
:

90455 
	`sqlite3ExprDelete
(
pParse
->
db
, 
pPartial
);

90456 
	}
}

90458 static 
sqlite3_index_info
 *
	$allocateIndexInfo
(

90459 
Parse
 *
pParse
,

90460 
WhereClause
 *
pWC
,

90461 
Bitmask
 
mUnusable
,

90462 struct 
SrcList_item
 *
pSrc
,

90463 
ExprList
 *
pOrderBy


90467 int 
i
, 
j
;

90468 int 
nTerm
;

90469 struct 
sqlite3_index_constraint
 *
pIdxCons
;

90470 struct 
sqlite3_index_orderby
 *
pIdxOrderBy
;

90471 struct 
sqlite3_index_constraint_usage
 *
pUsage
;

90472 
WhereTerm
 *
pTerm
;

90473 int 
nOrderBy
;

90474 
sqlite3_index_info
 *
pIdxInfo
;

90478 for(
i
=
nTerm
=0, 
pTerm
=
pWC
->
a
; i<pWC->nTerm; i++, pTerm++)

90481 if( 
pTerm
->
leftCursor
 != 
pSrc
->
iCursor
 ) continue;

90482 if( 
pTerm
->
prereqRight
 & 
mUnusable
 ) continue;

90488 if( (
pTerm
->
eOperator
 & ~(0x0100|0x0800|0x0080))==0 ) continue;

90489 if( 
pTerm
->
wtFlags
 & 0x00 ) continue;

90491 
nTerm
++;

90498 
nOrderBy
 = 0;

90499 if( 
pOrderBy
 )

90502 int 
n
 = 
pOrderBy
->
nExpr
;

90503 for(
i
=0; i<
n
; i++)

90506 
Expr
 *
pExpr
 = 
pOrderBy
->
a
[
i
].pExpr;

90507 if( 
pExpr
->
op
!=152 || pExpr->
iTable
!=
pSrc
->
iCursor
 ) break;

90509 if( 
i
==
n
)

90512 
nOrderBy
 = 
n
;

90518 
pIdxInfo
 = 
	`sqlite3DbMallocZero
(
pParse
->
db
, sizeof(*pIdxInfo)

90519 + (sizeof(*
pIdxCons
) + sizeof(*
pUsage
))*
nTerm


90520 + sizeof(*
pIdxOrderBy
)*
nOrderBy
 );

90521 if( 
pIdxInfo
==0 )

90524 
	`sqlite3ErrorMsg
(
pParse
, "out of memory");

90533 
pIdxCons
 = (struct 
sqlite3_index_constraint
*)&
pIdxInfo
[1];

90534 
pIdxOrderBy
 = (struct 
sqlite3_index_orderby
*)&
pIdxCons
[
nTerm
];

90535 
pUsage
 = (struct 
sqlite3_index_constraint_usage
*)&
pIdxOrderBy
[
nOrderBy
];

90536 *(int*)&
pIdxInfo
->
nConstraint
 = 
nTerm
;

90537 *(int*)&
pIdxInfo
->
nOrderBy
 = nOrderBy;

90538 *(struct 
sqlite3_index_constraint
**)&
pIdxInfo
->
aConstraint
 = 
pIdxCons
;

90539 *(struct 
sqlite3_index_orderby
**)&
pIdxInfo
->
aOrderBy
 = 
pIdxOrderBy
;

90540 *(struct 
sqlite3_index_constraint_usage
**)&
pIdxInfo
->
aConstraintUsage
 =

90541 
pUsage
;

90543 for(
i
=
j
=0, 
pTerm
=
pWC
->
a
; i<pWC->
nTerm
; i++, pTerm++)

90546 
u8
 
op
;

90547 if( 
pTerm
->
leftCursor
 != 
pSrc
->
iCursor
 ) continue;

90548 if( 
pTerm
->
prereqRight
 & 
mUnusable
 ) continue;

90554 if( (
pTerm
->
eOperator
 & ~(0x0100|0x0800|0x0080))==0 ) continue;

90555 if( 
pTerm
->
wtFlags
 & 0x00 ) continue;

90557 
pIdxCons
[
j
].
iColumn
 = 
pTerm
->
u
.
leftColumn
;

90558 
pIdxCons
[
j
].
iTermOffset
 = 
i
;

90559 
op
 = (
u8
)
pTerm
->
eOperator
 & 0x1fff;

90560 if( 
op
==0x0001 ) op = 0x0002;

90561 if( 
op
==0x0040 )

90564 
op
 = 
pTerm
->
eMatchOp
;

90566 
pIdxCons
[
j
].
op
 = op;

90577 
j
++;

90579 for(
i
=0; i<
nOrderBy
; i++)

90582 
Expr
 *
pExpr
 = 
pOrderBy
->
a
[
i
].pExpr;

90583 
pIdxOrderBy
[
i
].
iColumn
 = 
pExpr
->iColumn;

90584 
pIdxOrderBy
[
i
].
desc
 = 
pOrderBy
->
a
[i].
sortOrder
;

90587 return 
pIdxInfo
;

90588 
	}
}

90590 static int 
	$vtabBestIndex
(
Parse
 *
pParse
, 
Table
 *
pTab
, 
sqlite3_index_info
 *
p
)

90593 
sqlite3_vtab
 *
pVtab
 = 
	`sqlite3GetVTable
(
pParse
->
db
, 
pTab
)->pVtab;

90594 int 
rc
;

90597 
rc
 = 
pVtab
->
pModule
->
	`xBestIndex
(pVtab, 
p
);

90600 if( 
rc
!=0 )

90603 if( 
rc
==7 )

90606 
	`sqlite3OomFault
(
pParse
->
db
);

90607 }else if( !
pVtab
->
zErrMsg
 )

90610 
	`sqlite3ErrorMsg
(
pParse
, "%s", 
	`sqlite3ErrStr
(
rc
));

90612 
	`sqlite3ErrorMsg
(
pParse
, "%s", 
pVtab
->
zErrMsg
);

90615 
	`sqlite3_free
(
pVtab
->
zErrMsg
);

90616 
pVtab
->
zErrMsg
 = 0;

90618 return 
pParse
->
nErr
;

90619 
	}
}

90621 static 
LogEst
 
	$whereRangeAdjust
(
WhereTerm
 *
pTerm
, 
LogEst
 
nNew
)

90624 
LogEst
 
nRet
 = 
nNew
;

90625 if( 
pTerm
 )

90628 if( 
pTerm
->
truthProb
<=0 )

90631 
nRet
 += 
pTerm
->
truthProb
;

90632 }else if( (
pTerm
->
wtFlags
 & 0x00)==0 )

90635 
nRet
 -= 20; ((void) (0));

90638 return 
nRet
;

90639 
	}
}

90641 static int 
	$whereRangeScanEst
(

90642 
Parse
 *
pParse
,

90643 
WhereLoopBuilder
 *
pBuilder
,

90644 
WhereTerm
 *
pLower
,

90645 
WhereTerm
 *
pUpper
,

90646 
WhereLoop
 *
pLoop


90650 int 
rc
 = 0;

90651 int 
nOut
 = 
pLoop
->nOut;

90652 
LogEst
 
nNew
;

90654 (void)(
pParse
);

90655 (void)(
pBuilder
);

90659 
nNew
 = 
	`whereRangeAdjust
(
pLower
, 
nOut
);

90660 
nNew
 = 
	`whereRangeAdjust
(
pUpper
, nNew);

90668 if( 
pLower
 && pLower->
truthProb
>0 && 
pUpper
 && pUpper->truthProb>0 )

90671 
nNew
 -= 20;

90674 
nOut
 -= (
pLower
!=0) + (
pUpper
!=0);

90675 if( 
nNew
<10 ) nNew = 10;

90676 if( 
nNew
<
nOut
 ) nOut = nNew;

90683 
pLoop
->
nOut
 = (
LogEst
)nOut;

90684 return 
rc
;

90685 
	}
}

90687 static void 
	$whereLoopInit
(
WhereLoop
 *
p
)

90690 
p
->
aLTerm
 = p->
aLTermSpace
;

90691 
p
->
nLTerm
 = 0;

90692 
p
->
nLSlot
 = ((int)(sizeof(p->
aLTermSpace
)/sizeof(p->aLTermSpace[0])));

90693 
p
->
wsFlags
 = 0;

90694 
	}
}

90699 static void 
	$whereLoopClearUnion
(
sqlite3
 *
db
, 
WhereLoop
 *
p
)

90702 if( 
p
->
wsFlags
 & (0x00000400|0x00004000) )

90705 if( (
p
->
wsFlags
 & 0x00000400)!=0 && p->
u
.
vtab
.
needFree
 )

90708 
	`sqlite3_free
(
p
->
u
.
vtab
.
idxStr
);

90709 
p
->
u
.
vtab
.
needFree
 = 0;

90710 
p
->
u
.
vtab
.
idxStr
 = 0;

90711 }else if( (
p
->
wsFlags
 & 0x00004000)!=0 && p->
u
.
btree
.
pIndex
!=0 )

90714 
	`sqlite3DbFree
(
db
, 
p
->
u
.
btree
.
pIndex
->
zColAff
);

90715 
	`sqlite3DbFree
(
db
, 
p
->
u
.
btree
.
pIndex
);

90716 
p
->
u
.
btree
.
pIndex
 = 0;

90719 
	}
}

90724 static void 
	$whereLoopClear
(
sqlite3
 *
db
, 
WhereLoop
 *
p
)

90727 if( 
p
->
aLTerm
!=p->
aLTermSpace
 ) 
	`sqlite3DbFree
(
db
, p->aLTerm);

90728 
	`whereLoopClearUnion
(
db
, 
p
);

90729 
	`whereLoopInit
(
p
);

90730 
	}
}

90735 static int 
	$whereLoopResize
(
sqlite3
 *
db
, 
WhereLoop
 *
p
, int 
n
)

90738 
WhereTerm
 **
paNew
;

90739 if( 
p
->
nLSlot
>=
n
 ) return 0;

90740 
n
 = (n+7)&~7;

90741 
paNew
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(
p
->
aLTerm
[0])*
n
);

90742 if( 
paNew
==0 ) return 7;

90743 
	`memcpy
(
paNew
, 
p
->
aLTerm
, sizeof(p->aLTerm[0])*p->
nLSlot
);

90744 if( 
p
->
aLTerm
!=p->
aLTermSpace
 ) 
	`sqlite3DbFree
(
db
, p->aLTerm);

90745 
p
->
aLTerm
 = 
paNew
;

90746 
p
->
nLSlot
 = 
n
;

90748 
	}
}

90753 static int 
	$whereLoopXfer
(
sqlite3
 *
db
, 
WhereLoop
 *
pTo
, WhereLoop *
pFrom
)

90756 
	`whereLoopClearUnion
(
db
, 
pTo
);

90757 if( 
	`whereLoopResize
(
db
, 
pTo
, 
pFrom
->
nLTerm
) )

90760 
	`memset
(&
pTo
->
u
, 0, sizeof(pTo->u));

90763 
	`memcpy
(
pTo
, 
pFrom
, 
	`__builtin_offsetof
 (
WhereLoop
, 
nLSlot
));

90764 
	`memcpy
(
pTo
->
aLTerm
, 
pFrom
->aLTerm, pTo->
nLTerm
*sizeof(pTo->aLTerm[0]));

90765 if( 
pFrom
->
wsFlags
 & 0x00000400 )

90768 
pFrom
->
u
.
vtab
.
needFree
 = 0;

90769 }else if( (
pFrom
->
wsFlags
 & 0x00004000)!=0 )

90772 
pFrom
->
u
.
btree
.
pIndex
 = 0;

90775 
	}
}

90780 static void 
	$whereLoopDelete
(
sqlite3
 *
db
, 
WhereLoop
 *
p
)

90783 
	`whereLoopClear
(
db
, 
p
);

90784 
	`sqlite3DbFree
(
db
, 
p
);

90785 
	}
}

90790 static void 
	$whereInfoFree
(
sqlite3
 *
db
, 
WhereInfo
 *
pWInfo
)

90793 if( (
pWInfo
) )

90796 int 
i
;

90797 for(
i
=0; i<
pWInfo
->
nLevel
; i++)

90800 
WhereLevel
 *
pLevel
 = &
pWInfo
->
a
[
i
];

90801 if( 
pLevel
->
pWLoop
 && (pLevel->pWLoop->
wsFlags
 & 0x00000800) )

90804 
	`sqlite3DbFree
(
db
, 
pLevel
->
u
.
in
.
aInLoop
);

90807 
	`sqlite3WhereClauseClear
(&
pWInfo
->
sWC
);

90808 while( 
pWInfo
->
pLoops
 )

90811 
WhereLoop
 *
p
 = 
pWInfo
->
pLoops
;

90812 
pWInfo
->
pLoops
 = 
p
->
pNextLoop
;

90813 
	`whereLoopDelete
(
db
, 
p
);

90815 
	`sqlite3DbFree
(
db
, 
pWInfo
);

90817 
	}
}

90819 static int 
	$whereLoopCheaperProperSubset
(

90820 const 
WhereLoop
 *
pX
,

90821 const 
WhereLoop
 *
pY


90825 int 
i
, 
j
;

90826 if( 
pX
->
nLTerm
-pX->
nSkip
 >= 
pY
->nLTerm-pY->nSkip )

90831 if( 
pY
->
nSkip
 > 
pX
->nSkip ) return 0;

90832 if( 
pX
->
rRun
 >= 
pY
->rRun )

90835 if( 
pX
->
rRun
 > 
pY
->rRun ) return 0;

90836 if( 
pX
->
nOut
 > 
pY
->nOut ) return 0;

90838 for(
i
=
pX
->
nLTerm
-1; i>=0; i--)

90841 if( 
pX
->
aLTerm
[
i
]==0 ) continue;

90842 for(
j
=
pY
->
nLTerm
-1; j>=0; j--)

90845 if( 
pY
->
aLTerm
[
j
]==
pX
->aLTerm[
i
] ) break;

90847 if( 
j
<0 ) return 0;

90850 
	}
}

90852 static void 
	$whereLoopAdjustCost
(const 
WhereLoop
 *
p
, WhereLoop *
pTemplate
)

90855 if( (
pTemplate
->
wsFlags
 & 0x00000200)==0 ) return;

90856 for(; 
p
; p=p->
pNextLoop
)

90859 if( 
p
->
iTab
!=
pTemplate
->iTab ) continue;

90860 if( (
p
->
wsFlags
 & 0x00000200)==0 ) continue;

90861 if( 
	`whereLoopCheaperProperSubset
(
p
, 
pTemplate
) )

90868 
pTemplate
->
rRun
 = 
p
->rRun;

90869 
pTemplate
->
nOut
 = 
p
->nOut - 1;

90870 }else if( 
	`whereLoopCheaperProperSubset
(
pTemplate
, 
p
) )

90877 
pTemplate
->
rRun
 = 
p
->rRun;

90878 
pTemplate
->
nOut
 = 
p
->nOut + 1;

90881 
	}
}

90883 static 
WhereLoop
 **
	$whereLoopFindLesser
(

90884 
WhereLoop
 **
ppPrev
,

90885 const 
WhereLoop
 *
pTemplate


90889 
WhereLoop
 *
p
;

90890 for(
p
=(*
ppPrev
); p; ppPrev=&p->
pNextLoop
, p=*ppPrev)

90893 if( 
p
->
iTab
!=
pTemplate
->iTab || p->
iSortIdx
!=pTemplate->iSortIdx )

90915 if( (
p
->
wsFlags
 & 0x00004000)!=0

90916 && (
pTemplate
->
nSkip
)==0

90917 && (
pTemplate
->
wsFlags
 & 0x00000200)!=0

90918 && (
pTemplate
->
wsFlags
 & 0x00000001)!=0

90919 && (
p
->
prereq
 & 
pTemplate
->prereq)==pTemplate->prereq

90931 if( (
p
->
prereq
 & 
pTemplate
->prereq)==p->prereq

90932 && 
p
->
rSetup
<=
pTemplate
->rSetup

90933 && 
p
->
rRun
<=
pTemplate
->rRun

90934 && 
p
->
nOut
<=
pTemplate
->nOut

90946 if( (
p
->
prereq
 & 
pTemplate
->prereq)==pTemplate->prereq

90947 && 
p
->
rRun
>=
pTemplate
->rRun

90948 && 
p
->
nOut
>=
pTemplate
->nOut

90956 return 
ppPrev
;

90957 
	}
}

90959 static int 
	$whereLoopInsert
(
WhereLoopBuilder
 *
pBuilder
, 
WhereLoop
 *
pTemplate
)

90962 
WhereLoop
 **
ppPrev
, *
p
;

90963 
WhereInfo
 *
pWInfo
 = 
pBuilder
->pWInfo;

90964 
sqlite3
 *
db
 = 
pWInfo
->
pParse
->db;

90965 int 
rc
;

90970 if( 
pBuilder
->
pOrSet
!=0 )

90973 if( 
pTemplate
->
nLTerm
 )

90980 
	`whereOrInsert
(
pBuilder
->
pOrSet
, 
pTemplate
->
prereq
, pTemplate->
rRun
,

90981 
pTemplate
->
nOut
);

90994 
	`whereLoopAdjustCost
(
pWInfo
->
pLoops
, 
pTemplate
);

90995 
ppPrev
 = 
	`whereLoopFindLesser
(&
pWInfo
->
pLoops
, 
pTemplate
);

90997 if( 
ppPrev
==0 )

91003 
p
 = *
ppPrev
;

91006 if( 
p
==0 )

91010 *
ppPrev
 = 
p
 = 
	`sqlite3DbMallocRawNN
(
db
, sizeof(
WhereLoop
));

91011 if( 
p
==0 ) return 7;

91012 
	`whereLoopInit
(
p
);

91013 
p
->
pNextLoop
 = 0;

91018 
WhereLoop
 **
ppTail
 = &
p
->
pNextLoop
;

91019 
WhereLoop
 *
pToDel
;

91020 while( *
ppTail
 )

91023 
ppTail
 = 
	`whereLoopFindLesser
(ppTail, 
pTemplate
);

91024 if( 
ppTail
==0 ) break;

91025 
pToDel
 = *
ppTail
;

91026 if( 
pToDel
==0 ) break;

91027 *
ppTail
 = 
pToDel
->
pNextLoop
;

91034 
	`whereLoopDelete
(
db
, 
pToDel
);

91037 
rc
 = 
	`whereLoopXfer
(
db
, 
p
, 
pTemplate
);

91038 if( (
p
->
wsFlags
 & 0x00000400)==0 )

91041 
Index
 *
pIndex
 = 
p
->
u
.
btree
.pIndex;

91042 if( 
pIndex
 && pIndex->
tnum
==0 )

91045 
p
->
u
.
btree
.
pIndex
 = 0;

91048 return 
rc
;

91049 
	}
}

91051 static void 
	$whereLoopOutputAdjust
(

91052 
WhereClause
 *
pWC
,

91053 
WhereLoop
 *
pLoop
,

91054 
LogEst
 
nRow


91058 
WhereTerm
 *
pTerm
, *
pX
;

91059 
Bitmask
 
notAllowed
 = ~(
pLoop
->
prereq
|pLoop->
maskSelf
);

91060 int 
i
, 
j
, 
k
;

91061 
LogEst
 
iReduce
 = 0;

91064 for(
i
=
pWC
->
nTerm
, 
pTerm
=pWC->
a
; i>0; i--, pTerm++)

91067 if( (
pTerm
->
wtFlags
 & 0x02)!=0 ) break;

91068 if( (
pTerm
->
prereqAll
 & 
pLoop
->
maskSelf
)==0 ) continue;

91069 if( (
pTerm
->
prereqAll
 & 
notAllowed
)!=0 ) continue;

91070 for(
j
=
pLoop
->
nLTerm
-1; j>=0; j--)

91073 
pX
 = 
pLoop
->
aLTerm
[
j
];

91074 if( 
pX
==0 ) continue;

91075 if( 
pX
==
pTerm
 ) break;

91076 if( 
pX
->
iParent
>=0 && (&
pWC
->
a
[pX->iParent])==
pTerm
 ) break;

91078 if( 
j
<0 )

91081 if( 
pTerm
->
truthProb
<=0 )

91086 
pLoop
->
nOut
 += 
pTerm
->
truthProb
;

91090 
pLoop
->
nOut
--;

91091 if( 
pTerm
->
eOperator
&(0x0002|0x0080) )

91094 
Expr
 *
pRight
 = 
pTerm
->
pExpr
->pRight;

91096 if( 
	`sqlite3ExprIsInteger
(
pRight
, &
k
) && k>=(-1) && k<=1 )

91099 
k
 = 10;

91101 
k
 = 20;

91103 if( 
iReduce
<
k
 ) iReduce = k;

91108 if( 
pLoop
->
nOut
 > 
nRow
-
iReduce
 ) pLoop->nOut = nRow - iReduce;

91109 
	}
}

91111 static int 
	$whereLoopAddBtreeIndex
(

91112 
WhereLoopBuilder
 *
pBuilder
,

91113 struct 
SrcList_item
 *
pSrc
,

91114 
Index
 *
pProbe
,

91115 
LogEst
 
nInMul


91119 
WhereInfo
 *
pWInfo
 = 
pBuilder
->pWInfo;

91120 
Parse
 *
pParse
 = 
pWInfo
->pParse;

91121 
sqlite3
 *
db
 = 
pParse
->db;

91122 
WhereLoop
 *
pNew
;

91123 
WhereTerm
 *
pTerm
;

91124 int 
opMask
;

91125 
WhereScan
 
scan
;

91126 
Bitmask
 
saved_prereq
;

91127 
u16
 
saved_nLTerm
;

91128 
u16
 
saved_nEq
;

91129 
u16
 
saved_nSkip
;

91130 
u32
 
saved_wsFlags
;

91131 
LogEst
 
saved_nOut
;

91132 int 
rc
 = 0;

91133 
LogEst
 
rSize
;

91134 
LogEst
 
rLogSize
;

91135 
WhereTerm
 *
pTop
 = 0, *
pBtm
 = 0;

91137 
pNew
 = 
pBuilder
->pNew;

91138 if( 
db
->
mallocFailed
 ) return 7;

91142 if( 
pNew
->
wsFlags
 & 0x00000020 )

91145 
opMask
 = (0x0002<<(82 -79))|(0x0002<<(81 -79));

91146 }else if( (
pSrc
->
fg
.
jointype
 & 0x0008)!=0 )

91149 
opMask
 = 0x0002|0x0001|(0x0002<<(80 -79))|(0x0002<<(83 -79))|(0x0002<<(82 -79))|(0x0002<<(81 -79));

91151 
opMask
 = 0x0002|0x0001|(0x0002<<(80 -79))|(0x0002<<(83 -79))|(0x0002<<(82 -79))|(0x0002<<(81 -79))|0x0100|0x0080;

91153 if( 
pProbe
->
bUnordered
 ) 
opMask
 &= ~((0x0002<<(80 -79))|(0x0002<<(83 -79))|(0x0002<<(82 -79))|(0x0002<<(81 -79)));

91157 
saved_nEq
 = 
pNew
->
u
.
btree
.
nEq
;

91158 
saved_nSkip
 = 
pNew
->
nSkip
;

91159 
saved_nLTerm
 = 
pNew
->
nLTerm
;

91160 
saved_wsFlags
 = 
pNew
->
wsFlags
;

91161 
saved_prereq
 = 
pNew
->
prereq
;

91162 
saved_nOut
 = 
pNew
->
nOut
;

91163 
pTerm
 = 
	`whereScanInit
(&
scan
, 
pBuilder
->
pWC
, 
pSrc
->
iCursor
, 
saved_nEq
,

91164 
opMask
, 
pProbe
);

91165 
pNew
->
rSetup
 = 0;

91166 
rSize
 = 
pProbe
->
aiRowLogEst
[0];

91167 
rLogSize
 = 
	`estLog
(
rSize
);

91168 for(; 
rc
==0 && 
pTerm
!=0; pTerm = 
	`whereScanNext
(&
scan
))

91171 
u16
 
eOp
 = 
pTerm
->
eOperator
;

91172 
LogEst
 
rCostIdx
;

91173 
LogEst
 
nOutUnadjusted
;

91174 int 
nIn
 = 0;

91178 if( (
eOp
==0x0100 || (
pTerm
->
wtFlags
&0x00)!=0)

91179 && 
	`indexColumnNotNull
(
pProbe
, 
saved_nEq
)

91185 if( 
pTerm
->
prereqRight
 & 
pNew
->
maskSelf
 ) continue;

91189 if( 
pTerm
->
wtFlags
 & 0x100 && pTerm->
eOperator
==(0x0002<<(82 -79)) ) continue;

91191 
pNew
->
wsFlags
 = 
saved_wsFlags
;

91192 
pNew
->
u
.
btree
.
nEq
 = 
saved_nEq
;

91193 
pNew
->
nLTerm
 = 
saved_nLTerm
;

91194 if( 
	`whereLoopResize
(
db
, 
pNew
, pNew->
nLTerm
+1) ) break;

91195 
pNew
->
aLTerm
[pNew->
nLTerm
++] = 
pTerm
;

91196 
pNew
->
prereq
 = (
saved_prereq
 | 
pTerm
->
prereqRight
) & ~pNew->
maskSelf
;

91204 if( 
eOp
 & 0x0001 )

91207 
Expr
 *
pExpr
 = 
pTerm
->pExpr;

91208 
pNew
->
wsFlags
 |= 0x00000004;

91209 if( (((
pExpr
)->
flags
&(0x000800))!=0) )

91213 
nIn
 = 46; ((void) (0));

91214 }else if( (
pExpr
->
x
.
pList
 && pExpr->x.pList->
nExpr
) )

91218 
nIn
 = 
	`sqlite3LogEst
(
pExpr
->
x
.
pList
->
nExpr
);

91223 }else if( 
eOp
 & (0x0002|0x0080) )

91226 int 
iCol
 = 
pProbe
->
aiColumn
[
saved_nEq
];

91227 
pNew
->
wsFlags
 |= 0x00000001;

91229 if( 
iCol
==(-1)

91230 || (
iCol
>0 && 
nInMul
==0 && 
saved_nEq
==
pProbe
->
nKeyCol
-1)

91234 if( 
iCol
>=0 && 
pProbe
->
uniqNotNull
==0 )

91237 
pNew
->
wsFlags
 |= 0x00010000;

91239 
pNew
->
wsFlags
 |= 0x00001000;

91242 }else if( 
eOp
 & 0x0100 )

91245 
pNew
->
wsFlags
 |= 0x00000008;

91246 }else if( 
eOp
 & ((0x0002<<(80 -79))|(0x0002<<(83 -79))) )

91251 
pNew
->
wsFlags
 |= 0x00000002|0x00000020;

91252 
pBtm
 = 
pTerm
;

91253 
pTop
 = 0;

91254 if( 
pTerm
->
wtFlags
 & 0x100 )

91259 
pTop
 = &
pTerm
[1];

91263 if( 
	`whereLoopResize
(
db
, 
pNew
, pNew->
nLTerm
+1) ) break;

91264 
pNew
->
aLTerm
[pNew->
nLTerm
++] = 
pTop
;

91265 
pNew
->
wsFlags
 |= 0x00000010;

91271 
pNew
->
wsFlags
 |= 0x00000002|0x00000010;

91272 
pTop
 = 
pTerm
;

91273 
pBtm
 = (
pNew
->
wsFlags
 & 0x00000020)!=0 ?

91274 
pNew
->
aLTerm
[pNew->
nLTerm
-2] : 0;

91283 if( 
pNew
->
wsFlags
 & 0x00000002 )

91288 
	`whereRangeScanEst
(
pParse
, 
pBuilder
, 
pBtm
, 
pTop
, 
pNew
);

91290 int 
nEq
 = ++
pNew
->
u
.
btree
.nEq;

91294 if( 
pTerm
->
truthProb
<=0 && 
pProbe
->
aiColumn
[
saved_nEq
]>=0 )

91299 
pNew
->
nOut
 += 
pTerm
->
truthProb
;

91300 
pNew
->
nOut
 -= 
nIn
;

91304 
pNew
->
nOut
 += (
pProbe
->
aiRowLogEst
[
nEq
] - pProbe->aiRowLogEst[nEq-1]);

91305 if( 
eOp
 & 0x0100 )

91311 
pNew
->
nOut
 += 10;

91321 
rCostIdx
 = 
pNew
->
nOut
 + 1 + (15*
pProbe
->
szIdxRow
)/
pSrc
->
pTab
->
szTabRow
;

91322 
pNew
->
rRun
 = 
	`sqlite3LogEstAdd
(
rLogSize
, 
rCostIdx
);

91323 if( (
pNew
->
wsFlags
 & (0x00000040|0x00000100))==0 )

91326 
pNew
->
rRun
 = 
	`sqlite3LogEstAdd
(pNew->rRun, pNew->
nOut
 + 16);

91330 
nOutUnadjusted
 = 
pNew
->
nOut
;

91331 
pNew
->
rRun
 += 
nInMul
 + 
nIn
;

91332 
pNew
->
nOut
 += 
nInMul
 + 
nIn
;

91333 
	`whereLoopOutputAdjust
(
pBuilder
->
pWC
, 
pNew
, 
rSize
);

91334 
rc
 = 
	`whereLoopInsert
(
pBuilder
, 
pNew
);

91336 if( 
pNew
->
wsFlags
 & 0x00000002 )

91339 
pNew
->
nOut
 = 
saved_nOut
;

91341 
pNew
->
nOut
 = 
nOutUnadjusted
;

91344 if( (
pNew
->
wsFlags
 & 0x00000010)==0

91345 && 
pNew
->
u
.
btree
.
nEq
<
pProbe
->
nColumn


91349 
	`whereLoopAddBtreeIndex
(
pBuilder
, 
pSrc
, 
pProbe
, 
nInMul
+
nIn
);

91351 
pNew
->
nOut
 = 
saved_nOut
;

91356 
pNew
->
prereq
 = 
saved_prereq
;

91357 
pNew
->
u
.
btree
.
nEq
 = 
saved_nEq
;

91358 
pNew
->
nSkip
 = 
saved_nSkip
;

91359 
pNew
->
wsFlags
 = 
saved_wsFlags
;

91360 
pNew
->
nOut
 = 
saved_nOut
;

91361 
pNew
->
nLTerm
 = 
saved_nLTerm
;

91364 if( 
saved_nEq
==
saved_nSkip


91365 && 
saved_nEq
+1<
pProbe
->
nKeyCol


91366 && 
pProbe
->
noSkipScan
==0

91367 && 
pProbe
->
aiRowLogEst
[
saved_nEq
+1]>=42

91368 && (
rc
 = 
	`whereLoopResize
(
db
, 
pNew
, pNew->
nLTerm
+1))==0

91372 
LogEst
 
nIter
;

91373 
pNew
->
u
.
btree
.
nEq
++;

91374 
pNew
->
nSkip
++;

91375 
pNew
->
aLTerm
[pNew->
nLTerm
++] = 0;

91376 
pNew
->
wsFlags
 |= 0x00008000;

91377 
nIter
 = 
pProbe
->
aiRowLogEst
[
saved_nEq
] - pProbe->aiRowLogEst[saved_nEq+1];

91378 
pNew
->
nOut
 -= 
nIter
;

91381 
nIter
 += 5;

91382 
	`whereLoopAddBtreeIndex
(
pBuilder
, 
pSrc
, 
pProbe
, 
nIter
 + 
nInMul
);

91383 
pNew
->
nOut
 = 
saved_nOut
;

91384 
pNew
->
u
.
btree
.
nEq
 = 
saved_nEq
;

91385 
pNew
->
nSkip
 = 
saved_nSkip
;

91386 
pNew
->
wsFlags
 = 
saved_wsFlags
;

91389 return 
rc
;

91390 
	}
}

91392 static int 
	$indexMightHelpWithOrderBy
(

91393 
WhereLoopBuilder
 *
pBuilder
,

91394 
Index
 *
pIndex
,

91395 int 
iCursor


91399 
ExprList
 *
pOB
;

91400 
ExprList
 *
aColExpr
;

91401 int 
ii
, 
jj
;

91403 if( 
pIndex
->
bUnordered
 ) return 0;

91404 if( (
pOB
 = 
pBuilder
->
pWInfo
->
pOrderBy
)==0 ) return 0;

91405 for(
ii
=0; ii<
pOB
->
nExpr
; ii++)

91408 
Expr
 *
pExpr
 = 
	`sqlite3ExprSkipCollate
(
pOB
->
a
[
ii
].pExpr);

91409 if( 
pExpr
->
op
==152 && pExpr->
iTable
==
iCursor
 )

91412 if( 
pExpr
->
iColumn
<0 ) return 1;

91413 for(
jj
=0; jj<
pIndex
->
nKeyCol
; jj++)

91416 if( 
pExpr
->
iColumn
==
pIndex
->
aiColumn
[
jj
] ) return 1;

91418 }else if( (
aColExpr
 = 
pIndex
->aColExpr)!=0 )

91421 for(
jj
=0; jj<
pIndex
->
nKeyCol
; jj++)

91424 if( 
pIndex
->
aiColumn
[
jj
]!=(-2) ) continue;

91425 if( 
	`sqlite3ExprCompare
(
pExpr
,
aColExpr
->
a
[
jj
].pExpr,
iCursor
)==0 )

91434 
	}
}

91440 static 
Bitmask
 
	$columnsInIndex
(
Index
 *
pIdx
)

91443 
Bitmask
 
m
 = 0;

91444 int 
j
;

91445 for(
j
=
pIdx
->
nColumn
-1; j>=0; j--)

91448 int 
x
 = 
pIdx
->
aiColumn
[
j
];

91449 if( 
x
>=0 )

91454 if( 
x
<((int)(sizeof(
Bitmask
)*8))-1 ) 
m
 |= (((Bitmask)1)<<(x));

91457 return 
m
;

91458 
	}
}

91463 static int 
	$whereUsablePartialIndex
(int 
iTab
, 
WhereClause
 *
pWC
, 
Expr
 *
pWhere
)

91466 int 
i
;

91467 
WhereTerm
 *
pTerm
;

91468 while( 
pWhere
->
op
==72 )

91471 if( !
	`whereUsablePartialIndex
(
iTab
,
pWC
,
pWhere
->
pLeft
) ) return 0;

91472 
pWhere
 = pWhere->
pRight
;

91474 for(
i
=0, 
pTerm
=
pWC
->
a
; i<pWC->
nTerm
; i++, pTerm++)

91477 
Expr
 *
pExpr
 = 
pTerm
->pExpr;

91478 if( 
	`sqlite3ExprImpliesExpr
(
pExpr
, 
pWhere
, 
iTab
)

91479 && (!(((
pExpr
)->
flags
&(0x000001))!=0) || pExpr->
iRightJoinTable
==
iTab
)

91487 
	}
}

91489 static int 
	$whereLoopAddBtree
(

91490 
WhereLoopBuilder
 *
pBuilder
,

91491 
Bitmask
 
mPrereq


91495 
WhereInfo
 *
pWInfo
;

91496 
Index
 *
pProbe
;

91497 
Index
 
sPk
;

91498 
LogEst
 
aiRowEstPk
[2];

91499 
i16
 
aiColumnPk
 = -1;

91500 
SrcList
 *
pTabList
;

91501 struct 
SrcList_item
 *
pSrc
;

91502 
WhereLoop
 *
pNew
;

91503 int 
rc
 = 0;

91504 int 
iSortIdx
 = 1;

91505 int 
b
;

91506 
LogEst
 
rSize
;

91507 
LogEst
 
rLogSize
;

91508 
WhereClause
 *
pWC
;

91509 
Table
 *
pTab
;

91511 
pNew
 = 
pBuilder
->pNew;

91512 
pWInfo
 = 
pBuilder
->pWInfo;

91513 
pTabList
 = 
pWInfo
->pTabList;

91514 
pSrc
 = 
pTabList
->
a
 + 
pNew
->
iTab
;

91515 
pTab
 = 
pSrc
->pTab;

91516 
pWC
 = 
pBuilder
->pWC;

91519 if( 
pSrc
->
pIBIndex
 )

91523 
pProbe
 = 
pSrc
->
pIBIndex
;

91524 }else if( !(((
pTab
)->
tabFlags
 & 0x20)==0) )

91527 
pProbe
 = 
pTab
->
pIndex
;

91533 
Index
 *
pFirst
;

91534 
	`memset
(&
sPk
, 0, sizeof(
Index
));

91535 
sPk
.
nKeyCol
 = 1;

91536 
sPk
.
nColumn
 = 1;

91537 
sPk
.
aiColumn
 = &
aiColumnPk
;

91538 
sPk
.
aiRowLogEst
 = 
aiRowEstPk
;

91539 
sPk
.
onError
 = 5;

91540 
sPk
.
pTable
 = 
pTab
;

91541 
sPk
.
szIdxRow
 = 
pTab
->
szTabRow
;

91542 
aiRowEstPk
[0] = 
pTab
->
nRowLogEst
;

91543 
aiRowEstPk
[1] = 0;

91544 
pFirst
 = 
pSrc
->
pTab
->
pIndex
;

91545 if( 
pSrc
->
fg
.
notIndexed
==0 )

91550 
sPk
.
pNext
 = 
pFirst
;

91552 
pProbe
 = &
sPk
;

91554 
rSize
 = 
pTab
->
nRowLogEst
;

91555 
rLogSize
 = 
	`estLog
(
rSize
);

91559 if( !
pBuilder
->
pOrSet


91560 && (
pWInfo
->
wctrlFlags
 & 0x0080)==0

91561 && (
pWInfo
->
pParse
->
db
->
flags
 & 0x00100000)!=0

91562 && 
pSrc
->
pIBIndex
==0

91563 && !
pSrc
->
fg
.
notIndexed


91564 && (((
pTab
)->
tabFlags
 & 0x20)==0)

91565 && !
pSrc
->
fg
.
isCorrelated


91566 && !
pSrc
->
fg
.
isRecursive


91571 
WhereTerm
 *
pTerm
;

91572 
WhereTerm
 *
pWCEnd
 = 
pWC
->
a
 + pWC->
nTerm
;

91573 for(
pTerm
=
pWC
->
a
; 
rc
==0 && pTerm<
pWCEnd
; pTerm++)

91576 if( 
pTerm
->
prereqRight
 & 
pNew
->
maskSelf
 ) continue;

91577 if( 
	`termCanDriveIndex
(
pTerm
, 
pSrc
, 0) )

91580 
pNew
->
u
.
btree
.
nEq
 = 1;

91581 
pNew
->
nSkip
 = 0;

91582 
pNew
->
u
.
btree
.
pIndex
 = 0;

91583 
pNew
->
nLTerm
 = 1;

91584 
pNew
->
aLTerm
[0] = 
pTerm
;

91586 
pNew
->
rSetup
 = 
rLogSize
 + 
rSize
 + 4;

91587 if( 
pTab
->
pSelect
==0 && (pTab->
tabFlags
 & 0x02)==0 )

91590 
pNew
->
rSetup
 += 24;

91597 
pNew
->
nOut
 = 43; ((void) (0));

91598 
pNew
->
rRun
 = 
	`sqlite3LogEstAdd
(
rLogSize
,pNew->
nOut
);

91599 
pNew
->
wsFlags
 = 0x00004000;

91600 
pNew
->
prereq
 = 
mPrereq
 | 
pTerm
->
prereqRight
;

91601 
rc
 = 
	`whereLoopInsert
(
pBuilder
, 
pNew
);

91609 for(; 
rc
==0 && 
pProbe
; pProbe=pProbe->
pNext
, 
iSortIdx
++)

91612 if( 
pProbe
->
pPartIdxWhere
!=0

91613 && !
	`whereUsablePartialIndex
(
pSrc
->
iCursor
, 
pWC
, 
pProbe
->
pPartIdxWhere
) )

91619 
rSize
 = 
pProbe
->
aiRowLogEst
[0];

91620 
pNew
->
u
.
btree
.
nEq
 = 0;

91621 
pNew
->
nSkip
 = 0;

91622 
pNew
->
nLTerm
 = 0;

91623 
pNew
->
iSortIdx
 = 0;

91624 
pNew
->
rSetup
 = 0;

91625 
pNew
->
prereq
 = 
mPrereq
;

91626 
pNew
->
nOut
 = 
rSize
;

91627 
pNew
->
u
.
btree
.
pIndex
 = 
pProbe
;

91628 
b
 = 
	`indexMightHelpWithOrderBy
(
pBuilder
, 
pProbe
, 
pSrc
->
iCursor
);

91631 if( 
pProbe
->
tnum
<=0 )

91635 
pNew
->
wsFlags
 = 0x00000100;

91638 
pNew
->
iSortIdx
 = 
b
 ? iSortIdx : 0;

91640 
pNew
->
rRun
 = 
rSize
 + 16;

91642 
	`whereLoopOutputAdjust
(
pWC
, 
pNew
, 
rSize
);

91643 
rc
 = 
	`whereLoopInsert
(
pBuilder
, 
pNew
);

91644 
pNew
->
nOut
 = 
rSize
;

91645 if( 
rc
 ) break;

91647 
Bitmask
 
m
;

91648 if( 
pProbe
->
isCovering
 )

91651 
pNew
->
wsFlags
 = 0x00000040 | 0x00000200;

91652 
m
 = 0;

91654 
m
 = 
pSrc
->
colUsed
 & ~
	`columnsInIndex
(
pProbe
);

91655 
pNew
->
wsFlags
 = (
m
==0) ? (0x00000040|0x00000200) : 0x00000200;

91659 if( 
b


91660 || !(((
pTab
)->
tabFlags
 & 0x20)==0)

91661 || ( 
m
==0

91662 && 
pProbe
->
bUnordered
==0

91663 && (
pProbe
->
szIdxRow
<
pTab
->
szTabRow
)

91664 && (
pWInfo
->
wctrlFlags
 & 0x0004)==0

91665 && 
sqlite3Config
.
bUseCis


91666 && (((
pWInfo
->
pParse
->
db
)->
dbOptFlags
&(0x0040))==0)

91671 
pNew
->
iSortIdx
 = 
b
 ? iSortIdx : 0;

91677 
pNew
->
rRun
 = 
rSize
 + 1 + (15*
pProbe
->
szIdxRow
)/
pTab
->
szTabRow
;

91678 if( 
m
!=0 )

91681 
pNew
->
rRun
 = 
	`sqlite3LogEstAdd
(pNew->rRun, 
rSize
+16);

91684 
	`whereLoopOutputAdjust
(
pWC
, 
pNew
, 
rSize
);

91685 
rc
 = 
	`whereLoopInsert
(
pBuilder
, 
pNew
);

91686 
pNew
->
nOut
 = 
rSize
;

91687 if( 
rc
 ) break;

91691 
rc
 = 
	`whereLoopAddBtreeIndex
(
pBuilder
, 
pSrc
, 
pProbe
, 0);

91693 if( 
pSrc
->
pIBIndex
 ) break;

91695 return 
rc
;

91696 
	}
}

91698 static int 
	$whereLoopAddVirtualOne
(

91699 
WhereLoopBuilder
 *
pBuilder
,

91700 
Bitmask
 
mPrereq
,

91701 
Bitmask
 
mUsable
,

91702 
u16
 
mExclude
,

91703 
sqlite3_index_info
 *
pIdxInfo
,

91704 int *
pbIn


91708 
WhereClause
 *
pWC
 = 
pBuilder
->pWC;

91709 struct 
sqlite3_index_constraint
 *
pIdxCons
;

91710 struct 
sqlite3_index_constraint_usage
 *
pUsage
 = 
pIdxInfo
->
aConstraintUsage
;

91711 int 
i
;

91712 int 
mxTerm
;

91713 int 
rc
 = 0;

91714 
WhereLoop
 *
pNew
 = 
pBuilder
->pNew;

91715 
Parse
 *
pParse
 = 
pBuilder
->
pWInfo
->pParse;

91716 struct 
SrcList_item
 *
pSrc
 = &
pBuilder
->
pWInfo
->
pTabList
->
a
[
pNew
->
iTab
];

91717 int 
nConstraint
 = 
pIdxInfo
->nConstraint;

91720 *
pbIn
 = 0;

91721 
pNew
->
prereq
 = 
mPrereq
;

91725 
pIdxCons
 = *(struct 
sqlite3_index_constraint
**)&
pIdxInfo
->
aConstraint
;

91726 for(
i
=0; i<
nConstraint
; i++, 
pIdxCons
++)

91729 
WhereTerm
 *
pTerm
 = &
pWC
->
a
[
pIdxCons
->
iTermOffset
];

91730 
pIdxCons
->
usable
 = 0;

91731 if( (
pTerm
->
prereqRight
 & 
mUsable
)==pTerm->prereqRight

91732 && (
pTerm
->
eOperator
 & 
mExclude
)==0

91736 
pIdxCons
->
usable
 = 1;

91741 
	`memset
(
pUsage
, 0, sizeof(pUsage[0])*
nConstraint
);

91743 
pIdxInfo
->
idxStr
 = 0;

91744 
pIdxInfo
->
idxNum
 = 0;

91745 
pIdxInfo
->
orderByConsumed
 = 0;

91746 
pIdxInfo
->
estimatedCost
 = (1e99) / (double)2;

91747 
pIdxInfo
->
estimatedRows
 = 25;

91748 
pIdxInfo
->
idxFlags
 = 0;

91749 
pIdxInfo
->
colUsed
 = (
sqlite3_int64
)
pSrc
->colUsed;

91752 
rc
 = 
	`vtabBestIndex
(
pParse
, 
pSrc
->
pTab
, 
pIdxInfo
);

91753 if( 
rc
 ) return rc;

91755 
mxTerm
 = -1;

91757 for(
i
=0; i<
nConstraint
; i++) 
pNew
->
aLTerm
[i] = 0;

91758 
pNew
->
u
.
vtab
.
omitMask
 = 0;

91759 
pIdxCons
 = *(struct 
sqlite3_index_constraint
**)&
pIdxInfo
->
aConstraint
;

91760 for(
i
=0; i<
nConstraint
; i++, 
pIdxCons
++)

91763 int 
iTerm
;

91764 if( (
iTerm
 = 
pUsage
[
i
].
argvIndex
 - 1)>=0 )

91767 
WhereTerm
 *
pTerm
;

91768 int 
j
 = 
pIdxCons
->
iTermOffset
;

91769 if( 
iTerm
>=
nConstraint


91770 || 
j
<0

91771 || 
j
>=
pWC
->
nTerm


91772 || 
pNew
->
aLTerm
[
iTerm
]!=0

91773 || 
pIdxCons
->
usable
==0

91777 
rc
 = 1;

91778 
	`sqlite3ErrorMsg
(
pParse
,"%s.xBestIndex malfunction",
pSrc
->
pTab
->
zName
);

91779 return 
rc
;

91784 
pTerm
 = &
pWC
->
a
[
j
];

91785 
pNew
->
prereq
 |= 
pTerm
->
prereqRight
;

91787 
pNew
->
aLTerm
[
iTerm
] = 
pTerm
;

91788 if( 
iTerm
>
mxTerm
 ) mxTerm = iTerm;

91791 if( 
iTerm
<16 && 
pUsage
[
i
].
omit
 ) 
pNew
->
u
.
vtab
.
omitMask
 |= 1<<iTerm;

91792 if( (
pTerm
->
eOperator
 & 0x0001)!=0 )

91800 
pIdxInfo
->
orderByConsumed
 = 0;

91801 
pIdxInfo
->
idxFlags
 &= ~1;

91802 *
pbIn
 = 1; ((void) (0));

91807 
pNew
->
nLTerm
 = 
mxTerm
+1;

91809 
pNew
->
u
.
vtab
.
idxNum
 = 
pIdxInfo
->idxNum;

91810 
pNew
->
u
.
vtab
.
needFree
 = 
pIdxInfo
->
needToFreeIdxStr
;

91811 
pIdxInfo
->
needToFreeIdxStr
 = 0;

91812 
pNew
->
u
.
vtab
.
idxStr
 = 
pIdxInfo
->idxStr;

91813 
pNew
->
u
.
vtab
.
isOrdered
 = (
i8
)(
pIdxInfo
->
orderByConsumed
 ?

91814 
pIdxInfo
->
nOrderBy
 : 0);

91815 
pNew
->
rSetup
 = 0;

91816 
pNew
->
rRun
 = 
	`sqlite3LogEstFromDouble
(
pIdxInfo
->
estimatedCost
);

91817 
pNew
->
nOut
 = 
	`sqlite3LogEst
(
pIdxInfo
->
estimatedRows
);

91821 if( 
pIdxInfo
->
idxFlags
 & 1 )

91824 
pNew
->
wsFlags
 |= 0x00001000;

91826 
pNew
->
wsFlags
 &= ~0x00001000;

91828 
rc
 = 
	`whereLoopInsert
(
pBuilder
, 
pNew
);

91829 if( 
pNew
->
u
.
vtab
.
needFree
 )

91832 
	`sqlite3_free
(
pNew
->
u
.
vtab
.
idxStr
);

91833 
pNew
->
u
.
vtab
.
needFree
 = 0;

91839 return 
rc
;

91840 
	}
}

91842 static int 
	$whereLoopAddVirtual
(

91843 
WhereLoopBuilder
 *
pBuilder
,

91844 
Bitmask
 
mPrereq
,

91845 
Bitmask
 
mUnusable


91849 int 
rc
 = 0;

91850 
WhereInfo
 *
pWInfo
;

91851 
Parse
 *
pParse
;

91852 
WhereClause
 *
pWC
;

91853 struct 
SrcList_item
 *
pSrc
;

91854 
sqlite3_index_info
 *
p
;

91855 int 
nConstraint
;

91856 int 
bIn
;

91857 
WhereLoop
 *
pNew
;

91858 
Bitmask
 
mBest
;

91861 
pWInfo
 = 
pBuilder
->pWInfo;

91862 
pParse
 = 
pWInfo
->pParse;

91863 
pWC
 = 
pBuilder
->pWC;

91864 
pNew
 = 
pBuilder
->pNew;

91865 
pSrc
 = &
pWInfo
->
pTabList
->
a
[
pNew
->
iTab
];

91867 
p
 = 
	`allocateIndexInfo
(
pParse
, 
pWC
, 
mUnusable
, 
pSrc
, 
pBuilder
->
pOrderBy
);

91868 if( 
p
==0 ) return 7;

91869 
pNew
->
rSetup
 = 0;

91870 
pNew
->
wsFlags
 = 0x00000400;

91871 
pNew
->
nLTerm
 = 0;

91872 
pNew
->
u
.
vtab
.
needFree
 = 0;

91873 
nConstraint
 = 
p
->nConstraint;

91874 if( 
	`whereLoopResize
(
pParse
->
db
, 
pNew
, 
nConstraint
) )

91877 
	`sqlite3DbFree
(
pParse
->
db
, 
p
);

91883 
rc
 = 
	`whereLoopAddVirtualOne
(
pBuilder
, 
mPrereq
, ((
Bitmask
)-1), 0, 
p
, &
bIn
);

91890 if( 
rc
==0 && (
mBest
 = (
pNew
->
prereq
 & ~
mPrereq
))!=0 )

91893 int 
seenZero
 = 0;

91894 int 
seenZeroNoIN
 = 0;

91895 
Bitmask
 
mPrev
 = 0;

91896 
Bitmask
 
mBestNoIn
 = 0;

91900 if( 
bIn
 )

91904 
rc
 = 
	`whereLoopAddVirtualOne
(
pBuilder
, 
mPrereq
, ((
Bitmask
)-1), 0x0001, 
p
, &
bIn
);

91906 
mBestNoIn
 = 
pNew
->
prereq
 & ~
mPrereq
;

91907 if( 
mBestNoIn
==0 )

91910 
seenZero
 = 1;

91911 
seenZeroNoIN
 = 1;

91917 while( 
rc
==0 )

91920 int 
i
;

91921 
Bitmask
 
mNext
 = ((Bitmask)-1);

91923 for(
i
=0; i<
nConstraint
; i++)

91926 
Bitmask
 
mThis
 = (

91927 
pWC
->
a
[
p
->
aConstraint
[
i
].
iTermOffset
].
prereqRight
 & ~
mPrereq


91929 if( 
mThis
>
mPrev
 && mThis<
mNext
 ) mNext = mThis;

91931 
mPrev
 = 
mNext
;

91932 if( 
mNext
==((
Bitmask
)-1) ) break;

91933 if( 
mNext
==
mBest
 || mNext==
mBestNoIn
 ) continue;

91936 
rc
 = 
	`whereLoopAddVirtualOne
(
pBuilder
, 
mPrereq
, 
mNext
|mPrereq, 0, 
p
, &
bIn
);

91937 if( 
pNew
->
prereq
==
mPrereq
 )

91940 
seenZero
 = 1;

91941 if( 
bIn
==0 ) 
seenZeroNoIN
 = 1;

91948 if( 
rc
==0 && 
seenZero
==0 )

91952 
rc
 = 
	`whereLoopAddVirtualOne
(
pBuilder
, 
mPrereq
, mPrereq, 0, 
p
, &
bIn
);

91953 if( 
bIn
==0 ) 
seenZeroNoIN
 = 1;

91959 if( 
rc
==0 && 
seenZeroNoIN
==0 )

91963 
rc
 = 
	`whereLoopAddVirtualOne
(
pBuilder
, 
mPrereq
, mPrereq, 0x0001, 
p
, &
bIn
);

91967 if( 
p
->
needToFreeIdxStr
 ) 
	`sqlite3_free
(p->
idxStr
);

91968 
	`sqlite3DbFree
(
pParse
->
db
, 
p
);

91969 return 
rc
;

91970 
	}
}

91977 static int 
	$whereLoopAddOr
(

91978 
WhereLoopBuilder
 *
pBuilder
,

91979 
Bitmask
 
mPrereq
,

91980 
Bitmask
 
mUnusable


91984 
WhereInfo
 *
pWInfo
 = 
pBuilder
->pWInfo;

91985 
WhereClause
 *
pWC
;

91986 
WhereLoop
 *
pNew
;

91987 
WhereTerm
 *
pTerm
, *
pWCEnd
;

91988 int 
rc
 = 0;

91989 int 
iCur
;

91990 
WhereClause
 
tempWC
;

91991 
WhereLoopBuilder
 
sSubBuild
;

91992 
WhereOrSet
 
sSum
, 
sCur
;

91993 struct 
SrcList_item
 *
pItem
;

91995 
pWC
 = 
pBuilder
->pWC;

91996 
pWCEnd
 = 
pWC
->
a
 + pWC->
nTerm
;

91997 
pNew
 = 
pBuilder
->pNew;

91998 
	`memset
(&
sSum
, 0, sizeof(sSum));

91999 
pItem
 = 
pWInfo
->
pTabList
->
a
 + 
pNew
->
iTab
;

92000 
iCur
 = 
pItem
->
iCursor
;

92002 for(
pTerm
=
pWC
->
a
; pTerm<
pWCEnd
 && 
rc
==0; pTerm++)

92005 if( (
pTerm
->
eOperator
 & 0x0200)!=0

92006 && (
pTerm
->
u
.
pOrInfo
->
indexable
 & 
pNew
->
maskSelf
)!=0

92010 
WhereClause
 * const 
pOrWC
 = &
pTerm
->
u
.
pOrInfo
->
wc
;

92011 
WhereTerm
 * const 
pOrWCEnd
 = &
pOrWC
->
a
[pOrWC->
nTerm
];

92012 
WhereTerm
 *
pOrTerm
;

92013 int 
once
 = 1;

92014 int 
i
, 
j
;

92016 
sSubBuild
 = *
pBuilder
;

92017 
sSubBuild
.
pOrderBy
 = 0;

92018 
sSubBuild
.
pOrSet
 = &
sCur
;

92021 for(
pOrTerm
=
pOrWC
->
a
; pOrTerm<
pOrWCEnd
; pOrTerm++)

92024 if( (
pOrTerm
->
eOperator
 & 0x0400)!=0 )

92027 
sSubBuild
.
pWC
 = &
pOrTerm
->
u
.
pAndInfo
->
wc
;

92028 }else if( 
pOrTerm
->
leftCursor
==
iCur
 )

92031 
tempWC
.
pWInfo
 = 
pWC
->pWInfo;

92032 
tempWC
.
pOuter
 = 
pWC
;

92033 
tempWC
.
op
 = 72;

92034 
tempWC
.
nTerm
 = 1;

92035 
tempWC
.
a
 = 
pOrTerm
;

92036 
sSubBuild
.
pWC
 = &
tempWC
;

92040 
sCur
.
n
 = 0;

92042 if( (((
pItem
->
pTab
)->
tabFlags
 & 0x10)!=0) )

92045 
rc
 = 
	`whereLoopAddVirtual
(&
sSubBuild
, 
mPrereq
, 
mUnusable
);

92049 
rc
 = 
	`whereLoopAddBtree
(&
sSubBuild
, 
mPrereq
);

92051 if( 
rc
==0 )

92054 
rc
 = 
	`whereLoopAddOr
(&
sSubBuild
, 
mPrereq
, 
mUnusable
);

92057 if( 
sCur
.
n
==0 )

92060 
sSum
.
n
 = 0;

92062 }else if( 
once
 )

92065 
	`whereOrMove
(&
sSum
, &
sCur
);

92066 
once
 = 0;

92068 
WhereOrSet
 
sPrev
;

92069 
	`whereOrMove
(&
sPrev
, &
sSum
);

92070 
sSum
.
n
 = 0;

92071 for(
i
=0; i<
sPrev
.
n
; i++)

92074 for(
j
=0; j<
sCur
.
n
; j++)

92077 
	`whereOrInsert
(&
sSum
, 
sPrev
.
a
[
i
].
prereq
 | 
sCur
.a[
j
].prereq,

92078 
	`sqlite3LogEstAdd
(
sPrev
.
a
[
i
].
rRun
, 
sCur
.a[
j
].rRun),

92079 
	`sqlite3LogEstAdd
(
sPrev
.
a
[
i
].
nOut
, 
sCur
.a[
j
].nOut));

92084 
pNew
->
nLTerm
 = 1;

92085 
pNew
->
aLTerm
[0] = 
pTerm
;

92086 
pNew
->
wsFlags
 = 0x00002000;

92087 
pNew
->
rSetup
 = 0;

92088 
pNew
->
iSortIdx
 = 0;

92089 
	`memset
(&
pNew
->
u
, 0, sizeof(pNew->u));

92090 for(
i
=0; 
rc
==0 && i<
sSum
.
n
; i++)

92094 
pNew
->
rRun
 = 
sSum
.
a
[
i
].rRun + 1;

92095 
pNew
->
nOut
 = 
sSum
.
a
[
i
].nOut;

92096 
pNew
->
prereq
 = 
sSum
.
a
[
i
].prereq;

92097 
rc
 = 
	`whereLoopInsert
(
pBuilder
, 
pNew
);

92102 return 
rc
;

92103 
	}
}

92108 static int 
	$whereLoopAddAll
(
WhereLoopBuilder
 *
pBuilder
)

92111 
WhereInfo
 *
pWInfo
 = 
pBuilder
->pWInfo;

92112 
Bitmask
 
mPrereq
 = 0;

92113 
Bitmask
 
mPrior
 = 0;

92114 int 
iTab
;

92115 
SrcList
 *
pTabList
 = 
pWInfo
->pTabList;

92116 struct 
SrcList_item
 *
pItem
;

92117 struct 
SrcList_item
 *
pEnd
 = &
pTabList
->
a
[
pWInfo
->
nLevel
];

92118 
sqlite3
 *
db
 = 
pWInfo
->
pParse
->db;

92119 int 
rc
 = 0;

92120 
WhereLoop
 *
pNew
;

92121 
u8
 
priorJointype
 = 0;

92124 
pNew
 = 
pBuilder
->pNew;

92125 
	`whereLoopInit
(
pNew
);

92126 for(
iTab
=0, 
pItem
=
pTabList
->
a
; pItem<
pEnd
; iTab++, pItem++)

92129 
Bitmask
 
mUnusable
 = 0;

92130 
pNew
->
iTab
 = iTab;

92131 
pNew
->
maskSelf
 = 
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
, 
pItem
->
iCursor
);

92132 if( ((
pItem
->
fg
.
jointype
|
priorJointype
) & (0x0008|0x0002))!=0 )

92137 
mPrereq
 = 
mPrior
;

92139 
priorJointype
 = 
pItem
->
fg
.
jointype
;

92140 if( (((
pItem
->
pTab
)->
tabFlags
 & 0x10)!=0) )

92143 struct 
SrcList_item
 *
p
;

92144 for(
p
=&
pItem
[1]; p<
pEnd
; p++)

92147 if( 
mUnusable
 || (
p
->
fg
.
jointype
 & (0x0008|0x0002)) )

92150 
mUnusable
 |= 
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
, 
p
->
iCursor
);

92153 
rc
 = 
	`whereLoopAddVirtual
(
pBuilder
, 
mPrereq
, 
mUnusable
);

92155 
rc
 = 
	`whereLoopAddBtree
(
pBuilder
, 
mPrereq
);

92157 if( 
rc
==0 )

92160 
rc
 = 
	`whereLoopAddOr
(
pBuilder
, 
mPrereq
, 
mUnusable
);

92162 
mPrior
 |= 
pNew
->
maskSelf
;

92163 if( 
rc
 || 
db
->
mallocFailed
 ) break;

92166 
	`whereLoopClear
(
db
, 
pNew
);

92167 return 
rc
;

92168 
	}
}

92170 static 
i8
 
	$wherePathSatisfiesOrderBy
(

92171 
WhereInfo
 *
pWInfo
,

92172 
ExprList
 *
pOrderBy
,

92173 
WherePath
 *
pPath
,

92174 
u16
 
wctrlFlags
,

92175 
u16
 
nLoop
,

92176 
WhereLoop
 *
pLast
,

92177 
Bitmask
 *
pRevMask


92181 
u8
 
revSet
;

92182 
u8
 
rev
;

92183 
u8
 
revIdx
;

92184 
u8
 
isOrderDistinct
;

92185 
u8
 
distinctColumns
;

92186 
u8
 
isMatch
;

92187 
u16
 
nKeyCol
;

92188 
u16
 
nColumn
;

92189 
u16
 
nOrderBy
;

92190 int 
iLoop
;

92191 int 
i
, 
j
;

92192 int 
iCur
;

92193 int 
iColumn
;

92194 
WhereLoop
 *
pLoop
 = 0;

92195 
WhereTerm
 *
pTerm
;

92196 
Expr
 *
pOBExpr
;

92197 
CollSeq
 *
pColl
;

92198 
Index
 *
pIndex
;

92199 
sqlite3
 *
db
 = 
pWInfo
->
pParse
->db;

92200 
Bitmask
 
obSat
 = 0;

92201 
Bitmask
 
obDone
;

92202 
Bitmask
 
orderDistinctMask
;

92203 
Bitmask
 
ready
;

92206 if( 
nLoop
 && (((
db
)->
dbOptFlags
&(0x0080))!=0) ) return 0;

92208 
nOrderBy
 = 
pOrderBy
->
nExpr
;

92210 if( 
nOrderBy
>((int)(sizeof(
Bitmask
)*8))-1 ) return 0;

92211 
isOrderDistinct
 = 1;

92212 
obDone
 = (((
Bitmask
)1)<<(
nOrderBy
))-1;

92213 
orderDistinctMask
 = 0;

92214 
ready
 = 0;

92215 for(
iLoop
=0; 
isOrderDistinct
 && 
obSat
<
obDone
 && iLoop<=
nLoop
; iLoop++)

92218 if( 
iLoop
>0 ) 
ready
 |= 
pLoop
->
maskSelf
;

92219 
pLoop
 = 
iLoop
<
nLoop
 ? 
pPath
->
aLoop
[iLoop] : 
pLast
;

92220 if( 
pLoop
->
wsFlags
 & 0x00000400 )

92223 if( 
pLoop
->
u
.
vtab
.
isOrdered
 ) 
obSat
 = 
obDone
;

92226 
iCur
 = 
pWInfo
->
pTabList
->
a
[
pLoop
->
iTab
].
iCursor
;

92233 for(
i
=0; i<
nOrderBy
; i++)

92236 if( (((
Bitmask
)1)<<(
i
)) & 
obSat
 ) continue;

92237 
pOBExpr
 = 
	`sqlite3ExprSkipCollate
(
pOrderBy
->
a
[
i
].
pExpr
);

92238 if( 
pOBExpr
->
op
!=152 ) continue;

92239 if( 
pOBExpr
->
iTable
!=
iCur
 ) continue;

92240 
pTerm
 = 
	`sqlite3WhereFindTerm
(&
pWInfo
->
sWC
, 
iCur
, 
pOBExpr
->
iColumn
,

92241 ~
ready
, 0x0002|0x0100|0x0080, 0);

92242 if( 
pTerm
==0 ) continue;

92243 if( (
pTerm
->
eOperator
&(0x0002|0x0080))!=0 && 
pOBExpr
->
iColumn
>=0 )

92246 const char *
z1
, *
z2
;

92247 
pColl
 = 
	`sqlite3ExprCollSeq
(
pWInfo
->
pParse
, 
pOrderBy
->
a
[
i
].
pExpr
);

92248 if( !
pColl
 ) pColl = 
db
->
pDfltColl
;

92249 
z1
 = 
pColl
->
zName
;

92250 
pColl
 = 
	`sqlite3ExprCollSeq
(
pWInfo
->
pParse
, 
pTerm
->
pExpr
);

92251 if( !
pColl
 ) pColl = 
db
->
pDfltColl
;

92252 
z2
 = 
pColl
->
zName
;

92253 if( 
	`sqlite3StrICmp
(
z1
, 
z2
)!=0 ) continue;

92256 
obSat
 |= (((
Bitmask
)1)<<(
i
));

92259 if( (
pLoop
->
wsFlags
 & 0x00001000)==0 )

92262 if( 
pLoop
->
wsFlags
 & 0x00000100 )

92265 
pIndex
 = 0;

92266 
nKeyCol
 = 0;

92267 
nColumn
 = 1;

92268 }else if( (
pIndex
 = 
pLoop
->
u
.
btree
.pIndex)==0 || pIndex->
bUnordered
 )

92273 
nKeyCol
 = 
pIndex
->nKeyCol;

92274 
nColumn
 = 
pIndex
->nColumn;

92278 
isOrderDistinct
 = ((
pIndex
)->
onError
!=0);

92284 
rev
 = 
revSet
 = 0;

92285 
distinctColumns
 = 0;

92286 for(
j
=0; j<
nColumn
; j++)

92289 
u8
 
bOnce
;

92292 if( 
j
<
pLoop
->
u
.
btree
.
nEq


92293 && 
pLoop
->
nSkip
==0

92294 && ((
i
 = 
pLoop
->
aLTerm
[
j
]->
eOperator
) & (0x0002|0x0100|0x0080))!=0

92298 if( 
i
 & 0x0100 )

92302 
isOrderDistinct
 = 0;

92310 if( 
pIndex
 )

92313 
iColumn
 = 
pIndex
->
aiColumn
[
j
];

92314 
revIdx
 = 
pIndex
->
aSortOrder
[
j
];

92315 if( 
iColumn
==
pIndex
->
pTable
->
iPKey
 ) iColumn = -1;

92317 
iColumn
 = (-1);

92318 
revIdx
 = 0;

92324 if( 
isOrderDistinct


92325 && 
iColumn
>=0

92326 && 
j
>=
pLoop
->
u
.
btree
.
nEq


92327 && 
pIndex
->
pTable
->
aCol
[
iColumn
].
notNull
==0

92331 
isOrderDistinct
 = 0;

92337 
bOnce
 = 1;

92338 
isMatch
 = 0;

92339 for(
i
=0; 
bOnce
 && i<
nOrderBy
; i++)

92342 if( (((
Bitmask
)1)<<(
i
)) & 
obSat
 ) continue;

92343 
pOBExpr
 = 
	`sqlite3ExprSkipCollate
(
pOrderBy
->
a
[
i
].
pExpr
);

92346 if( (
wctrlFlags
 & (0x0100|0x0200))==0 ) 
bOnce
 = 0;

92347 if( 
iColumn
>=(-1) )

92350 if( 
pOBExpr
->
op
!=152 ) continue;

92351 if( 
pOBExpr
->
iTable
!=
iCur
 ) continue;

92352 if( 
pOBExpr
->
iColumn
!=iColumn ) continue;

92354 if( 
	`sqlite3ExprCompare
(
pOBExpr
,
pIndex
->
aColExpr
->
a
[
j
].
pExpr
,
iCur
) )

92360 if( 
iColumn
>=0 )

92363 
pColl
 = 
	`sqlite3ExprCollSeq
(
pWInfo
->
pParse
, 
pOrderBy
->
a
[
i
].
pExpr
);

92364 if( !
pColl
 ) pColl = 
db
->
pDfltColl
;

92365 if( 
	`sqlite3StrICmp
(
pColl
->
zName
, 
pIndex
->
azColl
[
j
])!=0 ) continue;

92367 
isMatch
 = 1;

92370 if( 
isMatch
 && (
wctrlFlags
 & 0x0100)==0 )

92375 if( 
revSet
 )

92378 if( (
rev
 ^ 
revIdx
)!=
pOrderBy
->
a
[
i
].
sortOrder
 ) 
isMatch
 = 0;

92380 
rev
 = 
revIdx
 ^ 
pOrderBy
->
a
[
i
].
sortOrder
;

92381 if( 
rev
 ) *
pRevMask
 |= (((
Bitmask
)1)<<(
iLoop
));

92382 
revSet
 = 1;

92385 if( 
isMatch
 )

92388 if( 
iColumn
<0 )

92392 
distinctColumns
 = 1;

92394 
obSat
 |= (((
Bitmask
)1)<<(
i
));

92397 if( 
j
==0 || j<
nKeyCol
 )

92401 
isOrderDistinct
 = 0;

92406 if( 
distinctColumns
 )

92410 
isOrderDistinct
 = 1;

92415 if( 
isOrderDistinct
 )

92418 
orderDistinctMask
 |= 
pLoop
->
maskSelf
;

92419 for(
i
=0; i<
nOrderBy
; i++)

92422 
Expr
 *
p
;

92423 
Bitmask
 
mTerm
;

92424 if( (((
Bitmask
)1)<<(
i
)) & 
obSat
 ) continue;

92425 
p
 = 
pOrderBy
->
a
[
i
].
pExpr
;

92426 
mTerm
 = 
	`sqlite3WhereExprUsage
(&
pWInfo
->
sMaskSet
,
p
);

92427 if( 
mTerm
==0 && !
	`sqlite3ExprIsConstant
(
p
) ) continue;

92428 if( (
mTerm
&~
orderDistinctMask
)==0 )

92431 
obSat
 |= (((
Bitmask
)1)<<(
i
));

92436 if( 
obSat
==
obDone
 ) return (
i8
)
nOrderBy
;

92437 if( !
isOrderDistinct
 )

92440 for(
i
=
nOrderBy
-1; i>0; i--)

92443 
Bitmask
 
m
 = (((Bitmask)1)<<(
i
)) - 1;

92444 if( (
obSat
&
m
)==m ) return 
i
;

92449 
	}
}

92451 static int 
	$sqlite3WhereIsSorted
(
WhereInfo
 *
pWInfo
)

92456 return 
pWInfo
->
sorted
;

92457 
	}
}

92459 static 
LogEst
 
	$whereSortingCost
(

92460 
WhereInfo
 *
pWInfo
,

92461 
LogEst
 
nRow
,

92462 int 
nOrderBy
,

92463 int 
nSorted


92468 
LogEst
 
rScale
, 
rSortCost
;

92470 
rScale
 = 
	`sqlite3LogEst
((
nOrderBy
-
nSorted
)*100/nOrderBy) - 66;

92471 
rSortCost
 = 
nRow
 + 
rScale
 + 16;

92475 if( (
pWInfo
->
wctrlFlags
 & 0x4000)!=0 && pWInfo->
iLimit
<
nRow
 )

92478 
nRow
 = 
pWInfo
->
iLimit
;

92480 
rSortCost
 += 
	`estLog
(
nRow
);

92481 return 
rSortCost
;

92482 
	}
}

92484 static int 
	$wherePathSolver
(
WhereInfo
 *
pWInfo
, 
LogEst
 
nRowEst
)

92487 int 
mxChoice
;

92488 int 
nLoop
;

92489 
Parse
 *
pParse
;

92490 
sqlite3
 *
db
;

92491 int 
iLoop
;

92492 int 
ii
, 
jj
;

92493 int 
mxI
 = 0;

92494 int 
nOrderBy
;

92495 
LogEst
 
mxCost
 = 0;

92496 
LogEst
 
mxUnsorted
 = 0;

92497 int 
nTo
, 
nFrom
;

92498 
WherePath
 *
aFrom
;

92499 
WherePath
 *
aTo
;

92500 
WherePath
 *
pFrom
;

92501 
WherePath
 *
pTo
;

92502 
WhereLoop
 *
pWLoop
;

92503 
WhereLoop
 **
pX
;

92504 
LogEst
 *
aSortCost
 = 0;

92505 char *
pSpace
;

92506 int 
nSpace
;

92508 
pParse
 = 
pWInfo
->pParse;

92509 
db
 = 
pParse
->db;

92510 
nLoop
 = 
pWInfo
->
nLevel
;

92514 
mxChoice
 = (
nLoop
<=1) ? 1 : (nLoop==2 ? 5 : 10);

92523 if( 
pWInfo
->
pOrderBy
==0 || 
nRowEst
==0 )

92526 
nOrderBy
 = 0;

92528 
nOrderBy
 = 
pWInfo
->
pOrderBy
->
nExpr
;

92532 
nSpace
 = (sizeof(
WherePath
)+sizeof(
WhereLoop
*)*
nLoop
)*
mxChoice
*2;

92533 
nSpace
 += sizeof(
LogEst
) * 
nOrderBy
;

92534 
pSpace
 = 
	`sqlite3DbMallocRawNN
(
db
, 
nSpace
);

92535 if( 
pSpace
==0 ) return 7;

92536 
aTo
 = (
WherePath
*)
pSpace
;

92537 
aFrom
 = 
aTo
+
mxChoice
;

92538 
	`memset
(
aFrom
, 0, sizeof(aFrom[0]));

92539 
pX
 = (
WhereLoop
**)(
aFrom
+
mxChoice
);

92540 for(
ii
=
mxChoice
*2, 
pFrom
=
aTo
; ii>0; ii--, pFrom++, 
pX
 += 
nLoop
)

92543 
pFrom
->
aLoop
 = 
pX
;

92545 if( 
nOrderBy
 )

92554 
aSortCost
 = (
LogEst
*)
pX
;

92555 
	`memset
(
aSortCost
, 0, sizeof(
LogEst
) * 
nOrderBy
);

92565 
aFrom
[0].
nRow
 = ((
pParse
->
nQueryLoop
)<(48)?(pParse->nQueryLoop):(48)); ((void) (0));

92566 
nFrom
 = 1;

92568 if( 
nOrderBy
 )

92577 
aFrom
[0].
isOrdered
 = 
nLoop
>0 ? -1 : 
nOrderBy
;

92583 for(
iLoop
=0; iLoop<
nLoop
; iLoop++)

92586 
nTo
 = 0;

92587 for(
ii
=0, 
pFrom
=
aFrom
; ii<
nFrom
; ii++, pFrom++)

92590 for(
pWLoop
=
pWInfo
->
pLoops
; pWLoop; pWLoop=pWLoop->
pNextLoop
)

92593 
LogEst
 
nOut
;

92594 
LogEst
 
rCost
;

92595 
LogEst
 
rUnsorted
;

92596 
i8
 
isOrdered
 = 
pFrom
->isOrdered;

92597 
Bitmask
 
maskNew
;

92598 
Bitmask
 
revMask
 = 0;

92600 if( (
pWLoop
->
prereq
 & ~
pFrom
->
maskLoop
)!=0 ) continue;

92601 if( (
pWLoop
->
maskSelf
 & 
pFrom
->
maskLoop
)!=0 ) continue;

92602 if( (
pWLoop
->
wsFlags
 & 0x00004000)!=0 && 
pFrom
->
nRow
<10 )

92612 
rUnsorted
 = 
	`sqlite3LogEstAdd
(
pWLoop
->
rSetup
,pWLoop->
rRun
 + 
pFrom
->
nRow
);

92613 
rUnsorted
 = 
	`sqlite3LogEstAdd
(rUnsorted, 
pFrom
->rUnsorted);

92614 
nOut
 = 
pFrom
->
nRow
 + 
pWLoop
->nOut;

92615 
maskNew
 = 
pFrom
->
maskLoop
 | 
pWLoop
->
maskSelf
;

92616 if( 
isOrdered
<0 )

92619 
isOrdered
 = 
	`wherePathSatisfiesOrderBy
(
pWInfo
,

92620 
pWInfo
->
pOrderBy
, 
pFrom
, pWInfo->
wctrlFlags
,

92621 
iLoop
, 
pWLoop
, &
revMask
);

92623 
revMask
 = 
pFrom
->
revLoop
;

92625 if( 
isOrdered
>=0 && isOrdered<
nOrderBy
 )

92628 if( 
aSortCost
[
isOrdered
]==0 )

92631 
aSortCost
[
isOrdered
] = 
	`whereSortingCost
(

92632 
pWInfo
, 
nRowEst
, 
nOrderBy
, 
isOrdered


92635 
rCost
 = 
	`sqlite3LogEstAdd
(
rUnsorted
, 
aSortCost
[
isOrdered
]);

92642 
rCost
 = 
rUnsorted
;

92645 for(
jj
=0, 
pTo
=
aTo
; jj<
nTo
; jj++, pTo++)

92648 if( 
pTo
->
maskLoop
==
maskNew


92649 && ((
pTo
->
isOrdered
^isOrdered)&0x80)==0

92657 if( 
jj
>=
nTo
 )

92661 if( 
nTo
>=
mxChoice


92662 && (
rCost
>
mxCost
 || (rCost==mxCost && 
rUnsorted
>=
mxUnsorted
))

92671 if( 
nTo
<
mxChoice
 )

92675 
jj
 = 
nTo
++;

92678 
jj
 = 
mxI
;

92680 
pTo
 = &
aTo
[
jj
];

92693 if( 
pTo
->
rCost
<rCost || (pTo->rCost==rCost && pTo->
nRow
<=
nOut
) )

92704 
pTo
->
maskLoop
 = 
pFrom
->maskLoop | 
pWLoop
->
maskSelf
;

92705 
pTo
->
revLoop
 = 
revMask
;

92706 
pTo
->
nRow
 = 
nOut
;

92707 
pTo
->
rCost
 = rCost;

92708 
pTo
->
rUnsorted
 = rUnsorted;

92709 
pTo
->
isOrdered
 = isOrdered;

92710 
	`memcpy
(
pTo
->
aLoop
, 
pFrom
->aLoop, sizeof(
WhereLoop
*)*
iLoop
);

92711 
pTo
->
aLoop
[
iLoop
] = 
pWLoop
;

92712 if( 
nTo
>=
mxChoice
 )

92715 
mxI
 = 0;

92716 
mxCost
 = 
aTo
[0].
rCost
;

92717 
mxUnsorted
 = 
aTo
[0].
nRow
;

92718 for(
jj
=1, 
pTo
=&
aTo
[1]; jj<
mxChoice
; jj++, pTo++)

92721 if( 
pTo
->
rCost
>
mxCost


92722 || (
pTo
->
rCost
==
mxCost
 && pTo->
rUnsorted
>
mxUnsorted
)

92726 
mxCost
 = 
pTo
->
rCost
;

92727 
mxUnsorted
 = 
pTo
->
rUnsorted
;

92728 
mxI
 = 
jj
;

92735 
pFrom
 = 
aTo
;

92736 
aTo
 = 
aFrom
;

92737 
aFrom
 = 
pFrom
;

92738 
nFrom
 = 
nTo
;

92741 if( 
nFrom
==0 )

92744 
	`sqlite3ErrorMsg
(
pParse
, "no query solution");

92745 
	`sqlite3DbFree
(
db
, 
pSpace
);

92750 
pFrom
 = 
aFrom
;

92751 for(
ii
=1; ii<
nFrom
; ii++)

92754 if( 
pFrom
->
rCost
>
aFrom
[
ii
].rCost ) pFrom = &aFrom[ii];

92758 for(
iLoop
=0; iLoop<
nLoop
; iLoop++)

92761 
WhereLevel
 *
pLevel
 = 
pWInfo
->
a
 + 
iLoop
;

92762 
pLevel
->
pWLoop
 = pWLoop = 
pFrom
->
aLoop
[
iLoop
];

92763 
pLevel
->
iFrom
 = 
pWLoop
->
iTab
;

92764 
pLevel
->
iTabCur
 = 
pWInfo
->
pTabList
->
a
[pLevel->
iFrom
].
iCursor
;

92766 if( (
pWInfo
->
wctrlFlags
 & 0x0400)!=0

92767 && (
pWInfo
->
wctrlFlags
 & 0x0200)==0

92768 && 
pWInfo
->
eDistinct
==0

92769 && 
nRowEst


92773 
Bitmask
 
notUsed
;

92774 int 
rc
 = 
	`wherePathSatisfiesOrderBy
(
pWInfo
, pWInfo->
pResultSet
, 
pFrom
,

92775 0x0200, 
nLoop
-1, 
pFrom
->
aLoop
[nLoop-1], &
notUsed
);

92776 if( 
rc
==
pWInfo
->
pResultSet
->
nExpr
 )

92779 
pWInfo
->
eDistinct
 = 2;

92782 if( 
pWInfo
->
pOrderBy
 )

92785 if( 
pWInfo
->
wctrlFlags
 & 0x0200 )

92788 if( 
pFrom
->
isOrdered
==
pWInfo
->
pOrderBy
->
nExpr
 )

92791 
pWInfo
->
eDistinct
 = 2;

92794 
pWInfo
->
nOBSat
 = 
pFrom
->
isOrdered
;

92795 if( 
pWInfo
->
nOBSat
<0 ) pWInfo->nOBSat = 0;

92796 
pWInfo
->
revMask
 = 
pFrom
->
revLoop
;

92798 if( (
pWInfo
->
wctrlFlags
 & 0x0800)

92799 && 
pWInfo
->
nOBSat
==pWInfo->
pOrderBy
->
nExpr
 && 
nLoop
>0

92803 
Bitmask
 
revMask
 = 0;

92804 int 
nOrder
 = 
	`wherePathSatisfiesOrderBy
(
pWInfo
, pWInfo->
pOrderBy
,

92805 
pFrom
, 0, 
nLoop
-1, pFrom->
aLoop
[nLoop-1], &
revMask


92808 if( 
nOrder
==
pWInfo
->
pOrderBy
->
nExpr
 )

92811 
pWInfo
->
sorted
 = 1;

92812 
pWInfo
->
revMask
 = revMask;

92818 
pWInfo
->
nRowOut
 = 
pFrom
->
nRow
;

92821 
	`sqlite3DbFree
(
db
, 
pSpace
);

92823 
	}
}

92825 static int 
	$whereShortCut
(
WhereLoopBuilder
 *
pBuilder
)

92828 
WhereInfo
 *
pWInfo
;

92829 struct 
SrcList_item
 *
pItem
;

92830 
WhereClause
 *
pWC
;

92831 
WhereTerm
 *
pTerm
;

92832 
WhereLoop
 *
pLoop
;

92833 int 
iCur
;

92834 int 
j
;

92835 
Table
 *
pTab
;

92836 
Index
 *
pIdx
;

92838 
pWInfo
 = 
pBuilder
->pWInfo;

92839 if( 
pWInfo
->
wctrlFlags
 & 0x0020 ) return 0;

92841 
pItem
 = 
pWInfo
->
pTabList
->
a
;

92842 
pTab
 = 
pItem
->pTab;

92843 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) ) return 0;

92844 if( 
pItem
->
fg
.
isIndexedBy
 ) return 0;

92845 
iCur
 = 
pItem
->
iCursor
;

92846 
pWC
 = &
pWInfo
->
sWC
;

92847 
pLoop
 = 
pBuilder
->
pNew
;

92848 
pLoop
->
wsFlags
 = 0;

92849 
pLoop
->
nSkip
 = 0;

92850 
pTerm
 = 
	`sqlite3WhereFindTerm
(
pWC
, 
iCur
, -1, 0, 0x0002|0x0080, 0);

92851 if( 
pTerm
 )

92855 
pLoop
->
wsFlags
 = 0x00000001|0x00000100|0x00001000;

92856 
pLoop
->
aLTerm
[0] = 
pTerm
;

92857 
pLoop
->
nLTerm
 = 1;

92858 
pLoop
->
u
.
btree
.
nEq
 = 1;

92860 
pLoop
->
rRun
 = 33;

92862 for(
pIdx
=
pTab
->
pIndex
; pIdx; pIdx=pIdx->
pNext
)

92865 int 
opMask
;

92867 if( !((
pIdx
)->
onError
!=0)

92868 || 
pIdx
->
pPartIdxWhere
!=0

92869 || 
pIdx
->
nKeyCol
>((int)(sizeof(
pLoop
->
aLTermSpace
)/sizeof(pLoop->aLTermSpace[0])))

92871 
opMask
 = 
pIdx
->
uniqNotNull
 ? (0x0002|0x0080) : 0x0002;

92872 for(
j
=0; j<
pIdx
->
nKeyCol
; j++)

92875 
pTerm
 = 
	`sqlite3WhereFindTerm
(
pWC
, 
iCur
, 
j
, 0, 
opMask
, 
pIdx
);

92876 if( 
pTerm
==0 ) break;

92878 
pLoop
->
aLTerm
[
j
] = 
pTerm
;

92880 if( 
j
!=
pIdx
->
nKeyCol
 ) continue;

92881 
pLoop
->
wsFlags
 = 0x00000001|0x00001000|0x00000200;

92882 if( 
pIdx
->
isCovering
 || (
pItem
->
colUsed
 & ~
	`columnsInIndex
(pIdx))==0 )

92885 
pLoop
->
wsFlags
 |= 0x00000040;

92887 
pLoop
->
nLTerm
 = 
j
;

92888 
pLoop
->
u
.
btree
.
nEq
 = 
j
;

92889 
pLoop
->
u
.
btree
.
pIndex
 = 
pIdx
;

92891 
pLoop
->
rRun
 = 39;

92895 if( 
pLoop
->
wsFlags
 )

92898 
pLoop
->
nOut
 = (
LogEst
)1;

92899 
pWInfo
->
a
[0].
pWLoop
 = 
pLoop
;

92900 
pLoop
->
maskSelf
 = 
	`sqlite3WhereGetMask
(&
pWInfo
->
sMaskSet
, 
iCur
);

92901 
pWInfo
->
a
[0].
iTabCur
 = 
iCur
;

92902 
pWInfo
->
nRowOut
 = 1;

92903 if( 
pWInfo
->
pOrderBy
 ) pWInfo->
nOBSat
 = pWInfo->pOrderBy->
nExpr
;

92904 if( 
pWInfo
->
wctrlFlags
 & 0x0400 )

92907 
pWInfo
->
eDistinct
 = 1;

92915 
	}
}

92917 static 
WhereInfo
 *
	$sqlite3WhereBegin
(

92918 
Parse
 *
pParse
,

92919 
SrcList
 *
pTabList
,

92920 
Expr
 *
pWhere
,

92921 
ExprList
 *
pOrderBy
,

92922 
ExprList
 *
pResultSet
,

92923 
u16
 
wctrlFlags
,

92924 int 
iAuxArg


92929 int 
nByteWInfo
;

92930 int 
nTabList
;

92931 
WhereInfo
 *
pWInfo
;

92932 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

92933 
Bitmask
 
notReady
;

92934 
WhereLoopBuilder
 
sWLB
;

92935 
WhereMaskSet
 *
pMaskSet
;

92936 
WhereLevel
 *
pLevel
;

92937 
WhereLoop
 *
pLoop
;

92938 int 
ii
;

92939 
sqlite3
 *
db
;

92940 int 
rc
;

92941 
u8
 
bFordelete
 = 0;

92953 
db
 = 
pParse
->db;

92954 
	`memset
(&
sWLB
, 0, sizeof(sWLB));

92958 if( 
pOrderBy
 && pOrderBy->
nExpr
>=((int)(sizeof(
Bitmask
)*8)) ) pOrderBy = 0;

92959 
sWLB
.
pOrderBy
 = pOrderBy;

92963 if( (((
db
)->
dbOptFlags
&(0x0020))!=0) )

92966 
wctrlFlags
 &= ~0x0400;

92973 if( 
pTabList
->
nSrc
>((int)(sizeof(
Bitmask
)*8)) )

92976 
	`sqlite3ErrorMsg
(
pParse
, "at most %d tables in a join", ((int)(sizeof(
Bitmask
)*8)));

92985 
nTabList
 = (
wctrlFlags
 & 0x0040) ? 1 : 
pTabList
->
nSrc
;

92987 
nByteWInfo
 = (((sizeof(
WhereInfo
)+(
nTabList
-1)*sizeof(
WhereLevel
))+7)&~7);

92988 
pWInfo
 = 
	`sqlite3DbMallocZero
(
db
, 
nByteWInfo
 + sizeof(
WhereLoop
));

92989 if( 
db
->
mallocFailed
 )

92992 
	`sqlite3DbFree
(
db
, 
pWInfo
);

92993 
pWInfo
 = 0;

92994 goto 
whereBeginError
;

92996 
pWInfo
->
aiCurOnePass
[0] = pWInfo->aiCurOnePass[1] = -1;

92997 
pWInfo
->
nLevel
 = 
nTabList
;

92998 
pWInfo
->
pParse
 = pParse;

92999 
pWInfo
->
pTabList
 = pTabList;

93000 
pWInfo
->
pOrderBy
 = pOrderBy;

93001 
pWInfo
->
pResultSet
 = pResultSet;

93002 
pWInfo
->
iBreak
 = pWInfo->
iContinue
 = 
	`sqlite3VdbeMakeLabel
(
v
);

93003 
pWInfo
->
wctrlFlags
 = wctrlFlags;

93004 
pWInfo
->
iLimit
 = 
iAuxArg
;

93005 
pWInfo
->
savedNQueryLoop
 = 
pParse
->
nQueryLoop
;

93007 
pMaskSet
 = &
pWInfo
->
sMaskSet
;

93008 
sWLB
.
pWInfo
 = pWInfo;

93009 
sWLB
.
pWC
 = &
pWInfo
->
sWC
;

93010 
sWLB
.
pNew
 = (
WhereLoop
*)(((char*)
pWInfo
)+
nByteWInfo
);

93012 
	`whereLoopInit
(
sWLB
.
pNew
);

93020 (
pMaskSet
)->
n
=0;

93021 
	`sqlite3WhereClauseInit
(&
pWInfo
->
sWC
, pWInfo);

93022 
	`sqlite3WhereSplit
(&
pWInfo
->
sWC
, 
pWhere
, 72);

93027 for(
ii
=0; ii<
sWLB
.
pWC
->
nTerm
; ii++)

93030 if( 
nTabList
==0 || 
	`sqlite3ExprIsConstantNotJoin
(
sWLB
.
pWC
->
a
[
ii
].
pExpr
) )

93033 
	`sqlite3ExprIfFalse
(
pParse
, 
sWLB
.
pWC
->
a
[
ii
].
pExpr
, 
pWInfo
->
iBreak
,

93035 
sWLB
.
pWC
->
a
[
ii
].
wtFlags
 |= 0x04;

93041 if( 
nTabList
==0 )

93044 if( 
pOrderBy
 ) 
pWInfo
->
nOBSat
 = pOrderBy->
nExpr
;

93045 if( 
wctrlFlags
 & 0x0400 )

93048 
pWInfo
->
eDistinct
 = 1;

93052 for(
ii
=0; ii<
pTabList
->
nSrc
; ii++)

93055 
	`createMask
(
pMaskSet
, 
pTabList
->
a
[
ii
].
iCursor
);

93056 
	`sqlite3WhereTabFuncArgs
(
pParse
, &
pTabList
->
a
[
ii
], &
pWInfo
->
sWC
);

93059 
	`sqlite3WhereExprAnalyze
(
pTabList
, &
pWInfo
->
sWC
);

93060 if( 
db
->
mallocFailed
 ) goto 
whereBeginError
;

93062 if( 
wctrlFlags
 & 0x0400 )

93065 if( 
	`isDistinctRedundant
(
pParse
, 
pTabList
, &
pWInfo
->
sWC
, 
pResultSet
) )

93069 
pWInfo
->
eDistinct
 = 1;

93070 }else if( 
pOrderBy
==0 )

93074 
pWInfo
->
wctrlFlags
 |= 0x0200;

93075 
pWInfo
->
pOrderBy
 = 
pResultSet
;

93079 if( 
nTabList
!=1 || 
	`whereShortCut
(&
sWLB
)==0 )

93082 
rc
 = 
	`whereLoopAddAll
(&
sWLB
);

93083 if( 
rc
 ) goto 
whereBeginError
;

93085 
	`wherePathSolver
(
pWInfo
, 0);

93086 if( 
db
->
mallocFailed
 ) goto 
whereBeginError
;

93087 if( 
pWInfo
->
pOrderBy
 )

93090 
	`wherePathSolver
(
pWInfo
, pWInfo->
nRowOut
+1);

93091 if( 
db
->
mallocFailed
 ) goto 
whereBeginError
;

93094 if( 
pWInfo
->
pOrderBy
==0 && (
db
->
flags
 & 0x00020000)!=0 )

93097 
pWInfo
->
revMask
 = ((
Bitmask
)-1);

93099 if( 
pParse
->
nErr
 || (
db
->
mallocFailed
) )

93102 goto 
whereBeginError
;

93105 if( 
pWInfo
->
nLevel
>=2

93106 && 
pResultSet
!=0

93107 && (((
db
)->
dbOptFlags
&(0x0400))==0)

93111 
Bitmask
 
tabUsed
 = 
	`sqlite3WhereExprListUsage
(
pMaskSet
, 
pResultSet
);

93112 if( 
sWLB
.
pOrderBy
 )

93115 
tabUsed
 |= 
	`sqlite3WhereExprListUsage
(
pMaskSet
, 
sWLB
.
pOrderBy
);

93117 while( 
pWInfo
->
nLevel
>=2 )

93120 
WhereTerm
 *
pTerm
, *
pEnd
;

93121 
pLoop
 = 
pWInfo
->
a
[pWInfo->
nLevel
-1].
pWLoop
;

93122 if( (
pWInfo
->
pTabList
->
a
[
pLoop
->
iTab
].
fg
.
jointype
 & 0x0008)==0 ) break;

93123 if( (
wctrlFlags
 & 0x0400)==0

93124 && (
pLoop
->
wsFlags
 & 0x00001000)==0

93130 if( (
tabUsed
 & 
pLoop
->
maskSelf
)!=0 ) break;

93131 
pEnd
 = 
sWLB
.
pWC
->
a
 + sWLB.pWC->
nTerm
;

93132 for(
pTerm
=
sWLB
.
pWC
->
a
; pTerm<
pEnd
; pTerm++)

93135 if( (
pTerm
->
prereqAll
 & 
pLoop
->
maskSelf
)!=0

93136 && !(((
pTerm
->
pExpr
)->
flags
&(0x000001))!=0)

93143 if( 
pTerm
<
pEnd
 ) break;

93145 
pWInfo
->
nLevel
--;

93146 
nTabList
--;

93150 
pWInfo
->
pParse
->
nQueryLoop
 += pWInfo->
nRowOut
;

93156 if( (
wctrlFlags
 & 0x0004)!=0 )

93159 int 
wsFlags
 = 
pWInfo
->
a
[0].
pWLoop
->wsFlags;

93160 int 
bOnerow
 = (
wsFlags
 & 0x00001000)!=0;

93161 if( 
bOnerow


93162 || ((
wctrlFlags
 & 0x2000)!=0

93163 && 0==(
wsFlags
 & 0x00000400))

93167 
pWInfo
->
eOnePass
 = 
bOnerow
 ? 1 : 2;

93168 if( (((
pTabList
->
a
[0].
pTab
)->
tabFlags
 & 0x20)==0) && (
wsFlags
 & 0x00000040) )

93171 if( 
wctrlFlags
 & 0x2000 )

93174 
bFordelete
 = 0x08;

93176 
pWInfo
->
a
[0].
pWLoop
->
wsFlags
 = (wsFlags & ~0x00000040);

93184 for(
ii
=0, 
pLevel
=
pWInfo
->
a
; ii<
nTabList
; ii++, pLevel++)

93187 
Table
 *
pTab
;

93188 int 
iDb
;

93189 struct 
SrcList_item
 *
pTabItem
;

93191 
pTabItem
 = &
pTabList
->
a
[
pLevel
->
iFrom
];

93192 
pTab
 = 
pTabItem
->pTab;

93193 
iDb
 = 
	`sqlite3SchemaToIndex
(
db
, 
pTab
->
pSchema
);

93194 
pLoop
 = 
pLevel
->
pWLoop
;

93195 if( (
pTab
->
tabFlags
 & 0x02)!=0 || pTab->
pSelect
 )

93201 if( (
pLoop
->
wsFlags
 & 0x00000400)!=0 )

93204 const char *
pVTab
 = (const char *)
	`sqlite3GetVTable
(
db
, 
pTab
);

93205 int 
iCur
 = 
pTabItem
->
iCursor
;

93206 
	`sqlite3VdbeAddOp4
(
v
, 152, 
iCur
, 0, 0, 
pVTab
, (-10));

93207 }else if( (((
pTab
)->
tabFlags
 & 0x10)!=0) )

93213 if( (
pLoop
->
wsFlags
 & 0x00000040)==0

93214 && (
wctrlFlags
 & 0x0010)==0 )

93217 int 
op
 = 54;

93218 if( 
pWInfo
->
eOnePass
!=0 )

93221 
op
 = 55;

93222 
pWInfo
->
aiCurOnePass
[0] = 
pTabItem
->
iCursor
;

93224 
	`sqlite3OpenTable
(
pParse
, 
pTabItem
->
iCursor
, 
iDb
, 
pTab
, 
op
);

93228 if( 
pWInfo
->
eOnePass
==0 && 
pTab
->
nCol
<((int)(sizeof(
Bitmask
)*8)) && (((pTab)->
tabFlags
 & 0x20)==0) )

93231 
Bitmask
 
b
 = 
pTabItem
->
colUsed
;

93232 int 
n
 = 0;

93233 for(; 
b
; b=b>>1, 
n
++)

93236 
	`sqlite3VdbeChangeP4
(
v
, -1, ((void*)(long int)(
n
)), (-14));

93245 
	`sqlite3VdbeChangeP5
(
v
, 
bFordelete
);

93252 
	`sqlite3TableLock
(
pParse
, 
iDb
, 
pTab
->
tnum
, 0, pTab->
zName
);

93254 if( 
pLoop
->
wsFlags
 & 0x00000200 )

93257 
Index
 *
pIx
 = 
pLoop
->
u
.
btree
.
pIndex
;

93258 int 
iIndexCur
;

93259 int 
op
 = 54;

93262 if( !(((
pTab
)->
tabFlags
 & 0x20)==0) && ((
pIx
)->
idxType
==2)

93263 && (
wctrlFlags
 & 0x0040)!=0

93269 
iIndexCur
 = 
pLevel
->
iTabCur
;

93270 
op
 = 0;

93271 }else if( 
pWInfo
->
eOnePass
!=0 )

93274 
Index
 *
pJ
 = 
pTabItem
->
pTab
->
pIndex
;

93275 
iIndexCur
 = 
iAuxArg
;

93277 while( (
pJ
) && pJ!=
pIx
 )

93280 
iIndexCur
++;

93281 
pJ
 = pJ->
pNext
;

93283 
op
 = 55;

93284 
pWInfo
->
aiCurOnePass
[1] = 
iIndexCur
;

93285 }else if( 
iAuxArg
 && (
wctrlFlags
 & 0x0040)!=0 )

93288 
iIndexCur
 = 
iAuxArg
;

93289 if( 
wctrlFlags
 & 0x1000 ) 
op
 = 53;

93291 
iIndexCur
 = 
pParse
->
nTab
++;

93293 
pLevel
->
iIdxCur
 = 
iIndexCur
;

93296 if( 
op
 )

93299 
	`sqlite3VdbeAddOp3
(
v
, 
op
, 
iIndexCur
, 
pIx
->
tnum
, 
iDb
);

93300 
	`sqlite3VdbeSetP4KeyInfo
(
pParse
, 
pIx
);

93301 if( (
pLoop
->
wsFlags
 & 0x0000000f)!=0

93302 && (
pLoop
->
wsFlags
 & (0x00000002|0x00008000))==0

93303 && (
pWInfo
->
wctrlFlags
&0x0001)==0

93307 
	`sqlite3VdbeChangeP5
(
v
, 0x02);

93313 if( 
iDb
>=0 ) 
	`sqlite3CodeVerifySchema
(
pParse
, iDb);

93315 
pWInfo
->
iTop
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

93316 if( 
db
->
mallocFailed
 ) goto 
whereBeginError
;

93322 
notReady
 = ~(
Bitmask
)0;

93323 for(
ii
=0; ii<
nTabList
; ii++)

93326 int 
addrExplain
;

93327 int 
wsFlags
;

93328 
pLevel
 = &
pWInfo
->
a
[
ii
];

93329 
wsFlags
 = 
pLevel
->
pWLoop
->wsFlags;

93331 if( (
pLevel
->
pWLoop
->
wsFlags
 & 0x00004000)!=0 )

93334 
	`constructAutomaticIndex
(
pParse
, &
pWInfo
->
sWC
,

93335 &
pTabList
->
a
[
pLevel
->
iFrom
], 
notReady
, pLevel);

93336 if( 
db
->
mallocFailed
 ) goto 
whereBeginError
;

93339 
addrExplain
 = 
	`sqlite3WhereExplainOneScan
(

93340 
pParse
, 
pTabList
, 
pLevel
, 
ii
, pLevel->
iFrom
, 
wctrlFlags


93342 
pLevel
->
addrBody
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

93343 
notReady
 = 
	`sqlite3WhereCodeOneLoopStart
(
pWInfo
, 
ii
, notReady);

93344 
pWInfo
->
iContinue
 = 
pLevel
->
addrCont
;

93345 if( (
wsFlags
&0x00002000)==0 && (
wctrlFlags
&0x0040)==0 )

93348 ((void)
addrExplain
);

93354 return 
pWInfo
;

93357 
whereBeginError
:

93358 if( 
pWInfo
 )

93361 
pParse
->
nQueryLoop
 = 
pWInfo
->
savedNQueryLoop
;

93362 
	`whereInfoFree
(
db
, 
pWInfo
);

93365 
	}
}

93371 static void 
	$sqlite3WhereEnd
(
WhereInfo
 *
pWInfo
)

93374 
Parse
 *
pParse
 = 
pWInfo
->pParse;

93375 
Vdbe
 *
v
 = 
pParse
->
pVdbe
;

93376 int 
i
;

93377 
WhereLevel
 *
pLevel
;

93378 
WhereLoop
 *
pLoop
;

93379 
SrcList
 *
pTabList
 = 
pWInfo
->pTabList;

93380 
sqlite3
 *
db
 = 
pParse
->db;

93385 
	`sqlite3ExprCacheClear
(
pParse
);

93386 for(
i
=
pWInfo
->
nLevel
-1; i>=0; i--)

93389 int 
addr
;

93390 
pLevel
 = &
pWInfo
->
a
[
i
];

93391 
pLoop
 = 
pLevel
->
pWLoop
;

93392 
	`sqlite3VdbeResolveLabel
(
v
, 
pLevel
->
addrCont
);

93393 if( 
pLevel
->
op
!=160 )

93396 
	`sqlite3VdbeAddOp3
(
v
, 
pLevel
->
op
, pLevel->
p1
, pLevel->
p2
, pLevel->
p3
);

93397 
	`sqlite3VdbeChangeP5
(
v
, 
pLevel
->
p5
);

93403 if( 
pLoop
->
wsFlags
 & 0x00000800 && 
pLevel
->
u
.
in
.
nIn
>0 )

93406 struct 
InLoop
 *
pIn
;

93407 int 
j
;

93408 
	`sqlite3VdbeResolveLabel
(
v
, 
pLevel
->
addrNxt
);

93409 for(
j
=
pLevel
->
u
.
in
.
nIn
, 
pIn
=&pLevel->u.in.
aInLoop
[j-1]; j>0; j--, pIn--)

93412 
	`sqlite3VdbeJumpHere
(
v
, 
pIn
->
addrInTop
+1);

93413 
	`sqlite3VdbeAddOp2
(
v
, 
pIn
->
eEndLoopOp
, pIn->
iCur
, pIn->
addrInTop
);

93417 
	`sqlite3VdbeJumpHere
(
v
, 
pIn
->
addrInTop
-1);

93420 
	`sqlite3VdbeResolveLabel
(
v
, 
pLevel
->
addrBrk
);

93421 if( 
pLevel
->
addrSkip
 )

93424 
	`sqlite3VdbeGoto
(
v
, 
pLevel
->
addrSkip
);

93426 
	`sqlite3VdbeJumpHere
(
v
, 
pLevel
->
addrSkip
);

93427 
	`sqlite3VdbeJumpHere
(
v
, 
pLevel
->
addrSkip
-2);

93430 if( 
pLevel
->
addrLikeRep
 )

93433 int 
op
;

93434 if( 
	`sqlite3VdbeGetOp
(
v
, 
pLevel
->
addrLikeRep
-1)->
p1
 )

93437 
op
 = 141;

93439 
op
 = 142;

93441 
	`sqlite3VdbeAddOp2
(
v
, 
op
, 
pLevel
->
iLikeRepCntr
, pLevel->
addrLikeRep
);

93445 if( 
pLevel
->
iLeftJoin
 )

93448 
addr
 = 
	`sqlite3VdbeAddOp1
(
v
, 138, 
pLevel
->
iLeftJoin
); ;

93451 if( (
pLoop
->
wsFlags
 & 0x00000040)==0 )

93454 
	`sqlite3VdbeAddOp1
(
v
, 104, 
pTabList
->
a
[
i
].
iCursor
);

93456 if( 
pLoop
->
wsFlags
 & 0x00000200 )

93459 
	`sqlite3VdbeAddOp1
(
v
, 104, 
pLevel
->
iIdxCur
);

93461 if( 
pLevel
->
op
==15 )

93464 
	`sqlite3VdbeAddOp2
(
v
, 14, 
pLevel
->
p1
, pLevel->
addrFirst
);

93466 
	`sqlite3VdbeGoto
(
v
, 
pLevel
->
addrFirst
);

93468 
	`sqlite3VdbeJumpHere
(
v
, 
addr
);

93477 
	`sqlite3VdbeResolveLabel
(
v
, 
pWInfo
->
iBreak
);

93480 for(
i
=0, 
pLevel
=
pWInfo
->
a
; i<pWInfo->
nLevel
; i++, pLevel++)

93483 int 
k
, 
last
;

93484 
VdbeOp
 *
pOp
;

93485 
Index
 *
pIdx
 = 0;

93486 struct 
SrcList_item
 *
pTabItem
 = &
pTabList
->
a
[
pLevel
->
iFrom
];

93487 
Table
 *
pTab
 = 
pTabItem
->pTab;

93489 
pLoop
 = 
pLevel
->
pWLoop
;

93495 if( 
pTabItem
->
fg
.
viaCoroutine
 && !
db
->
mallocFailed
 )

93498 
	`translateColumnToCopy
(
v
, 
pLevel
->
addrBody
, pLevel->
iTabCur
,

93499 
pTabItem
->
regResult
, 0);

93508 if( (
pTab
->
tabFlags
 & 0x02)==0

93509 && 
pTab
->
pSelect
==0

93510 && (
pWInfo
->
wctrlFlags
 & 0x0010)==0

93514 int 
ws
 = 
pLoop
->
wsFlags
;

93515 if( 
pWInfo
->
eOnePass
==0 && (
ws
 & 0x00000040)==0 )

93518 
	`sqlite3VdbeAddOp1
(
v
, 61, 
pTabItem
->
iCursor
);

93520 if( (
ws
 & 0x00000200)!=0

93521 && (
ws
 & (0x00000100|0x00004000))==0

93522 && 
pLevel
->
iIdxCur
!=
pWInfo
->
aiCurOnePass
[1]

93526 
	`sqlite3VdbeAddOp1
(
v
, 61, 
pLevel
->
iIdxCur
);

93530 if( 
pLoop
->
wsFlags
 & (0x00000200|0x00000040) )

93533 
pIdx
 = 
pLoop
->
u
.
btree
.
pIndex
;

93534 }else if( 
pLoop
->
wsFlags
 & 0x00002000 )

93537 
pIdx
 = 
pLevel
->
u
.
pCovidx
;

93539 if( 
pIdx


93540 && (
pWInfo
->
eOnePass
==0 || !(((
pIdx
->
pTable
)->
tabFlags
 & 0x20)==0))

93541 && !
db
->
mallocFailed


93545 
last
 = 
	`sqlite3VdbeCurrentAddr
(
v
);

93546 
k
 = 
pLevel
->
addrBody
;

93547 
pOp
 = 
	`sqlite3VdbeGetOp
(
v
, 
k
);

93548 for(; 
k
<
last
; k++, 
pOp
++)

93551 if( 
pOp
->
p1
!=
pLevel
->
iTabCur
 ) continue;

93552 if( 
pOp
->
opcode
==47 )

93555 int 
x
 = 
pOp
->
p2
;

93557 if( !(((
pTab
)->
tabFlags
 & 0x20)==0) )

93560 
Index
 *
pPk
 = 
	`sqlite3PrimaryKeyIndex
(
pTab
);

93561 
x
 = 
pPk
->
aiColumn
[x];

93564 
x
 = 
	`sqlite3ColumnOfIndex
(
pIdx
, x);

93565 if( 
x
>=0 )

93568 
pOp
->
p2
 = 
x
;

93569 
pOp
->
p1
 = 
pLevel
->
iIdxCur
;

93572 }else if( 
pOp
->
opcode
==103 )

93575 
pOp
->
p1
 = 
pLevel
->
iIdxCur
;

93576 
pOp
->
opcode
 = 113;

93584 
pParse
->
nQueryLoop
 = 
pWInfo
->
savedNQueryLoop
;

93585 
	`whereInfoFree
(
db
, 
pWInfo
);

93587 
	}
}

93589 struct 
	sLimitVal
 {

93590 
Expr
 *
	mpLimit
;

93591 
Expr
 *
	mpOffset
;

93598 struct 
	sLikeOp
 {

93599 
Token
 
	meOperator
;

93600 int 
	mbNot
;

93603 struct 
	sTrigEvent
 { int 
	ma
; 
IdList
 * 
	mb
; };

93608 struct 
	sAttachKey
 { int 
	mtype
; 
Token
 
	mkey
; };

93614 static void 
	$disableLookaside
(
Parse
 *
pParse
)

93617 
pParse
->
disableLookaside
++;

93618 
pParse
->
db
->
lookaside
.
bDisable
++;

93619 
	}
}

93627 static void 
	$parserDoubleLinkSelect
(
Parse
 *
pParse
, 
Select
 *
p
)

93630 if( 
p
->
pPrior
 )

93633 
Select
 *
pNext
 = 0, *
pLoop
;

93634 int 
mxSelect
, 
cnt
 = 0;

93635 for(
pLoop
=
p
; pLoop; 
pNext
=pLoop, pLoop=pLoop->
pPrior
, 
cnt
++)

93638 
pLoop
->
pNext
 = pNext;

93639 
pLoop
->
selFlags
 |= 0x00080;

93641 if( (
p
->
selFlags
 & 0x00200)==0 &&

93642 (
mxSelect
 = 
pParse
->
db
->
aLimit
[4])>0 &&

93643 
cnt
>
mxSelect


93647 
	`sqlite3ErrorMsg
(
pParse
, "too many terms in compound SELECT");

93650 
	}
}

93656 static void 
	$spanSet
(
ExprSpan
 *
pOut
, 
Token
 *
pStart
, Token *
pEnd
)

93659 
pOut
->
zStart
 = 
pStart
->
z
;

93660 
pOut
->
zEnd
 = &
pEnd
->
z
[pEnd->
n
];

93661 
	}
}

93667 static void 
	$spanExpr
(
ExprSpan
 *
pOut
, 
Parse
 *
pParse
, int 
op
, 
Token
 
t
)

93670 
pOut
->
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 
op
, 0, 0, &
t
);

93671 
pOut
->
zStart
 = 
t
.
z
;

93672 
pOut
->
zEnd
 = &
t
.
z
[t.
n
];

93673 
	}
}

93678 static void 
	$spanBinaryExpr
(

93679 
Parse
 *
pParse
,

93680 int 
op
,

93681 
ExprSpan
 *
pLeft
,

93682 
ExprSpan
 *
pRight


93686 
pLeft
->
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 
op
, pLeft->pExpr, 
pRight
->pExpr, 0);

93687 
pLeft
->
zEnd
 = 
pRight
->zEnd;

93688 
	}
}

93693 static void 
	$exprNot
(
Parse
 *
pParse
, int 
doNot
, 
ExprSpan
 *
pSpan
)

93696 if( 
doNot
 )

93699 
pSpan
->
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 19, pSpan->pExpr, 0, 0);

93701 
	}
}

93705 static void 
	$spanUnaryPostfix
(

93706 
Parse
 *
pParse
,

93707 int 
op
,

93708 
ExprSpan
 *
pOperand
,

93709 
Token
 *
pPostOp


93713 
pOperand
->
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 
op
, pOperand->pExpr, 0, 0);

93714 
pOperand
->
zEnd
 = &
pPostOp
->
z
[pPostOp->
n
];

93715 
	}
}

93719 static void 
	$binaryToUnaryIfNull
(
Parse
 *
pParse
, 
Expr
 *
pY
, Expr *
pA
, int 
op
)

93722 
sqlite3
 *
db
 = 
pParse
->db;

93723 if( 
pA
 && 
pY
 && pY->
op
==101 )

93726 
pA
->
op
 = (
u8
)op;

93727 
	`sqlite3ExprDelete
(
db
, 
pA
->
pRight
);

93728 
pA
->
pRight
 = 0;

93730 
	}
}

93734 static void 
	$spanUnaryPrefix
(

93735 
ExprSpan
 *
pOut
,

93736 
Parse
 *
pParse
,

93737 int 
op
,

93738 
ExprSpan
 *
pOperand
,

93739 
Token
 *
pPreOp


93743 
pOut
->
zStart
 = 
pPreOp
->
z
;

93744 
pOut
->
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 
op
, 
pOperand
->pExpr, 0, 0);

93745 
pOut
->
zEnd
 = 
pOperand
->zEnd;

93746 
	}
}

93753 static 
ExprList
 *
	$parserAddExprIdListTerm
(

93754 
Parse
 *
pParse
,

93755 
ExprList
 *
pPrior
,

93756 
Token
 *
pIdToken
,

93757 int 
hasCollate
,

93758 int 
sortOrder


93762 
ExprList
 *
p
 = 
	`sqlite3ExprListAppend
(
pParse
, 
pPrior
, 0);

93763 if( (
hasCollate
 || 
sortOrder
!=-1)

93764 && 
pParse
->
db
->
init
.
busy
==0

93768 
	`sqlite3ErrorMsg
(
pParse
, "syntax error after column name \"%.*s\"",

93769 
pIdToken
->
n
, pIdToken->
z
);

93771 
	`sqlite3ExprListSetName
(
pParse
, 
p
, 
pIdToken
, 1);

93772 return 
p
;

93773 
	}
}

93776 int 
	myyinit
;

93777 
Token
 
	myy0
;

93778 struct 
LimitVal
 
	myy64
;

93779 
Expr
* 
	myy122
;

93780 
Select
* 
	myy159
;

93781 
IdList
* 
	myy180
;

93782 struct {int 
	mvalue
; int 
	mmask
;} 
	myy207
;

93783 struct 
LikeOp
 
	myy318
;

93784 
TriggerStep
* 
	myy327
;

93785 
With
* 
	myy331
;

93786 
ExprSpan
 
	myy342
;

93787 
SrcList
* 
	myy347
;

93788 int 
	myy392
;

93789 struct 
TrigEvent
 
	myy410
;

93790 
ExprList
* 
	myy442
;

93791 } 
	tYYMINORTYPE
;

93793 static const unsigned short int 
	gyy_action
[] = {

93945 static const unsigned char 
	gyy_lookahead
[] = {

94101 static const short 
	gyy_shift_ofst
[] = {

94151 static const short 
	gyy_reduce_ofst
[] = {

94185 static const unsigned short int 
	gyy_default
[] = {

94232 static const unsigned char 
	gyyFallback
[] = {

94305 struct 
	syyStackEntry
 {

94306 unsigned short int 
	mstateno
;

94307 unsigned char 
	mmajor
;

94309 
YYMINORTYPE
 
	mminor
;

94312 typedef struct 
yyStackEntry
 
	tyyStackEntry
;

94316 struct 
	syyParser
 {

94317 int 
	myyidx
;

94324 
Parse
 *
	mpParse
;

94329 
yyStackEntry
 
	myystack
[100];

94332 typedef struct 
yyParser
 
	tyyParser
;

94334 static void *
sqlite3ParserAlloc
(void *(*
mallocProc
)(
u64
))

94337 
yyParser
 *
	gpParser
;

94338 
	gpParser
 = (
yyParser
*)(*
mallocProc
)( (
u64
)sizeof(yyParser) );

94339 if( 
	gpParser
 )

94342 
	gpParser
->
	gyyidx
 = -1;

94345 return 
	gpParser
;

94348 static void 
	$yy_destructor
(

94349 
yyParser
 *
yypParser
,

94350 unsigned char 
yymajor
,

94351 
YYMINORTYPE
 *
yypminor


94355 
Parse
 *
pParse
 = 
yypParser
->pParse;

94356 switch( 
yymajor
 )

94365 
	`sqlite3SelectDelete
(
pParse
->
db
, (
yypminor
->
yy159
));

94371 
	`sqlite3ExprDelete
(
pParse
->
db
, (
yypminor
->
yy342
).
pExpr
);

94386 
	`sqlite3ExprListDelete
(
pParse
->
db
, (
yypminor
->
yy442
));

94394 
	`sqlite3SrcListDelete
(
pParse
->
db
, (
yypminor
->
yy347
));

94400 
	`sqlite3WithDelete
(
pParse
->
db
, (
yypminor
->
yy331
));

94411 
	`sqlite3ExprDelete
(
pParse
->
db
, (
yypminor
->
yy122
));

94418 
	`sqlite3IdListDelete
(
pParse
->
db
, (
yypminor
->
yy180
));

94424 
	`sqlite3DeleteTriggerStep
(
pParse
->
db
, (
yypminor
->
yy327
));

94429 
	`sqlite3IdListDelete
(
pParse
->
db
, (
yypminor
->
yy410
).
b
);

94435 
	}
}

94443 static void 
	$yy_pop_parser_stack
(
yyParser
 *
pParser
)

94446 
yyStackEntry
 *
yytos
;

94448 
yytos
 = &
pParser
->
yystack
[pParser->
yyidx
--];

94456 
	`yy_destructor
(
pParser
, 
yytos
->
major
, &yytos->
minor
);

94457 
	}
}

94459 static void 
sqlite3ParserFree
(

94460 void *
p
,

94461 void (*
freeProc
)(void*)

94465 
yyParser
 *
pParser
 = (yyParser*)
p
;

94469 while( 
pParser
->
yyidx
>=0 ) 
	`yy_pop_parser_stack
(pParser);

94473 (*
freeProc
)((void*)
pParser
);

94474 
	}
}

94476 static unsigned int 
	$yy_find_shift_action
(

94477 
yyParser
 *
pParser
,

94478 unsigned char 
iLookAhead


94482 int 
i
;

94483 int 
stateno
 = 
pParser
->
yystack
[pParser->
yyidx
].stateno;

94485 if( 
stateno
>=975 ) return stateno;

94488 
i
 = 
yy_shift_ofst
[
stateno
];

94489 if( 
i
==(-72) ) return 
yy_default
[
stateno
];

94491 
i
 += 
iLookAhead
;

94492 if( 
i
<0 || i>=(1499) || 
yy_lookahead
[i]!=
iLookAhead
 )

94495 if( 
iLookAhead
>0 )

94499 unsigned char 
iFallback
;

94500 if( 
iLookAhead
<sizeof(
yyFallback
)/sizeof(yyFallback[0])

94501 && (
iFallback
 = 
yyFallback
[
iLookAhead
])!=0 )

94511 
iLookAhead
 = 
iFallback
;

94517 int 
j
 = 
i
 - 
iLookAhead
 + 70;

94520 
j
>=0 &&

94523 
j
<(1499) &&

94525 
yy_lookahead
[
j
]==70

94536 return 
yy_action
[
j
];

94541 return 
yy_default
[
stateno
];

94543 return 
yy_action
[
i
];

94546 
	}
}

94552 static int 
	$yy_find_reduce_action
(

94553 int 
stateno
,

94554 unsigned char 
iLookAhead


94558 int 
i
;

94566 
i
 = 
yy_reduce_ofst
[
stateno
];

94569 
i
 += 
iLookAhead
;

94578 return 
yy_action
[
i
];

94579 
	}
}

94584 static void 
	$yyStackOverflow
(
yyParser
 *
yypParser
)

94587 
Parse
 *
pParse
 = 
yypParser
->pParse;

94588 
yypParser
->
yyidx
--;

94594 while( 
yypParser
->
yyidx
>=0 ) 
	`yy_pop_parser_stack
(yypParser);

94599 
	`sqlite3ErrorMsg
(
pParse
, "parser stack overflow");

94601 
yypParser
->
pParse
 = pParse;

94602 
	}
}

94604 static void 
	$yy_shift
(

94605 
yyParser
 *
yypParser
,

94606 int 
yyNewState
,

94607 int 
yyMajor
,

94608 
Token
 
yyMinor


94612 
yyStackEntry
 *
yytos
;

94613 
yypParser
->
yyidx
++;

94620 if( 
yypParser
->
yyidx
>=100 )

94623 
	`yyStackOverflow
(
yypParser
);

94627 
yytos
 = &
yypParser
->
yystack
[yypParser->
yyidx
];

94628 
yytos
->
stateno
 = (unsigned short int)
yyNewState
;

94629 
yytos
->
major
 = (unsigned char)
yyMajor
;

94630 
yytos
->
minor
.
yy0
 = 
yyMinor
;

94632 
	}
}

94638 unsigned char 
	mlhs
;

94639 unsigned char 
	mnrhs
;

94640 } 
	gyyRuleInfo
[] = {

94969 static void 
yy_accept
(
yyParser
*);

94975 static void 
	$yy_reduce
(

94976 
yyParser
 *
yypParser
,

94977 unsigned int 
yyruleno


94981 int 
yygoto
;

94982 int 
yyact
;

94983 
yyStackEntry
 *
yymsp
;

94984 int 
yysize
;

94985 
Parse
 *
pParse
 = 
yypParser
->pParse;

94986 
yymsp
 = &
yypParser
->
yystack
[yypParser->
yyidx
];

94988 if( 
yyRuleInfo
[
yyruleno
].
nrhs
==0 )

94997 if( 
yypParser
->
yyidx
>=100 -1 )

95000 
	`yyStackOverflow
(
yypParser
);

95006 switch( 
yyruleno
 )

95010 
YYMINORTYPE
 
yylhsminor
;

95012 { 
pParse
->
explain
 = 1; }

95015 { 
pParse
->
explain
 = 2; }

95018 { 
	`sqlite3FinishCoding
(
pParse
); }

95021 {
	`sqlite3BeginTransaction
(
pParse
, 
yymsp
[-1].
minor
.
yy392
);}

95024 {
yymsp
[1].
minor
.
yy392
 = 7;}

95029 {
yymsp
[0].
minor
.
yy392
 = yymsp[0].
major
; }

95033 {
	`sqlite3CommitTransaction
(
pParse
);}

95036 {
	`sqlite3RollbackTransaction
(
pParse
);}

95040 
	`sqlite3Savepoint
(
pParse
, 0, &
yymsp
[0].
minor
.
yy0
);

95045 
	`sqlite3Savepoint
(
pParse
, 1, &
yymsp
[0].
minor
.
yy0
);

95050 
	`sqlite3Savepoint
(
pParse
, 2, &
yymsp
[0].
minor
.
yy0
);

95055 
	`sqlite3StartTable
(
pParse
,&
yymsp
[-1].
minor
.
yy0
,&yymsp[0].minor.yy0,yymsp[-4].minor.
yy392
,0,0,yymsp[-2].minor.yy392);

95059 {
	`disableLookaside
(
pParse
);}

95070 {
yymsp
[1].
minor
.
yy392
 = 0;}

95073 {
yymsp
[-2].
minor
.
yy392
 = 1;}

95077 {
yymsp
[0].
minor
.
yy392
 = 1;}

95081 
	`sqlite3EndTable
(
pParse
,&
yymsp
[-2].
minor
.
yy0
,&yymsp[-1].minor.yy0,yymsp[0].minor.
yy392
,0);

95086 
	`sqlite3EndTable
(
pParse
,0,0,0,
yymsp
[0].
minor
.
yy159
);

95087 
	`sqlite3SelectDelete
(
pParse
->
db
, 
yymsp
[0].
minor
.
yy159
);

95092 if( 
yymsp
[0].
minor
.
yy0
.
n
==5 && 
	`sqlite3_strnicmp
(yymsp[0].minor.yy0.
z
,"rowid",5)==0 )

95095 
yymsp
[-1].
minor
.
yy392
 = 0x20 | 0x40;

95097 
yymsp
[-1].
minor
.
yy392
 = 0;

95098 
	`sqlite3ErrorMsg
(
pParse
, "unknown table option: %.*s", 
yymsp
[0].
minor
.
yy0
.
n
, yymsp[0].minor.yy0.
z
);

95103 {
	`sqlite3AddColumn
(
pParse
,&
yymsp
[-1].
minor
.
yy0
,&yymsp[0].minor.yy0);}

95108 {
yymsp
[1].
minor
.
yy0
.
n
 = 0; yymsp[1].minor.yy0.
z
 = 0;}

95112 
yymsp
[-3].
minor
.
yy0
.
n
 = (int)(&yymsp[0].minor.yy0.
z
[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);

95117 
yymsp
[-5].
minor
.
yy0
.
n
 = (int)(&yymsp[0].minor.yy0.
z
[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);

95121 {
yymsp
[-1].
minor
.
yy0
.
n
=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.
z
-yymsp[-1].minor.yy0.z);}

95125 {
pParse
->
constraintName
 = 
yymsp
[0].
minor
.
yy0
;}

95129 {
	`sqlite3AddDefaultValue
(
pParse
,&
yymsp
[0].
minor
.
yy342
);}

95132 {
	`sqlite3AddDefaultValue
(
pParse
,&
yymsp
[-1].
minor
.
yy342
);}

95136 
ExprSpan
 
v
;

95137 
v
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 155, 
yymsp
[0].
minor
.
yy342
.pExpr, 0, 0);

95138 
v
.
zStart
 = 
yymsp
[-1].
minor
.
yy0
.
z
;

95139 
v
.
zEnd
 = 
yymsp
[0].
minor
.
yy342
.zEnd;

95140 
	`sqlite3AddDefaultValue
(
pParse
,&
v
);

95145 
ExprSpan
 
v
;

95146 
	`spanExpr
(&
v
, 
pParse
, 97, 
yymsp
[0].
minor
.
yy0
);

95147 
	`sqlite3AddDefaultValue
(
pParse
,&
v
);

95151 {
	`sqlite3AddNotNull
(
pParse
, 
yymsp
[0].
minor
.
yy392
);}

95154 {
	`sqlite3AddPrimaryKey
(
pParse
,0,
yymsp
[-1].
minor
.
yy392
,yymsp[0].minor.yy392,yymsp[-2].minor.yy392);}

95157 {
	`sqlite3CreateIndex
(
pParse
,0,0,0,0,
yymsp
[0].
minor
.
yy392
,0,0,0,0);}

95160 {
	`sqlite3AddCheckConstraint
(
pParse
,
yymsp
[-1].
minor
.
yy342
.
pExpr
);}

95163 {
	`sqlite3CreateForeignKey
(
pParse
,0,&
yymsp
[-2].
minor
.
yy0
,yymsp[-1].minor.
yy442
,yymsp[0].minor.
yy392
);}

95166 {
	`sqlite3DeferForeignKey
(
pParse
,
yymsp
[0].
minor
.
yy392
);}

95169 {
	`sqlite3AddCollateType
(
pParse
, &
yymsp
[0].
minor
.
yy0
);}

95172 { 
yymsp
[1].
minor
.
yy392
 = 0*0x0101; }

95175 { 
yymsp
[-1].
minor
.
yy392
 = (yymsp[-1].minor.yy392 & ~yymsp[0].minor.
yy207
.
mask
) | yymsp[0].minor.yy207.
value
; }

95178 { 
yymsp
[-1].
minor
.
yy207
.
value
 = 0; yymsp[-1].minor.yy207.
mask
 = 0x000000; }

95181 { 
yymsp
[-2].
minor
.
yy207
.
value
 = 0; yymsp[-2].minor.yy207.
mask
 = 0x000000; }

95184 { 
yymsp
[-2].
minor
.
yy207
.
value
 = yymsp[0].minor.
yy392
; yymsp[-2].minor.yy207.
mask
 = 0x0000ff; }

95187 { 
yymsp
[-2].
minor
.
yy207
.
value
 = yymsp[0].minor.
yy392
<<8; yymsp[-2].minor.yy207.
mask
 = 0x00ff00; }

95190 { 
yymsp
[-1].
minor
.
yy392
 = 7; }

95193 { 
yymsp
[-1].
minor
.
yy392
 = 8; }

95196 { 
yymsp
[0].
minor
.
yy392
 = 9; }

95199 { 
yymsp
[0].
minor
.
yy392
 = 6; }

95202 { 
yymsp
[-1].
minor
.
yy392
 = 0; }

95205 {
yymsp
[-2].
minor
.
yy392
 = 0;}

95210 {
yymsp
[-1].
minor
.
yy392
 = yymsp[0].minor.yy392;}

95217 {
yymsp
[-1].
minor
.
yy392
 = 1;}

95220 {
yymsp
[-1].
minor
.
yy392
 = 0;}

95223 {
pParse
->
constraintName
.
n
 = 0;}

95226 {
	`sqlite3AddPrimaryKey
(
pParse
,
yymsp
[-3].
minor
.
yy442
,yymsp[0].minor.
yy392
,yymsp[-2].minor.yy392,0);}

95229 {
	`sqlite3CreateIndex
(
pParse
,0,0,0,
yymsp
[-2].
minor
.
yy442
,yymsp[0].minor.
yy392
,0,0,0,0);}

95232 {
	`sqlite3AddCheckConstraint
(
pParse
,
yymsp
[-2].
minor
.
yy342
.
pExpr
);}

95236 
	`sqlite3CreateForeignKey
(
pParse
, 
yymsp
[-6].
minor
.
yy442
, &yymsp[-3].minor.
yy0
, yymsp[-2].minor.yy442, yymsp[-1].minor.
yy392
);

95237 
	`sqlite3DeferForeignKey
(
pParse
, 
yymsp
[0].
minor
.
yy392
);

95242 {
yymsp
[1].
minor
.
yy392
 = 10;}

95245 {
yymsp
[-2].
minor
.
yy392
 = yymsp[0].minor.yy392;}

95248 {
yymsp
[0].
minor
.
yy392
 = 4;}

95252 {
yymsp
[0].
minor
.
yy392
 = 5;}

95256 
	`sqlite3DropTable
(
pParse
, 
yymsp
[0].
minor
.
yy347
, 0, yymsp[-1].minor.
yy392
);

95261 
	`sqlite3CreateView
(
pParse
, &
yymsp
[-8].
minor
.
yy0
, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.
yy442
, yymsp[0].minor.
yy159
, yymsp[-7].minor.
yy392
, yymsp[-5].minor.yy392);

95266 
	`sqlite3DropTable
(
pParse
, 
yymsp
[0].
minor
.
yy347
, 1, yymsp[-1].minor.
yy392
);

95271 
SelectDest
 
dest
 = {9, 0, 0, 0, 0, 0};

95272 
	`sqlite3Select
(
pParse
, 
yymsp
[0].
minor
.
yy159
, &
dest
);

95273 
	`sqlite3SelectDelete
(
pParse
->
db
, 
yymsp
[0].
minor
.
yy159
);

95278 
Select
 *
p
 = 
yymsp
[0].
minor
.
yy159
;

95279 if( 
p
 )

95282 
p
->
pWith
 = 
yymsp
[-1].
minor
.
yy331
;

95283 
	`parserDoubleLinkSelect
(
pParse
, 
p
);

95285 
	`sqlite3WithDelete
(
pParse
->
db
, 
yymsp
[-1].
minor
.
yy331
);

95287 
yymsp
[-1].
minor
.
yy159
 = 
p
;

95292 
Select
 *
pRhs
 = 
yymsp
[0].
minor
.
yy159
;

95293 
Select
 *
pLhs
 = 
yymsp
[-2].
minor
.
yy159
;

95294 if( 
pRhs
 && pRhs->
pPrior
 )

95297 
SrcList
 *
pFrom
;

95298 
Token
 
x
;

95299 
x
.
n
 = 0;

95300 
	`parserDoubleLinkSelect
(
pParse
, 
pRhs
);

95301 
pFrom
 = 
	`sqlite3SrcListAppendFromTerm
(
pParse
,0,0,0,&
x
,
pRhs
,0,0);

95302 
pRhs
 = 
	`sqlite3SelectNew
(
pParse
,0,
pFrom
,0,0,0,0,0,0,0);

95304 if( 
pRhs
 )

95307 
pRhs
->
op
 = (
u8
)
yymsp
[-1].
minor
.
yy392
;

95308 
pRhs
->
pPrior
 = 
pLhs
;

95309 if( (
pLhs
) ) pLhs->
selFlags
 &= ~0x00200;

95310 
pRhs
->
selFlags
 &= ~0x00200;

95311 if( 
yymsp
[-1].
minor
.
yy392
!=116 ) 
pParse
->
hasCompound
 = 1;

95313 
	`sqlite3SelectDelete
(
pParse
->
db
, 
pLhs
);

95315 
yymsp
[-2].
minor
.
yy159
 = 
pRhs
;

95320 {
yymsp
[0].
minor
.
yy392
 = yymsp[0].
major
; }

95323 {
yymsp
[-1].
minor
.
yy392
 = 116;}

95330 
yymsp
[-8].
minor
.
yy159
 = 
	`sqlite3SelectNew
(
pParse
,yymsp[-6].minor.
yy442
,yymsp[-5].minor.
yy347
,yymsp[-4].minor.
yy122
,yymsp[-3].minor.yy442,yymsp[-2].minor.yy122,yymsp[-1].minor.yy442,yymsp[-7].minor.
yy392
,yymsp[0].minor.
yy64
.
pLimit
,yymsp[0].minor.yy64.
pOffset
);

95336 
yymsp
[-3].
minor
.
yy159
 = 
	`sqlite3SelectNew
(
pParse
,yymsp[-1].minor.
yy442
,0,0,0,0,0,0x00100,0,0);

95341 
Select
 *
pRight
, *
pLeft
 = 
yymsp
[-4].
minor
.
yy159
;

95342 
pRight
 = 
	`sqlite3SelectNew
(
pParse
,
yymsp
[-1].
minor
.
yy442
,0,0,0,0,0,0x00100|0x00200,0,0);

95343 if( (
pLeft
) ) pLeft->
selFlags
 &= ~0x00200;

95344 if( 
pRight
 )

95347 
pRight
->
op
 = 116;

95348 
pRight
->
pPrior
 = 
pLeft
;

95349 
yymsp
[-4].
minor
.
yy159
 = 
pRight
;

95351 
yymsp
[-4].
minor
.
yy159
 = 
pLeft
;

95356 {
yymsp
[0].
minor
.
yy392
 = 0x00001;}

95359 {
yymsp
[0].
minor
.
yy392
 = 0x00002;}

95366 {
yymsp
[1].
minor
.
yy442
 = 0;}

95370 
yymsp
[-2].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
, yymsp[-2].minor.yy442, yymsp[-1].minor.
yy342
.
pExpr
);

95371 if( 
yymsp
[0].
minor
.
yy0
.
n
>0 ) 
	`sqlite3ExprListSetName
(
pParse
, yymsp[-2].minor.
yy442
, &yymsp[0].minor.yy0, 1);

95372 
	`sqlite3ExprListSetSpan
(
pParse
,
yymsp
[-2].
minor
.
yy442
,&yymsp[-1].minor.
yy342
);

95377 
Expr
 *
p
 = 
	`sqlite3Expr
(
pParse
->
db
, 158, 0);

95378 
yymsp
[-1].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
, yymsp[-1].minor.yy442, 
p
);

95383 
Expr
 *
pRight
 = 
	`sqlite3PExpr
(
pParse
, 158, 0, 0, &
yymsp
[0].
minor
.
yy0
);

95384 
Expr
 *
pLeft
 = 
	`sqlite3PExpr
(
pParse
, 27, 0, 0, &
yymsp
[-2].
minor
.
yy0
);

95385 
Expr
 *
pDot
 = 
	`sqlite3PExpr
(
pParse
, 122, 
pLeft
, 
pRight
, 0);

95386 
yymsp
[-3].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,yymsp[-3].minor.yy442, 
pDot
);

95393 {
yymsp
[-1].
minor
.
yy0
 = yymsp[0].minor.yy0;}

95396 {
yymsp
[1].
minor
.
yy347
 = 
	`sqlite3DbMallocZero
(
pParse
->
db
, sizeof(*yymsp[1].minor.yy347));}

95400 
yymsp
[-1].
minor
.
yy347
 = yymsp[0].minor.yy347;

95401 
	`sqlite3SrcListShiftJoinType
(
yymsp
[-1].
minor
.
yy347
);

95406 if( (
yymsp
[-1].
minor
.
yy347
 && yymsp[-1].minor.yy347->
nSrc
>0) ) yymsp[-1].minor.yy347->
a
[yymsp[-1].minor.yy347->nSrc-1].
fg
.
jointype
 = (
u8
)yymsp[0].minor.
yy392
;

95410 {
yymsp
[1].
minor
.
yy347
 = 0;}

95414 
yymsp
[-6].
minor
.
yy347
 = 
	`sqlite3SrcListAppendFromTerm
(
pParse
,yymsp[-6].minor.yy347,&yymsp[-5].minor.
yy0
,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.
yy122
,yymsp[0].minor.
yy180
);

95415 
	`sqlite3SrcListIndexedBy
(
pParse
, 
yymsp
[-6].
minor
.
yy347
, &yymsp[-2].minor.
yy0
);

95420 
yymsp
[-8].
minor
.
yy347
 = 
	`sqlite3SrcListAppendFromTerm
(
pParse
,yymsp[-8].minor.yy347,&yymsp[-7].minor.
yy0
,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.
yy122
,yymsp[0].minor.
yy180
);

95421 
	`sqlite3SrcListFuncArgs
(
pParse
, 
yymsp
[-8].
minor
.
yy347
, yymsp[-4].minor.
yy442
);

95426 
yymsp
[-6].
minor
.
yy347
 = 
	`sqlite3SrcListAppendFromTerm
(
pParse
,yymsp[-6].minor.yy347,0,0,&yymsp[-2].minor.
yy0
,yymsp[-4].minor.
yy159
,yymsp[-1].minor.
yy122
,yymsp[0].minor.
yy180
);

95431 if( 
yymsp
[-6].
minor
.
yy347
==0 && yymsp[-2].minor.
yy0
.
n
==0 && yymsp[-1].minor.
yy122
==0 && yymsp[0].minor.
yy180
==0 )

95434 
yymsp
[-6].
minor
.
yy347
 = yymsp[-4].minor.yy347;

95435 }else if( 
yymsp
[-4].
minor
.
yy347
->
nSrc
==1 )

95438 
yymsp
[-6].
minor
.
yy347
 = 
	`sqlite3SrcListAppendFromTerm
(
pParse
,yymsp[-6].minor.yy347,0,0,&yymsp[-2].minor.
yy0
,0,yymsp[-1].minor.
yy122
,yymsp[0].minor.
yy180
);

95439 if( 
yymsp
[-6].
minor
.
yy347
 )

95442 struct 
SrcList_item
 *
pNew
 = &
yymsp
[-6].
minor
.
yy347
->
a
[yymsp[-6].minor.yy347->
nSrc
-1];

95443 struct 
SrcList_item
 *
pOld
 = 
yymsp
[-4].
minor
.
yy347
->
a
;

95444 
pNew
->
zName
 = 
pOld
->zName;

95445 
pNew
->
zDatabase
 = 
pOld
->zDatabase;

95446 
pNew
->
pSelect
 = 
pOld
->pSelect;

95447 
pOld
->
zName
 = pOld->
zDatabase
 = 0;

95448 
pOld
->
pSelect
 = 0;

95450 
	`sqlite3SrcListDelete
(
pParse
->
db
, 
yymsp
[-4].
minor
.
yy347
);

95452 
Select
 *
pSubquery
;

95453 
	`sqlite3SrcListShiftJoinType
(
yymsp
[-4].
minor
.
yy347
);

95454 
pSubquery
 = 
	`sqlite3SelectNew
(
pParse
,0,
yymsp
[-4].
minor
.
yy347
,0,0,0,0,0x00400,0,0);

95455 
yymsp
[-6].
minor
.
yy347
 = 
	`sqlite3SrcListAppendFromTerm
(
pParse
,yymsp[-6].minor.yy347,0,0,&yymsp[-2].minor.
yy0
,
pSubquery
,yymsp[-1].minor.
yy122
,yymsp[0].minor.
yy180
);

95461 {
yymsp
[1].
minor
.
yy0
.
z
=0; yymsp[1].minor.yy0.
n
=0;}

95464 {
yymsp
[-1].
minor
.
yy347
 = 
	`sqlite3SrcListAppend
(
pParse
->
db
,0,&yymsp[-1].minor.
yy0
,&yymsp[0].minor.yy0); }

95467 { 
yymsp
[0].
minor
.
yy392
 = 0x0001; }

95470 {
yymsp
[-1].
minor
.
yy392
 = 
	`sqlite3JoinType
(
pParse
,&yymsp[-1].minor.
yy0
,0,0); }

95473 {
yymsp
[-2].
minor
.
yy392
 = 
	`sqlite3JoinType
(
pParse
,&yymsp[-2].minor.
yy0
,&yymsp[-1].minor.yy0,0); }

95476 {
yymsp
[-3].
minor
.
yy392
 = 
	`sqlite3JoinType
(
pParse
,&yymsp[-3].minor.
yy0
,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0); }

95482 {
yymsp
[-1].
minor
.
yy122
 = yymsp[0].minor.
yy342
.
pExpr
;}

95489 {
yymsp
[1].
minor
.
yy122
 = 0;}

95492 {
yymsp
[-2].
minor
.
yy0
 = yymsp[0].minor.yy0;}

95495 {
yymsp
[-1].
minor
.
yy0
.
z
=0; yymsp[-1].minor.yy0.
n
=1;}

95498 {
yymsp
[-3].
minor
.
yy180
 = yymsp[-1].minor.yy180;}

95502 {
yymsp
[1].
minor
.
yy180
 = 0;}

95506 {
yymsp
[-2].
minor
.
yy442
 = yymsp[0].minor.yy442;}

95510 
yymsp
[-3].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,yymsp[-3].minor.yy442,yymsp[-1].minor.
yy342
.
pExpr
);

95511 
	`sqlite3ExprListSetSortOrder
(
yymsp
[-3].
minor
.
yy442
,yymsp[0].minor.
yy392
);

95516 
yymsp
[-1].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,0,yymsp[-1].minor.
yy342
.
pExpr
);

95517 
	`sqlite3ExprListSetSortOrder
(
yymsp
[-1].
minor
.
yy442
,yymsp[0].minor.
yy392
);

95521 {
yymsp
[0].
minor
.
yy392
 = 0;}

95524 {
yymsp
[0].
minor
.
yy392
 = 1;}

95527 {
yymsp
[1].
minor
.
yy392
 = -1;}

95530 {
yymsp
[1].
minor
.
yy64
.
pLimit
 = 0; yymsp[1].minor.yy64.
pOffset
 = 0;}

95533 {
yymsp
[-1].
minor
.
yy64
.
pLimit
 = yymsp[0].minor.
yy342
.
pExpr
; yymsp[-1].minor.yy64.
pOffset
 = 0;}

95536 {
yymsp
[-3].
minor
.
yy64
.
pLimit
 = yymsp[-2].minor.
yy342
.
pExpr
; yymsp[-3].minor.yy64.
pOffset
 = yymsp[0].minor.yy342.pExpr;}

95539 {
yymsp
[-3].
minor
.
yy64
.
pOffset
 = yymsp[-2].minor.
yy342
.
pExpr
; yymsp[-3].minor.yy64.
pLimit
 = yymsp[0].minor.yy342.pExpr;}

95543 
	`sqlite3WithPush
(
pParse
, 
yymsp
[-5].
minor
.
yy331
, 1);

95544 
	`sqlite3SrcListIndexedBy
(
pParse
, 
yymsp
[-2].
minor
.
yy347
, &yymsp[-1].minor.
yy0
);

95545 
	`sqlite3DeleteFrom
(
pParse
,
yymsp
[-2].
minor
.
yy347
,yymsp[0].minor.
yy122
);

95550 
	`sqlite3WithPush
(
pParse
, 
yymsp
[-7].
minor
.
yy331
, 1);

95551 
	`sqlite3SrcListIndexedBy
(
pParse
, 
yymsp
[-4].
minor
.
yy347
, &yymsp[-3].minor.
yy0
);

95552 
	`sqlite3ExprListCheckLength
(
pParse
,
yymsp
[-1].
minor
.
yy442
,"set list");

95553 
	`sqlite3Update
(
pParse
,
yymsp
[-4].
minor
.
yy347
,yymsp[-1].minor.
yy442
,yymsp[0].minor.
yy122
,yymsp[-5].minor.
yy392
);

95558 
yymsp
[-4].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
, yymsp[-4].minor.yy442, yymsp[0].minor.
yy342
.
pExpr
);

95559 
	`sqlite3ExprListSetName
(
pParse
, 
yymsp
[-4].
minor
.
yy442
, &yymsp[-2].minor.
yy0
, 1);

95564 
yylhsminor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
, 0, 
yymsp
[0].
minor
.
yy342
.
pExpr
);

95565 
	`sqlite3ExprListSetName
(
pParse
, 
yylhsminor
.
yy442
, &
yymsp
[-2].
minor
.
yy0
, 1);

95567 
yymsp
[-2].
minor
.
yy442
 = 
yylhsminor
.yy442;

95571 
	`sqlite3WithPush
(
pParse
, 
yymsp
[-5].
minor
.
yy331
, 1);

95572 
	`sqlite3Insert
(
pParse
, 
yymsp
[-2].
minor
.
yy347
, yymsp[0].minor.
yy159
, yymsp[-1].minor.
yy180
, yymsp[-4].minor.
yy392
);

95577 
	`sqlite3WithPush
(
pParse
, 
yymsp
[-6].
minor
.
yy331
, 1);

95578 
	`sqlite3Insert
(
pParse
, 
yymsp
[-3].
minor
.
yy347
, 0, yymsp[-2].minor.
yy180
, yymsp[-5].minor.
yy392
);

95582 {
yymsp
[-2].
minor
.
yy180
 = yymsp[-1].minor.yy180;}

95585 {
yymsp
[-2].
minor
.
yy180
 = 
	`sqlite3IdListAppend
(
pParse
->
db
,yymsp[-2].minor.yy180,&yymsp[0].minor.
yy0
);}

95588 {
yymsp
[0].
minor
.
yy180
 = 
	`sqlite3IdListAppend
(
pParse
->
db
,0,&yymsp[0].minor.
yy0
); }

95591 {
	`spanSet
(&
yymsp
[-2].
minor
.
yy342
,&yymsp[-2].minor.
yy0
,&yymsp[0].minor.yy0); yymsp[-2].minor.yy342.
pExpr
 = yymsp[-1].minor.yy342.pExpr;}

95596 {
	`spanExpr
(&
yymsp
[0].
minor
.
yy342
,
pParse
,yymsp[0].
major
,yymsp[0].minor.
yy0
); }

95600 {
	`spanExpr
(&
yymsp
[0].
minor
.
yy342
,
pParse
,27,yymsp[0].minor.
yy0
); }

95604 
Expr
 *
temp1
 = 
	`sqlite3PExpr
(
pParse
, 27, 0, 0, &
yymsp
[-2].
minor
.
yy0
);

95605 
Expr
 *
temp2
 = 
	`sqlite3PExpr
(
pParse
, 27, 0, 0, &
yymsp
[0].
minor
.
yy0
);

95606 
	`spanSet
(&
yymsp
[-2].
minor
.
yy342
,&yymsp[-2].minor.
yy0
,&yymsp[0].minor.yy0);

95607 
yymsp
[-2].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 122, 
temp1
, 
temp2
, 0);

95612 
Expr
 *
temp1
 = 
	`sqlite3PExpr
(
pParse
, 27, 0, 0, &
yymsp
[-4].
minor
.
yy0
);

95613 
Expr
 *
temp2
 = 
	`sqlite3PExpr
(
pParse
, 27, 0, 0, &
yymsp
[-2].
minor
.
yy0
);

95614 
Expr
 *
temp3
 = 
	`sqlite3PExpr
(
pParse
, 27, 0, 0, &
yymsp
[0].
minor
.
yy0
);

95615 
Expr
 *
temp4
 = 
	`sqlite3PExpr
(
pParse
, 122, 
temp2
, 
temp3
, 0);

95616 
	`spanSet
(&
yymsp
[-4].
minor
.
yy342
,&yymsp[-4].minor.
yy0
,&yymsp[0].minor.yy0);

95617 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 122, 
temp1
, 
temp4
, 0);

95622 
Token
 
t
 = 
yymsp
[0].
minor
.
yy0
;

95623 if( 
t
.
n
>=2 && t.
z
[0]=='#' && (
sqlite3CtypeMap
[(unsigned char)(t.z[1])]&0x04) )

95629 
	`spanSet
(&
yymsp
[0].
minor
.
yy342
, &
t
, &t);

95630 if( 
pParse
->
nested
==0 )

95633 
	`sqlite3ErrorMsg
(
pParse
, "near \"%T\": syntax error", &
t
);

95634 
yymsp
[0].
minor
.
yy342
.
pExpr
 = 0;

95636 
yymsp
[0].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 157, 0, 0, &
t
);

95637 if( 
yymsp
[0].
minor
.
yy342
.
pExpr
 ) 
	`sqlite3GetInt32
(&
t
.
z
[1], &yymsp[0].minor.yy342.pExpr->
iTable
);

95640 
	`spanExpr
(&
yymsp
[0].
minor
.
yy342
, 
pParse
, 135, 
t
);

95641 
	`sqlite3ExprAssignVarNumber
(
pParse
, 
yymsp
[0].
minor
.
yy342
.
pExpr
);

95647 
yymsp
[-2].
minor
.
yy342
.
pExpr
 = 
	`sqlite3ExprAddCollateToken
(
pParse
, yymsp[-2].minor.yy342.pExpr, &yymsp[0].minor.
yy0
, 1);

95648 
yymsp
[-2].
minor
.
yy342
.
zEnd
 = &yymsp[0].minor.
yy0
.
z
[yymsp[0].minor.yy0.
n
];

95653 
	`spanSet
(&
yymsp
[-5].
minor
.
yy342
,&yymsp[-5].minor.
yy0
,&yymsp[0].minor.yy0);

95654 
yymsp
[-5].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 38, yymsp[-3].minor.yy342.pExpr, 0, &yymsp[-1].minor.
yy0
);

95659 if( 
yymsp
[-1].
minor
.
yy442
 && yymsp[-1].minor.yy442->
nExpr
>
pParse
->
db
->
aLimit
[6] )

95662 
	`sqlite3ErrorMsg
(
pParse
, "too many arguments on function %T", &
yymsp
[-4].
minor
.
yy0
);

95664 
yylhsminor
.
yy342
.
pExpr
 = 
	`sqlite3ExprFunction
(
pParse
, 
yymsp
[-1].
minor
.
yy442
, &yymsp[-4].minor.
yy0
);

95665 
	`spanSet
(&
yylhsminor
.
yy342
,&
yymsp
[-4].
minor
.
yy0
,&yymsp[0].minor.yy0);

95666 if( 
yymsp
[-2].
minor
.
yy392
==0x00001 && 
yylhsminor
.
yy342
.
pExpr
 )

95669 
yylhsminor
.
yy342
.
pExpr
->
flags
 |= 0x000010;

95672 
yymsp
[-4].
minor
.
yy342
 = 
yylhsminor
.yy342;

95676 
yylhsminor
.
yy342
.
pExpr
 = 
	`sqlite3ExprFunction
(
pParse
, 0, &
yymsp
[-3].
minor
.
yy0
);

95677 
	`spanSet
(&
yylhsminor
.
yy342
,&
yymsp
[-3].
minor
.
yy0
,&yymsp[0].minor.yy0);

95679 
yymsp
[-3].
minor
.
yy342
 = 
yylhsminor
.yy342;

95683 
yylhsminor
.
yy342
.
pExpr
 = 
	`sqlite3ExprFunction
(
pParse
, 0, &
yymsp
[0].
minor
.
yy0
);

95684 
	`spanSet
(&
yylhsminor
.
yy342
, &
yymsp
[0].
minor
.
yy0
, &yymsp[0].minor.yy0);

95686 
yymsp
[0].
minor
.
yy342
 = 
yylhsminor
.yy342;

95696 {
	`spanBinaryExpr
(
pParse
,
yymsp
[-1].
major
,&yymsp[-2].
minor
.
yy342
,&yymsp[0].minor.yy342);}

95699 {
yymsp
[0].
minor
.
yy318
.
eOperator
 = yymsp[0].minor.
yy0
; yymsp[0].minor.yy318.
bNot
 = 0; }

95702 {
yymsp
[-1].
minor
.
yy318
.
eOperator
 = yymsp[0].minor.
yy0
; yymsp[-1].minor.yy318.
bNot
 = 1;}

95706 
ExprList
 *
pList
;

95707 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
,0, 
yymsp
[0].
minor
.
yy342
.
pExpr
);

95708 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
,pList, 
yymsp
[-2].
minor
.
yy342
.
pExpr
);

95709 
yymsp
[-2].
minor
.
yy342
.
pExpr
 = 
	`sqlite3ExprFunction
(
pParse
, 
pList
, &yymsp[-1].minor.
yy318
.
eOperator
);

95710 
	`exprNot
(
pParse
, 
yymsp
[-1].
minor
.
yy318
.
bNot
, &yymsp[-2].minor.
yy342
);

95711 
yymsp
[-2].
minor
.
yy342
.
zEnd
 = yymsp[0].minor.yy342.zEnd;

95712 if( 
yymsp
[-2].
minor
.
yy342
.
pExpr
 ) yymsp[-2].minor.yy342.pExpr->
flags
 |= 0x000080;

95717 
ExprList
 *
pList
;

95718 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
,0, 
yymsp
[-2].
minor
.
yy342
.
pExpr
);

95719 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
,pList, 
yymsp
[-4].
minor
.
yy342
.
pExpr
);

95720 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
,pList, 
yymsp
[0].
minor
.
yy342
.
pExpr
);

95721 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3ExprFunction
(
pParse
, 
pList
, &yymsp[-3].minor.
yy318
.
eOperator
);

95722 
	`exprNot
(
pParse
, 
yymsp
[-3].
minor
.
yy318
.
bNot
, &yymsp[-4].minor.
yy342
);

95723 
yymsp
[-4].
minor
.
yy342
.
zEnd
 = yymsp[0].minor.yy342.zEnd;

95724 if( 
yymsp
[-4].
minor
.
yy342
.
pExpr
 ) yymsp[-4].minor.yy342.pExpr->
flags
 |= 0x000080;

95728 {
	`spanUnaryPostfix
(
pParse
,
yymsp
[0].
major
,&yymsp[-1].
minor
.
yy342
,&yymsp[0].minor.
yy0
);}

95731 {
	`spanUnaryPostfix
(
pParse
,77,&
yymsp
[-2].
minor
.
yy342
,&yymsp[0].minor.
yy0
);}

95735 
	`spanBinaryExpr
(
pParse
,73,&
yymsp
[-2].
minor
.
yy342
,&yymsp[0].minor.yy342);

95736 
	`binaryToUnaryIfNull
(
pParse
, 
yymsp
[0].
minor
.
yy342
.
pExpr
, yymsp[-2].minor.yy342.pExpr, 76);

95741 
	`spanBinaryExpr
(
pParse
,148,&
yymsp
[-3].
minor
.
yy342
,&yymsp[0].minor.yy342);

95742 
	`binaryToUnaryIfNull
(
pParse
, 
yymsp
[0].
minor
.
yy342
.
pExpr
, yymsp[-3].minor.yy342.pExpr, 77);

95747 {
	`spanUnaryPrefix
(&
yymsp
[-1].
minor
.
yy342
,
pParse
,yymsp[-1].
major
,&yymsp[0].minor.yy342,&yymsp[-1].minor.
yy0
); }

95750 {
	`spanUnaryPrefix
(&
yymsp
[-1].
minor
.
yy342
,
pParse
,155,&yymsp[0].minor.yy342,&yymsp[-1].minor.
yy0
); }

95753 {
	`spanUnaryPrefix
(&
yymsp
[-1].
minor
.
yy342
,
pParse
,156,&yymsp[0].minor.yy342,&yymsp[-1].minor.
yy0
); }

95757 {
yymsp
[0].
minor
.
yy392
 = 0;}

95761 
ExprList
 *
pList
 = 
	`sqlite3ExprListAppend
(
pParse
,0, 
yymsp
[-2].
minor
.
yy342
.
pExpr
);

95762 
pList
 = 
	`sqlite3ExprListAppend
(
pParse
,pList, 
yymsp
[0].
minor
.
yy342
.
pExpr
);

95763 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 74, yymsp[-4].minor.yy342.pExpr, 0, 0);

95764 if( 
yymsp
[-4].
minor
.
yy342
.
pExpr
 )

95767 
yymsp
[-4].
minor
.
yy342
.
pExpr
->
x
.
pList
 = pList;

95769 
	`sqlite3ExprListDelete
(
pParse
->
db
, 
pList
);

95771 
	`exprNot
(
pParse
, 
yymsp
[-3].
minor
.
yy392
, &yymsp[-4].minor.
yy342
);

95772 
yymsp
[-4].
minor
.
yy342
.
zEnd
 = yymsp[0].minor.yy342.zEnd;

95777 if( 
yymsp
[-1].
minor
.
yy442
==0 )

95781 
	`sqlite3ExprDelete
(
pParse
->
db
, 
yymsp
[-4].
minor
.
yy342
.
pExpr
);

95782 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 132, 0, 0, &
sqlite3IntTokens
[yymsp[-3].minor.
yy392
]);

95783 }else if( 
yymsp
[-1].
minor
.
yy442
->
nExpr
==1 )

95787 
Expr
 *
pRHS
 = 
yymsp
[-1].
minor
.
yy442
->
a
[0].
pExpr
;

95788 
yymsp
[-1].
minor
.
yy442
->
a
[0].
pExpr
 = 0;

95789 
	`sqlite3ExprListDelete
(
pParse
->
db
, 
yymsp
[-1].
minor
.
yy442
);

95792 if( (
pRHS
) )

95795 
pRHS
->
flags
 &= ~0x000100;

95796 
pRHS
->
flags
 |= 0x000200;

95798 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, yymsp[-3].minor.
yy392
 ? 78 : 79, yymsp[-4].minor.yy342.pExpr, 
pRHS
, 0);

95800 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 75, yymsp[-4].minor.yy342.pExpr, 0, 0);

95801 if( 
yymsp
[-4].
minor
.
yy342
.
pExpr
 )

95804 
yymsp
[-4].
minor
.
yy342
.
pExpr
->
x
.
pList
 = yymsp[-1].minor.
yy442
;

95805 
	`sqlite3ExprSetHeightAndFlags
(
pParse
, 
yymsp
[-4].
minor
.
yy342
.
pExpr
);

95807 
	`sqlite3ExprListDelete
(
pParse
->
db
, 
yymsp
[-1].
minor
.
yy442
);

95809 
	`exprNot
(
pParse
, 
yymsp
[-3].
minor
.
yy392
, &yymsp[-4].minor.
yy342
);

95811 
yymsp
[-4].
minor
.
yy342
.
zEnd
 = &yymsp[0].minor.
yy0
.
z
[yymsp[0].minor.yy0.
n
];

95816 
	`spanSet
(&
yymsp
[-2].
minor
.
yy342
,&yymsp[-2].minor.
yy0
,&yymsp[0].minor.yy0);

95817 
yymsp
[-2].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 119, 0, 0, 0);

95818 if( 
yymsp
[-2].
minor
.
yy342
.
pExpr
 )

95821 
yymsp
[-2].
minor
.
yy342
.
pExpr
->
x
.
pSelect
 = yymsp[-1].minor.
yy159
;

95822 (
yymsp
[-2].
minor
.
yy342
.
pExpr
)->
flags
|=(0x000800|0x200000);

95823 
	`sqlite3ExprSetHeightAndFlags
(
pParse
, 
yymsp
[-2].
minor
.
yy342
.
pExpr
);

95825 
	`sqlite3SelectDelete
(
pParse
->
db
, 
yymsp
[-1].
minor
.
yy159
);

95831 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 75, yymsp[-4].minor.yy342.pExpr, 0, 0);

95832 if( 
yymsp
[-4].
minor
.
yy342
.
pExpr
 )

95835 
yymsp
[-4].
minor
.
yy342
.
pExpr
->
x
.
pSelect
 = yymsp[-1].minor.
yy159
;

95836 (
yymsp
[-4].
minor
.
yy342
.
pExpr
)->
flags
|=(0x000800|0x200000);

95837 
	`sqlite3ExprSetHeightAndFlags
(
pParse
, 
yymsp
[-4].
minor
.
yy342
.
pExpr
);

95839 
	`sqlite3SelectDelete
(
pParse
->
db
, 
yymsp
[-1].
minor
.
yy159
);

95841 
	`exprNot
(
pParse
, 
yymsp
[-3].
minor
.
yy392
, &yymsp[-4].minor.
yy342
);

95842 
yymsp
[-4].
minor
.
yy342
.
zEnd
 = &yymsp[0].minor.
yy0
.
z
[yymsp[0].minor.yy0.
n
];

95847 
SrcList
 *
pSrc
 = 
	`sqlite3SrcListAppend
(
pParse
->
db
, 0,&
yymsp
[-1].
minor
.
yy0
,&yymsp[0].minor.yy0);

95848 
yymsp
[-3].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 75, yymsp[-3].minor.yy342.pExpr, 0, 0);

95849 if( 
yymsp
[-3].
minor
.
yy342
.
pExpr
 )

95852 
yymsp
[-3].
minor
.
yy342
.
pExpr
->
x
.
pSelect
 = 
	`sqlite3SelectNew
(
pParse
, 0,
pSrc
,0,0,0,0,0,0,0);

95853 (
yymsp
[-3].
minor
.
yy342
.
pExpr
)->
flags
|=(0x000800|0x200000);

95854 
	`sqlite3ExprSetHeightAndFlags
(
pParse
, 
yymsp
[-3].
minor
.
yy342
.
pExpr
);

95856 
	`sqlite3SrcListDelete
(
pParse
->
db
, 
pSrc
);

95858 
	`exprNot
(
pParse
, 
yymsp
[-2].
minor
.
yy392
, &yymsp[-3].minor.
yy342
);

95859 
yymsp
[-3].
minor
.
yy342
.
zEnd
 = yymsp[0].minor.
yy0
.
z
 ? &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.
n
] : &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n];

95864 
Expr
 *
p
;

95865 
	`spanSet
(&
yymsp
[-3].
minor
.
yy342
,&yymsp[-3].minor.
yy0
,&yymsp[0].minor.yy0);

95866 
p
 = 
yymsp
[-3].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 20, 0, 0, 0);

95867 if( 
p
 )

95870 
p
->
x
.
pSelect
 = 
yymsp
[-1].
minor
.
yy159
;

95871 (
p
)->
flags
|=(0x000800|0x200000);

95872 
	`sqlite3ExprSetHeightAndFlags
(
pParse
, 
p
);

95874 
	`sqlite3SelectDelete
(
pParse
->
db
, 
yymsp
[-1].
minor
.
yy159
);

95880 
	`spanSet
(&
yymsp
[-4].
minor
.
yy342
,&yymsp[-4].minor.
yy0
,&yymsp[0].minor.yy0);

95881 
yymsp
[-4].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 136, yymsp[-3].minor.
yy122
, 0, 0);

95882 if( 
yymsp
[-4].
minor
.
yy342
.
pExpr
 )

95885 
yymsp
[-4].
minor
.
yy342
.
pExpr
->
x
.
pList
 = yymsp[-1].minor.
yy122
 ? 
	`sqlite3ExprListAppend
(
pParse
,yymsp[-2].minor.
yy442
,yymsp[-1].minor.yy122) : yymsp[-2].minor.yy442;

95886 
	`sqlite3ExprSetHeightAndFlags
(
pParse
, 
yymsp
[-4].
minor
.
yy342
.
pExpr
);

95888 
	`sqlite3ExprListDelete
(
pParse
->
db
, 
yymsp
[-2].
minor
.
yy442
);

95889 
	`sqlite3ExprDelete
(
pParse
->
db
, 
yymsp
[-1].
minor
.
yy122
);

95895 
yymsp
[-4].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,yymsp[-4].minor.yy442, yymsp[-2].minor.
yy342
.
pExpr
);

95896 
yymsp
[-4].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,yymsp[-4].minor.yy442, yymsp[0].minor.
yy342
.
pExpr
);

95901 
yymsp
[-3].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,0, yymsp[-2].minor.
yy342
.
pExpr
);

95902 
yymsp
[-3].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,yymsp[-3].minor.yy442, yymsp[0].minor.
yy342
.
pExpr
);

95906 {
yymsp
[0].
minor
.
yy122
 = yymsp[0].minor.
yy342
.
pExpr
; }

95909 {
yymsp
[-2].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,yymsp[-2].minor.yy442,yymsp[0].minor.
yy342
.
pExpr
);}

95912 {
yymsp
[0].
minor
.
yy442
 = 
	`sqlite3ExprListAppend
(
pParse
,0,yymsp[0].minor.
yy342
.
pExpr
); }

95916 
	`sqlite3CreateIndex
(
pParse
, &
yymsp
[-7].
minor
.
yy0
, &yymsp[-6].minor.yy0,

95917 
	`sqlite3SrcListAppend
(
pParse
->
db
,0,&
yymsp
[-4].
minor
.
yy0
,0), yymsp[-2].minor.
yy442
, yymsp[-10].minor.
yy392
,

95918 &
yymsp
[-11].
minor
.
yy0
, yymsp[0].minor.
yy122
, 0, yymsp[-8].minor.
yy392
);

95923 {
yymsp
[0].
minor
.
yy392
 = 2;}

95926 {
yymsp
[1].
minor
.
yy392
 = 0;}

95929 {
yymsp
[-2].
minor
.
yy442
 = yymsp[-1].minor.yy442;}

95933 
yymsp
[-4].
minor
.
yy442
 = 
	`parserAddExprIdListTerm
(
pParse
, yymsp[-4].minor.yy442, &yymsp[-2].minor.
yy0
, yymsp[-1].minor.
yy392
, yymsp[0].minor.yy392);

95938 
yymsp
[-2].
minor
.
yy442
 = 
	`parserAddExprIdListTerm
(
pParse
, 0, &yymsp[-2].minor.
yy0
, yymsp[-1].minor.
yy392
, yymsp[0].minor.yy392);

95942 {
	`sqlite3DropIndex
(
pParse
, 
yymsp
[0].
minor
.
yy347
, yymsp[-1].minor.
yy392
);}

95946 {
	`sqlite3Vacuum
(
pParse
);}

95949 {
	`sqlite3Pragma
(
pParse
,&
yymsp
[-1].
minor
.
yy0
,&yymsp[0].minor.yy0,0,0);}

95952 {
	`sqlite3Pragma
(
pParse
,&
yymsp
[-3].
minor
.
yy0
,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}

95955 {
	`sqlite3Pragma
(
pParse
,&
yymsp
[-4].
minor
.
yy0
,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}

95958 {
	`sqlite3Pragma
(
pParse
,&
yymsp
[-3].
minor
.
yy0
,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}

95961 {
	`sqlite3Pragma
(
pParse
,&
yymsp
[-4].
minor
.
yy0
,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}

95965 
Token
 
all
;

95966 
all
.
z
 = 
yymsp
[-3].
minor
.
yy0
.z;

95967 
all
.
n
 = (int)(
yymsp
[0].
minor
.
yy0
.
z
 - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;

95968 
	`sqlite3FinishTrigger
(
pParse
, 
yymsp
[-1].
minor
.
yy327
, &
all
);

95973 
	`sqlite3BeginTrigger
(
pParse
, &
yymsp
[-7].
minor
.
yy0
, &yymsp[-6].minor.yy0, yymsp[-5].minor.
yy392
, yymsp[-4].minor.
yy410
.
a
, yymsp[-4].minor.yy410.
b
, yymsp[-2].minor.
yy347
, yymsp[0].minor.
yy122
, yymsp[-10].minor.yy392, yymsp[-8].minor.yy392);

95974 
yymsp
[-10].
minor
.
yy0
 = (yymsp[-6].minor.yy0.
n
==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0);

95978 { 
yymsp
[0].
minor
.
yy392
 = 35; }

95981 { 
yymsp
[0].
minor
.
yy392
 = 31; }

95984 { 
yymsp
[-1].
minor
.
yy392
 = 49;}

95987 { 
yymsp
[1].
minor
.
yy392
 = 35; }

95991 {
yymsp
[0].
minor
.
yy410
.
a
 = yymsp[0].
major
; yymsp[0].minor.yy410.
b
 = 0;}

95994 {
yymsp
[-2].
minor
.
yy410
.
a
 = 110; yymsp[-2].minor.yy410.
b
 = yymsp[0].minor.
yy180
;}

95998 { 
yymsp
[1].
minor
.
yy122
 = 0; }

96002 { 
yymsp
[-1].
minor
.
yy122
 = yymsp[0].minor.
yy342
.
pExpr
; }

96007 
yymsp
[-2].
minor
.
yy327
->
pLast
->
pNext
 = yymsp[-1].minor.yy327;

96008 
yymsp
[-2].
minor
.
yy327
->
pLast
 = yymsp[-1].minor.yy327;

96014 
yymsp
[-1].
minor
.
yy327
->
pLast
 = yymsp[-1].minor.yy327;

96019 
yymsp
[-2].
minor
.
yy0
 = yymsp[0].minor.yy0;

96020 
	`sqlite3ErrorMsg
(
pParse
,

96027 
	`sqlite3ErrorMsg
(
pParse
,

96034 
	`sqlite3ErrorMsg
(
pParse
,

96040 {
yymsp
[-6].
minor
.
yy327
 = 
	`sqlite3TriggerUpdateStep
(
pParse
->
db
, &yymsp[-4].minor.
yy0
, yymsp[-1].minor.
yy442
, yymsp[0].minor.
yy122
, yymsp[-5].minor.
yy392
);}

96043 {
yymsp
[-4].
minor
.
yy327
 = 
	`sqlite3TriggerInsertStep
(
pParse
->
db
, &yymsp[-2].minor.
yy0
, yymsp[-1].minor.
yy180
, yymsp[0].minor.
yy159
, yymsp[-4].minor.
yy392
); }

96046 {
yymsp
[-4].
minor
.
yy327
 = 
	`sqlite3TriggerDeleteStep
(
pParse
->
db
, &yymsp[-2].minor.
yy0
, yymsp[0].minor.
yy122
);}

96049 {
yymsp
[0].
minor
.
yy327
 = 
	`sqlite3TriggerSelectStep
(
pParse
->
db
, yymsp[0].minor.
yy159
); }

96053 
	`spanSet
(&
yymsp
[-3].
minor
.
yy342
,&yymsp[-3].minor.
yy0
,&yymsp[0].minor.yy0);

96054 
yymsp
[-3].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 57, 0, 0, 0);

96055 if( 
yymsp
[-3].
minor
.
yy342
.
pExpr
 )

96058 
yymsp
[-3].
minor
.
yy342
.
pExpr
->
affinity
 = 4;

96064 
	`spanSet
(&
yymsp
[-5].
minor
.
yy342
,&yymsp[-5].minor.
yy0
,&yymsp[0].minor.yy0);

96065 
yymsp
[-5].
minor
.
yy342
.
pExpr
 = 
	`sqlite3PExpr
(
pParse
, 57, 0, 0, &yymsp[-1].minor.
yy0
);

96066 if( 
yymsp
[-5].
minor
.
yy342
.
pExpr
 ) {

96067 
yymsp
[-5].
minor
.
yy342
.
pExpr
->
affinity
 = (char)yymsp[-3].minor.
yy392
;

96072 {
yymsp
[0].
minor
.
yy392
 = 1;}

96075 {
yymsp
[0].
minor
.
yy392
 = 3;}

96079 
	`sqlite3DropTrigger
(
pParse
,
yymsp
[0].
minor
.
yy347
,yymsp[-1].minor.
yy392
);

96084 
	`sqlite3Attach
(
pParse
, 
yymsp
[-3].
minor
.
yy342
.
pExpr
, yymsp[-1].minor.yy342.pExpr, yymsp[0].minor.
yy122
);

96089 
	`sqlite3Detach
(
pParse
, 
yymsp
[0].
minor
.
yy342
.
pExpr
);

96093 {
	`sqlite3Reindex
(
pParse
, 0, 0);}

96096 {
	`sqlite3Reindex
(
pParse
, &
yymsp
[-1].
minor
.
yy0
, &yymsp[0].minor.yy0);}

96099 {
	`sqlite3Analyze
(
pParse
, 0, 0);}

96102 {
	`sqlite3Analyze
(
pParse
, &
yymsp
[-1].
minor
.
yy0
, &yymsp[0].minor.yy0);}

96106 
	`sqlite3AlterRenameTable
(
pParse
,
yymsp
[-3].
minor
.
yy347
,&yymsp[0].minor.
yy0
);

96111 
yymsp
[-1].
minor
.
yy0
.
n
 = (int)(
pParse
->
sLastToken
.
z
-yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;

96112 
	`sqlite3AlterFinishAddColumn
(
pParse
, &
yymsp
[-1].
minor
.
yy0
);

96117 
	`disableLookaside
(
pParse
);

96118 
	`sqlite3AlterBeginAddColumn
(
pParse
, 
yymsp
[0].
minor
.
yy347
);

96122 {
	`sqlite3VtabFinishParse
(
pParse
,0);}

96125 {
	`sqlite3VtabFinishParse
(
pParse
,&
yymsp
[0].
minor
.
yy0
);}

96129 
	`sqlite3VtabBeginParse
(
pParse
, &
yymsp
[-3].
minor
.
yy0
, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.
yy392
);

96133 {
	`sqlite3VtabArgInit
(
pParse
);}

96138 {
	`sqlite3VtabArgExtend
(
pParse
,&
yymsp
[0].
minor
.
yy0
);}

96141 {
yymsp
[1].
minor
.
yy331
 = 0;}

96144 { 
yymsp
[-1].
minor
.
yy331
 = yymsp[0].minor.yy331; }

96147 { 
yymsp
[-2].
minor
.
yy331
 = yymsp[0].minor.yy331; }

96151 
yymsp
[-5].
minor
.
yy331
 = 
	`sqlite3WithAdd
(
pParse
, 0, &yymsp[-5].minor.
yy0
, yymsp[-4].minor.
yy442
, yymsp[-1].minor.
yy159
);

96156 
yymsp
[-7].
minor
.
yy331
 = 
	`sqlite3WithAdd
(
pParse
, yymsp[-7].minor.yy331, &yymsp[-5].minor.
yy0
, yymsp[-4].minor.
yy442
, yymsp[-1].minor.
yy159
);

96220 
yygoto
 = 
yyRuleInfo
[
yyruleno
].
lhs
;

96221 
yysize
 = 
yyRuleInfo
[
yyruleno
].
nrhs
;

96222 
yyact
 = 
	`yy_find_reduce_action
(
yymsp
[-
yysize
].
stateno
,(unsigned char)
yygoto
);

96223 if( 
yyact
 <= 974 )

96226 if( 
yyact
>439 ) yyact += 975 - 649;

96227 
yypParser
->
yyidx
 -= 
yysize
 - 1;

96228 
yymsp
 -= 
yysize
-1;

96229 
yymsp
->
stateno
 = (unsigned short int)
yyact
;

96230 
yymsp
->
major
 = (unsigned char)
yygoto
;

96234 
yypParser
->
yyidx
 -= 
yysize
;

96235 
	`yy_accept
(
yypParser
);

96237 
	}
}

96239 static void 
	$yy_syntax_error
(

96240 
yyParser
 *
yypParser
,

96241 int 
yymajor
,

96242 
Token
 
yyminor


96246 
Parse
 *
pParse
 = 
yypParser
->pParse;

96250 (void)(
yymajor
);

96252 
	`sqlite3ErrorMsg
(
pParse
, "near \"%T\": syntax error", &
yyminor
);

96254 
yypParser
->
pParse
 = pParse;

96255 
	}
}

96260 static void 
	$yy_accept
(

96261 
yyParser
 *
yypParser


96265 
Parse
 *
pParse
 = 
yypParser
->pParse;

96271 while( 
yypParser
->
yyidx
>=0 ) 
	`yy_pop_parser_stack
(yypParser);

96276 
yypParser
->
pParse
 = pParse;

96277 
	}
}

96279 static void 
	$sqlite3Parser
(

96280 void *
yyp
,

96281 int 
yymajor
,

96282 
Token
 
yyminor


96283 ,
Parse
 *
pParse


96287 
YYMINORTYPE
 
yyminorunion
;

96288 unsigned int 
yyact
;

96295 
yyParser
 *
yypParser
;

96298 
yypParser
 = (
yyParser
*)
yyp
;

96299 if( 
yypParser
->
yyidx
<0 )

96308 
yypParser
->
yyidx
 = 0;

96312 
yypParser
->
yystack
[0].
stateno
 = 0;

96313 
yypParser
->
yystack
[0].
major
 = 0;

96324 
yypParser
->
pParse
 = pParse;

96333 
yyact
 = 
	`yy_find_shift_action
(
yypParser
,(unsigned char)
yymajor
);

96334 if( 
yyact
 <= 974 )

96337 if( 
yyact
 > 439 ) yyact += 975 - 649;

96338 
	`yy_shift
(
yypParser
,
yyact
,
yymajor
,
yyminor
);

96342 
yymajor
 = 251;

96343 }else if( 
yyact
 <= 1300 )

96346 
	`yy_reduce
(
yypParser
,
yyact
-975);

96349 
yyminorunion
.
yy0
 = 
yyminor
;

96351 
	`yy_syntax_error
(
yypParser
,
yymajor
, 
yyminor
);

96352 
	`yy_destructor
(
yypParser
,(unsigned char)
yymajor
,&
yyminorunion
);

96353 
yymajor
 = 251;

96356 }while( 
yymajor
!=251 && 
yypParser
->
yyidx
>=0 );

96359 
	}
}

96361 static const unsigned char 
	gaiClass
[] = {

96383 static int 
	$keywordCode
(const char *
z
, int 
n
, int *
pType
)

96387 static const char 
zText
[553] = {

96420 static const unsigned char 
aHash
[127] = {

96432 static const unsigned char 
aNext
[124] = {

96444 static const unsigned char 
aLen
[124] = {

96456 static const unsigned short int 
aOffset
[124] = {

96468 static const unsigned char 
aCode
[124] = {

96495 int 
i
, 
j
;

96496 const char *
zKW
;

96497 if( 
n
>=2 )

96500 
i
 = ((
sqlite3UpperToLower
[(unsigned char)
z
[0]]*4) ^ (sqlite3UpperToLower[(unsigned char)z[
n
-1]]*3) ^ n) % 127;

96501 for(
i
=((int)
aHash
[i])-1; i>=0; i=((int)
aNext
[i])-1)

96504 if( 
aLen
[
i
]!=
n
 ) continue;

96505 
j
 = 0;

96506 
zKW
 = &
zText
[
aOffset
[
i
]];

96508 while( 
j
<
n
 && (
z
[j]&~0x20)==
zKW
[j] )

96510 
j
++; }

96515 if( 
j
<
n
 ) continue;

96640 *
pType
 = 
aCode
[
i
];

96644 return 
n
;

96645 
	}
}

96646 static int 
	$sqlite3KeywordCode
(const unsigned char *
z
, int 
n
)

96649 int 
id
 = 27;

96650 
	`keywordCode
((char*)
z
, 
n
, &
id
);

96651 return 
id
;

96652 
	}
}

96654 static int 
	$sqlite3IsIdChar
(
u8
 
c
)

96656 return ((
sqlite3CtypeMap
[(unsigned char)
c
]&0x46)!=0); 
	}
}

96664 static int 
	$sqlite3GetToken
(const unsigned char *
z
, int *
tokenType
)

96667 int 
i
, 
c
;

96668 switch( 
aiClass
[*
z
] )

96679 for(
i
=1; (
sqlite3CtypeMap
[(unsigned char)(
z
[i])]&0x01); i++)

96682 *
tokenType
 = 160;

96683 return 
i
;

96686 if( 
z
[1]=='-' )

96689 for(
i
=2; (
c
=
z
[i])!=0 && c!='\n'; i++)

96692 *
tokenType
 = 160;

96693 return 
i
;

96695 *
tokenType
 = 90;

96699 *
tokenType
 = 22;

96703 *
tokenType
 = 23;

96707 *
tokenType
 = 1;

96711 *
tokenType
 = 89;

96715 *
tokenType
 = 91;

96719 if( 
z
[1]!='*' || z[2]==0 )

96722 *
tokenType
 = 92;

96725 for(
i
=3, 
c
=
z
[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++)

96728 if( 
c
 ) 
i
++;

96729 *
tokenType
 = 160;

96730 return 
i
;

96733 *
tokenType
 = 93;

96737 *
tokenType
 = 79;

96738 return 1 + (
z
[1]=='=');

96741 if( (
c
=
z
[1])=='=' )

96744 *
tokenType
 = 81;

96746 }else if( 
c
=='>' )

96749 *
tokenType
 = 78;

96751 }else if( 
c
=='<' )

96754 *
tokenType
 = 87;

96757 *
tokenType
 = 82;

96762 if( (
c
=
z
[1])=='=' )

96765 *
tokenType
 = 83;

96767 }else if( 
c
=='>' )

96770 *
tokenType
 = 88;

96773 *
tokenType
 = 80;

96778 if( 
z
[1]!='=' )

96781 *
tokenType
 = 161;

96784 *
tokenType
 = 78;

96789 if( 
z
[1]!='|' )

96792 *
tokenType
 = 86;

96795 *
tokenType
 = 94;

96800 *
tokenType
 = 26;

96804 *
tokenType
 = 85;

96808 *
tokenType
 = 96;

96812 int 
delim
 = 
z
[0];

96816 for(
i
=1; (
c
=
z
[i])!=0; i++)

96819 if( 
c
==
delim
 )

96822 if( 
z
[
i
+1]==
delim
 )

96825 
i
++;

96831 if( 
c
=='\'' )

96834 *
tokenType
 = 97;

96835 return 
i
+1;

96836 }else if( 
c
!=0 )

96839 *
tokenType
 = 27;

96840 return 
i
+1;

96842 *
tokenType
 = 161;

96843 return 
i
;

96848 if( !(
sqlite3CtypeMap
[(unsigned char)(
z
[1])]&0x04) )

96851 *
tokenType
 = 122;

96862 *
tokenType
 = 132;

96864 if( 
z
[0]=='0' && (z[1]=='x' || z[1]=='X') && (
sqlite3CtypeMap
[(unsigned char)(z[2])]&0x08) )

96867 for(
i
=3; (
sqlite3CtypeMap
[(unsigned char)(
z
[i])]&0x08); i++)

96870 return 
i
;

96873 for(
i
=0; (
sqlite3CtypeMap
[(unsigned char)(
z
[i])]&0x04); i++)

96877 if( 
z
[
i
]=='.' )

96880 
i
++;

96881 while( (
sqlite3CtypeMap
[(unsigned char)(
z
[
i
])]&0x04) )

96883 
i
++; }

96884 *
tokenType
 = 133;

96886 if( (
z
[
i
]=='e' || z[i]=='E') &&

96887 ( (
sqlite3CtypeMap
[(unsigned char)(
z
[
i
+1])]&0x04)

96888 || ((
z
[
i
+1]=='+' || z[i+1]=='-') && (
sqlite3CtypeMap
[(unsigned char)(z[i+2])]&0x04))

96893 
i
 += 2;

96894 while( (
sqlite3CtypeMap
[(unsigned char)(
z
[
i
])]&0x04) )

96896 
i
++; }

96897 *
tokenType
 = 133;

96900 while( ((
sqlite3CtypeMap
[(unsigned char)
z
[
i
]]&0x46)!=0) )

96903 *
tokenType
 = 161;

96904 
i
++;

96906 return 
i
;

96909 for(
i
=1, 
c
=
z
[0]; c!=']' && (c=z[i])!=0; i++)

96912 *
tokenType
 = 
c
==']' ? 27 : 161;

96913 return 
i
;

96916 *
tokenType
 = 135;

96917 for(
i
=1; (
sqlite3CtypeMap
[(unsigned char)(
z
[i])]&0x04); i++)

96920 return 
i
;

96924 int 
n
 = 0;

96927 *
tokenType
 = 135;

96928 for(
i
=1; (
c
=
z
[i])!=0; i++)

96931 if( ((
sqlite3CtypeMap
[(unsigned char)
c
]&0x46)!=0) )

96934 
n
++;

96936 }else if( 
c
=='(' && 
n
>0 )

96940 
i
++;

96941 }while( (
c
=
z
[
i
])!=0 && !(
sqlite3CtypeMap
[(unsigned char)(c)]&0x01) && c!=')' );

96942 if( 
c
==')' )

96945 
i
++;

96947 *
tokenType
 = 161;

96950 }else if( 
c
==':' && 
z
[
i
+1]==':' )

96953 
i
++;

96959 if( 
n
==0 ) *
tokenType
 = 161;

96960 return 
i
;

96963 for(
i
=1; 
aiClass
[
z
[i]]<=1; i++)

96966 if( ((
sqlite3CtypeMap
[(unsigned char)
z
[
i
]]&0x46)!=0) )

96972 
i
++;

96975 *
tokenType
 = 27;

96976 return 
	`keywordCode
((char*)
z
, 
i
, 
tokenType
);

96981 if( 
z
[1]=='\'' )

96984 *
tokenType
 = 134;

96985 for(
i
=2; (
sqlite3CtypeMap
[(unsigned char)(
z
[i])]&0x08); i++)

96988 if( 
z
[
i
]!='\'' || i%2 )

96991 *
tokenType
 = 161;

96992 while( 
z
[
i
] && z[i]!='\'' )

96994 
i
++; }

96996 if( 
z
[
i
] ) i++;

96997 return 
i
;

97004 
i
 = 1;

97008 *
tokenType
 = 161;

97012 while( ((
sqlite3CtypeMap
[(unsigned char)
z
[
i
]]&0x46)!=0) )

97014 
i
++; }

97015 *
tokenType
 = 27;

97016 return 
i
;

97017 
	}
}

97019 static int 
	$sqlite3RunParser
(
Parse
 *
pParse
, const char *
zSql
, char **
pzErrMsg
)

97022 int 
nErr
 = 0;

97023 int 
i
;

97024 void *
pEngine
;

97025 int 
tokenType
;

97026 int 
lastTokenParsed
 = -1;

97027 
sqlite3
 *
db
 = 
pParse
->db;

97028 int 
mxSqlLen
;

97031 
mxSqlLen
 = 
db
->
aLimit
[1];

97032 if( 
db
->
nVdbeActive
==0 )

97035 
db
->
u1
.
isInterrupted
 = 0;

97037 
pParse
->
rc
 = 0;

97038 
pParse
->
zTail
 = 
zSql
;

97039 
i
 = 0;

97042 
pEngine
 = 
	`sqlite3ParserAlloc
(
sqlite3Malloc
);

97043 if( 
pEngine
==0 )

97046 
	`sqlite3OomFault
(
db
);

97054 while( 
zSql
[
i
]!=0 )

97058 
pParse
->
sLastToken
.
z
 = &
zSql
[
i
];

97059 
pParse
->
sLastToken
.
n
 = 
	`sqlite3GetToken
((unsigned char*)&
zSql
[
i
],&
tokenType
);

97060 
i
 += 
pParse
->
sLastToken
.
n
;

97061 if( 
i
>
mxSqlLen
 )

97064 
pParse
->
rc
 = 18;

97067 if( 
tokenType
>=160 )

97071 if( 
db
->
u1
.
isInterrupted
 )

97074 
pParse
->
rc
 = 9;

97077 if( 
tokenType
==161 )

97080 
	`sqlite3ErrorMsg
(
pParse
, "unrecognized token: \"%T\"",

97081 &
pParse
->
sLastToken
);

97085 
	`sqlite3Parser
(
pEngine
, 
tokenType
, 
pParse
->
sLastToken
, pParse);

97086 
lastTokenParsed
 = 
tokenType
;

97087 if( 
pParse
->
rc
!=0 || 
db
->
mallocFailed
 ) break;

97091 
pParse
->
zTail
 = &
zSql
[
i
];

97092 if( 
pParse
->
rc
==0 && 
db
->
mallocFailed
==0 )

97096 if( 
lastTokenParsed
!=1 )

97099 
	`sqlite3Parser
(
pEngine
, 1, 
pParse
->
sLastToken
, pParse);

97101 if( 
pParse
->
rc
==0 && 
db
->
mallocFailed
==0 )

97104 
	`sqlite3Parser
(
pEngine
, 0, 
pParse
->
sLastToken
, pParse);

97114 
	`sqlite3ParserFree
(
pEngine
, 
sqlite3_free
);

97115 if( 
db
->
mallocFailed
 )

97118 
pParse
->
rc
 = 7;

97120 if( 
pParse
->
rc
!=0 && pParse->rc!=101 && pParse->
zErrMsg
==0 )

97123 
pParse
->
zErrMsg
 = 
	`sqlite3MPrintf
(
db
, "%s", 
	`sqlite3ErrStr
(pParse->
rc
));

97126 if( 
pParse
->
zErrMsg
 )

97129 *
pzErrMsg
 = 
pParse
->
zErrMsg
;

97130 
	`sqlite3_log
(
pParse
->
rc
, "%s", *
pzErrMsg
);

97131 
pParse
->
zErrMsg
 = 0;

97132 
nErr
++;

97134 if( 
pParse
->
pVdbe
 && pParse->
nErr
>0 && pParse->
nested
==0 )

97137 
	`sqlite3VdbeDelete
(
pParse
->
pVdbe
);

97138 
pParse
->
pVdbe
 = 0;

97141 if( 
pParse
->
nested
==0 )

97144 
	`sqlite3DbFree
(
db
, 
pParse
->
aTableLock
);

97145 
pParse
->
aTableLock
 = 0;

97146 
pParse
->
nTableLock
 = 0;

97150 
	`sqlite3_free
(
pParse
->
apVtabLock
);

97153 if( !(
pParse
->
declareVtab
) )

97160 
	`sqlite3DeleteTable
(
db
, 
pParse
->
pNewTable
);

97163 
	`sqlite3WithDelete
(
db
, 
pParse
->
pWithToFree
);

97164 
	`sqlite3DeleteTrigger
(
db
, 
pParse
->
pNewTrigger
);

97165 for(
i
=
pParse
->
nzVar
-1; i>=0; i--) 
	`sqlite3DbFree
(
db
, pParse->
azVar
[i]);

97166 
	`sqlite3DbFree
(
db
, 
pParse
->
azVar
);

97167 while( 
pParse
->
pAinc
 )

97170 
AutoincInfo
 *
p
 = 
pParse
->
pAinc
;

97171 
pParse
->
pAinc
 = 
p
->
pNext
;

97172 
	`sqlite3DbFree
(
db
, 
p
);

97174 while( 
pParse
->
pZombieTab
 )

97177 
Table
 *
p
 = 
pParse
->
pZombieTab
;

97178 
pParse
->
pZombieTab
 = 
p
->
pNextZombie
;

97179 
	`sqlite3DeleteTable
(
db
, 
p
);

97182 return 
nErr
;

97183 
	}
}

97185 int 
	$sqlite3_complete
(const char *
zSql
)

97188 
u8
 
state
 = 0;

97189 
u8
 
token
;

97195 static const 
u8
 
trans
[8][8] = {

97208 while( *
zSql
 )

97211 switch( *
zSql
 )

97215 
token
 = 0;

97223 
token
 = 1;

97227 if( 
zSql
[1]!='*' )

97230 
token
 = 2;

97233 
zSql
 += 2;

97234 while( 
zSql
[0] && (zSql[0]!='*' || zSql[1]!='/') )

97236 
zSql
++; }

97237 if( 
zSql
[0]==0 ) return 0;

97238 
zSql
++;

97239 
token
 = 1;

97243 if( 
zSql
[1]!='-' )

97246 
token
 = 2;

97249 while( *
zSql
 && *zSql!='\n' )

97251 
zSql
++; }

97252 if( *
zSql
==0 ) return 
state
==1;

97253 
token
 = 1;

97257 
zSql
++;

97258 while( *
zSql
 && *zSql!=']' )

97260 
zSql
++; }

97261 if( *
zSql
==0 ) return 0;

97262 
token
 = 2;

97268 int 
c
 = *
zSql
;

97269 
zSql
++;

97270 while( *
zSql
 && *zSql!=
c
 )

97272 
zSql
++; }

97273 if( *
zSql
==0 ) return 0;

97274 
token
 = 2;

97281 if( ((
sqlite3CtypeMap
[(unsigned char)(
u8
)*
zSql
]&0x46)!=0) )

97285 int 
nId
;

97286 for(
nId
=1; ((
sqlite3CtypeMap
[(unsigned char)
zSql
[nId]]&0x46)!=0); nId++)

97292 switch( *
zSql
 )

97296 if( 
nId
==6 && 
	`sqlite3_strnicmp
(
zSql
, "create", 6)==0 )

97299 
token
 = 4;

97301 
token
 = 2;

97306 if( 
nId
==7 && 
	`sqlite3_strnicmp
(
zSql
, "trigger", 7)==0 )

97309 
token
 = 6;

97310 }else if( 
nId
==4 && 
	`sqlite3_strnicmp
(
zSql
, "temp", 4)==0 )

97313 
token
 = 5;

97314 }else if( 
nId
==9 && 
	`sqlite3_strnicmp
(
zSql
, "temporary", 9)==0 )

97317 
token
 = 5;

97319 
token
 = 2;

97324 if( 
nId
==3 && 
	`sqlite3_strnicmp
(
zSql
, "end", 3)==0 )

97327 
token
 = 7;

97330 if( 
nId
==7 && 
	`sqlite3_strnicmp
(
zSql
, "explain", 7)==0 )

97333 
token
 = 3;

97337 
token
 = 2;

97342 
token
 = 2;

97347 
zSql
 += 
nId
-1;

97350 
token
 = 2;

97355 
state
 = 
trans
[state][
token
];

97356 
zSql
++;

97358 return 
state
==1;

97359 
	}
}

97367 int 
	$sqlite3_complete16
(const void *
zSql
)

97370 
sqlite3_value
 *
pVal
;

97371 char const *
zSql8
;

97372 int 
rc
;

97375 
rc
 = 
	`sqlite3_initialize
();

97376 if( 
rc
 ) return rc;

97378 
pVal
 = 
	`sqlite3ValueNew
(0);

97379 
	`sqlite3ValueSetStr
(
pVal
, -1, 
zSql
, 2, ((
sqlite3_destructor_type
)0));

97380 
zSql8
 = 
	`sqlite3ValueText
(
pVal
, 1);

97381 if( 
zSql8
 )

97384 
rc
 = 
	`sqlite3_complete
(
zSql8
);

97386 
rc
 = 7;

97388 
	`sqlite3ValueFree
(
pVal
);

97389 return 
rc
 & 0xff;

97390 
	}
}

97392 const char * 
	$sqlite3_libversion
(void)

97394 return 
sqlite3_version
; 
	}
}

97400 const char * 
	$sqlite3_sourceid
(void)

97402 return "2016-03-29 10:14:15 e9bb4cf40f4971974a74468ef922bdee481c988b"; 
	}
}

97407 int 
	$sqlite3_libversion_number
(void)

97409 return 3012000; 
	}
}

97415 int 
	$sqlite3_threadsafe
(void)

97417 return 1; 
	}
}

97419 char *
	gsqlite3_temp_directory
 = 0;

97421 char *
	gsqlite3_data_directory
 = 0;

97423 int 
	$sqlite3_initialize
(void)

97426 
sqlite3_mutex
 *
pMaster
;

97427 int 
rc
;

97436 if( 
sqlite3Config
.
isInit
 ) return 0;

97438 
rc
 = 
	`sqlite3MutexInit
();

97439 if( 
rc
 ) return rc;

97447 
pMaster
 = 
	`sqlite3MutexAlloc
(2);

97448 
	`sqlite3_mutex_enter
(
pMaster
);

97449 
sqlite3Config
.
isMutexInit
 = 1;

97450 if( !
sqlite3Config
.
isMallocInit
 )

97453 
rc
 = 
	`sqlite3MallocInit
();

97455 if( 
rc
==0 )

97458 
sqlite3Config
.
isMallocInit
 = 1;

97459 if( !
sqlite3Config
.
pInitMutex
 )

97462 
sqlite3Config
.
pInitMutex
 =

97463 
	`sqlite3MutexAlloc
(1);

97464 if( 
sqlite3Config
.
bCoreMutex
 && !sqlite3Config.
pInitMutex
 )

97467 
rc
 = 7;

97471 if( 
rc
==0 )

97474 
sqlite3Config
.
nRefInitMutex
++;

97476 
	`sqlite3_mutex_leave
(
pMaster
);

97481 if( 
rc
!=0 )

97484 return 
rc
;

97487 
	`sqlite3_mutex_enter
(
sqlite3Config
.
pInitMutex
);

97488 if( 
sqlite3Config
.
isInit
==0 && sqlite3Config.
inProgress
==0 )

97491 
sqlite3Config
.
inProgress
 = 1;

97498 
	`memset
(&
sqlite3BuiltinFunctions
, 0, sizeof(sqlite3BuiltinFunctions));

97499 
	`sqlite3RegisterBuiltinFunctions
();

97500 if( 
sqlite3Config
.
isPCacheInit
==0 )

97503 
rc
 = 
	`sqlite3PcacheInitialize
();

97505 if( 
rc
==0 )

97508 
sqlite3Config
.
isPCacheInit
 = 1;

97509 
rc
 = 
	`sqlite3OsInit
();

97511 if( 
rc
==0 )

97514 
	`sqlite3PCacheBufferSetup
( 
sqlite3Config
.
pPage
,

97515 
sqlite3Config
.
szPage
, sqlite3Config.
nPage
);

97516 
sqlite3Config
.
isInit
 = 1;

97521 
sqlite3Config
.
inProgress
 = 0;

97523 
	`sqlite3_mutex_leave
(
sqlite3Config
.
pInitMutex
);

97528 
	`sqlite3_mutex_enter
(
pMaster
);

97529 
sqlite3Config
.
nRefInitMutex
--;

97530 if( 
sqlite3Config
.
nRefInitMutex
<=0 )

97534 
	`sqlite3_mutex_free
(
sqlite3Config
.
pInitMutex
);

97535 
sqlite3Config
.
pInitMutex
 = 0;

97537 
	`sqlite3_mutex_leave
(
pMaster
);

97539 return 
rc
;

97540 
	}
}

97542 int 
	$sqlite3_shutdown
(void)

97552 if( 
sqlite3Config
.
isInit
 )

97559 
	`sqlite3_os_end
();

97560 
	`sqlite3_reset_auto_extension
();

97561 
sqlite3Config
.
isInit
 = 0;

97563 if( 
sqlite3Config
.
isPCacheInit
 )

97566 
	`sqlite3PcacheShutdown
();

97567 
sqlite3Config
.
isPCacheInit
 = 0;

97569 if( 
sqlite3Config
.
isMallocInit
 )

97572 
	`sqlite3MallocEnd
();

97573 
sqlite3Config
.
isMallocInit
 = 0;

97575 
sqlite3_data_directory
 = 0;

97576 
sqlite3_temp_directory
 = 0;

97579 if( 
sqlite3Config
.
isMutexInit
 )

97582 
	`sqlite3MutexEnd
();

97583 
sqlite3Config
.
isMutexInit
 = 0;

97587 
	}
}

97589 int 
	$sqlite3_config
(int 
op
, ...)

97592 
va_list
 
ap
;

97593 int 
rc
 = 0;

97597 if( 
sqlite3Config
.
isInit
 ) return 
	`sqlite3MisuseError
(133555);

97599 
	`__builtin_va_start
(
ap
,
op
);

97600 switch( 
op
 )

97611 
sqlite3Config
.
bCoreMutex
 = 0;

97612 
sqlite3Config
.
bFullMutex
 = 0;

97620 
sqlite3Config
.
bCoreMutex
 = 1;

97621 
sqlite3Config
.
bFullMutex
 = 0;

97629 
sqlite3Config
.
bCoreMutex
 = 1;

97630 
sqlite3Config
.
bFullMutex
 = 1;

97637 
sqlite3Config
.
mutex
 = *
	`__builtin_va_arg
(
ap
,
sqlite3_mutex_methods
*);

97644 *
	`__builtin_va_arg
(
ap
,
sqlite3_mutex_methods
*) = 
sqlite3Config
.
mutex
;

97655 
sqlite3Config
.
m
 = *
	`__builtin_va_arg
(
ap
,
sqlite3_mem_methods
*);

97663 if( 
sqlite3Config
.
m
.
xMalloc
==0 ) 
	`sqlite3MemSetDefault
();

97664 *
	`__builtin_va_arg
(
ap
,
sqlite3_mem_methods
*) = 
sqlite3Config
.
m
;

97671 
sqlite3Config
.
bMemstat
 = 
	`__builtin_va_arg
(
ap
,int);

97679 
sqlite3Config
.
pScratch
 = 
	`__builtin_va_arg
(
ap
,void*);

97680 
sqlite3Config
.
szScratch
 = 
	`__builtin_va_arg
(
ap
,int);

97681 
sqlite3Config
.
nScratch
 = 
	`__builtin_va_arg
(
ap
,int);

97689 
sqlite3Config
.
pPage
 = 
	`__builtin_va_arg
(
ap
,void*);

97690 
sqlite3Config
.
szPage
 = 
	`__builtin_va_arg
(
ap
,int);

97691 
sqlite3Config
.
nPage
 = 
	`__builtin_va_arg
(
ap
,int);

97699 *
	`__builtin_va_arg
(
ap
,int*) =

97700 
	`sqlite3HeaderSizeBtree
() +

97701 
	`sqlite3HeaderSizePcache
() +

97702 
	`sqlite3HeaderSizePcache1
();

97712 
rc
 = 1;

97721 
sqlite3Config
.
pcache2
 = *
	`__builtin_va_arg
(
ap
,
sqlite3_pcache_methods2
*);

97729 if( 
sqlite3Config
.
pcache2
.
xInit
==0 )

97732 
	`sqlite3PCacheSetDefault
();

97734 *
	`__builtin_va_arg
(
ap
,
sqlite3_pcache_methods2
*) = 
sqlite3Config
.
pcache2
;

97739 
sqlite3Config
.
szLookaside
 = 
	`__builtin_va_arg
(
ap
,int);

97740 
sqlite3Config
.
nLookaside
 = 
	`__builtin_va_arg
(
ap
,int);

97753 typedef void(*
	tLOGFUNC_t
)(void*,int,const char*);

97754 
sqlite3Config
.
xLog
 = 
	`__builtin_va_arg
(
ap
,
LOGFUNC_t
);

97755 
sqlite3Config
.
pLogArg
 = 
	`__builtin_va_arg
(
ap
,void*);

97769 
sqlite3Config
.
bOpenUri
 = 
	`__builtin_va_arg
(
ap
,int);

97778 
sqlite3Config
.
bUseCis
 = 
	`__builtin_va_arg
(
ap
,int);

97787 
sqlite3_int64
 
szMmap
 = 
	`__builtin_va_arg
(
ap
,sqlite3_int64);

97788 
sqlite3_int64
 
mxMmap
 = 
	`__builtin_va_arg
(
ap
,sqlite3_int64);

97790 if( 
mxMmap
<0 || mxMmap>0x7fff0000 )

97793 
mxMmap
 = 0x7fff0000;

97795 if( 
szMmap
<0 ) szMmap = 0;

97796 if( 
szMmap
>
mxMmap
) szMmap = mxMmap;

97797 
sqlite3Config
.
mxMmap
 = mxMmap;

97798 
sqlite3Config
.
szMmap
 = szMmap;

97803 
sqlite3Config
.
szPma
 = 
	`__builtin_va_arg
(
ap
,unsigned int);

97808 
sqlite3Config
.
nStmtSpill
 = 
	`__builtin_va_arg
(
ap
,int);

97813 
rc
 = 1;

97817 
	`__builtin_va_end
(
ap
);

97818 return 
rc
;

97819 
	}
}

97821 static int 
	$setupLookaside
(
sqlite3
 *
db
, void *
pBuf
, int 
sz
, int 
cnt
)

97825 void *
pStart
;

97826 if( 
db
->
lookaside
.
nOut
 )

97835 if( 
db
->
lookaside
.
bMalloced
 )

97838 
	`sqlite3_free
(
db
->
lookaside
.
pStart
);

97843 
sz
 = ((sz)&~7);

97844 if( 
sz
<=(int)sizeof(
LookasideSlot
*) ) sz = 0;

97845 if( 
cnt
<0 ) cnt = 0;

97846 if( 
sz
==0 || 
cnt
==0 )

97849 
sz
 = 0;

97850 
pStart
 = 0;

97851 }else if( 
pBuf
==0 )

97854 
	`sqlite3BeginBenignMalloc
();

97855 
pStart
 = 
	`sqlite3Malloc
( 
sz
*
cnt
 );

97856 
	`sqlite3EndBenignMalloc
();

97857 if( 
pStart
 ) 
cnt
 = 
	`sqlite3MallocSize
(pStart)/
sz
;

97859 
pStart
 = 
pBuf
;

97861 
db
->
lookaside
.
pStart
 = pStart;

97862 
db
->
lookaside
.
pFree
 = 0;

97863 
db
->
lookaside
.
sz
 = (
u16
)sz;

97864 if( 
pStart
 )

97867 int 
i
;

97868 
LookasideSlot
 *
p
;

97870 
p
 = (
LookasideSlot
*)
pStart
;

97871 for(
i
=
cnt
-1; i>=0; i--)

97874 
p
->
pNext
 = 
db
->
lookaside
.
pFree
;

97875 
db
->
lookaside
.
pFree
 = 
p
;

97876 
p
 = (
LookasideSlot
*)&((
u8
*)p)[
sz
];

97878 
db
->
lookaside
.
pEnd
 = 
p
;

97879 
db
->
lookaside
.
bDisable
 = 0;

97880 
db
->
lookaside
.
bMalloced
 = 
pBuf
==0 ?1:0;

97882 
db
->
lookaside
.
pStart
 = db;

97883 
db
->
lookaside
.
pEnd
 = db;

97884 
db
->
lookaside
.
bDisable
 = 1;

97885 
db
->
lookaside
.
bMalloced
 = 0;

97889 
	}
}

97894 
sqlite3_mutex
 * 
	$sqlite3_db_mutex
(
sqlite3
 *
db
)

97903 return 
db
->
mutex
;

97904 
	}
}

97910 int 
	$sqlite3_db_release_memory
(
sqlite3
 *
db
)

97913 int 
i
;

97918 
	`sqlite3_mutex_enter
(
db
->
mutex
);

97919 
	`sqlite3BtreeEnterAll
(
db
);

97920 for(
i
=0; i<
db
->
nDb
; i++)

97923 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

97924 if( 
pBt
 )

97927 
Pager
 *
pPager
 = 
	`sqlite3BtreePager
(
pBt
);

97928 
	`sqlite3PagerShrink
(
pPager
);

97931 
	`sqlite3BtreeLeaveAll
(
db
);

97932 
	`sqlite3_mutex_leave
(
db
->
mutex
);

97934 
	}
}

97940 int 
	$sqlite3_db_cacheflush
(
sqlite3
 *
db
)

97943 int 
i
;

97944 int 
rc
 = 0;

97945 int 
bSeenBusy
 = 0;

97950 
	`sqlite3_mutex_enter
(
db
->
mutex
);

97951 
	`sqlite3BtreeEnterAll
(
db
);

97952 for(
i
=0; 
rc
==0 && i<
db
->
nDb
; i++)

97955 
Btree
 *
pBt
 = 
db
->
aDb
[
i
].pBt;

97956 if( 
pBt
 && 
	`sqlite3BtreeIsInTrans
(pBt) )

97959 
Pager
 *
pPager
 = 
	`sqlite3BtreePager
(
pBt
);

97960 
rc
 = 
	`sqlite3PagerFlush
(
pPager
);

97961 if( 
rc
==5 )

97964 
bSeenBusy
 = 1;

97965 
rc
 = 0;

97969 
	`sqlite3BtreeLeaveAll
(
db
);

97970 
	`sqlite3_mutex_leave
(
db
->
mutex
);

97971 return ((
rc
==0 && 
bSeenBusy
) ? 5 : rc);

97972 
	}
}

97977 int 
	$sqlite3_db_config
(
sqlite3
 *
db
, int 
op
, ...)

97980 
va_list
 
ap
;

97981 int 
rc
;

97982 
	`__builtin_va_start
(
ap
,
op
);

97983 switch( 
op
 )

97987 void *
pBuf
 = 
	`__builtin_va_arg
(
ap
,void*);

97988 int 
sz
 = 
	`__builtin_va_arg
(
ap
,int);

97989 int 
cnt
 = 
	`__builtin_va_arg
(
ap
,int);

97990 
rc
 = 
	`setupLookaside
(
db
, 
pBuf
, 
sz
, 
cnt
);

97995 int 
op
;

97996 
u32
 
mask
;

97997 } 
aFlagOp
[] = {

98002 unsigned int 
i
;

98003 
rc
 = 1;

98004 for(
i
=0; i<((int)(sizeof(
aFlagOp
)/sizeof(aFlagOp[0]))); i++)

98007 if( 
aFlagOp
[
i
].
op
==op )

98010 int 
onoff
 = 
	`__builtin_va_arg
(
ap
,int);

98011 int *
pRes
 = 
	`__builtin_va_arg
(
ap
,int*);

98012 int 
oldFlags
 = 
db
->
flags
;

98013 if( 
onoff
>0 )

98016 
db
->
flags
 |= 
aFlagOp
[
i
].
mask
;

98017 }else if( 
onoff
==0 )

98020 
db
->
flags
 &= ~
aFlagOp
[
i
].
mask
;

98022 if( 
oldFlags
!=
db
->
flags
 )

98025 
	`sqlite3ExpirePreparedStatements
(
db
);

98027 if( 
pRes
 )

98030 *
pRes
 = (
db
->
flags
 & 
aFlagOp
[
i
].
mask
)!=0;

98032 
rc
 = 0;

98039 
	`__builtin_va_end
(
ap
);

98040 return 
rc
;

98041 
	}
}

98047 static int 
	$allSpaces
(const char *
z
, int 
n
)

98050 while( 
n
>0 && 
z
[n-1]==' ' )

98052 
n
--; }

98053 return 
n
==0;

98054 
	}
}

98056 static int 
	$binCollFunc
(

98057 void *
padFlag
,

98058 int 
nKey1
, const void *
pKey1
,

98059 int 
nKey2
, const void *
pKey2


98063 int 
rc
, 
n
;

98064 
n
 = 
nKey1
<
nKey2
 ? nKey1 : nKey2;

98068 
rc
 = 
	`memcmp
(
pKey1
, 
pKey2
, 
n
);

98069 if( 
rc
==0 )

98072 if( 
padFlag


98073 && 
	`allSpaces
(((char*)
pKey1
)+
n
, 
nKey1
-n)

98074 && 
	`allSpaces
(((char*)
pKey2
)+
n
, 
nKey2
-n)

98084 
rc
 = 
nKey1
 - 
nKey2
;

98087 return 
rc
;

98088 
	}
}

98090 static int 
	$nocaseCollatingFunc
(

98091 void *
NotUsed
,

98092 int 
nKey1
, const void *
pKey1
,

98093 int 
nKey2
, const void *
pKey2


98097 int 
r
 = 
	`sqlite3_strnicmp
(

98098 (const char *)
pKey1
, (const char *)
pKey2
, (
nKey1
<
nKey2
)?nKey1:nKey2);

98099 (void)(
NotUsed
);

98100 if( 0==
r
 )

98103 
r
 = 
nKey1
-
nKey2
;

98105 return 
r
;

98106 
	}
}

98111 
sqlite_int64
 
	$sqlite3_last_insert_rowid
(
sqlite3
 *
db
)

98120 return 
db
->
lastRowid
;

98121 
	}
}

98126 int 
	$sqlite3_changes
(
sqlite3
 *
db
)

98135 return 
db
->
nChange
;

98136 
	}
}

98141 int 
	$sqlite3_total_changes
(
sqlite3
 *
db
)

98150 return 
db
->
nTotalChange
;

98151 
	}
}

98158 static void 
	$sqlite3CloseSavepoints
(
sqlite3
 *
db
)

98161 while( 
db
->
pSavepoint
 )

98164 
Savepoint
 *
pTmp
 = 
db
->
pSavepoint
;

98165 
db
->
pSavepoint
 = 
pTmp
->
pNext
;

98166 
	`sqlite3DbFree
(
db
, 
pTmp
);

98168 
db
->
nSavepoint
 = 0;

98169 
db
->
nStatement
 = 0;

98170 
db
->
isTransactionSavepoint
 = 0;

98171 
	}
}

98179 static void 
	$functionDestroy
(
sqlite3
 *
db
, 
FuncDef
 *
p
)

98182 
FuncDestructor
 *
pDestructor
 = 
p
->
u
.pDestructor;

98183 if( 
pDestructor
 )

98186 
pDestructor
->
nRef
--;

98187 if( 
pDestructor
->
nRef
==0 )

98190 
pDestructor
->
	`xDestroy
(pDestructor->
pUserData
);

98191 
	`sqlite3DbFree
(
db
, 
pDestructor
);

98194 
	}
}

98200 static void 
	$disconnectAllVtab
(
sqlite3
 *
db
)

98204 int 
i
;

98205 
HashElem
 *
p
;

98206 
	`sqlite3BtreeEnterAll
(
db
);

98207 for(
i
=0; i<
db
->
nDb
; i++)

98210 
Schema
 *
pSchema
 = 
db
->
aDb
[
i
].pSchema;

98211 if( 
db
->
aDb
[
i
].
pSchema
 )

98214 for(
p
=((&
pSchema
->
tblHash
)->
first
); p; p=((p)->
next
))

98217 
Table
 *
pTab
 = (Table *)((
p
)->
data
);

98218 if( (((
pTab
)->
tabFlags
 & 0x10)!=0) ) 
	`sqlite3VtabDisconnect
(
db
, pTab);

98222 for(
p
=((&
db
->
aModule
)->
first
); p; p=((p)->
next
))

98225 
Module
 *
pMod
 = (Module *)((
p
)->
data
);

98226 if( 
pMod
->
pEpoTab
 )

98229 
	`sqlite3VtabDisconnect
(
db
, 
pMod
->
pEpoTab
);

98232 
	`sqlite3VtabUnlockList
(
db
);

98233 
	`sqlite3BtreeLeaveAll
(
db
);

98237 
	}
}

98243 static int 
	$connectionIsBusy
(
sqlite3
 *
db
)

98246 int 
j
;

98248 if( 
db
->
pVdbe
 ) return 1;

98249 for(
j
=0; j<
db
->
nDb
; j++)

98252 
Btree
 *
pBt
 = 
db
->
aDb
[
j
].pBt;

98253 if( 
pBt
 && 
	`sqlite3BtreeIsInBackup
(pBt) ) return 1;

98256 
	}
}

98261 static int 
	$sqlite3Close
(
sqlite3
 *
db
, int 
forceZombie
)

98264 if( !
db
 )

98271 if( !
	`sqlite3SafetyCheckSickOrOk
(
db
) )

98274 return 
	`sqlite3MisuseError
(134226);

98276 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98279 
	`disconnectAllVtab
(
db
);

98281 
	`sqlite3VtabRollback
(
db
);

98286 if( !
forceZombie
 && 
	`connectionIsBusy
(
db
) )

98289 
	`sqlite3ErrorWithMsg
(
db
, 5, "unable to close due to unfinalized "

98291 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98295 
db
->
magic
 = 0x64cffc7f;

98296 
	`sqlite3LeaveMutexAndCloseZombie
(
db
);

98298 
	}
}

98300 int 
	$sqlite3_close
(
sqlite3
 *
db
)

98302 return 
	`sqlite3Close
(
db
,0); 
	}
}

98303 int 
	$sqlite3_close_v2
(
sqlite3
 *
db
)

98305 return 
	`sqlite3Close
(
db
,1); 
	}
}

98307 static void 
	$sqlite3LeaveMutexAndCloseZombie
(
sqlite3
 *
db
)

98310 
HashElem
 *
i
;

98311 int 
j
;

98317 if( 
db
->
magic
!=0x64cffc7f || 
	`connectionIsBusy
(db) )

98320 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98324 
	`sqlite3RollbackAll
(
db
, 0);

98327 
	`sqlite3CloseSavepoints
(
db
);

98330 for(
j
=0; j<
db
->
nDb
; j++)

98333 struct 
Db
 *
pDb
 = &
db
->
aDb
[
j
];

98334 if( 
pDb
->
pBt
 )

98337 
	`sqlite3BtreeClose
(
pDb
->
pBt
);

98338 
pDb
->
pBt
 = 0;

98339 if( 
j
!=1 )

98342 
pDb
->
pSchema
 = 0;

98347 if( 
db
->
aDb
[1].
pSchema
 )

98350 
	`sqlite3SchemaClear
(
db
->
aDb
[1].
pSchema
);

98352 
	`sqlite3VtabUnlockList
(
db
);

98355 
	`sqlite3CollapseDatabaseArray
(
db
);

98364 for(
i
=((&
db
->
aFunc
)->
first
); i; i=((i)->
next
))

98367 
FuncDef
 *
pNext
, *
p
;

98368 
p
 = ((
i
)->
data
);

98370 
	`functionDestroy
(
db
, 
p
);

98371 
pNext
 = 
p
->pNext;

98372 
	`sqlite3DbFree
(
db
, 
p
);

98373 
p
 = 
pNext
;

98374 }while( 
p
 );

98376 
	`sqlite3HashClear
(&
db
->
aFunc
);

98377 for(
i
=((&
db
->
aCollSeq
)->
first
); i; i=((i)->
next
))

98380 
CollSeq
 *
pColl
 = (CollSeq *)((
i
)->
data
);

98382 for(
j
=0; j<3; j++)

98385 if( 
pColl
[
j
].
xDel
 )

98388 
pColl
[
j
].
	`xDel
(pColl[j].
pUser
);

98391 
	`sqlite3DbFree
(
db
, 
pColl
);

98393 
	`sqlite3HashClear
(&
db
->
aCollSeq
);

98395 for(
i
=((&
db
->
aModule
)->
first
); i; i=((i)->
next
))

98398 
Module
 *
pMod
 = (Module *)((
i
)->
data
);

98399 if( 
pMod
->
xDestroy
 )

98402 
pMod
->
	`xDestroy
(pMod->
pAux
);

98404 
	`sqlite3VtabEponymousTableClear
(
db
, 
pMod
);

98405 
	`sqlite3DbFree
(
db
, 
pMod
);

98407 
	`sqlite3HashClear
(&
db
->
aModule
);

98410 
	`sqlite3Error
(
db
, 0);

98411 
	`sqlite3ValueFree
(
db
->
pErr
);

98412 
	`sqlite3CloseExtensions
(
db
);

98418 
db
->
magic
 = 0xb5357930;

98426 
	`sqlite3DbFree
(
db
, db->
aDb
[1].
pSchema
);

98427 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98428 
db
->
magic
 = 0x9f3c2d33;

98429 
	`sqlite3_mutex_free
(
db
->
mutex
);

98431 if( 
db
->
lookaside
.
bMalloced
 )

98434 
	`sqlite3_free
(
db
->
lookaside
.
pStart
);

98436 
	`sqlite3_free
(
db
);

98437 
	}
}

98439 static void 
	$sqlite3RollbackAll
(
sqlite3
 *
db
, int 
tripCode
)

98442 int 
i
;

98443 int 
inTrans
 = 0;

98444 int 
schemaChange
;

98446 
	`sqlite3BeginBenignMalloc
();

98454 
	`sqlite3BtreeEnterAll
(
db
);

98455 
schemaChange
 = (
db
->
flags
 & 0x00000002)!=0 && db->
init
.
busy
==0;

98457 for(
i
=0; i<
db
->
nDb
; i++)

98460 
Btree
 *
p
 = 
db
->
aDb
[
i
].
pBt
;

98461 if( 
p
 )

98464 if( 
	`sqlite3BtreeIsInTrans
(
p
) )

98467 
inTrans
 = 1;

98469 
	`sqlite3BtreeRollback
(
p
, 
tripCode
, !
schemaChange
);

98472 
	`sqlite3VtabRollback
(
db
);

98473 
	`sqlite3EndBenignMalloc
();

98475 if( (
db
->
flags
&0x00000002)!=0 && db->
init
.
busy
==0 )

98478 
	`sqlite3ExpirePreparedStatements
(
db
);

98479 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

98481 
	`sqlite3BtreeLeaveAll
(
db
);

98484 
db
->
nDeferredCons
 = 0;

98485 
db
->
nDeferredImmCons
 = 0;

98486 
db
->
flags
 &= ~0x01000000;

98489 if( 
db
->
xRollbackCallback
 && (
inTrans
 || !db->
autoCommit
) )

98492 
db
->
	`xRollbackCallback
(db->
pRollbackArg
);

98494 
	}
}

98496 static const char *
	$sqlite3ErrStr
(int 
rc
)

98499 static const char* const 
aMsg
[] = {

98528 const char *
zErr
 = "unknown error";

98529 switch( 
rc
 )

98533 
zErr
 = "abort due to ROLLBACK";

98537 
rc
 &= 0xff;

98538 if( (
rc
>=0) && rc<((int)(sizeof(
aMsg
)/sizeof(aMsg[0]))) && aMsg[rc]!=0 )

98541 
zErr
 = 
aMsg
[
rc
];

98546 return 
zErr
;

98547 
	}
}

98555 static int 
	$sqliteDefaultBusyCallback
(

98556 void *
ptr
,

98557 int 
count


98562 
sqlite3
 *
db
 = (sqlite3 *)
ptr
;

98563 int 
timeout
 = ((
sqlite3
 *)
ptr
)->
busyTimeout
;

98564 if( (
count
+1)*1000 > 
timeout
 )

98569 
	`sqlite3OsSleep
(
db
->
pVfs
, 1000000);

98572 
	}
}

98574 static int 
	$sqlite3InvokeBusyHandler
(
BusyHandler
 *
p
)

98577 int 
rc
;

98578 if( (
p
==0) || p->
xFunc
==0 || p->
nBusy
<0 ) return 0;

98579 
rc
 = 
p
->
	`xFunc
(p->
pArg
, p->
nBusy
);

98580 if( 
rc
==0 )

98583 
p
->
nBusy
 = -1;

98585 
p
->
nBusy
++;

98587 return 
rc
;

98588 
	}
}

98594 int 
sqlite3_busy_handler
(

98595 
sqlite3
 *
db
,

98596 int (*
xBusy
)(void*,int),

98597 void *
pArg


98604 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98605 
db
->
busyHandler
.
xFunc
 = 
xBusy
;

98606 
db
->
busyHandler
.
pArg
 = pArg;

98607 
db
->
busyHandler
.
nBusy
 = 0;

98608 
db
->
busyTimeout
 = 0;

98609 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98611 
	}
}

98619 void 
sqlite3_progress_handler
(

98620 
sqlite3
 *
db
,

98621 int 
nOps
,

98622 int (*
xProgress
)(void*),

98623 void *
pArg


98633 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98634 if( 
nOps
>0 )

98637 
db
->
xProgress
 = xProgress;

98638 
db
->
nProgressOps
 = (unsigned)
nOps
;

98639 
db
->
pProgressArg
 = 
pArg
;

98641 
db
->
xProgress
 = 0;

98642 
db
->
nProgressOps
 = 0;

98643 
db
->
pProgressArg
 = 0;

98645 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98646 
	}
}

98654 int 
	$sqlite3_busy_timeout
(
sqlite3
 *
db
, int 
ms
)

98660 if( 
ms
>0 )

98663 
	`sqlite3_busy_handler
(
db
, 
sqliteDefaultBusyCallback
, (void*)db);

98664 
db
->
busyTimeout
 = 
ms
;

98666 
	`sqlite3_busy_handler
(
db
, 0, 0);

98669 
	}
}

98674 void 
	$sqlite3_interrupt
(
sqlite3
 *
db
)

98683 
db
->
u1
.
isInterrupted
 = 1;

98684 
	}
}

98686 static int 
sqlite3CreateFunc
(

98687 
sqlite3
 *
db
,

98688 const char *
zFunctionName
,

98689 int 
nArg
,

98690 int 
enc
,

98691 void *
pUserData
,

98692 void (*
xSFunc
)(
sqlite3_context
*,int,
sqlite3_value
 **),

98693 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
 **),

98694 void (*
xFinal
)(
sqlite3_context
*),

98695 
FuncDestructor
 *
pDestructor


98699 
FuncDef
 *
p
;

98700 int 
nName
;

98701 int 
extraFlags
;

98704 if( 
zFunctionName
==0 ||

98705 (
xSFunc
 && (
xFinal
 || 
xStep
)) ||

98706 (!
xSFunc
 && (
xFinal
 && !
xStep
)) ||

98707 (!
xSFunc
 && (!
xFinal
 && 
xStep
)) ||

98708 (
nArg
<-1 || nArg>127) ||

98709 (255<(
nName
 = 
	`sqlite3Strlen30
( 
zFunctionName
))) )

98712 return 
	`sqlite3MisuseError
(134792);

98716 
extraFlags
 = 
enc
 & 0x800;

98717 
enc
 &= (0x0003|5);

98719 if( 
enc
==4 )

98722 
enc
 = 2;

98723 }else if( 
enc
==5 )

98726 int 
rc
;

98727 
rc
 = 
	`sqlite3CreateFunc
(
db
, 
zFunctionName
, 
nArg
, 1|
extraFlags
,

98728 
pUserData
, 
xSFunc
, 
xStep
, 
xFinal
, 
pDestructor
);

98729 if( 
rc
==0 )

98732 
rc
 = 
	`sqlite3CreateFunc
(
db
, 
zFunctionName
, 
nArg
, 2|
extraFlags
,

98733 
pUserData
, 
xSFunc
, 
xStep
, 
xFinal
, 
pDestructor
);

98735 if( 
rc
!=0 )

98738 return 
rc
;

98740 
enc
 = 3;

98743 
p
 = 
	`sqlite3FindFunction
(
db
, 
zFunctionName
, 
nArg
, (
u8
)
enc
, 0);

98744 if( 
p
 && (p->
funcFlags
 & 0x0003)==
enc
 && p->
nArg
==nArg )

98747 if( 
db
->
nVdbeActive
 )

98750 
	`sqlite3ErrorWithMsg
(
db
, 5,

98755 
	`sqlite3ExpirePreparedStatements
(
db
);

98759 
p
 = 
	`sqlite3FindFunction
(
db
, 
zFunctionName
, 
nArg
, (
u8
)
enc
, 1);

98761 if( !
p
 )

98769 
	`functionDestroy
(
db
, 
p
);

98771 if( 
pDestructor
 )

98774 
pDestructor
->
nRef
++;

98776 
p
->
u
.
pDestructor
 = pDestructor;

98777 
p
->
funcFlags
 = (p->funcFlags & 0x0003) | 
extraFlags
;

98779 
p
->
xSFunc
 = xSFunc ? xSFunc : 
xStep
;

98780 
p
->
xFinalize
 = 
xFinal
;

98781 
p
->
pUserData
 = pUserData;

98782 
p
->
nArg
 = (
u16
)nArg;

98784 
	}
}

98789 int 
sqlite3_create_function
(

98790 
sqlite3
 *
db
,

98791 const char *
zFunc
,

98792 int 
nArg
,

98793 int 
enc
,

98794 void *
p
,

98795 void (*
xSFunc
)(
sqlite3_context
*,int,
sqlite3_value
 **),

98796 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
 **),

98797 void (*
xFinal
)(
sqlite3_context
*)

98801 return 
	`sqlite3_create_function_v2
(
db
, 
zFunc
, 
nArg
, 
enc
, 
p
, 
xSFunc
, 
xStep
,

98802 
xFinal
, 0);

98803 
	}
}

98805 int 
sqlite3_create_function_v2
(

98806 
sqlite3
 *
db
,

98807 const char *
zFunc
,

98808 int 
nArg
,

98809 int 
enc
,

98810 void *
p
,

98811 void (*
xSFunc
)(
sqlite3_context
*,int,
sqlite3_value
 **),

98812 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
 **),

98813 void (*
xFinal
)(
sqlite3_context
*),

98814 void (*
xDestroy
)(void *)

98818 int 
rc
 = 1;

98819 
FuncDestructor
 *
pArg
 = 0;

98826 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98827 if( 
xDestroy
 )

98830 
pArg
 = (
FuncDestructor
 *)
	`sqlite3DbMallocZero
(
db
, sizeof(FuncDestructor));

98831 if( !
pArg
 )

98834 
	`xDestroy
(
p
);

98835 goto 
out
;

98837 
pArg
->
xDestroy
 = xDestroy;

98838 
pArg
->
pUserData
 = 
p
;

98840 
rc
 = 
	`sqlite3CreateFunc
(
db
, 
zFunc
, 
nArg
, 
enc
, 
p
, 
xSFunc
, 
xStep
, 
xFinal
, 
pArg
);

98841 if( 
pArg
 && pArg->
nRef
==0 )

98845 
	`xDestroy
(
p
);

98846 
	`sqlite3DbFree
(
db
, 
pArg
);

98849 
out
:

98850 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

98851 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98852 return 
rc
;

98853 
	}
}

98856 int 
sqlite3_create_function16
(

98857 
sqlite3
 *
db
,

98858 const void *
zFunctionName
,

98859 int 
nArg
,

98860 int 
eTextRep
,

98861 void *
p
,

98862 void (*
xSFunc
)(
sqlite3_context
*,int,
sqlite3_value
**),

98863 void (*
xStep
)(
sqlite3_context
*,int,
sqlite3_value
**),

98864 void (*
xFinal
)(
sqlite3_context
*)

98868 int 
rc
;

98869 char *
zFunc8
;

98874 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98876 
zFunc8
 = 
	`sqlite3Utf16to8
(
db
, 
zFunctionName
, -1, 2);

98877 
rc
 = 
	`sqlite3CreateFunc
(
db
, 
zFunc8
, 
nArg
, 
eTextRep
, 
p
, 
xSFunc
,
xStep
,
xFinal
,0);

98878 
	`sqlite3DbFree
(
db
, 
zFunc8
);

98879 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

98880 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98881 return 
rc
;

98882 
	}
}

98884 int 
	$sqlite3_overload_function
(

98885 
sqlite3
 *
db
,

98886 const char *
zName
,

98887 int 
nArg


98891 int 
rc
 = 0;

98898 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98899 if( 
	`sqlite3FindFunction
(
db
, 
zName
, 
nArg
, 1, 0)==0 )

98902 
rc
 = 
	`sqlite3CreateFunc
(
db
, 
zName
, 
nArg
, 1,

98903 0, 
sqlite3InvalidFunction
, 0, 0, 0);

98905 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

98906 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98907 return 
rc
;

98908 
	}
}

98910 void * 
sqlite3_trace
(
sqlite3
 *
db
, void (*
xTrace
)(void*,const char*), void *
pArg
)

98913 void *
pOld
;

98921 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98922 
pOld
 = 
db
->
pTraceArg
;

98923 
db
->
xTrace
 = xTrace;

98924 
db
->
pTraceArg
 = 
pArg
;

98925 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98926 return 
pOld
;

98927 
	}
}

98929 void * 
sqlite3_profile
(

98930 
sqlite3
 *
db
,

98931 void (*
xProfile
)(void*,const char*,
sqlite_uint64
),

98932 void *
pArg


98936 void *
pOld
;

98944 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98945 
pOld
 = 
db
->
pProfileArg
;

98946 
db
->
xProfile
 = xProfile;

98947 
db
->
pProfileArg
 = 
pArg
;

98948 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98949 return 
pOld
;

98950 
	}
}

98958 void * 
sqlite3_commit_hook
(

98959 
sqlite3
 *
db
,

98960 int (*
xCallback
)(void*),

98961 void *
pArg


98965 void *
pOld
;

98973 
	`sqlite3_mutex_enter
(
db
->
mutex
);

98974 
pOld
 = 
db
->
pCommitArg
;

98975 
db
->
xCommitCallback
 = 
xCallback
;

98976 
db
->
pCommitArg
 = 
pArg
;

98977 
	`sqlite3_mutex_leave
(
db
->
mutex
);

98978 return 
pOld
;

98979 
	}
}

98985 void * 
sqlite3_update_hook
(

98986 
sqlite3
 *
db
,

98987 void (*
xCallback
)(void*,int,char const *,char const *,
sqlite_int64
),

98988 void *
pArg


98992 void *
pRet
;

99000 
	`sqlite3_mutex_enter
(
db
->
mutex
);

99001 
pRet
 = 
db
->
pUpdateArg
;

99002 
db
->
xUpdateCallback
 = 
xCallback
;

99003 
db
->
pUpdateArg
 = 
pArg
;

99004 
	`sqlite3_mutex_leave
(
db
->
mutex
);

99005 return 
pRet
;

99006 
	}
}

99012 void * 
sqlite3_rollback_hook
(

99013 
sqlite3
 *
db
,

99014 void (*
xCallback
)(void*),

99015 void *
pArg


99019 void *
pRet
;

99027 
	`sqlite3_mutex_enter
(
db
->
mutex
);

99028 
pRet
 = 
db
->
pRollbackArg
;

99029 
db
->
xRollbackCallback
 = 
xCallback
;

99030 
db
->
pRollbackArg
 = 
pArg
;

99031 
	`sqlite3_mutex_leave
(
db
->
mutex
);

99032 return 
pRet
;

99033 
	}
}

99035 static int 
	$sqlite3WalDefaultHook
(

99036 void *
pClientData
,

99037 
sqlite3
 *
db
,

99038 const char *
zDb
,

99039 int 
nFrame


99043 if( 
nFrame
>=((int)(long int)(
pClientData
)) )

99046 
	`sqlite3BeginBenignMalloc
();

99047 
	`sqlite3_wal_checkpoint
(
db
, 
zDb
);

99048 
	`sqlite3EndBenignMalloc
();

99051 
	}
}

99053 int 
	$sqlite3_wal_autocheckpoint
(
sqlite3
 *
db
, int 
nFrame
)

99063 if( 
nFrame
>0 )

99066 
	`sqlite3_wal_hook
(
db
, 
sqlite3WalDefaultHook
, ((void*)(long int)(
nFrame
)));

99068 
	`sqlite3_wal_hook
(
db
, 0, 0);

99072 
	}
}

99078 void * 
sqlite3_wal_hook
(

99079 
sqlite3
 *
db
,

99080 int(*
xCallback
)(void *, 
sqlite3
*, const char*, int),

99081 void *
pArg


99086 void *
pRet
;

99093 
	`sqlite3_mutex_enter
(
db
->
mutex
);

99094 
pRet
 = 
db
->
pWalArg
;

99095 
db
->
xWalCallback
 = 
xCallback
;

99096 
db
->
pWalArg
 = 
pArg
;

99097 
	`sqlite3_mutex_leave
(
db
->
mutex
);

99098 return 
pRet
;

99102 
	}
}

99107 int 
	$sqlite3_wal_checkpoint_v2
(

99108 
sqlite3
 *
db
,

99109 const char *
zDb
,

99110 int 
eMode
,

99111 int *
pnLog
,

99112 int *
pnCkpt


99119 int 
rc
;

99120 int 
iDb
 = 10;

99127 if( 
pnLog
 ) *pnLog = -1;

99128 if( 
pnCkpt
 ) *pnCkpt = -1;

99134 if( 
eMode
<0 || eMode>3 )

99142 
	`sqlite3_mutex_enter
(
db
->
mutex
);

99143 if( 
zDb
 && zDb[0] )

99146 
iDb
 = 
	`sqlite3FindDbName
(
db
, 
zDb
);

99148 if( 
iDb
<0 )

99151 
rc
 = 1;

99152 
	`sqlite3ErrorWithMsg
(
db
, 1, "unknown database: %s", 
zDb
);

99154 
db
->
busyHandler
.
nBusy
 = 0;

99155 
rc
 = 
	`sqlite3Checkpoint
(
db
, 
iDb
, 
eMode
, 
pnLog
, 
pnCkpt
);

99156 
	`sqlite3Error
(
db
, 
rc
);

99158 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

99159 
	`sqlite3_mutex_leave
(
db
->
mutex
);

99160 return 
rc
;

99162 
	}
}

99170 int 
	$sqlite3_wal_checkpoint
(
sqlite3
 *
db
, const char *
zDb
)

99175 return 
	`sqlite3_wal_checkpoint_v2
(
db
,
zDb
,0,0,0);

99176 
	}
}

99178 static int 
	$sqlite3Checkpoint
(
sqlite3
 *
db
, int 
iDb
, int 
eMode
, int *
pnLog
, int *
pnCkpt
)

99181 int 
rc
 = 0;

99182 int 
i
;

99183 int 
bBusy
 = 0;

99189 for(
i
=0; i<
db
->
nDb
 && 
rc
==0; i++)

99192 if( 
i
==
iDb
 || iDb==10 )

99195 
rc
 = 
	`sqlite3BtreeCheckpoint
(
db
->
aDb
[
i
].
pBt
, 
eMode
, 
pnLog
, 
pnCkpt
);

99196 
pnLog
 = 0;

99197 
pnCkpt
 = 0;

99198 if( 
rc
==5 )

99201 
bBusy
 = 1;

99202 
rc
 = 0;

99207 return (
rc
==0 && 
bBusy
) ? 5 : rc;

99208 
	}
}

99210 static int 
	$sqlite3TempInMemory
(const 
sqlite3
 *
db
)

99214 return ( 
db
->
temp_store
==2 );

99216 
	}
}

99222 const char * 
	$sqlite3_errmsg
(
sqlite3
 *
db
)

99225 const char *
z
;

99226 if( !
db
 )

99229 return 
	`sqlite3ErrStr
(7);

99231 if( !
	`sqlite3SafetyCheckSickOrOk
(
db
) )

99234 return 
	`sqlite3ErrStr
(
	`sqlite3MisuseError
(135352));

99236 
	`sqlite3_mutex_enter
(
db
->
mutex
);

99237 if( 
db
->
mallocFailed
 )

99240 
z
 = 
	`sqlite3ErrStr
(7);

99243 
z
 = (char*)
	`sqlite3_value_text
(
db
->
pErr
);

99245 if( 
z
==0 )

99248 
z
 = 
	`sqlite3ErrStr
(
db
->
errCode
);

99251 
	`sqlite3_mutex_leave
(
db
->
mutex
);

99252 return 
z
;

99253 
	}
}

99260 const void * 
	$sqlite3_errmsg16
(
sqlite3
 *
db
)

99263 static const 
u16
 
outOfMem
[] = {

99266 static const 
u16
 
misuse
[] = {

99275 const void *
z
;

99276 if( !
db
 )

99279 return (void *)
outOfMem
;

99281 if( !
	`sqlite3SafetyCheckSickOrOk
(
db
) )

99284 return (void *)
misuse
;

99286 
	`sqlite3_mutex_enter
(
db
->
mutex
);

99287 if( 
db
->
mallocFailed
 )

99290 
z
 = (void *)
outOfMem
;

99292 
z
 = 
	`sqlite3_value_text16
(
db
->
pErr
);

99293 if( 
z
==0 )

99296 
	`sqlite3ErrorWithMsg
(
db
, db->
errCode
, 
	`sqlite3ErrStr
(db->errCode));

99297 
z
 = 
	`sqlite3_value_text16
(
db
->
pErr
);

99304 
	`sqlite3OomClear
(
db
);

99306 
	`sqlite3_mutex_leave
(
db
->
mutex
);

99307 return 
z
;

99308 
	}
}

99315 int 
	$sqlite3_errcode
(
sqlite3
 *
db
)

99318 if( 
db
 && !
	`sqlite3SafetyCheckSickOrOk
(db) )

99321 return 
	`sqlite3MisuseError
(135421);

99323 if( !
db
 || db->
mallocFailed
 )

99328 return 
db
->
errCode
 & db->
errMask
;

99329 
	}
}

99330 int 
	$sqlite3_extended_errcode
(
sqlite3
 *
db
)

99333 if( 
db
 && !
	`sqlite3SafetyCheckSickOrOk
(db) )

99336 return 
	`sqlite3MisuseError
(135430);

99338 if( !
db
 || db->
mallocFailed
 )

99343 return 
db
->
errCode
;

99344 
	}
}

99345 int 
	$sqlite3_system_errno
(
sqlite3
 *
db
)

99348 return 
db
 ? db->
iSysErrno
 : 0;

99349 
	}
}

99356 const char * 
	$sqlite3_errstr
(int 
rc
)

99359 return 
	`sqlite3ErrStr
(
rc
);

99360 
	}
}

99366 static int 
createCollation
(

99367 
sqlite3
* 
db
,

99368 const char *
zName
,

99369 
u8
 
enc
,

99370 void* 
pCtx
,

99371 int(*
xCompare
)(void*,int,const void*,int,const void*),

99372 void(*
xDel
)(void*)

99376 
CollSeq
 *
pColl
;

99377 int 
enc2
;

99385 
enc2
 = 
enc
;

99388 if( 
enc2
==4 || enc2==8 )

99391 
enc2
 = 2;

99393 if( 
enc2
<1 || enc2>3 )

99396 return 
	`sqlite3MisuseError
(135478);

99403 
pColl
 = 
	`sqlite3FindCollSeq
(
db
, (
u8
)
enc2
, 
zName
, 0);

99404 if( 
pColl
 && pColl->
xCmp
 )

99407 if( 
db
->
nVdbeActive
 )

99410 
	`sqlite3ErrorWithMsg
(
db
, 5,

99414 
	`sqlite3ExpirePreparedStatements
(
db
);

99422 if( (
pColl
->
enc
 & ~8)==
enc2
 )

99425 
CollSeq
 *
aColl
 = 
	`sqlite3HashFind
(&
db
->
aCollSeq
, 
zName
);

99426 int 
j
;

99427 for(
j
=0; j<3; j++)

99430 
CollSeq
 *
p
 = &
aColl
[
j
];

99431 if( 
p
->
enc
==
pColl
->enc )

99434 if( 
p
->
xDel
 )

99437 
p
->
	`xDel
(p->
pUser
);

99439 
p
->
xCmp
 = 0;

99445 
pColl
 = 
	`sqlite3FindCollSeq
(
db
, (
u8
)
enc2
, 
zName
, 1);

99446 if( 
pColl
==0 ) return 7;

99447 
pColl
->
xCmp
 = 
xCompare
;

99448 
pColl
->
pUser
 = 
pCtx
;

99449 
pColl
->
xDel
 = xDel;

99450 
pColl
->
enc
 = (
u8
)(
enc2
 | (enc & 8));

99451 
	`sqlite3Error
(
db
, 0);

99453 
	}
}

99461 static const int 
	gaHardLimit
[] = {

99476 int 
	$sqlite3_limit
(
sqlite3
 *
db
, int 
limitId
, int 
newLimit
)

99479 int 
oldLimit
;

99497 if( 
limitId
<0 || limitId>=(11 +1) )

99502 
oldLimit
 = 
db
->
aLimit
[
limitId
];

99503 if( 
newLimit
>=0 )

99506 if( 
newLimit
>
aHardLimit
[
limitId
] )

99509 
newLimit
 = 
aHardLimit
[
limitId
];

99511 
db
->
aLimit
[
limitId
] = 
newLimit
;

99513 return 
oldLimit
;

99514 
	}
}

99516 static int 
	$sqlite3ParseUri
(

99517 const char *
zDefaultVfs
,

99518 const char *
zUri
,

99519 unsigned int *
pFlags
,

99520 
sqlite3_vfs
 **
ppVfs
,

99521 char **
pzFile
,

99522 char **
pzErrMsg


99526 int 
rc
 = 0;

99527 unsigned int 
flags
 = *
pFlags
;

99528 const char *
zVfs
 = 
zDefaultVfs
;

99529 char *
zFile
;

99530 char 
c
;

99531 int 
nUri
 = 
	`sqlite3Strlen30
(
zUri
);

99535 if( ((
flags
 & 0x00000040)

99536 || 
sqlite3Config
.
bOpenUri
)

99537 && 
nUri
>=5 && 
	`memcmp
(
zUri
, "file:", 5)==0

99541 char *
zOpt
;

99542 int 
eState
;

99543 int 
iIn
;

99544 int 
iOut
 = 0;

99545 
u64
 
nByte
 = 
nUri
+2;

99549 
flags
 |= 0x00000040;

99551 for(
iIn
=0; iIn<
nUri
; iIn++) 
nByte
 += (
zUri
[iIn]=='&');

99552 
zFile
 = 
	`sqlite3_malloc64
(
nByte
);

99553 if( !
zFile
 ) return 7;

99555 
iIn
 = 5;

99557 if( 
zUri
[5]=='/' && zUri[6]=='/' )

99560 
iIn
 = 7;

99561 while( 
zUri
[
iIn
] && zUri[iIn]!='/' ) iIn++;

99562 if( 
iIn
!=7 && (iIn!=16 || 
	`memcmp
("localhost", &
zUri
[7], 9)) )

99565 *
pzErrMsg
 = 
	`sqlite3_mprintf
("invalid uri authority: %.*s",

99566 
iIn
-7, &
zUri
[7]);

99567 
rc
 = 1;

99568 goto 
parse_uri_out
;

99572 
eState
 = 0;

99573 while( (
c
 = 
zUri
[
iIn
])!=0 && c!='#' )

99576 
iIn
++;

99577 if( 
c
=='%'

99578 && (
sqlite3CtypeMap
[(unsigned char)(
zUri
[
iIn
])]&0x08)

99579 && (
sqlite3CtypeMap
[(unsigned char)(
zUri
[
iIn
+1])]&0x08)

99583 int 
octet
 = (
	`sqlite3HexToInt
(
zUri
[
iIn
++]) << 4);

99584 
octet
 += 
	`sqlite3HexToInt
(
zUri
[
iIn
++]);

99587 if( 
octet
==0 )

99594 while( (
c
 = 
zUri
[
iIn
])!=0 && c!='#'

99595 && (
eState
!=0 || 
c
!='?')

99596 && (
eState
!=1 || (
c
!='=' && c!='&'))

99597 && (
eState
!=2 || 
c
!='&')

99601 
iIn
++;

99605 
c
 = 
octet
;

99606 }else if( 
eState
==1 && (
c
=='&' || c=='=') )

99609 if( 
zFile
[
iOut
-1]==0 )

99613 while( 
zUri
[
iIn
] && zUri[iIn]!='#' && zUri[iIn-1]!='&' ) iIn++;

99616 if( 
c
=='&' )

99619 
zFile
[
iOut
++] = '\0';

99621 
eState
 = 2;

99623 
c
 = 0;

99624 }else if( (
eState
==0 && 
c
=='?') || (eState==2 && c=='&') )

99627 
c
 = 0;

99628 
eState
 = 1;

99630 
zFile
[
iOut
++] = 
c
;

99632 if( 
eState
==1 ) 
zFile
[
iOut
++] = '\0';

99633 
zFile
[
iOut
++] = '\0';

99634 
zFile
[
iOut
++] = '\0';

99640 
zOpt
 = &
zFile
[
	`sqlite3Strlen30
(zFile)+1];

99641 while( 
zOpt
[0] )

99644 int 
nOpt
 = 
	`sqlite3Strlen30
(
zOpt
);

99645 char *
zVal
 = &
zOpt
[
nOpt
+1];

99646 int 
nVal
 = 
	`sqlite3Strlen30
(
zVal
);

99648 if( 
nOpt
==3 && 
	`memcmp
("vfs", 
zOpt
, 3)==0 )

99651 
zVfs
 = 
zVal
;

99653 struct 
	sOpenMode
 {

99654 const char *
z
;

99655 int 
mode
;

99656 } *
aMode
 = 0;

99657 char *
zModeType
 = 0;

99658 int 
mask
 = 0;

99659 int 
limit
 = 0;

99661 if( 
nOpt
==5 && 
	`memcmp
("cache", 
zOpt
, 5)==0 )

99664 static struct 
OpenMode
 
aCacheMode
[] = {

99670 
mask
 = 0x00020000|0x00040000;

99671 
aMode
 = 
aCacheMode
;

99672 
limit
 = 
mask
;

99673 
zModeType
 = "cache";

99675 if( 
nOpt
==4 && 
	`memcmp
("mode", 
zOpt
, 4)==0 )

99678 static struct 
OpenMode
 
aOpenMode
[] = {

99686 
mask
 = 0x00000001 | 0x00000002

99688 
aMode
 = 
aOpenMode
;

99689 
limit
 = 
mask
 & 
flags
;

99690 
zModeType
 = "access";

99693 if( 
aMode
 )

99696 int 
i
;

99697 int 
mode
 = 0;

99698 for(
i
=0; 
aMode
[i].
z
; i++)

99701 const char *
z
 = 
aMode
[
i
].z;

99702 if( 
nVal
==
	`sqlite3Strlen30
(
z
) && 0==
	`memcmp
(
zVal
, z, nVal) )

99705 
mode
 = 
aMode
[
i
].mode;

99709 if( 
mode
==0 )

99712 *
pzErrMsg
 = 
	`sqlite3_mprintf
("no such %s mode: %s", 
zModeType
, 
zVal
);

99713 
rc
 = 1;

99714 goto 
parse_uri_out
;

99716 if( (
mode
 & ~0x00000080)>
limit
 )

99719 *
pzErrMsg
 = 
	`sqlite3_mprintf
("%s mode not allowed: %s",

99720 
zModeType
, 
zVal
);

99721 
rc
 = 3;

99722 goto 
parse_uri_out
;

99724 
flags
 = (flags & ~
mask
) | 
mode
;

99728 
zOpt
 = &
zVal
[
nVal
+1];

99732 
zFile
 = 
	`sqlite3_malloc64
(
nUri
+2);

99733 if( !
zFile
 ) return 7;

99734 
	`memcpy
(
zFile
, 
zUri
, 
nUri
);

99735 
zFile
[
nUri
] = '\0';

99736 
zFile
[
nUri
+1] = '\0';

99737 
flags
 &= ~0x00000040;

99740 *
ppVfs
 = 
	`sqlite3_vfs_find
(
zVfs
);

99741 if( *
ppVfs
==0 )

99744 *
pzErrMsg
 = 
	`sqlite3_mprintf
("no such vfs: %s", 
zVfs
);

99745 
rc
 = 1;

99747 
parse_uri_out
:

99748 if( 
rc
!=0 )

99751 
	`sqlite3_free
(
zFile
);

99752 
zFile
 = 0;

99754 *
pFlags
 = 
flags
;

99755 *
pzFile
 = 
zFile
;

99756 return 
rc
;

99757 
	}
}

99765 static int 
	$openDatabase
(

99766 const char *
zFilename
,

99767 
sqlite3
 **
ppDb
,

99768 unsigned int 
flags
,

99769 const char *
zVfs


99773 
sqlite3
 *
db
;

99774 int 
rc
;

99775 int 
isThreadsafe
;

99776 char *
zOpen
 = 0;

99777 char *
zErrMsg
 = 0;

99782 *
ppDb
 = 0;

99784 
rc
 = 
	`sqlite3_initialize
();

99785 if( 
rc
 ) return rc;

99793 if( ((1<<(
flags
&7)) & 0x46)==0 )

99796 return 
	`sqlite3MisuseError
(135927);

99799 if( 
sqlite3Config
.
bCoreMutex
==0 )

99802 
isThreadsafe
 = 0;

99803 }else if( 
flags
 & 0x00008000 )

99806 
isThreadsafe
 = 0;

99807 }else if( 
flags
 & 0x00010000 )

99810 
isThreadsafe
 = 1;

99812 
isThreadsafe
 = 
sqlite3Config
.
bFullMutex
;

99814 if( 
flags
 & 0x00040000 )

99817 
flags
 &= ~0x00020000;

99818 }else if( 
sqlite3Config
.
sharedCacheEnabled
 )

99821 
flags
 |= 0x00020000;

99824 
flags
 &= ~( 0x00000008 |

99839 
db
 = 
	`sqlite3MallocZero
( sizeof(
sqlite3
) );

99840 if( 
db
==0 ) goto 
opendb_out
;

99841 if( 
isThreadsafe
 )

99844 
db
->
mutex
 = 
	`sqlite3MutexAlloc
(1);

99845 if( 
db
->
mutex
==0 )

99848 
	`sqlite3_free
(
db
);

99849 
db
 = 0;

99850 goto 
opendb_out
;

99853 
	`sqlite3_mutex_enter
(
db
->
mutex
);

99854 
db
->
errMask
 = 0xff;

99855 
db
->
nDb
 = 2;

99856 
db
->
magic
 = 0xf03b7906;

99857 
db
->
aDb
 = db->
aDbStatic
;

99860 
	`memcpy
(
db
->
aLimit
, 
aHardLimit
, sizeof(db->aLimit));

99861 
db
->
aLimit
[11] = 0;

99862 
db
->
autoCommit
 = 1;

99863 
db
->
nextAutovac
 = -1;

99864 
db
->
szMmap
 = 
sqlite3Config
.szMmap;

99865 
db
->
nextPagesize
 = 0;

99866 
db
->
nMaxSorterMmap
 = 0x7FFFFFFF;

99867 
db
->
flags
 |= 0x00000040 | 0x00800000 | 0x00000020

99872 
	`sqlite3HashInit
(&
db
->
aCollSeq
);

99874 
	`sqlite3HashInit
(&
db
->
aModule
);

99876 
	`createCollation
(
db
, 
sqlite3StrBINARY
, 1, 0, 
binCollFunc
, 0);

99877 
	`createCollation
(
db
, 
sqlite3StrBINARY
, 3, 0, 
binCollFunc
, 0);

99878 
	`createCollation
(
db
, 
sqlite3StrBINARY
, 2, 0, 
binCollFunc
, 0);

99879 
	`createCollation
(
db
, "NOCASE", 1, 0, 
nocaseCollatingFunc
, 0);

99880 
	`createCollation
(
db
, "RTRIM", 1, (void*)1, 
binCollFunc
, 0);

99881 if( 
db
->
mallocFailed
 )

99884 goto 
opendb_out
;

99889 
db
->
pDfltColl
 = 
	`sqlite3FindCollSeq
(db, 1, 
sqlite3StrBINARY
, 0);

99893 
db
->
openFlags
 = 
flags
;

99894 
rc
 = 
	`sqlite3ParseUri
(
zVfs
, 
zFilename
, &
flags
, &
db
->
pVfs
, &
zOpen
, &
zErrMsg
);

99895 if( 
rc
!=0 )

99898 if( 
rc
==7 ) 
	`sqlite3OomFault
(
db
);

99899 
	`sqlite3ErrorWithMsg
(
db
, 
rc
, 
zErrMsg
 ? "%s" : 0, zErrMsg);

99900 
	`sqlite3_free
(
zErrMsg
);

99901 goto 
opendb_out
;

99905 
rc
 = 
	`sqlite3BtreeOpen
(
db
->
pVfs
, 
zOpen
, db, &db->
aDb
[0].
pBt
, 0,

99906 
flags
 | 0x00000100);

99907 if( 
rc
!=0 )

99910 if( 
rc
==(10 | (12<<8)) )

99913 
rc
 = 7;

99915 
	`sqlite3Error
(
db
, 
rc
);

99916 goto 
opendb_out
;

99918 
	`sqlite3BtreeEnter
(
db
->
aDb
[0].
pBt
);

99919 
db
->
aDb
[0].
pSchema
 = 
	`sqlite3SchemaGet
(db, db->aDb[0].
pBt
);

99920 if( !
db
->
mallocFailed
 ) ((db)->
enc
) = ((db)->
aDb
[0].
pSchema
->enc);

99921 
	`sqlite3BtreeLeave
(
db
->
aDb
[0].
pBt
);

99922 
db
->
aDb
[1].
pSchema
 = 
	`sqlite3SchemaGet
(db, 0);

99927 
db
->
aDb
[0].
zName
 = "main";

99928 
db
->
aDb
[0].
safety_level
 = (0x03 -1)+1;

99929 
db
->
aDb
[1].
zName
 = "temp";

99930 
db
->
aDb
[1].
safety_level
 = 0x01;

99932 
db
->
magic
 = 0xa029a697;

99933 if( 
db
->
mallocFailed
 )

99936 goto 
opendb_out
;

99943 
	`sqlite3Error
(
db
, 0);

99944 
	`sqlite3RegisterPerConnectionBuiltinFunctions
(
db
);

99949 
rc
 = 
	`sqlite3_errcode
(
db
);

99950 if( 
rc
==0 )

99953 
	`sqlite3AutoLoadExtensions
(
db
);

99954 
rc
 = 
	`sqlite3_errcode
(
db
);

99955 if( 
rc
!=0 )

99958 goto 
opendb_out
;

99962 if( 
rc
 ) 
	`sqlite3Error
(
db
, rc);

99965 
	`setupLookaside
(
db
, 0, 
sqlite3Config
.
szLookaside
,

99966 
sqlite3Config
.
nLookaside
);

99968 
	`sqlite3_wal_autocheckpoint
(
db
, 1000);

99970 
opendb_out
:

99971 if( 
db
 )

99976 
	`sqlite3_mutex_leave
(
db
->
mutex
);

99978 
rc
 = 
	`sqlite3_errcode
(
db
);

99980 if( 
rc
==7 )

99983 
	`sqlite3_close
(
db
);

99984 
db
 = 0;

99985 }else if( 
rc
!=0 )

99988 
db
->
magic
 = 0x4b771290;

99990 *
ppDb
 = 
db
;

99992 
	`sqlite3_free
(
zOpen
);

99993 return 
rc
 & 0xff;

99994 
	}
}

99999 int 
	$sqlite3_open
(

100000 const char *
zFilename
,

100001 
sqlite3
 **
ppDb


100005 return 
	`openDatabase
(
zFilename
, 
ppDb
,

100007 
	}
}

100008 int 
	$sqlite3_open_v2
(

100009 const char *
filename
,

100010 
sqlite3
 **
ppDb
,

100011 int 
flags
,

100012 const char *
zVfs


100016 return 
	`openDatabase
(
filename
, 
ppDb
, (unsigned int)
flags
, 
zVfs
);

100017 
	}
}

100023 int 
	$sqlite3_open16
(

100024 const void *
zFilename
,

100025 
sqlite3
 **
ppDb


100029 char const *
zFilename8
;

100030 
sqlite3_value
 *
pVal
;

100031 int 
rc
;

100036 *
ppDb
 = 0;

100038 
rc
 = 
	`sqlite3_initialize
();

100039 if( 
rc
 ) return rc;

100041 if( 
zFilename
==0 ) zFilename = "\000\000";

100042 
pVal
 = 
	`sqlite3ValueNew
(0);

100043 
	`sqlite3ValueSetStr
(
pVal
, -1, 
zFilename
, 2, ((
sqlite3_destructor_type
)0));

100044 
zFilename8
 = 
	`sqlite3ValueText
(
pVal
, 1);

100045 if( 
zFilename8
 )

100048 
rc
 = 
	`openDatabase
(
zFilename8
, 
ppDb
,

100051 if( 
rc
==0 && !(((*
ppDb
)->
aDb
[0].
pSchema
->
schemaFlags
&(0x0001))==(0x0001)) )

100054 ((*
ppDb
)->
aDb
[0].
pSchema
->
enc
) = ((*ppDb)->enc) = 2;

100057 
rc
 = 7;

100059 
	`sqlite3ValueFree
(
pVal
);

100061 return 
rc
 & 0xff;

100062 
	}
}

100068 int 
sqlite3_create_collation
(

100069 
sqlite3
* 
db
,

100070 const char *
zName
,

100071 int 
enc
,

100072 void* 
pCtx
,

100073 int(*
xCompare
)(void*,int,const void*,int,const void*)

100077 return 
	`sqlite3_create_collation_v2
(
db
, 
zName
, 
enc
, 
pCtx
, 
xCompare
, 0);

100078 
	}
}

100083 int 
sqlite3_create_collation_v2
(

100084 
sqlite3
* 
db
,

100085 const char *
zName
,

100086 int 
enc
,

100087 void* 
pCtx
,

100088 int(*
xCompare
)(void*,int,const void*,int,const void*),

100089 void(*
xDel
)(void*)

100093 int 
rc
;

100098 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100100 
rc
 = 
	`createCollation
(
db
, 
zName
, (
u8
)
enc
, 
pCtx
, 
xCompare
, 
xDel
);

100101 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

100102 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100103 return 
rc
;

100104 
	}
}

100110 int 
sqlite3_create_collation16
(

100111 
sqlite3
* 
db
,

100112 const void *
zName
,

100113 int 
enc
,

100114 void* 
pCtx
,

100115 int(*
xCompare
)(void*,int,const void*,int,const void*)

100119 int 
rc
 = 0;

100120 char *
zName8
;

100125 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100127 
zName8
 = 
	`sqlite3Utf16to8
(
db
, 
zName
, -1, 2);

100128 if( 
zName8
 )

100131 
rc
 = 
	`createCollation
(
db
, 
zName8
, (
u8
)
enc
, 
pCtx
, 
xCompare
, 0);

100132 
	`sqlite3DbFree
(
db
, 
zName8
);

100134 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

100135 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100136 return 
rc
;

100137 
	}
}

100144 int 
sqlite3_collation_needed
(

100145 
sqlite3
 *
db
,

100146 void *
pCollNeededArg
,

100147 void(*
xCollNeeded
)(void*,
sqlite3
*,int 
eTextRep
,const char*)

100154 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100155 
db
->
xCollNeeded
 = xCollNeeded;

100156 
db
->
xCollNeeded16
 = 0;

100157 
db
->
pCollNeededArg
 = pCollNeededArg;

100158 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100160 
	}
}

100167 int 
sqlite3_collation_needed16
(

100168 
sqlite3
 *
db
,

100169 void *
pCollNeededArg
,

100170 void(*
xCollNeeded16
)(void*,
sqlite3
*,int 
eTextRep
,const void*)

100177 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100178 
db
->
xCollNeeded
 = 0;

100179 
db
->
xCollNeeded16
 = xCollNeeded16;

100180 
db
->
pCollNeededArg
 = pCollNeededArg;

100181 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100183 
	}
}

100191 int 
	$sqlite3_global_recover
(void)

100195 
	}
}

100197 int 
	$sqlite3_get_autocommit
(
sqlite3
 *
db
)

100206 return 
db
->
autoCommit
;

100207 
	}
}

100209 static int 
	$reportError
(int 
iErr
, int 
lineno
, const char *
zType
)

100212 
	`sqlite3_log
(
iErr
, "%s at line %d of [%.10s]",

100213 
zType
, 
lineno
, 20+
	`sqlite3_sourceid
());

100214 return 
iErr
;

100215 
	}
}

100216 static int 
	$sqlite3CorruptError
(int 
lineno
)

100220 return 
	`reportError
(11, 
lineno
, "database corruption");

100221 
	}
}

100222 static int 
	$sqlite3MisuseError
(int 
lineno
)

100226 return 
	`reportError
(21, 
lineno
, "misuse");

100227 
	}
}

100228 static int 
	$sqlite3CantopenError
(int 
lineno
)

100232 return 
	`reportError
(14, 
lineno
, "cannot open file");

100233 
	}
}

100235 void 
	$sqlite3_thread_cleanup
(void)

100238 
	}
}

100245 int 
	$sqlite3_table_column_metadata
(

100246 
sqlite3
 *
db
,

100247 const char *
zDbName
,

100248 const char *
zTableName
,

100249 const char *
zColumnName
,

100250 char const **
pzDataType
,

100251 char const **
pzCollSeq
,

100252 int *
pNotNull
,

100253 int *
pPrimaryKey
,

100254 int *
pAutoinc


100258 int 
rc
;

100259 char *
zErrMsg
 = 0;

100260 
Table
 *
pTab
 = 0;

100261 
Column
 *
pCol
 = 0;

100262 int 
iCol
 = 0;

100263 char const *
zDataType
 = 0;

100264 char const *
zCollSeq
 = 0;

100265 int 
notnull
 = 0;

100266 int 
primarykey
 = 0;

100267 int 
autoinc
 = 0;

100269 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100270 
	`sqlite3BtreeEnterAll
(
db
);

100271 
rc
 = 
	`sqlite3Init
(
db
, &
zErrMsg
);

100272 if( 0!=
rc
 )

100275 goto 
error_out
;

100279 
pTab
 = 
	`sqlite3FindTable
(
db
, 
zTableName
, 
zDbName
);

100280 if( !
pTab
 || pTab->
pSelect
 )

100283 
pTab
 = 0;

100284 goto 
error_out
;

100288 if( 
zColumnName
==0 )

100293 for(
iCol
=0; iCol<
pTab
->
nCol
; iCol++)

100296 
pCol
 = &
pTab
->
aCol
[
iCol
];

100297 if( 0==
	`sqlite3StrICmp
(
pCol
->
zName
, 
zColumnName
) )

100303 if( 
iCol
==
pTab
->
nCol
 )

100306 if( (((
pTab
)->
tabFlags
 & 0x20)==0) && 
	`sqlite3IsRowid
(
zColumnName
) )

100309 
iCol
 = 
pTab
->
iPKey
;

100310 
pCol
 = 
iCol
>=0 ? &
pTab
->
aCol
[iCol] : 0;

100312 
pTab
 = 0;

100313 goto 
error_out
;

100318 if( 
pCol
 )

100321 
zDataType
 = 
	`sqlite3ColumnType
(
pCol
,0);

100322 
zCollSeq
 = 
pCol
->
zColl
;

100323 
notnull
 = 
pCol
->
notNull
!=0;

100324 
primarykey
 = (
pCol
->
colFlags
 & 0x0001)!=0;

100325 
autoinc
 = 
pTab
->
iPKey
==
iCol
 && (pTab->
tabFlags
 & 0x08)!=0;

100327 
zDataType
 = "INTEGER";

100328 
primarykey
 = 1;

100330 if( !
zCollSeq
 )

100333 
zCollSeq
 = 
sqlite3StrBINARY
;

100336 
error_out
:

100337 
	`sqlite3BtreeLeaveAll
(
db
);

100343 if( 
pzDataType
 ) *pzDataType = 
zDataType
;

100344 if( 
pzCollSeq
 ) *pzCollSeq = 
zCollSeq
;

100345 if( 
pNotNull
 ) *pNotNull = 
notnull
;

100346 if( 
pPrimaryKey
 ) *pPrimaryKey = 
primarykey
;

100347 if( 
pAutoinc
 ) *pAutoinc = 
autoinc
;

100349 if( 0==
rc
 && !
pTab
 )

100352 
	`sqlite3DbFree
(
db
, 
zErrMsg
);

100353 
zErrMsg
 = 
	`sqlite3MPrintf
(
db
, "no such table column: %s.%s", 
zTableName
,

100354 
zColumnName
);

100355 
rc
 = 1;

100357 
	`sqlite3ErrorWithMsg
(
db
, 
rc
, (
zErrMsg
?"%s":0), zErrMsg);

100358 
	`sqlite3DbFree
(
db
, 
zErrMsg
);

100359 
rc
 = 
	`sqlite3ApiExit
(
db
, rc);

100360 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100361 return 
rc
;

100362 
	}
}

100367 int 
	$sqlite3_sleep
(int 
ms
)

100370 
sqlite3_vfs
 *
pVfs
;

100371 int 
rc
;

100372 
pVfs
 = 
	`sqlite3_vfs_find
(0);

100373 if( 
pVfs
==0 ) return 0;

100378 
rc
 = (
	`sqlite3OsSleep
(
pVfs
, 1000*
ms
)/1000);

100379 return 
rc
;

100380 
	}
}

100385 int 
	$sqlite3_extended_result_codes
(
sqlite3
 *
db
, int 
onoff
)

100391 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100392 
db
->
errMask
 = 
onoff
 ? 0xffffffff : 0xff;

100393 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100395 
	}
}

100400 int 
	$sqlite3_file_control
(
sqlite3
 *
db
, const char *
zDbName
, int 
op
, void *
pArg
)

100403 int 
rc
 = 1;

100404 
Btree
 *
pBtree
;

100409 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100410 
pBtree
 = 
	`sqlite3DbNameToBtree
(
db
, 
zDbName
);

100411 if( 
pBtree
 )

100414 
Pager
 *
pPager
;

100415 
sqlite3_file
 *
fd
;

100416 
	`sqlite3BtreeEnter
(
pBtree
);

100417 
pPager
 = 
	`sqlite3BtreePager
(
pBtree
);

100419 
fd
 = 
	`sqlite3PagerFile
(
pPager
);

100421 if( 
op
==7 )

100424 *(
sqlite3_file
**)
pArg
 = 
fd
;

100425 
rc
 = 0;

100426 }else if( 
op
==27 )

100429 *(
sqlite3_vfs
**)
pArg
 = 
	`sqlite3PagerVfs
(
pPager
);

100430 
rc
 = 0;

100431 }else if( 
op
==28 )

100434 *(
sqlite3_file
**)
pArg
 = 
	`sqlite3PagerJrnlFile
(
pPager
);

100435 
rc
 = 0;

100436 }else if( 
fd
->
pMethods
 )

100439 
rc
 = 
	`sqlite3OsFileControl
(
fd
, 
op
, 
pArg
);

100441 
rc
 = 12;

100443 
	`sqlite3BtreeLeave
(
pBtree
);

100445 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100446 return 
rc
;

100447 
	}
}

100452 int 
	$sqlite3_test_control
(int 
op
, ...)

100455 int 
rc
 = 0;

100459 
va_list
 
ap
;

100460 
	`__builtin_va_start
(
ap
,
op
);

100461 switch( 
op
 )

100469 
	`sqlite3PrngSaveState
();

100479 
	`sqlite3PrngRestoreState
();

100489 
	`sqlite3_randomness
(0,0);

100494 int 
sz
 = 
	`__builtin_va_arg
(
ap
,int);

100495 int *
aProg
 = 
	`__builtin_va_arg
(
ap
,int*);

100496 
rc
 = 
	`sqlite3BitvecBuiltinTest
(
sz
, 
aProg
);

100505 typedef int(*
	tTESTCALLBACKFUNC_t
)(int);

100506 
sqlite3Config
.
xTestCallback
 = 
	`__builtin_va_arg
(
ap
,
TESTCALLBACKFUNC_t
);

100507 
rc
 = 
	`sqlite3FaultSim
(0);

100518 typedef void (*
	tvoid_function
)(void);

100519 
void_function
 
xBenignBegin
;

100520 
void_function
 
xBenignEnd
;

100521 
xBenignBegin
 = 
	`__builtin_va_arg
(
ap
,
void_function
);

100522 
xBenignEnd
 = 
	`__builtin_va_arg
(
ap
,
void_function
);

100523 
	`sqlite3BenignMallocHooks
(
xBenignBegin
, 
xBenignEnd
);

100528 
rc
 = 
sqlite3PendingByte
;

100531 unsigned int 
newVal
 = 
	`__builtin_va_arg
(
ap
,unsigned int);

100532 if( 
newVal
 ) 
sqlite3PendingByte
 = newVal;

100539 volatile int 
x
 = 0;

100541 
rc
 = 
x
;

100546 int 
x
 = 
	`__builtin_va_arg
(
ap
,int);

100547 
rc
 = (
x
);

100552 
rc
 = 1234*100 + 1*10 + 0;

100562 
sqlite3
 *
db
 = 
	`__builtin_va_arg
(
ap
,sqlite3*);

100563 int 
x
 = 
	`__builtin_va_arg
(
ap
,int);

100564 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100565 
	`sqlite3BtreeSetPageSize
(
db
->
aDb
[0].
pBt
, 0, 
x
, 0);

100566 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100571 
sqlite3
 *
db
 = 
	`__builtin_va_arg
(
ap
,sqlite3*);

100572 
db
->
dbOptFlags
 = (
u16
)(
	`__builtin_va_arg
(
ap
,int) & 0xffff);

100577 const char *
zWord
 = 
	`__builtin_va_arg
(
ap
,const char*);

100578 int 
n
 = 
	`sqlite3Strlen30
(
zWord
);

100579 
rc
 = (
	`sqlite3KeywordCode
((
u8
*)
zWord
, 
n
)!=27) ? 124 : 0;

100590 void *
pFree
, **
ppNew
;

100591 int 
sz
;

100592 
sz
 = 
	`__builtin_va_arg
(
ap
,int);

100593 
ppNew
 = 
	`__builtin_va_arg
(
ap
,void**);

100594 
pFree
 = 
	`__builtin_va_arg
(
ap
,void*);

100595 if( 
sz
 ) *
ppNew
 = 
	`sqlite3ScratchMalloc
(sz);

100596 
	`sqlite3ScratchFree
(
pFree
);

100607 
sqlite3Config
.
bLocaltimeFault
 = 
	`__builtin_va_arg
(
ap
,int);

100612 
sqlite3Config
.
neverCorrupt
 = 
	`__builtin_va_arg
(
ap
,int);

100633 
sqlite3
 *
db
 = 
	`__builtin_va_arg
(
ap
,sqlite3*);

100634 
db
->
nMaxSorterMmap
 = 
	`__builtin_va_arg
(
ap
,int);

100644 if( 
sqlite3Config
.
isInit
==0 ) 
rc
 = 1;

100649 
sqlite3
 *
db
 = 
	`__builtin_va_arg
(
ap
,sqlite3*);

100650 
	`sqlite3_mutex_enter
(
db
->
mutex
);

100651 
db
->
init
.
iDb
 = 
	`sqlite3FindDbName
(db, 
	`__builtin_va_arg
(
ap
,const char*));

100652 
db
->
init
.
busy
 = db->init.
imposterTable
 = 
	`__builtin_va_arg
(
ap
,int);

100653 
db
->
init
.
newTnum
 = 
	`__builtin_va_arg
(
ap
,int);

100654 if( 
db
->
init
.
busy
==0 && db->init.
newTnum
>0 )

100657 
	`sqlite3ResetAllSchemasOfConnection
(
db
);

100659 
	`sqlite3_mutex_leave
(
db
->
mutex
);

100663 
	`__builtin_va_end
(
ap
);

100665 return 
rc
;

100666 
	}
}

100668 const char * 
	$sqlite3_uri_parameter
(const char *
zFilename
, const char *
zParam
)

100671 if( 
zFilename
==0 || 
zParam
==0 ) return 0;

100672 
zFilename
 += 
	`sqlite3Strlen30
(zFilename) + 1;

100673 while( 
zFilename
[0] )

100676 int 
x
 = 
	`strcmp
(
zFilename
, 
zParam
);

100677 
zFilename
 += 
	`sqlite3Strlen30
(zFilename) + 1;

100678 if( 
x
==0 ) return 
zFilename
;

100679 
zFilename
 += 
	`sqlite3Strlen30
(zFilename) + 1;

100682 
	}
}

100687 int 
	$sqlite3_uri_boolean
(const char *
zFilename
, const char *
zParam
, int 
bDflt
)

100690 const char *
z
 = 
	`sqlite3_uri_parameter
(
zFilename
, 
zParam
);

100691 
bDflt
 = bDflt!=0;

100692 return 
z
 ? 
	`sqlite3GetBoolean
(z, 
bDflt
) : bDflt;

100693 
	}
}

100698 
sqlite3_int64
 
	$sqlite3_uri_int64
(

100699 const char *
zFilename
,

100700 const char *
zParam
,

100701 
sqlite3_int64
 
bDflt


100705 const char *
z
 = 
	`sqlite3_uri_parameter
(
zFilename
, 
zParam
);

100706 
sqlite3_int64
 
v
;

100707 if( 
z
 && 
	`sqlite3DecOrHexToI64
(z, &
v
)==0 )

100710 
bDflt
 = 
v
;

100712 return 
bDflt
;

100713 
	}
}

100718 static 
Btree
 *
	$sqlite3DbNameToBtree
(
sqlite3
 *
db
, const char *
zDbName
)

100721 int 
i
;

100722 for(
i
=0; i<
db
->
nDb
; i++)

100725 if( 
db
->
aDb
[
i
].
pBt


100726 && (
zDbName
==0 || 
	`sqlite3StrICmp
(zDbName, 
db
->
aDb
[
i
].
zName
)==0)

100730 return 
db
->
aDb
[
i
].
pBt
;

100734 
	}
}

100740 const char * 
	$sqlite3_db_filename
(
sqlite3
 *
db
, const char *
zDbName
)

100743 
Btree
 *
pBt
;

100750 
pBt
 = 
	`sqlite3DbNameToBtree
(
db
, 
zDbName
);

100751 return 
pBt
 ? 
	`sqlite3BtreeGetFilename
(pBt) : 0;

100752 
	}
}

100758 int 
	$sqlite3_db_readonly
(
sqlite3
 *
db
, const char *
zDbName
)

100761 
Btree
 *
pBt
;

100768 
pBt
 = 
	`sqlite3DbNameToBtree
(
db
, 
zDbName
);

100769 return 
pBt
 ? 
	`sqlite3BtreeIsReadonly
(pBt) : -1;

100770 
	}
}

	@
1
.
0
2
26
shell.cpp.c
sqlite3.cpp.c
